<!DOCTYPE html>
<html>
<head>
    <title>Exemplo de exibição de URI</title>
</head>
<body>
    <h1>Exemplo de exibição de URI</h1>
    <button onclick="changeUrl('/user/1')">Exibir URI</button>

    <script>
        function changeUrl(uri) {
            window.history.pushState({}, '', uri);
        }
    </script>
</body>
</html>

https://youtu.be/7fxguLAebl4


sudo firewall-cmd --zone=public --add-port=8000/tcp --permanent

sudo firewall-cmd --zone=public --add-port=3000/tcp --permanent

sudo firewall-cmd --zone=public --add-port=8080/tcp --permanent

sudo firewall-cmd --zone=public --add-port=5000/tcp --permanent

sudo firewall-cmd --zone=public --add-port=3306/tcp --permanent


sudo firewall-cmd --reload

sudo systemctl start firewalld

sudo systemctl status firewalld



wget https://getcomposer.org/installer

php installer



https://youtu.be/bcjlZl9F0dU

https://alexandrecardoso.dev.br/

https://youtu.be/rqtZ0EmciJ8

DIA 27/06/23

https://youtu.be/rqtZ0EmciJ8?list=PLyugqHiq-SKfJcQFnTxxzO7VGX-Fq2HnT

https://youtu.be/2H9DYpHlZyc?list=PLTrP4PHY9PuMidhcxJZuF0TF5Ij7ihY0t

https://www.udemy.com/course/php-profissional/learn/lecture/28275254#overview

/////////////////////////////////////////********************


https://www.youtube.com/watch?v=qH7rsZBENJo&list=PLnDvRpP8BnewYKI1n2chQrrR4EYiJKbUG&pp=iAQB


https://www.youtube.com/watch?v=QIlCT34gWh4

https://www.youtube.com/watch?v=7K-xSmN5B2o

https://www.youtube.com/watch?v=Cz5RjFCps2Q

https://www.youtube.com/watch?v=ipPjJkVeUpQ

https://www.youtube.com/watch?v=rQV9aI3LLnk

https://www.youtube.com/watch?v=BXl5mOle0z0

https://youtu.be/1K_nJRPajOA?list=PL193izPqf5X7aka3OPzoBPsMzyphRUytT

https://www.youtube.com/watch?v=-hxsj84X_vs&list=PL193izPqf5X7aka3OPzoBPsMzyphRUytT&index=8&pp=iAQB

https://www.youtube.com/watch?v=lJBgLwsrVhM&list=PL193izPqf5X7aka3OPzoBPsMzyphRUytT&index=11&pp=iAQB

https://www.youtube.com/watch?v=JETbmmXA0Uo&list=PL193izPqf5X7aka3OPzoBPsMzyphRUytT&index=20&pp=iAQB

https://youtu.be/bF04VPI68sg

https://www.youtube.com/watch?v=UXOXbDRX4Z4&list=PL6tf8fRbavl3lxHRw44aKyW0Hq2IXmxGv&pp=iAQB



https://www.youtube.com/watch?v=WoHPF2BDcMc&list=PL6tf8fRbavl2oguMj5NSrQXhsd6ztc8_O&pp=iAQB

https://www.youtube.com/watch?v=0iLQx5sXZhM


https://www.youtube.com/watch?v=xeqaEKeQUgg

https://www.youtube.com/watch?v=ujUhXLVqOO0

https://www.youtube.com/redirect?event=video_description&redir_token=QUFFLUhqbm53OTR2NURhNWZ4TnhWWDZ1V05WaHRldloyUXxBQ3Jtc0tubnJRVmxNU2JDYXA1ODZ1SS1pZWdsM0JJZ0lpUGRudDFrUENZdzY5V2djbkoxU016R21EVWRGazFvbkZQbjFidGZmV250eGowT09ZOFBHM0l0M1ZNakVYdExNOW9OdzU3dkd6enFpSFBQVGNpbFNBVQ&q=https%3A%2F%2Fgithub.com%2Fcodewithtonyofficial%2Flaravel-splade-employees&v=ptyghvAF_G0

https://pobreflix.org/filmes/the-flash-hd-7y4j1/


	ATIVO
Plano	 	VPS 1 GB LINUX 
Plataforma	 	Ubuntu 18.04 LTS
Dominio em uso	 	a8252m.vps-kinghost.net
Endereço principal	 	189.126.111.196


HTTP request sent, awaiting response... 200 OK
Length: 13041998 (12M) [application/octet-stream]
Saving to: ‘phpMyAdmin-5.2.1-all-languages.tar.gz’

phpMyAdmin-5.2.1-al 100%[===================>]  12.44M  9.24MB/s    in 1.3s

2023-06-21 21:22:07 (9.24 MB/s) - ‘phpMyAdmin-5.2.1-all-languages.tar.gz’ saved [13041998/13041998]

phpMyAdmin-5.2.1-all-languages.tar.gz download completed...
Install phpMyAdmin-5.2.1-all-languages completed...
Cleaning up...
Clean up completed...

Congratulations, LAMP install completed!

------------------------ Installed Overview -------------------------

Apache: httpd-2.4.57
Default Website: http://189.126.111.196
Apache Location: /usr/local/apache
Apache Additional Modules: do_not_install

Database: mysql-8.0.33
MySQL Location: /usr/local/mysql
MySQL Data Location: /usr/local/mysql/data
MySQL Root Password: 123456

Database Management Modules:
phpMyAdmin-5.2.1-all-languages

PHP: php-8.1.20
PHP Location: /usr/local/php
PHP Additional Extensions: do_not_install

KodExplorer: do_not_install

---------------------------------------------------------------------

Starting Apache...
Starting Database...
Active Internet connections (only servers)
Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name
tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN      1313/sshd
tcp6       0      0 :::33060                :::*                    LISTEN      11732/mysqld
tcp6       0      0 :::3306                 :::*                    LISTEN      11732/mysqld
tcp6       0      0 :::22                   :::*                    LISTEN      1313/sshd

Start time     : 2023-06-21 20:31:11
Completion time: 2023-06-21 21:22:19 (Use:51 minutes)
Welcome to visit our website: https://lamp.sh
Enjoy it
root@a8252m:~/lamp#


chown www-data:www-data -R *



CENTOS7 177.153.50.224
alber 12345678
sudo service docker start

https://youtu.be/8MJWke19g8U

https://youtu.be/ecj7FLt6chg

# CRIANDO USUÁRIO REMOTO AO MYSQL

 Verifique as configurações do MySQL: Abra o arquivo de configuração do MySQL no servidor. Dependendo do sistema operacional, o arquivo pode estar localizado em diferentes caminhos. No Ubuntu, por exemplo, o arquivo de configuração geralmente está em /etc/mysql/mysql.conf.d/mysqld.cnf.

Comente a diretiva "bind-address": Dentro do arquivo de configuração, procure a diretiva "bind-address" e comente-a adicionando um "#" no início da linha. Isso permitirá que o MySQL escute em todas as interfaces de rede disponíveis no servidor.


CREATE USER 'alber'@'%' IDENTIFIED BY '123456';

GRANT ALL PRIVILEGES ON *.* TO 'root'@'%' WITH GRANT OPTION;
FLUSH PRIVILEGES;




# EMAIL  #MAIL #EMAIL

MAIL_MAILER=smtp
MAIL_HOST=smtp.gmail.com
MAIL_PORT=587
MAIL_USERNAME=albertogomesdasilva@gmail.com
MAIL_PASSWORD=mgbogwfvkiefjmct
MAIL_ENCRYPTION=TLS
MAIL_FROM_ADDRESS="albertogomesdasilva@gmail.com" 
# MAIL_FROM_ADDRESS="${MAIL_USERNAME}" 
MAIL_FROM_NAME="${APP_NAME}"



/******************************** */
# LARAVEL CRUD
Laravel 10 CRUD (Create, Read, Update and Delete) with admin and Custom Login register

Download Laravel App

composer create-project --prefer-dist laravel/laravel my-app
C:\xampp\htdocs\laravel10project>composer create-project laravel/laravel laravel10project

Connecting our Database

open .env file root directory.

DB_CONNECTION=mysql
DB_HOST=127.0.0.1
DB_PORT=3306
DB_DATABASE=laraveldb
DB_USERNAME=root
DB_PASSWORD=123456
Create Controller AuthController

php artisan make:controller AuthController
C:\xampp\htdocs\laravel\laravel10project>php artisan make:controller AuthController
app\Http\Controllers\AuthController.php
?

//app\Http\Controllers\AuthController.php
<?php
  
namespace App\Http\Controllers;
  
use Illuminate\Http\Request;
use App\Models\User;
use Illuminate\Support\Facades\Auth;
use Illuminate\Support\Facades\Hash;
use Illuminate\Support\Facades\Validator;
use Illuminate\Validation\ValidationException;
  
class AuthController extends Controller
{
    public function register()
    {
        return view('auth/register');
    }
  
    public function registerSave(Request $request)
    {
        Validator::make($request->all(), [
            'name' => 'required',
            'email' => 'required|email',
            'password' => 'required|confirmed'
        ])->validate();
  
        User::create([
            'name' => $request->name,
            'email' => $request->email,
            'password' => Hash::make($request->password),
            'level' => 'Admin'
        ]);
  
        return redirect()->route('login');
    }
  
    public function login()
    {
        return view('auth/login');
    }
  
    public function loginAction(Request $request)
    {
        Validator::make($request->all(), [
            'email' => 'required|email',
            'password' => 'required'
        ])->validate();
  
        if (!Auth::attempt($request->only('email', 'password'), $request->boolean('remember'))) {
            throw ValidationException::withMessages([
                'email' => trans('auth.failed')
            ]);
        }
  
        $request->session()->regenerate();
  
        return redirect()->route('dashboard');
    }
  
    public function logout(Request $request)
    {
        Auth::guard('web')->logout();
  
        $request->session()->invalidate();
  
        return redirect('/');
    }
 
    public function profile()
    {
        return view('profile');
    }
}
Create Controller ProductController
php artisan make:controller ProductController --resource
C:\xampp\htdocs\laravel\laravel10project>php artisan make:controller ProductController --resource
app\Http\Controllers\ProductController.php
?

//app\Http\Controllers\ProductController.php
<?php
  
namespace App\Http\Controllers;
  
use Illuminate\Http\Request;
use App\Models\Product;
 
class ProductController extends Controller
{
    /**
     * Display a listing of the resource.
     */
    public function index()
    {
        $product = Product::orderBy('created_at', 'DESC')->get();
  
        return view('products.index', compact('product'));
    }
  
    /**
     * Show the form for creating a new resource.
     */
    public function create()
    {
        return view('products.create');
    }
  
    /**
     * Store a newly created resource in storage.
     */
    public function store(Request $request)
    {
        Product::create($request->all());
 
        return redirect()->route('products')->with('success', 'Product added successfully');
    }
  
    /**
     * Display the specified resource.
     */
    public function show(string $id)
    {
        $product = Product::findOrFail($id);
  
        return view('products.show', compact('product'));
    }
  
    /**
     * Show the form for editing the specified resource.
     */
    public function edit(string $id)
    {
        $product = Product::findOrFail($id);
  
        return view('products.edit', compact('product'));
    }
  
    /**
     * Update the specified resource in storage.
     */
    public function update(Request $request, string $id)
    {
        $product = Product::findOrFail($id);
  
        $product->update($request->all());
  
        return redirect()->route('products')->with('success', 'product updated successfully');
    }
  
    /**
     * Remove the specified resource from storage.
     */
    public function destroy(string $id)
    {
        $product = Product::findOrFail($id);
  
        $product->delete();
  
        return redirect()->route('products')->with('success', 'product deleted successfully');
    }
}
Database Migration
C:\xampp\htdocs\laravel\laravel10project>php artisan make:model Product -m
database/migrations/create_products_table.php
?

//database/migrations/create_products_table.php
<?php
 
use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;
 
return new class extends Migration
{
    public function up(): void
    {
        Schema::create('products', function (Blueprint $table) {
            $table->id();
            $table->string('title');
            $table->string('price');
            $table->string('product_code');
            $table->text('description');
            $table->timestamps();
        });
    }
    public function down(): void
    {
        Schema::dropIfExists('products');
    }
};
run this migration
C:\xampp\htdocs\laravel\laravel10project>php artisan migrate

open app/Product.php and update the below field
app/Models/Product.php
?

//app/Models/Product.php
<?php
 
namespace App\Models;
 
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
 
class Product extends Model
{
    use HasFactory;
 
    protected $fillable = [
        'title',
        'price',
        'product_code',
        'description'
    ];
}
Templates
Download SB Admin 2 https://startbootstrap.com/theme/sb-admin-2

create folder layouts new file app.blade.php resources/views/layouts/app.blade.php

?

//resources/views/layouts/app.blade.php
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="">
  <meta name="author" content="">
  <title>SB Admin 2 - Dashboard</title>
  <!-- Custom fonts for this template-->
  <link href="{{ asset('admin_assets/vendor/fontawesome-free/css/all.min.css') }}" rel="stylesheet" type="text/css">
  <link href="https://fonts.googleapis.com/css?family=Nunito:200,200i,300,300i,400,400i,600,600i,700,700i,800,800i,900,900i" rel="stylesheet">
  
  <!-- Custom styles for this template-->
  <link href="{{ asset('admin_assets/css/sb-admin-2.min.css') }}" rel="stylesheet">
</head>
<body id="page-top">
  <!-- Page Wrapper -->
  <div id="wrapper">
  
    <!-- Sidebar -->
    @include('layouts.sidebar')
    <!-- End of Sidebar -->
  
    <!-- Content Wrapper -->
    <div id="content-wrapper" class="d-flex flex-column">
  
      <!-- Main Content -->
      <div id="content">
  
        <!-- Topbar -->
        @include('layouts.navbar')
        <!-- End of Topbar -->
  
        <!-- Begin Page Content -->
        <div class="container-fluid">
  
          <!-- Page Heading -->
          <div class="mb-4 d-sm-flex align-items-center justify-content-between">
            <h1 class="mb-0 text-gray-800 h3">@yield('title')</h1>
          </div>
  
          @yield('contents')
  
          <!-- Content Row -->
  
  
        </div>
        <!-- /.container-fluid -->
  
      </div>
      <!-- End of Main Content -->
  
      <!-- Footer -->
      @include('layouts.footer')
      <!-- End of Footer -->
  
    </div>
    <!-- End of Content Wrapper -->
  
  </div>
  <!-- End of Page Wrapper -->
  
  <!-- Scroll to Top Button-->
  <a class="rounded scroll-to-top" href="#page-top">
    <i class="fas fa-angle-up"></i>
  </a>
  
  <!-- Bootstrap core JavaScript-->
  <script src="{{ asset('admin_assets/vendor/jquery/jquery.min.js') }}"></script>
  <script src="{{ asset('admin_assets/vendor/bootstrap/js/bootstrap.bundle.min.js') }}"></script>
  <!-- Core plugin JavaScript-->
  <script src="{{ asset('admin_assets/vendor/jquery-easing/jquery.easing.min.js') }}"></script>
  <!-- Custom scripts for all pages-->
  <script src="{{ asset('admin_assets/js/sb-admin-2.min.js') }}"></script>
  <!-- Page level plugins -->
  <script src="{{ asset('admin_assets/vendor/chart.js/Chart.min.js') }}"></script>
</body>
</html>
create folder admin_assets public/admin_assets paste css,img,js and vendor folder from downloaded template
?

//
<footer class="bg-white sticky-footer">
  <div class="container my-auto">
    <div class="my-auto text-center copyright">
      <span>Copyright © Your Website 2021</span>
    </div>
  </div>
</footer>
include file
resources/views/layouts/footer.blade.php
?

//resources/views/layouts/footer.blade.php
<footer class="bg-white sticky-footer">
  <div class="container my-auto">
    <div class="my-auto text-center copyright">
      <span>Copyright © Your Website 2021</span>
    </div>
  </div>
</footer>
resources/views/layouts/navbar.blade.php
?

//resources/views/layouts/navbar.blade.php
<nav class="mb-4 bg-white shadow navbar navbar-expand navbar-light topbar static-top">
  
  <!-- Sidebar Toggle (Topbar) -->
  <button id="sidebarToggleTop" class="mr-3 btn btn-link d-md-none rounded-circle">
    <i class="fa fa-bars"></i>
  </button>
  
  <!-- Topbar Search -->
  <form class="my-2 mr-auto d-none d-sm-inline-block form-inline ml-md-3 my-md-0 mw-100 navbar-search">
    <div class="input-group">
      <input type="text" class="border-0 form-control bg-light small" placeholder="Search for..." aria-label="Search" aria-describedby="basic-addon2">
      <div class="input-group-append">
        <button class="btn btn-primary" type="button">
          <i class="fas fa-search fa-sm"></i>
        </button>
      </div>
    </div>
  </form>
  
  <!-- Topbar Navbar -->
  <ul class="ml-auto navbar-nav">
  
    <!-- Nav Item - Search Dropdown (Visible Only XS) -->
    <li class="nav-item dropdown no-arrow d-sm-none">
      <a class="nav-link dropdown-toggle" href="#" id="searchDropdown" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
        <i class="fas fa-search fa-fw"></i>
      </a>
      <!-- Dropdown - Messages -->
      <div class="p-3 shadow dropdown-menu dropdown-menu-right animated--grow-in" aria-labelledby="searchDropdown">
        <form class="mr-auto form-inline w-100 navbar-search">
          <div class="input-group">
            <input type="text" class="border-0 form-control bg-light small" placeholder="Search for..." aria-label="Search" aria-describedby="basic-addon2">
            <div class="input-group-append">
              <button class="btn btn-primary" type="button">
                <i class="fas fa-search fa-sm"></i>
              </button>
            </div>
          </div>
        </form>
      </div>
    </li>
  
    <!-- Nav Item - Alerts -->
    <li class="mx-1 nav-item dropdown no-arrow">
      <a class="nav-link dropdown-toggle" href="#" id="alertsDropdown" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
        <i class="fas fa-bell fa-fw"></i>
        <!-- Counter - Alerts -->
        <span class="badge badge-danger badge-counter">3+</span>
      </a>
      <!-- Dropdown - Alerts -->
      <div class="shadow dropdown-list dropdown-menu dropdown-menu-right animated--grow-in" aria-labelledby="alertsDropdown">
        <h6 class="dropdown-header">
          Alerts Center
        </h6>
        <a class="dropdown-item d-flex align-items-center" href="#">
          <div class="mr-3">
            <div class="icon-circle bg-primary">
              <i class="text-white fas fa-file-alt"></i>
            </div>
          </div>
          <div>
            <div class="text-gray-500 small">December 12, 2019</div>
            <span class="font-weight-bold">A new monthly report is ready to download!</span>
          </div>
        </a>
        <a class="dropdown-item d-flex align-items-center" href="#">
          <div class="mr-3">
            <div class="icon-circle bg-success">
              <i class="text-white fas fa-donate"></i>
            </div>
          </div>
          <div>
            <div class="text-gray-500 small">December 7, 2019</div>
            $290.29 has been deposited into your account!
          </div>
        </a>
        <a class="dropdown-item d-flex align-items-center" href="#">
          <div class="mr-3">
            <div class="icon-circle bg-warning">
              <i class="text-white fas fa-exclamation-triangle"></i>
            </div>
          </div>
          <div>
            <div class="text-gray-500 small">December 2, 2019</div>
            Spending Alert: We've noticed unusually high spending for your account.
          </div>
        </a>
        <a class="text-center text-gray-500 dropdown-item small" href="#">Show All Alerts</a>
      </div>
    </li>
  
    <!-- Nav Item - Messages -->
    <li class="mx-1 nav-item dropdown no-arrow">
      <a class="nav-link dropdown-toggle" href="#" id="messagesDropdown" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
        <i class="fas fa-envelope fa-fw"></i>
        <!-- Counter - Messages -->
        <span class="badge badge-danger badge-counter">7</span>
      </a>
      <!-- Dropdown - Messages -->
      <div class="shadow dropdown-list dropdown-menu dropdown-menu-right animated--grow-in" aria-labelledby="messagesDropdown">
        <h6 class="dropdown-header">
          Message Center
        </h6>
        <a class="dropdown-item d-flex align-items-center" href="#">
          <div class="mr-3 dropdown-list-image">
            <img class="rounded-circle" src="https://startbootstrap.github.io/startbootstrap-sb-admin-2/img/undraw_profile_1.svg" alt="...">
            <div class="status-indicator bg-success"></div>
          </div>
          <div class="font-weight-bold">
            <div class="text-truncate">Hi there! I am wondering if you can help me with a
              problem I've been having.</div>
            <div class="text-gray-500 small">Emily Fowler · 58m</div>
          </div>
        </a>
        <a class="dropdown-item d-flex align-items-center" href="#">
          <div class="mr-3 dropdown-list-image">
            <img class="rounded-circle" src="https://startbootstrap.github.io/startbootstrap-sb-admin-2/img/undraw_profile_2.svg" alt="...">
            <div class="status-indicator"></div>
          </div>
          <div>
            <div class="text-truncate">I have the photos that you ordered last month, how
              would you like them sent to you?</div>
            <div class="text-gray-500 small">Jae Chun · 1d</div>
          </div>
        </a>
        <a class="dropdown-item d-flex align-items-center" href="#">
          <div class="mr-3 dropdown-list-image">
            <img class="rounded-circle" src="https://startbootstrap.github.io/startbootstrap-sb-admin-2/img/undraw_profile_3.svg" alt="...">
            <div class="status-indicator bg-warning"></div>
          </div>
          <div>
            <div class="text-truncate">Last month's report looks great, I am very happy with
              the progress so far, keep up the good work!</div>
            <div class="text-gray-500 small">Morgan Alvarez · 2d</div>
          </div>
        </a>
        <a class="dropdown-item d-flex align-items-center" href="#">
          <div class="mr-3 dropdown-list-image">
            <img class="rounded-circle" src="https://source.unsplash.com/Mv9hjnEUHR4/60x60" alt="...">
            <div class="status-indicator bg-success"></div>
          </div>
          <div>
            <div class="text-truncate">Am I a good boy? The reason I ask is because someone
              told me that people say this to all dogs, even if they aren't good...</div>
            <div class="text-gray-500 small">Chicken the Dog · 2w</div>
          </div>
        </a>
        <a class="text-center text-gray-500 dropdown-item small" href="#">Read More Messages</a>
      </div>
    </li>
  
    <div class="topbar-divider d-none d-sm-block"></div>
  
    <!-- Nav Item - User Information -->
    <li class="nav-item dropdown no-arrow">
      <a class="nav-link dropdown-toggle" href="#" id="userDropdown" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
        <span class="mr-2 text-gray-600 d-none d-lg-inline small">
          {{ auth()->user()->name }}
          <br>
          <small>{{ auth()->user()->level }}</small>
        </span>
        <img class="img-profile rounded-circle" src="https://startbootstrap.github.io/startbootstrap-sb-admin-2/img/undraw_profile.svg">
      </a>
      <!-- Dropdown - User Information -->
      <div class="shadow dropdown-menu dropdown-menu-right animated--grow-in" aria-labelledby="userDropdown">
        <a class="dropdown-item" href="/profile">
          <i class="mr-2 text-gray-400 fas fa-user fa-sm fa-fw"></i>
          Profile
        </a>
        <a class="dropdown-item" href="#">
          <i class="mr-2 text-gray-400 fas fa-cogs fa-sm fa-fw"></i>
          Settings
        </a>
        <a class="dropdown-item" href="#">
          <i class="mr-2 text-gray-400 fas fa-list fa-sm fa-fw"></i>
          Activity Log
        </a>
        <div class="dropdown-divider"></div>
        <a class="dropdown-item" href="{{ route('logout') }}">
          <i class="mr-2 text-gray-400 fas fa-sign-out-alt fa-sm fa-fw"></i>
          Logout
        </a>
      </div>
    </li>
  
  </ul>
  
</nav>
resources/views/layouts/sidebar.blade.php
?

//resources/views/layouts/sidebar.blade.php
<ul class="navbar-nav bg-gradient-primary sidebar sidebar-dark accordion" id="accordionSidebar">
  
  <!-- Sidebar - Brand -->
  <a class="sidebar-brand d-flex align-items-center justify-content-center" href="index.html">
    <div class="sidebar-brand-icon rotate-n-15">
      <i class="fas fa-laugh-wink"></i>
    </div>
    <div class="mx-3 sidebar-brand-text">SB Admin <sup>2</sup></div>
  </a>
  
  <!-- Divider -->
  <hr class="my-0 sidebar-divider">
  
  <!-- Nav Item - Dashboard -->
  <li class="nav-item">
    <a class="nav-link" href="{{ route('dashboard') }}">
      <i class="fas fa-fw fa-tachometer-alt"></i>
      <span>Dashboard</span></a>
  </li>
  
  <li class="nav-item">
    <a class="nav-link" href="{{ route('products') }}">
      <i class="fas fa-fw fa-tachometer-alt"></i>
      <span>Product</span></a>
  </li>
  
  <li class="nav-item">
    <a class="nav-link" href="/profile">
      <i class="fas fa-fw fa-tachometer-alt"></i>
      <span>Profile</span></a>
  </li>
  
  <!-- Divider -->
  <hr class="sidebar-divider d-none d-md-block">
  
  <!-- Sidebar Toggler (Sidebar) -->
  <div class="text-center d-none d-md-inline">
    <button class="border-0 rounded-circle" id="sidebarToggle"></button>
  </div>
  
  
</ul>
resources/views/dashboard.blade.php
?

//resources/views/dashboard.blade.php
@extends('layouts.app')
  
@section('title', 'Dashboard - Laravel Admin Panel With Login and Registration')
  
@section('contents')
  <div class="row">
    Dashboard
  </div>
@endsection
resources/views/profile.blade.php
?

//resources/views/profile.blade.php
@extends('layouts.app')
  
@section('title', 'Profile')
  
@section('contents')
    <h1 class="mb-0">Profile</h1>
    <hr />
 
    <form method="POST" enctype="multipart/form-data" id="profile_setup_frm" action="" >
    <div class="row">
        <div class="col-md-12 border-right">
            <div class="p-3 py-5">
                <div class="mb-3 d-flex justify-content-between align-items-center">
                    <h4 class="text-right">Profile Settings</h4>
                </div>
                <div class="row" id="res"></div>
                <div class="mt-2 row">
  
                    <div class="col-md-6">
                        <label class="labels">Name</label>
                        <input type="text" name="name" class="form-control" placeholder="first name" value="{{ auth()->user()->name }}">
                    </div>
                    <div class="col-md-6">
                        <label class="labels">Email</label>
                        <input type="text" name="email" disabled class="form-control" value="{{ auth()->user()->email }}" placeholder="Email">
                    </div>
                </div>
                <div class="mt-2 row">
                    <div class="col-md-6">
                        <label class="labels">Phone</label>
                        <input type="text" name="phone" class="form-control" placeholder="Phone Number" value="{{ auth()->user()->phone }}">
                    </div>
                    <div class="col-md-6">
                        <label class="labels">Address</label>
                        <input type="text" name="address" class="form-control" value="{{ auth()->user()->address }}" placeholder="Address">
                    </div>
                </div>
                 
                <div class="mt-5 text-center"><button id="btn" class="btn btn-primary profile-button" type="submit">Save Profile</button></div>
            </div>
        </div>
         
    </div>   
            
        </form>
@endsection
create folder auth and file login resources/views/auth/login.blade.php
?

//resources/views/auth/login.blade.php
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="">
  <meta name="author" content="">
  <title>SB Admin 2 - Login</title>
  <!-- Custom fonts for this template-->
  <link href="{{ asset('admin_assets/vendor/fontawesome-free/css/all.min.css') }}" rel="stylesheet" type="text/css">
  <link href="https://fonts.googleapis.com/css?family=Nunito:200,200i,300,300i,400,400i,600,600i,700,700i,800,800i,900,900i" rel="stylesheet">
  
  <!-- Custom styles for this template-->
  <link href="{{ asset('admin_assets/css/sb-admin-2.min.css') }}" rel="stylesheet">
</head>
<body class="bg-gradient-primary">
  <div class="container">
    <!-- Outer Row -->
    <div class="row justify-content-center">
      <div class="col-xl-10 col-lg-12 col-md-9">
        <div class="my-5 border-0 shadow-lg card o-hidden">
          <div class="p-0 card-body">
            <!-- Nested Row within Card Body -->
            <div class="row">
              <div class="col-lg-6 d-none d-lg-block bg-login-image"></div>
              <div class="col-lg-6">
                <div class="p-5">
                  <div class="text-center">
                    <h1 class="mb-4 text-gray-900 h4">Welcome Back!</h1>
                  </div>
                  <form action="{{ route('login.action') }}" method="POST" class="user">
                    @csrf
                    @if ($errors->any())
                      <div class="alert alert-danger">
                          <ul>
                            @foreach ($errors->all() as $error)
                              <li>{{ $error }}</li>
                            @endforeach
                          </ul>
                      </div>
                    @endif
                    <div class="form-group">
                      <input name="email" type="email" class="form-control form-control-user" id="exampleInputEmail" aria-describedby="emailHelp" placeholder="Enter Email Address...">
                    </div>
                    <div class="form-group">
                      <input name="password" type="password" class="form-control form-control-user" id="exampleInputPassword" placeholder="Password">
                    </div>
                    <div class="form-group">
                      <div class="custom-control custom-checkbox small">
                        <input name="remember" type="checkbox" class="custom-control-input" id="customCheck">
                        <label class="custom-control-label" for="customCheck">Remember
                          Me</label>
                      </div>
                    </div>
                    <button type="submit" class="btn btn-primary btn-block btn-user">Login</button>
                  </form>
                  <hr>
                  <div class="text-center">
                    <a class="small" href="{{ route('register') }}">Create an Account!</a>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
  <!-- Bootstrap core JavaScript-->
  <script src="{{ asset('admin_assets/vendor/jquery/jquery.min.js') }}"></script>
  <script src="{{ asset('admin_assets/vendor/bootstrap/js/bootstrap.bundle.min.js') }}"></script>
  <!-- Core plugin JavaScript-->
  <script src="{{ asset('admin_assets/vendor/jquery-easing/jquery.easing.min.js') }}"></script>
  <!-- Custom scripts for all pages-->
  <script src="{{ asset('admin_assets/js/sb-admin-2.min.js') }}"></script>
</body>
</html>
resources/views/auth/register.blade.php
?

//resources/views/auth/register.blade.php
<!DOCTYPE html>
<html lang="pt-br">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="">
  <meta name="author" content="">
  <title>SB Admin 2 - Register</title>
  <!-- Custom fonts for this template-->
  <link href="{{ asset('admin_assets/vendor/fontawesome-free/css/all.min.css') }}" rel="stylesheet" type="text/css">
  <link href="https://fonts.googleapis.com/css?family=Nunito:200,200i,300,300i,400,400i,600,600i,700,700i,800,800i,900,900i" rel="stylesheet">
  
  <!-- Custom styles for this template-->
  <link href="{{ asset('admin_assets/css/sb-admin-2.min.css') }}" rel="stylesheet">
</head>
<body class="bg-gradient-primary">
  <div class="container">
    <div class="my-5 border-0 shadow-lg card o-hidden">
      <div class="p-0 card-body">
        <!-- Nested Row within Card Body -->
        <div class="row">
          <div class="col-lg-5 d-none d-lg-block bg-register-image"></div>
          <div class="col-lg-7">
            <div class="p-5">
              <div class="text-center">
                <h1 class="mb-4 text-gray-900 h4">Create an Account!</h1>
              </div>
              <form action="{{ route('register.save') }}" method="POST" class="user">
                @csrf
                <div class="form-group">
                  <input name="name" type="text" class="form-control form-control-user @error('name')is-invalid @enderror" id="exampleInputName" placeholder="Name">
                  @error('name')
                    <span class="invalid-feedback">{{ $message }}</span>
                  @enderror
                </div>
                <div class="form-group">
                  <input name="email" type="email" class="form-control form-control-user @error('email')is-invalid @enderror" id="exampleInputEmail" placeholder="Email Address">
                  @error('email')
                    <span class="invalid-feedback">{{ $message }}</span>
                  @enderror
                </div>
                <div class="form-group row">
                  <div class="mb-3 col-sm-6 mb-sm-0">
                    <input name="password" type="password" class="form-control form-control-user @error('password')is-invalid @enderror" id="exampleInputPassword" placeholder="Password">
                    @error('password')
                      <span class="invalid-feedback">{{ $message }}</span>
                    @enderror
                  </div>
                  <div class="col-sm-6">
                    <input name="password_confirmation" type="password" class="form-control form-control-user @error('password_confirmation')is-invalid @enderror" id="exampleRepeatPassword" placeholder="Repeat Password">
                    @error('password_confirmation')
                      <span class="invalid-feedback">{{ $message }}</span>
                    @enderror
                  </div>
                </div>
                <button type="submit" class="btn btn-primary btn-user btn-block">Register Account</button>
              </form>
              <hr>
              <div class="text-center">
                <a class="small" href="{{ route('login') }}">Already have an account? Login!</a>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
  <!-- Bootstrap core JavaScript-->
  <script src="{{ asset('admin_assets/vendor/jquery/jquery.min.js') }}"></script>
  <script src="{{ asset('admin_assets/vendor/bootstrap/js/bootstrap.bundle.min.js') }}"></script>
  
  <!-- Core plugin JavaScript-->
  <script src="{{ asset('admin_assets/vendor/jquery-easing/jquery.easing.min.js') }}"></script>
  
  <!-- Custom scripts for all pages-->
  <script src="{{ asset('admin_assets/js/sb-admin-2.min.js') }}"></script>
</body>
</html>
create products folder and file resources/views/products/index.blade.php

?

//resources/views/products/index.blade.php
@extends('layouts.app')
  
@section('title', 'Home Product')
  
@section('contents')
    <div class="d-flex align-items-center justify-content-between">
        <h1 class="mb-0">List Product</h1>
        <a href="{{ route('products.create') }}" class="btn btn-primary">Add Product</a>
    </div>
    <hr />
    @if(Session::has('success'))
        <div class="alert alert-success" role="alert">
            {{ Session::get('success') }}
        </div>
    @endif
    <table class="table table-hover">
        <thead class="table-primary">
            <tr>
                <th>#</th>
                <th>Title</th>
                <th>Price</th>
                <th>Product Code</th>
                <th>Description</th>
                <th>Action</th>
            </tr>
        </thead>
        <tbody>+
            @if($product->count() > 0)
                @foreach($product as $rs)
                    <tr>
                        <td class="align-middle">{{ $loop->iteration }}</td>
                        <td class="align-middle">{{ $rs->title }}</td>
                        <td class="align-middle">{{ $rs->price }}</td>
                        <td class="align-middle">{{ $rs->product_code }}</td>
                        <td class="align-middle">{{ $rs->description }}</td>  
                        <td class="align-middle">
                            <div class="btn-group" role="group" aria-label="Basic example">
                                <a href="{{ route('products.show', $rs->id) }}" type="button" class="btn btn-secondary">Detail</a>
                                <a href="{{ route('products.edit', $rs->id)}}" type="button" class="btn btn-warning">Edit</a>
                                <form action="{{ route('products.destroy', $rs->id) }}" method="POST" type="button" class="p-0 btn btn-danger" onsubmit="return confirm('Delete?')">
                                    @csrf
                                    @method('DELETE')
                                    <button class="m-0 btn btn-danger">Delete</button>
                                </form>
                            </div>
                        </td>
                    </tr>
                @endforeach
            @else
                <tr>
                    <td class="text-center" colspan="5">Product not found</td>
                </tr>
            @endif
        </tbody>
    </table>
@endsection
resources/views/products/create.blade.php
?

//resources/views/products/create.blade.php
@extends('layouts.app')
  
@section('title', 'Create Product')
  
@section('contents')
    <h1 class="mb-0">Add Product</h1>
    <hr />
    <form action="{{ route('products.store') }}" method="POST" enctype="multipart/form-data">
        @csrf
        <div class="mb-3 row">
            <div class="col">
                <input type="text" name="title" class="form-control" placeholder="Title">
            </div>
            <div class="col">
                <input type="text" name="price" class="form-control" placeholder="Price">
            </div>
        </div>
        <div class="mb-3 row">
            <div class="col">
                <input type="text" name="product_code" class="form-control" placeholder="Product Code">
            </div>
            <div class="col">
                <textarea class="form-control" name="description" placeholder="Descriptoin"></textarea>
            </div>
        </div>
 
        <div class="row">
            <div class="d-grid">
                <button type="submit" class="btn btn-primary">Submit</button>
            </div>
        </div>
    </form>
@endsection
resources/views/products/show.blade.php
?

//resources/views/products/show.blade.php
@extends('layouts.app')
  
@section('title', 'Show Product')
  
@section('contents')
    <h1 class="mb-0">Detail Product</h1>
    <hr />
    <div class="row">
        <div class="mb-3 col">
            <label class="form-label">Title</label>
            <input type="text" name="title" class="form-control" placeholder="Title" value="{{ $product->title }}" readonly>
        </div>
        <div class="mb-3 col">
            <label class="form-label">Price</label>
            <input type="text" name="price" class="form-control" placeholder="Price" value="{{ $product->price }}" readonly>
        </div>
    </div>
    <div class="row">
        <div class="mb-3 col">
            <label class="form-label">product_code</label>
            <input type="text" name="product_code" class="form-control" placeholder="Product Code" value="{{ $product->product_code }}" readonly>
        </div>
        <div class="mb-3 col">
            <label class="form-label">Description</label>
            <textarea class="form-control" name="description" placeholder="Descriptoin" readonly>{{ $product->description }}</textarea>
        </div>
    </div>
    <div class="row">
        <div class="mb-3 col">
            <label class="form-label">Created At</label>
            <input type="text" name="created_at" class="form-control" placeholder="Created At" value="{{ $product->created_at }}" readonly>
        </div>
        <div class="mb-3 col">
            <label class="form-label">Updated At</label>
            <input type="text" name="updated_at" class="form-control" placeholder="Updated At" value="{{ $product->updated_at }}" readonly>
        </div>
    </div>
@endsection
resources/views/products/edit.blade.php
?

//resources/views/products/edit.blade.php
@extends('layouts.app')
  
@section('title', 'Edit Product')
  
@section('contents')
    <h1 class="mb-0">Edit Product</h1>
    <hr />
    <form action="{{ route('products.update', $product->id) }}" method="POST">
        @csrf
        @method('PUT')
        <div class="row">
            <div class="mb-3 col">
                <label class="form-label">Title</label>
                <input type="text" name="title" class="form-control" placeholder="Title" value="{{ $product->title }}" >
            </div>
            <div class="mb-3 col">
                <label class="form-label">Price</label>
                <input type="text" name="price" class="form-control" placeholder="Price" value="{{ $product->price }}" >
            </div>
        </div>
        <div class="row">
            <div class="mb-3 col">
                <label class="form-label">Product Code</label>
                <input type="text" name="product_code" class="form-control" placeholder="Product Code" value="{{ $product->product_code }}" >
            </div>
            <div class="mb-3 col">
                <label class="form-label">Description</label>
                <textarea class="form-control" name="description" placeholder="Descriptoin" >{{ $product->description }}</textarea>
            </div>
        </div>
        <div class="row">
            <div class="d-grid">
                <button class="btn btn-warning">Update</button>
            </div>
        </div>
    </form>
@endsection
Routes
routes/web.php
?

//routes/web.php
<?php
 
use Illuminate\Support\Facades\Route;
use App\Http\Controllers\AuthController;
use App\Http\Controllers\ProductController;
 
Route::get('/', function () {
    return view('welcome');
});
 
Route::controller(AuthController::class)->group(function () {
    Route::get('register', 'register')->name('register');
    Route::post('register', 'registerSave')->name('register.save');
  
    Route::get('login', 'login')->name('login');
    Route::post('login', 'loginAction')->name('login.action');
  
    Route::get('logout', 'logout')->middleware('auth')->name('logout');
});
  
Route::middleware('auth')->group(function () {
    Route::get('dashboard', function () {
        return view('dashboard');
    })->name('dashboard');
 
    Route::controller(ProductController::class)->prefix('products')->group(function () {
        Route::get('', 'index')->name('products');
        Route::get('create', 'create')->name('products.create');
        Route::post('store', 'store')->name('products.store');
        Route::get('show/{id}', 'show')->name('products.show');
        Route::get('edit/{id}', 'edit')->name('products.edit');
        Route::put('edit/{id}', 'update')->name('products.update');
        Route::delete('destroy/{id}', 'destroy')->name('products.destroy');
    });
 
    Route::get('/profile', [App\Http\Controllers\AuthController::class, 'profile'])->name('profile');
});
Run C:\xampp\htdocs\laravel\laravel10project>php artisan serve
Starting Laravel development server: http://127.0.0.1:8000

/**************************** */


app-geral
albertogomesdasilvaags@gmail.com
ltutegjecnbcgwro


# DespesaFactory.php
<?php

namespace Database\Factories;

use Illuminate\Database\Eloquent\Factories\Factory;

/**
 * @extends \Illuminate\Database\Eloquent\Factories\Factory<\App\Models\Despesa>
 */
class DespesaFactory extends Factory
{
    /**
     * Define the model's default state.
     *
     * @return array<string, mixed>
     */
    public function definition(): array
    {
        return [
            'despesas' => $this->faker->realTextBetween(25,45),
            'valor' => fake()->randomfloat(2, 10, 1000),
            'vencimento' => fake()->date(),
            'status' => fake()->boolean(),
            'pagamento' => fake()->date(),
            'obs' => fake()->sentence(5),
        ];
    }
}


# Model Despesa.php
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\SoftDeletes;
use Illuminate\Database\Eloquent\Factories\HasFactory;

class Despesa extends Model
{
    use HasFactory, SoftDeletes;

    protected $guarded = ['id'];
}


# Migrate migration Despesas
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create('despesas', function (Blueprint $table) {
            $table->id();

            $table->string('despesas');
            $table->float('valor')->nullable();
            $table->date('vencimento')->nullable();
            $table->boolean('status')->nullable();
            $table->date('pagamento')->nullable();
            $table->string('obs')->nullable();

            $table->softDeletes();

            
            $table->timestamps();
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists('despesas');
    }
};



# DatabaseSeeder.php
<?php

namespace Database\Seeders;

// use Illuminate\Database\Console\Seeds\WithoutModelEvents;
use App\Models\User;
use App\Models\Despesa;
use App\Models\Property;
use Illuminate\Database\Seeder;

class DatabaseSeeder extends Seeder
{
    /**
     * Seed the application's database.
     */
    public function run(): void
    {
        
        User::factory()->create([
            'name' => 'Alberto Gomes da Silva',
            'email' => 'albertogomesdasilva@gmail.com',
            'password' => bcrypt('12345678')
        ]);
        
       // \App\Models\User::factory(10)->create();
        
        Despesa::factory(10)->create();
        
        Property::factory(50)->create();
    }
}



### bootstrap no laravel 10

laravel new app_projeto

composer require laravel/ui

php artisan ui bootstrap

@vite(['resources/sass/app.scss','resources/js/app.js',])

npm install

npm run dev


http://www.oticamagnuns.com.br/cpanel/
ou
http://www.oticamagnuns.com.br:2083
Usuário: oticamag
Senha: p51HYa58yh!Q*V
FTP (Usado para transferências de arquivos do seu site)
FTP: ftp.oticamagnuns.com.br
O usuário e Senha é o mesmo do acesso ao cPanel
 
Acessos provisórios: Caso o DNS ainda não tenha completado a propagação, utilize os endereços abaixo para ter acesso ao cPanel, FTP.
cPanel: https://151.106.103.182:2083
FTP: 151.106.103.182

Assim que propagar você irá ver instalado já:
https://oticamagnuns.com.br/
admin@admin.com
adminadmin

Alterei lá para o subdominio:
pdv.oticamagnuns.com.br
admin@admin.com
adminadmin
18:24

Lucas Mendonça Prossi
o acesso ao cPanel é esse que vc mesmo me passou:
http://www.oticamagnuns.com.br:2083
Usuário: oticamag
Senha: p51HYa58yh!Q*V

CENTOS8
mysql  Ver 15.1 Distrib 10.3.28-MariaDB, for Linux (x86_64) using readline 5.1

https://www.digitalocean.com/community/tutorials/how-to-install-and-set-up-laravel-with-docker-compose-on-ubuntu-20-04-pt

https://www.digitalocean.com/community/tutorials/how-to-install-and-set-up-laravel-with-docker-compose-on-ubuntu-20-04-pt


docker stop $(docker ps -aq)
docker rm $(docker ps -aq)

docker rmi $(docker images -aq)


docker volume prune



https://www.youtube.com/watch?v=rK-nV-8_7vw&list=PLW-lITXBwAP-E0Lb627NzOgQx65Z_Wumv&index=2 - FILAMENT Designated Coder

https://youtu.be/B2HL572A3f0 FILAMENT - Leandro Beer and Code






sudo chown root:root storage/logs/laravel.log
sudo chmod 755 storage/logs/laravel.log


 criar projeto laravel com docker sail curl:
 curl -s "https://laravel.build/olw?with=mysql,redis,mailhog,minio" | bash
 curl -s "https://laravel.build/olw?with=pgsql" | bash
 curl -s "https://laravel.build/olw?with=mysql" | bash

# DOCKER
* APAGAR TODOS OS CONTAINERS EM EXECUÇÃO:
docker stop $(docker ps -aq)
docker rm $(docker ps -aq)

* APAGAR TODAS AS IMAGENS:
docker rmi $(docker images -aq)


* APAGAR TODOS OS VOLUMES:
docker volume prune



ALIAS: 
alias sail='[ -f sail ] && sh sail || sh vendor/bin/sail'

## DOCKER INSTALAR DOCKER CENTOS7


// Tutorial //
Como instalar e usar o Docker no CentOS 7
Publicado em 22 de agosto de 2019
Docker
CentOS
avatar padrão
por finido

Português
Como instalar e usar o Docker no CentOS 7
Introdução
O Docker é um aplicativo que torna simples e fácil executar processos de aplicações em um container, que são como máquinas virtuais, apenas mais portáteis, mais fáceis de usar e mais dependentes do sistema operacional do host. Para uma introdução detalhada aos diferentes componentes de um container Docker, confira O Ecossistema do Docker: Uma Introdução aos Componentes Comuns .

Existem dois métodos para instalar o Docker no CentOS 7. Um método envolve instalá-lo em uma instalação existente do sistema operacional. O outro envolve lançar um servidor com uma ferramenta chamada Docker Machine que instala automaticamente o Docker nele.

Neste tutorial, você aprenderá a instalar e usar o Docker em uma instalação existente do CentOS 7.

Pré-requisitos
Um Droplet CentOS de 64-bits
Um usuário não root com privilégios sudo. Um servidor CentOS 7 configurado usando o guia de Configuração Inicial do Servidor com o CentOS 7 .
Nota: O Docker requer uma versão de 64 bits do CentOS 7, bem como uma versão do kernel igual ou maior que 3.10. O Droplet padrão do CentOS 7 de 64 bits atende a esses requisitos.

Todos os comandos neste tutorial devem ser executados como um usuário não-root. Se o acesso como root for obrigatório para o comando, ele será precedido pelo sudo. O guia de Configuração Inicial do Servidor com o CentOS 7 explica como adicionar usuários e fornecer a eles o acesso ao sudo.

Passo 1 — Instalando o Docker
O pacote de instalação do Docker disponível no repositório oficial do CentOS 7 pode não ser a versão mais recente. Para obter uma versão mais recente e melhor, instale o Docker no repositório oficial do Docker. Esta seção mostra como fazer exatamente isso.

Mas primeiro, vamos atualizar o banco de dados de pacotes:

sudo yum check-update
Agora execute este comando. Ele adicionará o repositório oficial do Docker, baixará a versão mais recente do Docker e instalará:

curl -fsSL https://get.docker.com/ | sh
Após a conclusão da instalação, inicie o daemon do Docker:

sudo systemctl start docker
Verifique se ele está em execução:

sudo systemctl status docker
A saída deve ser semelhante à seguinte, mostrando que o serviço está ativo e em execução:

Output
● docker.service - Docker Application Container Engine
   Loaded: loaded (/lib/systemd/system/docker.service; enabled; vendor preset: enabled)
   Active: active (running) since Sun 2016-05-01 06:53:52 CDT; 1 weeks 3 days ago
     Docs: https://docs.docker.com
 Main PID: 749 (docker)
Por fim, certifique-se que ele vai iniciar em todas as reinicializações do servidor:

sudo systemctl enable docker
A instalação do Docker agora oferece não apenas o serviço Docker (daemon), mas também a utilidade de linha de comando dockerou o cliente Docker. Vamos explorar como usar o comando dockermais adiante neste tutorial.

Passo 2 — Executando Comandos Docker Sem Sudo (Opcional)
Por padrão, executar o comando dockerrequer privilégios de root — isto é, você tem que prefixar o comando com sudo. Ele também pode ser executado por um usuário no grupo docker , que é criado automaticamente durante a instalação do Docker. Se você tentar executar o comando dockersem prefixá-lo com sudo ou sem estar no grupo docker, você obterá uma saída como esta:

Output
docker: Cannot connect to the Docker daemon. Is the docker daemon running on this host?.
See 'docker run --help'.
Se você quiser evitar digitar sudosempre que executar o comando docker, adicione seu nome de usuário ao grupo docker:

sudo usermod -aG docker $(whoami)
Você precisará sair do Droplet e voltar como o mesmo usuário para ativar essa mudança.

Se você precisar adicionar um usuário ao grupo dockerno qual você não está logado, declare este nome de usuário explicitamente usando:

sudo usermod -aG docker username
O restante deste artigo supõe que você esteja executando o comando dockercomo um usuário do grupo de usuários docker. Se você optar por não fazê-lo, por favor, prefixe os comandos com sudo.

Passo 3 — Usando o Comando Docker
Com o Docker instalado e funcionando, agora é a hora de se familiarizar com o utilitário de linha de comando. O uso do dockerconsiste em passar uma cadeia de opções e subcomandos seguidos por argumentos. A sintaxe assume este formato:

docker [option] [command] [arguments]
Para ver todos os subcomandos disponíveis, digite:

docker
A partir do Docker 1.11.1, a lista completa de subcomandos disponíveis inclui:

Output

    attach    Attach to a running container
    build     Build an image from a Dockerfile
    commit    Create a new image from a container's changes
    cp        Copy files/folders between a container and the local filesystem
    create    Create a new container
    diff      Inspect changes on a container's filesystem
    events    Get real time events from the server
    exec      Run a command in a running container
    export    Export a container's filesystem as a tar archive
    history   Show the history of an image
    images    List images
    import    Import the contents from a tarball to create a filesystem image
    info      Display system-wide information
    inspect   Return low-level information on a container or image
    kill      Kill a running container
    load      Load an image from a tar archive or STDIN
    login     Log in to a Docker registry
    logout    Log out from a Docker registry
    logs      Fetch the logs of a container
    network   Manage Docker networks
    pause     Pause all processes within a container
    port      List port mappings or a specific mapping for the CONTAINER
    ps        List containers
    pull      Pull an image or a repository from a registry
    push      Push an image or a repository to a registry
    rename    Rename a container
    restart   Restart a container
    rm        Remove one or more containers
    rmi       Remove one or more images
    run       Run a command in a new container
    save      Save one or more images to a tar archive
    search    Search the Docker Hub for images
    start     Start one or more stopped containers
    stats     Display a live stream of container(s) resource usage statistics
    stop      Stop a running container
    tag       Tag an image into a repository
    top       Display the running processes of a container
    unpause   Unpause all processes within a container
    update    Update configuration of one or more containers
    version   Show the Docker version information
    volume    Manage Docker volumes
    wait      Block until a container stops, then print its exit code
Para visualizar as opções disponíveis para um comando específico, digite:

docker subcomando-docker --help
Para visualizar informações de todo o sistema, use:

docker info
Passo 4 — Trabalhando com Imagens Docker
Os containers Docker são executados a partir de imagens Docker. Por padrão, ele extrai essas imagens do Docker Hub, um registro Docker gerenciado pela Docker, a empresa por trás do projeto Docker. Qualquer pessoa pode criar e hospedar suas imagens no Docker Hub, de modo que a maioria das aplicações e distribuições Linux que você precisa para executar containers Docker tem imagens que estão hospedadas no Docker Hub.

Para verificar se você pode acessar e baixar imagens do Docker Hub, digite:

docker run hello-world
A saída, que deve incluir o seguinte, deve indicar que o Docker está funcionando corretamente:

Output
Hello from Docker.
This message shows that your installation appears to be working correctly.
...
Você pode procurar imagens disponíveis no Docker Hub usando o comando dockercom o subcomando search. Por exemplo, para procurar a imagem do CentOS, digite:

docker search centos
O script trackingá o Docker Hub e retornará uma listagem de todas as imagens cujo nome corresponde à string de pesquisa. Nesse caso, a saída será semelhante a esta:

Output
NAME                            DESCRIPTION                                     STARS     OFFICIAL   AUTOMATED
centos                          The official build of CentOS.                   2224      [OK]       
jdeathe/centos-ssh              CentOS-6 6.7 x86_64 / CentOS-7 7.2.1511 x8...   22                   [OK]
jdeathe/centos-ssh-apache-php   CentOS-6 6.7 x86_64 / Apache / PHP / PHP M...   17                   [OK]
million12/centos-supervisor     Base CentOS-7 with supervisord launcher, h...   11                   [OK]
nimmis/java-centos              This is docker images of CentOS 7 with dif...   10                   [OK]
torusware/speedus-centos        Always updated official CentOS docker imag...   8                    [OK]
nickistre/centos-lamp           LAMP on centos setup                            3                    [OK]

...
Na coluna OFICIAL , o OK indica uma imagem criada e suportada pela empresa por trás do projeto. Depois de identificar a imagem que você gostaria de usar, você pode fazer o download dela para o seu computador usando o subcomando pull, assim:

docker pull centos
Depois que uma imagem foi baixada, você pode então executar um container usando a imagem baixada com o subcomando run. Se uma imagem não tiver sido baixada quando o dockerfor executado com o subcomando run, o cliente do Docker primeiro fará o download da imagem e, em seguida, executará um container usando-a:

docker run centos
Para ver as imagens que foram baixadas para o seu computador, digite:

docker images
A saída deve ser semelhante ao seguinte:

[secondary_lable Output]
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
centos              latest              778a53015523        5 weeks ago         196.7 MB
hello-world         latest              94df4f0ce8a4        2 weeks ago         967 B
Como você verá mais adiante neste tutorial, as imagens que você usa para executar containers podem ser modificadas e usadas para gerar novas imagens, que podem então ser enviadas ( push é o termo técnico) para o Docker Hub ou outros registros Docker.

Passo 5 — Executando um Container Docker
O container hello-worldque você executou na etapa anterior é um exemplo de um container que é executado e sai após a emissão de uma mensagem de teste. Os containers, no entanto, podem ser muito mais úteis do que isso e podem ser interativos. Afinal, eles são semelhantes às máquinas virtuais, apenas mais fáceis de usar.

Como um exemplo, vamos rodar um container usando a última imagem do CentOS. A combinação das chaves -i e -t fornece a você o acesso interativo ao shell no container:

docker run -it centos
Seu prompt de comando deve mudar para refletir o fato de que você agora está trabalhando dentro do container e deve assumir esta forma:

Output
[root@59839a1b7de2 /]#
Importante: Observe o ID do container no prompt de comando. No exemplo acima, ele é 59839a1b7de2.

Agora você pode executar qualquer comando dentro do container. Por exemplo, vamos instalar o servidor MariaDB no container em execução. Não há necessidade de prefixar qualquer comando com o sudo, porque você está operando dentro do container com privilégios de root:

yum install mariadb-server
Passo 6 — Fazendo o Commit de alterações para uma Imagem Docker
Quando você inicia uma imagem Docker, você pode criar, modificar e excluir arquivos da mesma forma que você faz com uma máquina virtual. As alterações que você fez serão aplicadas apenas a esse container. Você pode iniciá-lo e pará-lo, mas depois de destruí-lo com o comando docker rm, as alterações serão perdidas para sempre.

Esta seção mostra como salvar o estado de um contêiner como uma nova imagem Docker.

Depois de instalar o servidor MariaDB dentro do container CentOS, agora você tem um container executando uma imagem, mas o container é diferente da imagem que você usou para criá-lo.

Para salvar o estado do container como uma nova imagem, primeiro saia dele:

exit
Em seguida, confirme ou faça o commit das alterações em uma nova instância de imagem Docker usando o seguinte comando. A chave -m é para a mensagem de commit que ajuda você e outras pessoas a saber quais alterações você fez, enquanto -a é usado para especificar o autor. O ID do container é aquele que você anotou anteriormente no tutorial quando iniciou uma sessão Docker interativa. A menos que você tenha criado repositórios adicionais no Docker Hub, o repositório geralmente é seu nome de usuário do Docker Hub:

docker commit -m "O que você fez na imagem" -a "Nome do autor" container-id repositório/novo_nome_da_imagem
Por exemplo:

docker commit -m "adicionado mariadb-server" -a "Sunday Ogwu-Chinuwa" 59839a1b7de2 finid/centos-mariadb
Nota: Quando você faz o commit de uma imagem, a nova imagem é salva localmente, isto é, no seu computador. Posteriormente neste tutorial, você aprenderá a enviar uma imagem para um registro Docker, como o Docker Hub, para que ela possa ser avaliada e usada por você e por outras pessoas.

Depois que a operação for concluída, listar as imagens Docker agora no seu computador deve a nova imagem, bem como mostrar a antiga da qual ela foi derivada:

docker images
A saída deve ser desse tipo:

Output
REPOSITORY             TAG                 IMAGE ID            CREATED             SIZE
finid/centos-mariadb   latest              23390430ec73        6 seconds ago       424.6 MB
centos                 latest              778a53015523        5 weeks ago         196.7 MB
hello-world            latest              94df4f0ce8a4        2 weeks ago         967 B
No exemplo acima, centos-mariadb é uma nova imagem, que foi derivada da imagem CentOS existente do Docker Hub. A diferença de tamanho reflete as alterações que foram feitas. Neste exemplo, a mudança foi que o servidor MariaDB foi instalado. Então, da próxima vez que você precisar executar um container usando o CentOS com o servidor MariaDB pré-instalado, basta usar a nova imagem. As imagens também podem ser construídas a partir do que é chamado de Dockerfile. Mas esse é um processo mais complicado e que está bem fora do escopo deste artigo. Vamos explorar isso em um artigo futuro.

Passo 7 — Listando os Containers Docker
Depois de usar o Docker por um tempo, você terá muitos contêineres ativos (em execução) e inativos no seu computador. Para ver os ativos, use:

docker ps
Você verá uma saída semelhante à seguinte:

Output
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES
f7c79cc556dd        centos              "/bin/bash"         3 hours ago         Up 3 hours                              silly_spence
Para visualizar todos os containers — ativos e inativos, passe a ele a chave -a:

docker ps -a
Para ver o container mais recente que você criou, utilize uma opção -l:

docker ps -l
Parar um container em execução ou ativo é tão simples quanto digitar:

docker stop container-id
Ocontainer-idpode ser encontrado na saída do comando docker ps.

Passo 8 — Enviando Imagens para um Repositório Docker
O próximo passo lógico depois de criar uma nova imagem a partir de uma imagem existente é tentar-la com alguns de seus amigos selecionados, o mundo inteiro no Docker Hub ou outro registro Docker ao qual você tem acesso. Para enviar uma imagem para o Docker Hub ou qualquer outro registro Docker, você deve ter uma conta lá.

Esta seção mostra como enviar uma imagem para o Docker Hub.

Para criar uma conta no Docker Hub, registre-se em Docker Hub . Depois, para enviar sua imagem, primeiro faça o login no Docker Hub. Você será solicitado a se autenticar:

docker login -u usuário_do_registro_docker
Se você especificou a senha correta, o login deve ser bem-sucedido. Então você pode enviar sua própria imagem usando:

docker push usuário_do_registro_docker/nome-da-imagem-docker
Isso levará algum tempo para ser concluído e, quando concluído, a saída será algo assim:

Output
The push refers to a repository [docker.io/finid/centos-mariadb]
670194edfaf5: Pushed 
5f70bf18a086: Mounted from library/centos 
6a6c96337be1: Mounted from library/centos

...

Depois de enviar uma imagem para um registro, ela deve estar listada no painel da sua conta, como mostra a imagem abaixo.

Listagem de imagens do Docker no Docker Hub

Se uma tentativa de envio resultar em um erro desse tipo, provavelmente você não efetuou login:

Output
The push refers to a repository [docker.io/finid/centos-mariadb]
e3fbbfb44187: Preparing
5f70bf18a086: Preparing
a3b5c80a4eba: Preparing
7f18b442972b: Preparing
3ce512daaf78: Preparing
7aae4540b42d: Waiting
unauthorized: authentication required
Faça o login e repita a tentativa de envio.

# INSTALAR DOCKER INTEGRADO AO TERMINAL UBUNTU DO WSL2

sudo update-alternatives --config iptables
/**/*/*/*/ */
Conclusão
Há muito mais no Docker do que foi mostrado neste artigo, mas isso deve ser suficiente para você começar a trabalhar com ele no CentOS 7. Como a maioria dos projetos open source, o Docker é construído a partir de uma base de código em rápido desenvolvimento , portanto, crie o hábito de visitar a página do blog do projeto para as informações mais recentes.

Confira também os outros tutoriais do Docker na Comunidade da DigitalOcean.

### INICIO 1
### LARAVEL PERMISSION COM SPATIE -Rômulo Ramos
1. Criar um novo projeto Laravel:
laravel new panel
2. Instalar a biblioteca Filament:
composer require filament/filament:"^2.0"
3. atualizar o composer.json: 
    "post-update-cmd": [
        // ...
        "@php artisan filament:upgrade"
],
4. Fazer a publicação do config/filament:
php artisan vendor:publish --tag=filament-config

5. Configurar o arquivo .env (Nome do aplicatico, banco de dados, usuario e senha do banco de dados)
6. Rodar a migrate
php artisan migrate
7. Criar usuário do Filament:
php artisan make:filament-user
8. \config\filament.php
    comenta linha 143 para remover widget
    linha 172 'dark_mode'
    linha 240 logo do rodapé 
    linha 248 collapsible true...

9. Instalar pacote de criação automática para formulários e tabelas:
composer require doctrine/dbal --dev

10. Criando formulários e Tabelas a partir da model User.php
php artisan make:filament-resource User --generate 

11. Configurando App\Filament\Resources\UserResource\Pages\CreateUser.php para salvar senha do usuário criptografada ao criar e ao editar o usuário:
<!-- CreateUser.php

class CreateUser extends CreateRecord
{
    protected static string $resourcee - UserResouce::class;

    protected function mutateFormDataBeforeCreate(array $data): array
    {
        dd($data);

        $data['password'] = Hash::make($data['password']);

        dd($data);

        return $data;
    }
}

EditUser.php

$data['password'] = Hash::make($data['password']);
return $data; -->

# FAZER TUDO EM UM ÚNICO ARQUIVO UserResouce.php (não esquecer de importar a class Hash) - só será obrigatório preencer o campo password quando estiver no modo de criação.

// ...
public static function form(Form $form): Form
{
    return $form
    /....

Forms\Components\TextInput::make('password')
    ->label('Senha')
    ->dehydrateStateUsing(fn($state) => Hash::make($state))
    ->dehydrated(fn($state) => filled($state))
    ->required(fn($context): bool => $context === 'create')
]);


# INSTALANDO O LARAVEL PERMISSION
php require spatie/laravel-permission
# PUBLICANDO
php artisan vendor::publish --provider="Spatie\Permission\PermissionServiceProvider"

php artisan optimizer:clear 
ou
php artisan config:clear

# RODANDO AS MIGRATES PARA GERAR NOVAS TABELAS DE DE PERMISSÕES (roles, permissions, ...)
php artisan migrate

# CRIAR A MODEL Role
php artisan make:model Role # ESTA MODEL DEVE SER EXTENDIDA NÃO DE Model mas de ModelsRole do Laravel permission:

Role.php
namespace App\Models;

use illuminate\Database\Eloquent\Factories\HasFactory;
use illuminate\Database\Eloquent\Model;

use Spatie\Permission\Model\Role as ModelsRole;

class Role extends ModelsRole
{
    use HasFactory;
}

# CRIANDO UM RESOURCE A PARTIR DA MODEL ROLE
php artisan make:filament-resource Role --generate
php artisan make:filament-resource Role --generate --simple (--simple cria os formulário com sistema de modal)

* No formulário de inserção de Roles por padrão o campo guarded é inserido como web, portanto, podemos eliminar esse campo do formulário em RoleResource.php

* podemos também remover o campo update:
* podemos criar a role admin

# CRIANDO A MODEL Permission.php
EXTENDER DE PERMISSION TAMBÉM
# CRIAR O RESOUCE
php artisan make:filament-resource Permission --generate --simple
 
* remover o campo guarded e updated_at do formulário e da table

# FAZENDO O RELACIONAMENTO ENTRE As ROLEs E o USUÁRIOS;
App\Filament\Resources\UserResource.php
UserResource.php

{ return $form
        ->schema([
            Forms\Components\ // ....
                Forms\Components\ // ....
                Forms\Components\ // ....

                Forms\Components\TextInput::make('password')
                    ->label('Senha')
                    ->dehydrateStateUsing(fn($state) => Hash::make($state))
                    ->dehydrated(fn($state) => filled($state))
                    ->required(fn($context): bool => $context === 'create'),

     =====>          //  ACRESCENTA ESTE CÓDIGO:   <===============
                Forms\Components\Select::make('roles')
                    ->multiple()
                    ->relationship('roles', 'name')
                    ->preload()  <==== ESTA OPÇÃO É PARA QUANDO ACESSAR O CAMPO JÁ CARREGAR AS OPÇÕES SEM PRECISAR DIGITAR...


        ]);
}

ANTES DE EDITAR .. NA MODEL DE USUÁRIOS: User.php acrescenta a classe HasRoles, e faz a importação dela:

User.php

    namespace App\Models;

    /...
    /...
    /...
    use Spatie\Permission\Traits\HasRoles;

    class User extendes Authenticatable
    {
        use HasApiTokens, HasFactory, Notifiable, HasRoles;

        // ...
        // ...
    }
Agora pode utilizar as Roles no Cadastro de Usuários;

### CADASTRANDO E CONFIGURANDO AS PERMISSÕES
User.php

    namespace App\Models;

    /...
    /...
    /...
    use Spatie\Permission\Traits\HasRoles;
    use Filament\Models\Contracts\FilamentUser;   <================= importa a classe

    <!-- class User extendes Authenticatable -->   <============= ERA ASSIM, ...
    class User extendes Authenticatable implements FilamentUser   <======== FICA ASSIM
    {
        use HasApiTokens, HasFactory, Notifiable, HasRoles;

        // ...
        // ... ;

        ACRESCENTA A FUNÇÃO ABAIXO PARA VALIDAR SE O USUÁRIO TEM A ROLES..

        public function canAccessFilament(): bool
        {
            return $this->hasRole(['Admin', 'Manager']);
        }
    }

* Desta forma o Admin e o Gerente  têm acesso ao painel admin

# Vamos fazer o mesmo relacionamento feito em UserPermission.php no arquivo PermissionResource.php sem alterar nada...

PermissionResource.php

/...

  =====>          //  ACRESCENTA ESTE CÓDIGO:   <===============
                Forms\Components\Select::make('roles')
                    ->multiple()
                    ->relationship('roles', 'name')
                    ->preload()  <==== ESTA OPÇÃO É PARA QUANDO ACESSAR O CAMPO JÁ CARREGAR AS OPÇÕES SEM PRECISAR DIGITAR...


        ]);
}

# E NAS ROLES, QUANDO CRIAMOS UMA ROLE SELECIONAR LOGO QUAIS AS PERMISSÕES QUE ELA VAI TER:

RoleResource.php

//..
{
    protected static ?string $model = Role::class;

    protected static ?string $navigationIcon = 'heroicon-o-collection';

    public static function form(Form $form): Form
       {
        return $form
            ->schema([
                Forms\Components\TextInput::make('name')
                    ->required()
                    ->maxLenght(255),
            ===> ADICIONAMOS ESTE CÓDIGO ABAIXO: <=======================================
                Forms\Components\Select::make('permissiona')   <========= AQUI ALTERA 'roles' PARA 'permissions'
                    ->multiple()
                    ->relationship('permissions', 'name')    <============= AQUI ALTERA 'roles' PARA 'permissions'
                    ->preload(),
            ======> ATÉ AQUI <=====================================================
            ]);
       }
       
       public static function table(Table $table): Table
       {
            return $table
            ->columns([
                //....
                //....
                //....

            ])
       }
}

* NÃO TEM NENHUMA PERMISÃO CADASTRADA AINDA... NA DOCUMENTAÇÃO: 'usuários possuem regras e regras possuem permissões'

* Criaremos uma nova permissão access_admin e adicionamos ela para Admin e Manager... e salva.

* AGORA EM User.php (na Model), alteramos a ultima função criada no final do arquivo:

User.php

//...
//...
    
        public function canAccessFilament(): bool
        {
            return $this->hasRole(['Admin', 'Manager']);
        }
    }

FICA ASSIM:
    
        public function canAccessFilament(): bool
        {
            return $this->hasPermissionTo('access_admin');
        }
    }

... assim continua funcionando.

# ATÉ ENTÃO O USUÁRIO QUE NÃO TEM REGRA NÃO TEM ACESSO AO ADMIN DO FILAMENT
* criaremos através do formulário de Permissões as regras: 
user_read ->Admin, Manager
user_create ->Admin, Manager
user_update ->Admin, Manager
user_delete ->Admin, Manager

* Agora para que essas permissões funcionem no sistema criando as policIes:

php artisan make:policy UserPolicy --model=User    //CRIA A POLICY UTILIZANDO A MODEL USER.PHP

App\Policies\UserPolicy.php

UserPolicy.php

* Precisa ser registrada em: App\Providers\AuthServiceProvider.php

AuthServiceProvider.php
    namespace App\Providers;

    use App\Models\User;
    use App\Policies\UserPolicy;  <========== TEM QUE IMPORTAR A CLASSE
    use Illuminate\Foundation\Support\Providers\AuthServiceProvider as ServiceProvider;

        class AuthServiceProvider extends ServiceProvider
    //...
    //...
        protected $policies = [
            // 'App\Models\Model' => 'App\Policies\ModelPolicy',
            User::class => UserPolicy::class,
        ];
        //...
        //...
        //...


# EM UserPolicy.php

UserPolicy.php
<?php
    namespace App\Policies;

    use App\Models\User;
    use illuminate\Auth\Access\Response;

    class UserPolicy
    {
        public function viewAny(User $user): bool
        {
            return $user->hasPermissionTo('user_read');
        }
        
        public function view(User $user, User $model): bool
        {
            return $user->hasPermissionTo('user_read');
        }

        public function create(User $user): bool
        {
            return $user->hasPermissionTo('user_create');
        }

        public function update(User $user, User $model): bool
        {
            return $user->hasPermissionTo('user_update');
        }
        public function delete(User $user, User $model): bool
        {
            return $user->hasPermissionTo('user_delete');
        }

        * OS DEMAIS PARA BAIXO PODEM SER DELETADOS...
    }

# CRIAREMOS PERMISSÕES E VINCULAREMOS AO USUÁRIO FAZ LOGOF E LOGON COM USUÁRIO PARA TESTAR

# CRIAREMO DA MESMA FORMA OS POLICIES DE ROLES:
App\Policies\c

PermissionPolicy.php

//...
 class RolePolicy
 {
    public function viewAny(User $user): bool
        {
            return $user->hasPermissionTo('role_read');
        }

        public function view(User $user, Role $role): bool
        {
            return $user->hasPermissionTo('role_read');
        }

        public function create(User $user): bool
        {
            return $user->hasPermissionTo('role_create');
        }

        public function update(User $user, Role $role): bool
        {
            return $user->hasPermissionTo('role_update');
        }

        public function delete(User $user, Role $role): bool
        {
            return $user->hasPermissionTo('role_delete');
        }

 }

# CRIAREMO DA MESMA FORMA OS POLICIES DE PERMISSIONS:
App\Policies\PermissionPolicy.php

PermissionPolicy.php

//...
 class PermissionPolicy
 {
     {
            return $user->hasPermissionTo('permission_read');
        }

        public function view(User $user, Permission $permission): bool
        {
            return $user->hasPermissionTo('permission_read');
        }

        public function create(User $user): bool
        {
            return $user->hasPermissionTo('permission_create');
        }

        public function update(User $user, Permission $permission): bool
        {
            return $user->hasPermissionTo('permission_update');
        }

        public function delete(User $user, Permission $permission): bool
        {
            return $user->hasPermissionTo('permission_delete');
        }

 }
    

### CRIAR ATRAVÉS DOS FORMULÁRIOS:

# criar no painel as demais permissions... access_admim, user_read, user_create, user_update, user_delete já tem...

# criar: role_read, role_create, role_update, role_delete, permission_read, permission_create, permission_update, permission_delete.

# Roles: 
        Mannager -> access_admin, user_read, user_create, user_update, user_delete
        User -> access_admin
        Admin-> access_admin, user_read, user_create, user_update, user_delete, role_read, role_create, role_update, role_delete,
                permission_read, permission_create, permission_update, permission_delete.


### LIMITANDO O PERFIL DE USUÁRIO E MANAGER PARA NÃO CRIAR, ALTERAR OU DELETAR INDEVIDAMENTE:
# LIMITANDO O USUARIO:

* LIMITANDO O MANAGER PARA NÃO CRIAR ADMINISTRADOR, SOMENTE MANAGER E USUÁRIOS:
-> App\Filament\Resource\UserResource.php
    UserResource.php

    //...
      <!-- =====>          //  ESTE CÓDIGO:   <===============
                Forms\Components\Select::make('roles')
                    ->multiple()
                    ->relationship('roles', 'name')
                    ->preload()  <====  -->

==================  > FICA ASSIM:
                 Forms\Components\Select::make('roles')
                    ->multiple()
                    ->relationship('roles', 'name', fn(Builder $query) =>
                        auth()->user()->hasRole('Admin') ? null : $query->where('name', '!=', 'Admin')
                                    )
                    ->preload()

* testa se admin continua acessando tudo, faz logof e login como manager e testa.. 
#### LIMITANDO O MANAGER DE EXCLUIR ADMIN:

->Em UserResource.php - NO FINAL DO ARQUIVO:
//..
//..
//..
public static function getPages(): array
{
    return [
        'index' => Pages\ListUsers::route('/'),
        'create' => Pages\CreateUser::route('/create'),
        'edit' => Pages\EditUser::route('/{record}/edit'),
    ];

====> INSERE A FUNÇÃO ABAIXO:
  public static function getEloquentQuery(): Builder
  {
    retunr auth()->user()->hasRole('Admin')
    ? parent::getEloquentQuery()
    : parent::getEloquentQuery()->whereHas('roles', fn(Builder $query) => $query->where('name', '!=', 'Admin'))
  }  

}

# INSTALANDO PACOTES DE TRADUÇÃO E PUBLICANDO O ARQUIVOS DE CONFIGURAÇÃO E ADICIONANDO A LINGUAGEM pr_BR:

php require laravel-lang/publisher laravel-lang/lang laravel-lang/attributes --dev

php artisan vendor:publish --provider="LaravelLang\Publisher\ServiceProvider"

php artisan lang:add pt_BR

config\app.php

linha 72: 'timezone' => 'America/Sao_Paulo',

linha 85: 'locale' => 'pt_BR',

* com isso todo o painel fica em português... fim.
# PARA COMPLETAR ALTERAÇÃO DE TEXTOS NO PAINEL E AGRUPANDO ITENS DO MENU
link: filament.com/docs/2.x/admin/resources/getting-started#model-labels

* UserResource.php
//..
protected static ?string $navigationIcon = 'heroicon-o-users';

protected static ?string $modelLabel = "Usuário";

* RoleResource.php
//..
protected static ?string $navigationIcon = 'heroicon-o-users';

protected static ?string $modelLabel = "Função";
protected static ?string $pluralmodelLabel = "Funções";

protected static ?string $navigationGroup = 'Configurações';  <=== Titulo no grupo no menu no painel

//..

* PermissionResource.php
//..
protected static ?string $navigationIcon = 'heroicon-o-users';

protected static ?string $modelLabel = "Permissão";
protected static ?string $pluralmodelLabel = "Permissões";
protected static ?string $navigationGroup = 'Configurações';  <=== Titulo no grupo no menu no painel

//..


# PERMITINDO EDIÇÃO NOS CAMPOS ->unique():
    ->unique
    ->unique(ignoreRecord: true)    <======== ACRESCENTA ESTE ABAIXO

# ALTERANDO O COMPORTAMENTO PADRÃO AO SALVAR UM NOVO USUÁRIO QUE É DE IR PARA A TELA DE EDIÇÃO, VAMOS MUDAR PARA IR PARA A TELA PRINCIPAL:
* App\Filament\Resources\UserResource\Pages\CreateUser.php
CreateUser.php, EditUser.php, CreateRole etc... Onde precisar...

//..
    class CreateUser extends CreateRecord
    {
        protected static string $resource = UserResouce::class;

        ///// FUNÇÃO PARA REDIRECIONAMENTO ///

        protected function getRedirectUrl(): string
        {
            return $this->getResource()::getUrl('index');
        }
    }


# SE QUISER ALTERAR O SLUG NA ROTA:

* UserResource.php, ou RoleResource.php ou PermissionResource.php
//..
protected static ?string $navigationIcon = 'heroicon-o-users';

protected static ?string $modelLabel = "Usuário";

protected static ?string $slug = 'usuario'   <================= acrescenta esta linha para mudar na url



# FIM 1. - RÔMULO RAMOS

#### ######### ############ INICIO 2
#  TITULO : PAINEL DE ADMINISTRAÇÃO DO LARAVEL FILAMENT E SPATIE (LARAVEL PERMISSION) PARA CONTROLE DE NIVEL DE ACESSO : ###############
 Filamento: https://filamentphp.com/

Permissão Laravel de Spatie: https://spatie.be/docs/laravel-permis...

laravel new coders_filament_admin_panel --jet

* links de videos no youtube:
  https://youtu.be/rK-nV-8_7vw?list=PLW-lITXBwAP-E0Lb627NzOgQx65Z_Wumv
  https://www.youtube.com/watch?v=uRj9QyrQTOU
* github: https://www.youtube.com/redirect?event=comments&redir_token=QUFFLUhqbGpPeWN4VlV4VTczUEFkendhVTdZMXF2aXVnd3xBQ3Jtc0tsTFVVSEdDak1fNEIyOUl2cVI3R0swamV4cFJyLURSLW1GSzkzSjhrRmZxX0tSYVNnekVRM29EQmM3RlYyZ0czY0xNcmx4M2pnaFlDT2JTVjNHRGlhSFBhbnRWUUhVeTRxa01pbVpBNnVZVWZkV3BPdw&q=https%3A%2F%2Fgithub.com%2Fdesignatedcoder%2Fcoders_filament_admin_panel&stzid=UgyQZuOX2HbYMSeZGI14AaABAg



  which Jetstream stack do you prefer?
  [0] livewire
  [1] inertia
  > 0 -> iremos usar o livrewire
  will your application use team? (yes/no) [no]:
  > no
* parte inicial do composer.json
{
    "name": "laravel/laravel",
    "type": "project",
    "description": "The Laravel Framework.",
    "keywords": ["framework", "laravel"],
    "license": "MIT",
    "require": {
        "php": "^8.0.2",
        "doctrine/dbal": "^3.4",
        "filament/filament": "^2.0",
        "guzzlehttp/guzzle": "^7.2",
        "laravel/framework": "^9.19",
        "laravel/jetstream": "^2.12",
        "laravel/sanctum": "^3.0",
        "laravel/tinker": "^2.7",
        "livewire/livewire": "^2.5",
        "spatie/laravel-permission": "^5.5"
    },
# .env -> nome do APP, DBASE_NAME, USER, PASSWORD
# RODANDO AS MIGRATIONS
php artisan migrate
# RODANDO O PROJETO
php artisan serve
npm run dev
# filament.com (Verificar Requirements: php 8.0+, Laravel v8.0+, Livewire v2.0+ )
composer require filament/filament:"^2.0"

# Criando usuário para o Filament:
php artisan make:filamente-user

# Alterando o composer.json
composer.json:
"post-update-cmd": {
  //..
  "@php artisan filamente:upgrade"
}

# Publicar o arquivo de configuração (Cria um arquivo em: \config\filament.php)
php artisan vendor:publish --tag=filament-config

# Instalando pacote de tradução:
php artisan vendor:publish --tab=filament-translations

# Configurações em config/filament.php
* linha 28: pode alterar a rota do painel admin do filament 
'path' => env('FILAMENT_PATH', 'admin') pode mudar para: 'path' => env('FILAMENT_PATH', '/')
* linha 172: mode dark_mode
* linha 239 'footer' => [ should_show_log' =>false, ],
* linha 246: 'sidebar' => [ 'is_collapsible' => true, ],


# spatie.be/docs/laravel-permission/v5/introduction
Filamento: https://filamentphp.com/
Permissão Laravel de Spatie: https://spatie.be/docs/laravel-permis...

* Instalando no laravel:
composer require spatie/laravel-permission

* Publicando spatie/laravel-permission: 
php artisan vendor:publish --provider="Spatie\Permission\PermissionServiceProvider"
*obs: se estiver usando uuid's rode: php artisan optimize:clear or php artisan config:clear e depois php artisan migrate

* vamos adicionar uma coluna is_admin na tabela de usuários:
php artisan make:migrateion add_is_admin_to_users_table

public function up()
  {
    Schema::table('users', function (Blueprint $table) {
      $table->boolean('is_admin')->after('name')->default(0);
    });
  }

Public function down()
{
  Shema::table('users', function(Blueprint $table) {
    $table->dropColumn('is_admin');
  });
}

# Alterando a Model User.php

Class User extends Authenticatable
  {
    use HasApiTokens;
    use HasFactory;
    use Has ProfilePhoto;
    use HasRoles;  <============================================= INCLUIMOS ESTA LINHA  
    use Notifiable;
    use TwoFactorAuthenticatable;
     
     /**
     *
     The attributes that are mass assignable.
     * @var.string[]
      */
    protected $fi.lable = [
      'name',
      'is_admin',    <=============---------============ INCLUIMOS ESTE CAMPO AQUI
      'emali',
      'password',
    ];
    /...
  }

# Criando um Seed: temos liberando o cach antes da propagação de novos dados:
php artisan make:seeder RolesAndPermissionsSeeder

RolesAndPermissionsSeeder.php
<?php

namespace Database\Seeders;

use App\Models\User;
use Illuminate\Support\Str;
use Illuminate\Database\Seeder;
use Spatie\Permission\Models\Role;
use Illuminate\Support\Facades\Hash;
use Spatie\Permission\Models\Permission;
use Spatie\Permission\PermissionRegistrar;
use Illuminate\Database\Console\Seeds\WithoutModelEvents;

class RolesAndPermissionsSeeder extends Seeder
{
    /**
     * Run the database seeds.
     *
     * @return void
     */
    public function run() {
        // reset cached roles and permissions
        app()[\Spatie\Permission\PermissionRegistrar::class]->forgetCachedPermissions();

        // Misc
        $miscPermission = Permission::create(['name' => 'N/A']);

        // USER MODEL
        $userPermission1 = Permission::create(['name' => 'create: user']);
        $userPermission2 = Permission::create(['name' => 'read: user']);
        $userPermission3 = Permission::create(['name' => 'update: user']);
        $userPermission4 = Permission::create(['name' => 'delete: user']);

        // ROLE MODEL
        $rolePermission1 = Permission::create(['name' => 'create: role']);
        $rolePermission2 = Permission::create(['name' => 'read: role']);
        $rolePermission3 = Permission::create(['name' => 'update: role']);
        $rolePermission4 = Permission::create(['name' => 'delete: role']);

        // PERMISSION MODEL
        $permission1 = Permission::create(['name' => 'create: permission']);
        $permission2 = Permission::create(['name' => 'read: permission']);
        $permission3 = Permission::create(['name' => 'update: permission']);
        $permission4 = Permission::create(['name' => 'delete: permission']);

        // ADMINS
        $adminPermission1 = Permission::create(['name' => 'read: admin']);
        $adminPermission2 = Permission::create(['name' => 'update: admin']);

        // CREATE ROLES
        $userRole = Role::create(['name' => 'user'])->syncPermissions([
            $miscPermission,
        ]);

        $superAdminRole = Role::create(['name' => 'super-admin'])->syncPermissions([
            $userPermission1,
            $userPermission2,
            $userPermission3,
            $userPermission4,
            $rolePermission1,
            $rolePermission2,
            $rolePermission3,
            $rolePermission4,
            $permission1,
            $permission2,
            $permission3,
            $permission4,
            $adminPermission1,
            $adminPermission2,
            $userPermission1,
        ]);
        $adminRole = Role::create(['name' => 'admin'])->syncPermissions([
            $userPermission1,
            $userPermission2,
            $userPermission3,
            $userPermission4,
            $rolePermission1,
            $rolePermission2,
            $rolePermission3,
            $rolePermission4,
            $permission1,
            $permission2,
            $permission3,
            $permission4,
            $adminPermission1,
            $adminPermission2,
            $userPermission1,
        ]);
        $moderatorRole = Role::create(['name' => 'moderator'])->syncPermissions([
            $userPermission2,
            $rolePermission2,
            $permission2,
            $adminPermission1,
        ]);
        $developerRole = Role::create(['name' => 'developer'])->syncPermissions([
            $adminPermission1,
        ]);

        // CREATE ADMINS & USERS
        User::create([
            'name' => 'super admin',
            'is_admin' => 1,
            'email' => 'super@admin.com',
            'email_verified_at' => now(),
            'password' => Hash::make('password'),
            'remember_token' => Str::random(10),
        ])->assignRole($superAdminRole);

        User::create([
            'name' => 'admin',
            'is_admin' => 1,
            'email' => 'admin@admin.com',
            'email_verified_at' => now(),
            'password' => Hash::make('password'),
            'remember_token' => Str::random(10),
        ])->assignRole($adminRole);

        User::create([
            'name' => 'moderator',
            'is_admin' => 1,
            'email' => 'moderator@admin.com',
            'email_verified_at' => now(),
            'password' => Hash::make('password'),
            'remember_token' => Str::random(10),
        ])->assignRole($moderatorRole);

        User::create([
            'name' => 'developer',
            'is_admin' => 1,
            'email' => 'developer@admin.com',
            'email_verified_at' => now(),
            'password' => Hash::make('password'),
            'remember_token' => Str::random(10),
        ])->assignRole($developerRole);

        for ($i=1; $i < 50; $i++) {
            User::create([
                'name' => 'Test '.$i,
                'is_admin' => 0,
                'email' => 'test'.$i.'@test.com',
                'email_verified_at' => now(),
                'password' => Hash::make('password'), // password
                'remember_token' => Str::random(10),
            ])->assignRole($userRole);
        }
    }
}

# Alterando o DatabaseSeeder.php
<?php

namespace Database\Seeders;

// use Illuminate\Database\Console\Seeds\WithoutModelEvents;
use Illuminate\Database\Seeder;

class DatabaseSeeder extends Seeder
{
    /**
     * Seed the application's database.
     *
     * @return void
     */
    public function run() {
        $this->call(RolesAndPermissionsSeeder::class);
        // \App\Models\User::factory(10)->create();

        // \App\Models\User::factory()->create([
        //     'name' => 'Test User',
        //     'email' => 'test@example.com',
        // ]);
    }
}

## AGORA RODANDO AS MIGRATIONS COM SEEDERS atualizando com fresh
php artisan migrate:fresh --seed

verificar tabelas criadas e alteradas...

# CRIANDO RESOURCES
php artisan make:filament-resource Permission --simple


* (obs) se der erro "Class App\Models\Permission" not foun exclui a importação em App\Filamente\Resource; da linha use App\Models\Permission; e importe de use Spatie\Permission\Models\Permission;
* NESTE ARQUIVO CRIAMOS A TABELA E O FORMULÁRIO NA DIGITANDO
* PARA CRIAR FORMULÁRIOS E TABELAS AUTOMATICAMENTE: 
php artisan require doctrine/dbal

## php artisan make:filament-resource Permission --generate --simple 
ou
## php artisan make:filament-resource Permission --generate --view --simple 



<?php

* app/Filament/Resources/PermissionResource.php


namespace App\Filament\Resources;

use Filament\Forms;
use Filament\Tables;
use Filament\Resources\Form;
use Filament\Resources\Table;
use Filament\Resources\Resource;
use Spatie\Permission\Models\Permission;
use Illuminate\Database\Eloquent\Builder;
use Illuminate\Database\Eloquent\SoftDeletingScope;
use App\Filament\Resources\PermissionResource\Pages;
use App\Filament\Resources\PermissionResource\RelationManagers;
use Filament\Forms\Components\Card;
use Filament\Forms\Components\TextInput;
use Filament\Tables\Columns\TextColumn;

class PermissionResource extends Resource
{
    protected static ?string $model = Permission::class;

    protected static ?string $navigationIcon = 'heroicon-o-key'; <=============== AQUI CONFIGURA O ÍCONE (mudou o nome collection para key)

    protected static ?string $navigationGroup = 'Admin Management';  <==================  CONFIGURA O MENU DO PAINEL EM GRUPOS DE OPÇÕES, SUB-MENUS

    public static function form(Form $form): Form {
        return $form
            ->schema([
                Card::make()
                    ->schema([
                        TextInput::make('name')
                            ->unique()
                            ->required()
                    ])
            ]);
    }

    public static function table(Table $table): Table {
        return $table
            ->columns([
                TextColumn::make('id')->sortable(),
                TextColumn::make('name')->sortable()->searchable(),
                TextColumn::make('created_at')
                    ->dateTime('d-M-Y')
                    ->sortable()
                    ->searchable(),
            ])
            ->filters([
                //
            ])
            ->actions([
                Tables\Actions\EditAction::make(),
                Tables\Actions\DeleteAction::make(),
            ])
            ->bulkActions([
                Tables\Actions\DeleteBulkAction::make(),
            ]);
    }

    public static function getPages(): array
    {
        return [
            'index' => Pages\ManagePermissions::route('/'),
        ];
    }
}

### CRIANDO AS ROLES: App\Filament\Resource\RoleResource.php
php artisan make:filamente-resource Role

* AO EXECUTAR O COMANDO E ATUALIZAR NO NAVEGADOR NÃO APARECE NADA PORQUE AS CLASSES DE FORMS E TABLES ESTÃO VAZIAS, FAZEMOS ASSIM:

RoleResource.php
<?php

namespace App\Filament\Resources;

use Filament\Forms;
use Filament\Tables;
use Filament\Resources\Form;
use Filament\Resources\Table;
use Filament\Resources\Resource;
use Spatie\Permission\Models\Role;   <==== AQUI TINA use App\Models\Role; e FOI SUBSTITUÍDO, DELETADO E IMPORTADA NOVAMENTE. nÃO É DA FUNÇÃO DE mODELOS DE APLICATIVO E SIM ESSAS FUNÇÕES VÊM DE SPATIE's.
use Filament\Forms\Components\Card;
use Filament\Tables\Columns\TextColumn;
use Filament\Forms\Components\TextInput;
use Filament\Tables\Actions\DeleteAction;
use Illuminate\Database\Eloquent\Builder;
use App\Filament\Resources\RoleResource\Pages;
use Illuminate\Database\Eloquent\SoftDeletingScope;
use App\Filament\Resources\RoleResource\RelationManagers;
use App\Filament\Resources\RoleResource\RelationManagers\PermissionsRelationManager;
use Filament\Forms\Components\Select;

class RoleResource extends Resource
{
    protected static ?string $model = Role::class;

    protected static ?string $navigationIcon = 'heroicon-s-cog';

    protected static ?string $navigationGroup = 'Admin Management';

    public static function form(Form $form): Form {
        return $form
            ->schema([
                Card::make()
                    ->schema([
                        TextInput::make('name')
                            ->unique(ignoreRecord: true)
                            ->required(),
                        Select::make('permissions')
                            ->multiple()
                            ->relationship('permissions', 'name')
                            ->preload()
                            ->required()
                    ])
            ]);
    }

    public static function table(Table $table): Table {
        return $table
            ->columns([
                TextColumn::make('id')->sortable(),
                TextColumn::make('name')->sortable()->searchable(),
                TextColumn::make('created_at')
                    ->dateTime('d-M-Y')
                    ->sortable()
                    ->searchable(),
            ])
            ->filters([
                //
            ])
            ->actions([
                Tables\Actions\EditAction::make(),
                DeleteAction::make(),
            ])
            ->bulkActions([
                Tables\Actions\DeleteBulkAction::make(),
            ]);
    }

    public static function getRelations(): array {
        return [
            PermissionsRelationManager::class,
        ];
    }

    public static function getPages(): array
    {
        return [
            'index' => Pages\ListRoles::route('/'),
            'create' => Pages\CreateRole::route('/create'),
            'edit' => Pages\EditRole::route('/{record}/edit'),
        ];
    }
}

# app/Filament/Resources/RoleResource/Pages
/CreateRole.php

<?php

namespace App\Filament\Resources\RoleResource\Pages;

use App\Filament\Resources\RoleResource;
use Filament\Pages\Actions;
use Filament\Resources\Pages\CreateRecord;

class CreateRole extends CreateRecord
{
    protected static string $resource = RoleResource::class;

    protected function getRedirectUrl(): string {
        return $this->getResource()::getUrl('index');
    }
}

# app/Filament/Resources/RoleResource/Pages/EditRole.php

<?php

namespace App\Filament\Resources\RoleResource\Pages;

use App\Filament\Resources\RoleResource;
use Filament\Pages\Actions;
use Filament\Resources\Pages\EditRecord;

class EditRole extends EditRecord
{
    protected static string $resource = RoleResource::class;

    protected function getActions(): array
    {
        return [
            Actions\DeleteAction::make(),
        ];
    }

    protected function getRedirectUrl(): string {
        return $this->getResource()::getUrl('index');
    }
}

# app/Filament/Resources/RoleResource/Pages/ListRoles.php
 <?php

namespace App\Filament\Resources\RoleResource\Pages;

use App\Filament\Resources\RoleResource;
use Filament\Pages\Actions;
use Filament\Resources\Pages\ListRecords;

class ListRoles extends ListRecords
{
    protected static string $resource = RoleResource::class;

    protected function getActions(): array
    {
        return [
            Actions\CreateAction::make(),
        ];
    }
}

# USANDO RECURSO DE FUNÇÃO E O RELACIONAMENTO A SER GERENCIADO:
php artisan make:filament-relation-manager RoleResource permission name

-CRIOU: App\Filament\Resources\RoleResource\RelationManagers\PermissionsRelation.php

PermissionsRelation.php

<?php

namespace App\Filament\Resources\RoleResource\RelationManagers;

use Filament\Forms;
use Filament\Resources\Form;
use Filament\Resources\RelationManagers\RelationManager;
use Filament\Resources\Table;
use Filament\Tables;
use Illuminate\Database\Eloquent\Builder;
use Illuminate\Database\Eloquent\SoftDeletingScope;

class PermissionsRelationManager extends RelationManager
{
    protected static string $relationship = 'permissions';

    protected static ?string $recordTitleAttribute = 'name';

    public static function form(Form $form): Form
    {
        return $form
            ->schema([
                Forms\Components\TextInput::make('name')
                    ->required()
                    ->maxLength(255),
            ]);
    }

    public static function table(Table $table): Table
    {
        return $table
            ->columns([
                Tables\Columns\TextColumn::make('name'),
            ])
            ->filters([
                //
            ])
            ->headerActions([
                Tables\Actions\CreateAction::make(),
            ])
            ->actions([
                Tables\Actions\EditAction::make(),
                Tables\Actions\DeleteAction::make(),
            ])
            ->bulkActions([
                Tables\Actions\DeleteBulkAction::make(),
            ]);
    }    
}

# app/Filament/Resources/RoleResource.php
RoleResouce.php

<?php

namespace App\Filament\Resources;

use Filament\Forms;
use Filament\Tables;
use Filament\Resources\Form;
use Filament\Resources\Table;
use Filament\Resources\Resource;
use Spatie\Permission\Models\Role;
use Filament\Forms\Components\Card;
use Filament\Tables\Columns\TextColumn;
use Filament\Forms\Components\TextInput;
use Filament\Tables\Actions\DeleteAction;
use Illuminate\Database\Eloquent\Builder;
use App\Filament\Resources\RoleResource\Pages;
use Illuminate\Database\Eloquent\SoftDeletingScope;
use App\Filament\Resources\RoleResource\RelationManagers;
use App\Filament\Resources\RoleResource\RelationManagers\PermissionsRelationManager;
use Filament\Forms\Components\Select;

class RoleResource extends Resource
{
    protected static ?string $model = Role::class;

    protected static ?string $navigationIcon = 'heroicon-s-cog';

    protected static ?string $navigationGroup = 'Admin Management';

    public static function form(Form $form): Form {
        return $form
            ->schema([
                Card::make()
                    ->schema([
                        TextInput::make('name')
                            ->unique(ignoreRecord: true)
                            ->required(),
                        Select::make('permissions')
                            ->multiple()
                            ->relationship('permissions', 'name')
                            ->preload()
                            ->required()
                    ])
            ]);
    }

    public static function table(Table $table): Table {
        return $table
            ->columns([
                TextColumn::make('id')->sortable(),
                TextColumn::make('name')->sortable()->searchable(),
                TextColumn::make('created_at')
                    ->dateTime('d-M-Y')
                    ->sortable()
                    ->searchable(),
            ])
            ->filters([
                //
            ])
            ->actions([
                Tables\Actions\EditAction::make(),
                DeleteAction::make(),
            ])
            ->bulkActions([
                Tables\Actions\DeleteBulkAction::make(),
            ]);
    }

    public static function getRelations(): array {
        return [
            PermissionsRelationManager::class,
        ];
    }

    public static function getPages(): array
    {
        return [
            'index' => Pages\ListRoles::route('/'),
            'create' => Pages\CreateRole::route('/create'),
            'edit' => Pages\EditRole::route('/{record}/edit'),
        ];
    }
}

# GERANDO FORMULÁRIOS E TABELAS AUTOMATICAMENTE:
composer require doctrine/dbal

php artisan make:filament-resource User --generate
UserResource.php
<?php

namespace App\Filament\Resources;

use Filament\Forms;
use App\Models\User;
use Filament\Tables;
use Filament\Pages\Page;
use Filament\Resources\Form;
use Filament\Resources\Table;
use Filament\Resources\Resource;
use Filament\Forms\Components\Card;
use Illuminate\Support\Facades\Hash;
use Filament\Forms\Components\Toggle;
use Filament\Tables\Actions\EditAction;
use Filament\Tables\Columns\TextColumn;
use Filament\Forms\Components\TextInput;
use Filament\Tables\Actions\DeleteAction;
use Illuminate\Database\Eloquent\Builder;
use Filament\Tables\Columns\BooleanColumn;
use Filament\Tables\Filters\TrashedFilter;
use Filament\Forms\Components\CheckboxList;
use Filament\Tables\Actions\DeleteBulkAction;
use App\Filament\Resources\UserResource\Pages;
use Filament\Tables\Actions\RestoreBulkAction;
use Filament\Tables\Actions\ForceDeleteBulkAction;
use Illuminate\Database\Eloquent\SoftDeletingScope;
use App\Filament\Resources\UserResource\Pages\EditUser;
use App\Filament\Resources\UserResource\Pages\ListUsers;
use App\Filament\Resources\UserResource\Pages\CreateUser;
use App\Filament\Resources\UserResource\RelationManagers;
use App\Filament\Resources\UserResource\RelationManagers\RolesRelationManager;

class UserResource extends Resource
{
    protected static ?string $model = User::class;

    protected static ?string $navigationIcon = 'heroicon-o-users';

    protected static ?string $navigationGroup = 'Admin Management';

    // protected static bool $shouldRegisterNavigation = false;

    public static function form(Form $form): Form {
        return $form
            ->schema([
                Card::make()
                ->schema([
                    TextInput::make('name')
                        ->required()
                        ->maxLength(255),
                    Toggle::make('is_admin')
                        ->required(),
                    TextInput::make('email')
                        ->email()
                        ->unique(ignoreRecord: true)
                        ->required()
                        ->maxLength(255),
                    TextInput::make('password')
                        ->password()
                        ->maxLength(255)
                        ->dehydrateStateUsing(static fn (null|string $state): null|string =>
                            filled($state) ? Hash::make($state): null,
                        )->required(static fn (Page $livewire): bool =>
                            $livewire instanceof CreateUser,
                        )->dehydrated(static fn (null|string $state): bool =>
                            filled($state),
                        )->label(static fn (Page $livewire): string =>
                            ($livewire instanceof EditUser) ? 'New Password' : 'Password'
                        ),
                    CheckboxList::make('roles')
                        ->relationship('roles', 'name')
                        ->columns(2)
                        ->helperText('Only Choose One!')
                        ->required()
                ])
            ]);
    }

    public static function table(Table $table): Table {
        return $table
            ->columns([
                TextColumn::make('name')->sortable(),
                BooleanColumn::make('is_admin')->sortable(),
                TextColumn::make('roles.name')->sortable(),
                TextColumn::make('email')->sortable(),
                TextColumn::make('deleted_at')
                ->dateTime('d-M-Y')
                ->sortable()
                ->searchable(),
                TextColumn::make('created_at')
                    ->dateTime('d-M-Y')
                    ->sortable()
                    ->searchable(),
            ])
            ->filters([
                TrashedFilter::make(),
            ])
            ->actions([
                EditAction::make(),
                DeleteAction::make(),
            ])
            ->bulkActions([
                DeleteBulkAction::make(),
                RestoreBulkAction::make(),
                ForceDeleteBulkAction::make(),
            ]);
    }

    public static function getRelations(): array
    {
        return [
            RolesRelationManager::class,
        ];
    }

    public static function getPages(): array
    {
        return [
            'index' => Pages\ListUsers::route('/'),
            'create' => Pages\CreateUser::route('/create'),
            'edit' => Pages\EditUser::route('/{record}/edit'),
        ];
    }
}



## ADICIONANDO A COLUNA SOFTDELETES À TABELA DE USUÁRIOS:
php artisan make:migrations add_softdeletes__to_users_table

# database/migrations/2022_10_13_142713_add_soft_deletes_to_users_table.php

<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     *
     * @return void
     */
    public function up()
    {
        Schema::table('users', function (Blueprint $table) {
            $table->softDeletes();
        });
    }

    /**
     * Reverse the migrations.
     *
     * @return void
     */
    public function down()
    {
        Schema::table('users', function (Blueprint $table) {
            $table->dropSoftDeletes();
        });
    }
};

# app/Filament/Resources/UserResource/Pages
* CreateUser.php
<?php

namespace App\Filament\Resources\UserResource\Pages;

use App\Filament\Resources\UserResource;
use Filament\Pages\Actions;
use Filament\Resources\Pages\CreateRecord;

class CreateUser extends CreateRecord
{
    protected static string $resource = UserResource::class;

    protected function getRedirectUrl(): string {
        return $this->getResource()::getUrl('index');
    }
}

* EditUser.php
<?php

namespace App\Filament\Resources\UserResource\Pages;

use App\Filament\Resources\UserResource;
use Filament\Pages\Actions;
use Filament\Resources\Pages\EditRecord;

class EditUser extends EditRecord
{
    protected static string $resource = UserResource::class;

    protected function getActions(): array
    {
        return [
            Actions\DeleteAction::make(),
        ];
    }

    protected function getRedirectUrl(): string {
        return $this->getResource()::getUrl('index');
    }
}

* ListUser.php
<?php

namespace App\Filament\Resources\UserResource\Pages;

use App\Filament\Resources\UserResource;
use Filament\Pages\Actions;
use Filament\Resources\Pages\ListRecords;

class ListUsers extends ListRecords
{
    protected static string $resource = UserResource::class;

    protected function getActions(): array
    {
        return [
            Actions\CreateAction::make(),
        ];
    }
}

## app/Filament/Resources/UserResource.php

UserResource.php
<?php

namespace App\Filament\Resources;

use Filament\Forms;
use App\Models\User;
use Filament\Tables;
use Filament\Pages\Page;
use Filament\Resources\Form;
use Filament\Resources\Table;
use Filament\Resources\Resource;
use Filament\Forms\Components\Card;
use Illuminate\Support\Facades\Hash;
use Filament\Forms\Components\Toggle;
use Filament\Tables\Actions\EditAction;
use Filament\Tables\Columns\TextColumn;
use Filament\Forms\Components\TextInput;
use Filament\Tables\Actions\DeleteAction;
use Illuminate\Database\Eloquent\Builder;
use Filament\Tables\Columns\BooleanColumn;
use Filament\Tables\Filters\TrashedFilter;
use Filament\Forms\Components\CheckboxList;
use Filament\Tables\Actions\DeleteBulkAction;
use App\Filament\Resources\UserResource\Pages;
use Filament\Tables\Actions\RestoreBulkAction;
use Filament\Tables\Actions\ForceDeleteBulkAction;
use Illuminate\Database\Eloquent\SoftDeletingScope;
use App\Filament\Resources\UserResource\Pages\EditUser;
use App\Filament\Resources\UserResource\Pages\ListUsers;
use App\Filament\Resources\UserResource\Pages\CreateUser;
use App\Filament\Resources\UserResource\RelationManagers;
use App\Filament\Resources\UserResource\RelationManagers\RolesRelationManager;

class UserResource extends Resource
{
    protected static ?string $model = User::class;

    protected static ?string $navigationIcon = 'heroicon-o-users';

    protected static ?string $navigationGroup = 'Admin Management';

    // protected static bool $shouldRegisterNavigation = false;

    public static function form(Form $form): Form {
        return $form
            ->schema([
                Card::make()
                ->schema([
                    TextInput::make('name')
                        ->required()
                        ->maxLength(255),
                    Toggle::make('is_admin')
                        ->required(),
                    TextInput::make('email')
                        ->email()
                        ->unique(ignoreRecord: true)
                        ->required()
                        ->maxLength(255),
                    TextInput::make('password')
                        ->password()
                        ->maxLength(255)
                        ->dehydrateStateUsing(static fn (null|string $state): null|string =>
                            filled($state) ? Hash::make($state): null,
                        )->required(static fn (Page $livewire): bool =>
                            $livewire instanceof CreateUser,
                        )->dehydrated(static fn (null|string $state): bool =>
                            filled($state),
                        )->label(static fn (Page $livewire): string =>
                            ($livewire instanceof EditUser) ? 'New Password' : 'Password'
                        ),
                    CheckboxList::make('roles')
                        ->relationship('roles', 'name')
                        ->columns(2)
                        ->helperText('Only Choose One!')
                        ->required()
                ])
            ]);
    }

    public static function table(Table $table): Table {
        return $table
            ->columns([
                TextColumn::make('name')->sortable(),
                BooleanColumn::make('is_admin')->sortable(),
                TextColumn::make('roles.name')->sortable(),
                TextColumn::make('email')->sortable(),
                TextColumn::make('deleted_at')
                ->dateTime('d-M-Y')
                ->sortable()
                ->searchable(),
                TextColumn::make('created_at')
                    ->dateTime('d-M-Y')
                    ->sortable()
                    ->searchable(),
            ])
            ->filters([
                TrashedFilter::make(),
            ])
            ->actions([
                EditAction::make(),
                DeleteAction::make(),
            ])
            ->bulkActions([
                DeleteBulkAction::make(),
                RestoreBulkAction::make(),
                ForceDeleteBulkAction::make(),
            ]);
    }

    public static function getRelations(): array
    {
        return [
            RolesRelationManager::class,
        ];
    }

    public static function getPages(): array
    {
        return [
            'index' => Pages\ListUsers::route('/'),
            'create' => Pages\CreateUser::route('/create'),
            'edit' => Pages\EditUser::route('/{record}/edit'),
        ];
    }
}

# CONFIGURANDO UM GERENCIADOR DE RELACIONAMENTO PARA OS USUÁRIOS PARA QUE POSSAMOS VER SUAS FUNÇÕES LISTADAS
php artisan make:filament-relation-manager UserResource roles name
 
# app/Filament/Resources/UserResource/RelationManagers/RolesRelationManager.php
RolesRelationManager.php

<?php

namespace App\Filament\Resources\UserResource\RelationManagers;

use Filament\Forms;
use Filament\Resources\Form;
use Filament\Resources\RelationManagers\RelationManager;
use Filament\Resources\Table;
use Filament\Tables;
use Illuminate\Database\Eloquent\Builder;
use Illuminate\Database\Eloquent\SoftDeletingScope;

class RolesRelationManager extends RelationManager
{
    protected static string $relationship = 'roles';

    protected static ?string $recordTitleAttribute = 'name';

    public static function form(Form $form): Form
    {
        return $form
            ->schema([
                Forms\Components\TextInput::make('name')
                    ->required()
                    ->maxLength(255),
            ]);
    }

    public static function table(Table $table): Table
    {
        return $table
            ->columns([
                Tables\Columns\TextColumn::make('name'),
            ])
            ->filters([
                //
            ])
            ->headerActions([
                Tables\Actions\CreateAction::make(),
            ])
            ->actions([
                Tables\Actions\EditAction::make(),
                Tables\Actions\DeleteAction::make(),
            ])
            ->bulkActions([
                Tables\Actions\DeleteBulkAction::make(),
            ]);
    }    
}

###  MENU DE USUÁRIO PERSONALIZADO
php artisan make:provider FilamentServiceProvider

App\Provider\FilamentServiceProvider.php

ServiceProvider.php
<?php

namespace App\Providers;

use Filament\Facades\Filament;
use Illuminate\Foundation\Vite;
use Filament\Navigation\UserMenuItem;
use Illuminate\Support\ServiceProvider;
use App\Filament\Resources\RoleResource;
use App\Filament\Resources\UserResource;
use App\Filament\Resources\PermissionResource;

class FilamentServiceProvider extends ServiceProvider
{
    /**
     * Register services.
     *
     * @return void
     */
    public function register()
    {
        //
    }

    /**
     * Bootstrap services.
     *
     * @return void
     */
    public function boot() {
        Filament::serving(function() {
            Filament::registerTheme(
                app(Vite::class)('resources/css/filament.css'),
            );
            if (auth()->user()) {
                if (auth()->user()->is_admin === 1 && auth()->user()->hasAnyRole(['super-admin', 'admin', 'moderator'])) {
                    Filament::registerUserMenuItems([
                        UserMenuItem::make()
                            ->label('Manage Users')
                            ->url(UserResource::getUrl())
                            ->icon('heroicon-s-users'),
                        UserMenuItem::make()
                            ->label('Manage Roles')
                            ->url(RoleResource::getUrl())
                            ->icon('heroicon-s-cog'),
                        UserMenuItem::make()
                            ->label('Manage Permissions')
                            ->url(PermissionResource::getUrl())
                            ->icon('heroicon-s-key'),
                    ]);
                }
            }
        });
    }
}

* ELE DEVE SER ACRESCENTADO em 'config\app.php' ONDE TODOS OS PROVIDERS SÃO REGISTRADOS.
app.php
   App\Providers\FilamentServiceProvider::class,   <====================================== ESTA LINHA FOI ACRESCENTADA PARA REGISTRAR
                                                                                          COMO MOSTRA O ARQUIVO ABAIXO

<?php

use Illuminate\Support\Facades\Facade;

return [

    /*
    |--------------------------------------------------------------------------
    | Application Name
    |--------------------------------------------------------------------------
    |
    | This value is the name of your application. This value is used when the
    | framework needs to place the application's name in a notification or
    | any other location as required by the application or its packages.
    |
    */

    'name' => env('APP_NAME', 'Laravel'),

    /*
    |--------------------------------------------------------------------------
    | Application Environment
    |--------------------------------------------------------------------------
    |
    | This value determines the "environment" your application is currently
    | running in. This may determine how you prefer to configure various
    | services the application utilizes. Set this in your ".env" file.
    |
    */

    'env' => env('APP_ENV', 'production'),

    /*
    |--------------------------------------------------------------------------
    | Application Debug Mode
    |--------------------------------------------------------------------------
    |
    | When your application is in debug mode, detailed error messages with
    | stack traces will be shown on every error that occurs within your
    | application. If disabled, a simple generic error page is shown.
    |
    */

    'debug' => (bool) env('APP_DEBUG', false),

    /*
    |--------------------------------------------------------------------------
    | Application URL
    |--------------------------------------------------------------------------
    |
    | This URL is used by the console to properly generate URLs when using
    | the Artisan command line tool. You should set this to the root of
    | your application so that it is used when running Artisan tasks.
    |
    */

    'url' => env('APP_URL', 'http://localhost'),

    'asset_url' => env('ASSET_URL'),

    /*
    |--------------------------------------------------------------------------
    | Application Timezone
    |--------------------------------------------------------------------------
    |
    | Here you may specify the default timezone for your application, which
    | will be used by the PHP date and date-time functions. We have gone
    | ahead and set this to a sensible default for you out of the box.
    |
    */

    'timezone' => 'UTC',

    /*
    |--------------------------------------------------------------------------
    | Application Locale Configuration
    |--------------------------------------------------------------------------
    |
    | The application locale determines the default locale that will be used
    | by the translation service provider. You are free to set this value
    | to any of the locales which will be supported by the application.
    |
    */

    'locale' => 'en',

    /*
    |--------------------------------------------------------------------------
    | Application Fallback Locale
    |--------------------------------------------------------------------------
    |
    | The fallback locale determines the locale to use when the current one
    | is not available. You may change the value to correspond to any of
    | the language folders that are provided through your application.
    |
    */

    'fallback_locale' => 'en',

    /*
    |--------------------------------------------------------------------------
    | Faker Locale
    |--------------------------------------------------------------------------
    |
    | This locale will be used by the Faker PHP library when generating fake
    | data for your database seeds. For example, this will be used to get
    | localized telephone numbers, street address information and more.
    |
    */

    'faker_locale' => 'en_US',

    /*
    |--------------------------------------------------------------------------
    | Encryption Key
    |--------------------------------------------------------------------------
    |
    | This key is used by the Illuminate encrypter service and should be set
    | to a random, 32 character string, otherwise these encrypted strings
    | will not be safe. Please do this before deploying an application!
    |
    */

    'key' => env('APP_KEY'),

    'cipher' => 'AES-256-CBC',

    /*
    |--------------------------------------------------------------------------
    | Maintenance Mode Driver
    |--------------------------------------------------------------------------
    |
    | These configuration options determine the driver used to determine and
    | manage Laravel's "maintenance mode" status. The "cache" driver will
    | allow maintenance mode to be controlled across multiple machines.
    |
    | Supported drivers: "file", "cache"
    |
    */

    'maintenance' => [
        'driver' => 'file',
        // 'store'  => 'redis',
    ],

    /*
    |--------------------------------------------------------------------------
    | Autoloaded Service Providers
    |--------------------------------------------------------------------------
    |
    | The service providers listed here will be automatically loaded on the
    | request to your application. Feel free to add your own services to
    | this array to grant expanded functionality to your applications.
    |
    */

    'providers' => [

        /*
         * Laravel Framework Service Providers...
         */
        Illuminate\Auth\AuthServiceProvider::class,
        Illuminate\Broadcasting\BroadcastServiceProvider::class,
        Illuminate\Bus\BusServiceProvider::class,
        Illuminate\Cache\CacheServiceProvider::class,
        Illuminate\Foundation\Providers\ConsoleSupportServiceProvider::class,
        Illuminate\Cookie\CookieServiceProvider::class,
        Illuminate\Database\DatabaseServiceProvider::class,
        Illuminate\Encryption\EncryptionServiceProvider::class,
        Illuminate\Filesystem\FilesystemServiceProvider::class,
        Illuminate\Foundation\Providers\FoundationServiceProvider::class,
        Illuminate\Hashing\HashServiceProvider::class,
        Illuminate\Mail\MailServiceProvider::class,
        Illuminate\Notifications\NotificationServiceProvider::class,
        Illuminate\Pagination\PaginationServiceProvider::class,
        Illuminate\Pipeline\PipelineServiceProvider::class,
        Illuminate\Queue\QueueServiceProvider::class,
        Illuminate\Redis\RedisServiceProvider::class,
        Illuminate\Auth\Passwords\PasswordResetServiceProvider::class,
        Illuminate\Session\SessionServiceProvider::class,
        Illuminate\Translation\TranslationServiceProvider::class,
        Illuminate\Validation\ValidationServiceProvider::class,
        Illuminate\View\ViewServiceProvider::class,

        /*
         * Package Service Providers...
         */
        App\Providers\FilamentServiceProvider::class,   <====================================== ESTA LINHA FOI ACRESCENTADA PARA REGISTRAR

        /*
         * Application Service Providers...
         */
        App\Providers\AppServiceProvider::class,
        App\Providers\AuthServiceProvider::class,
        // App\Providers\BroadcastServiceProvider::class,
        App\Providers\EventServiceProvider::class,
        App\Providers\RouteServiceProvider::class,
        App\Providers\FortifyServiceProvider::class,
        App\Providers\JetstreamServiceProvider::class,

    ],

    /*
    |--------------------------------------------------------------------------
    | Class Aliases
    |--------------------------------------------------------------------------
    |
    | This array of class aliases will be registered when this application
    | is started. However, feel free to register as many as you wish as
    | the aliases are "lazy" loaded so they don't hinder performance.
    |
    */

    'aliases' => Facade::defaultAliases()->merge([
        // 'ExampleClass' => App\Example\ExampleClass::class,
    ])->toArray(),

];


### AUTORIZAÇÃO COM POLÍTICAS PARA RESTRINGIR NOVOS USUÁRIOS QUE SE CADASTRAM NO FRONT-END
* Vamos implementar na Model User 

User.php
linha 16: class User extends Authenticatable implements FilamentUser 
linha 69:    public function canAccessFilament(): bool {
        return str_ends_with($this->email, '@admin.com' );
    } ===> nas últimas linha da model User.php

<?php

namespace App\Models;

use Filament\Models\Contracts\FilamentUser;
use Illuminate\Contracts\Auth\MustVerifyEmail;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\SoftDeletes;
use Illuminate\Foundation\Auth\User as Authenticatable;
use Illuminate\Notifications\Notifiable;
use Laravel\Fortify\TwoFactorAuthenticatable;
use Laravel\Jetstream\HasProfilePhoto;
use Laravel\Sanctum\HasApiTokens;
use Spatie\Permission\Traits\HasRoles;

class User extends Authenticatable implements FilamentUser
{
    use HasApiTokens;
    use HasFactory;
    use HasProfilePhoto;
    use HasRoles;
    use Notifiable;
    use SoftDeletes;
    use TwoFactorAuthenticatable;

    /**
     * The attributes that are mass assignable.
     *
     * @var string[]
     */
    protected $fillable = [
        'name',
        'is_admin',
        'email',
        'password',
    ];

    /**
     * The attributes that should be hidden for serialization.
     *
     * @var array
     */
    protected $hidden = [
        'password',
        'remember_token',
        'two_factor_recovery_codes',
        'two_factor_secret',
    ];

    /**
     * The attributes that should be cast.
     *
     * @var array
     */
    protected $casts = [
        'email_verified_at' => 'datetime',
    ];

    /**
     * The accessors to append to the model's array form.
     *
     * @var array
     */
    protected $appends = [
        'profile_photo_url',
    ];

    public function canAccessFilament(): bool {
        return str_ends_with($this->email, '@admin.com' );
    }
}


# USANDO AS POLÍTICAS DO LARAVEL PARA ALAVANCAR A AUTORIZAÇÃO PARA O PACOTE SPATIE.
php artisan make:policy PermissionPolicy --model=Permission
* app/Policies/PermissionPolicy.php
<?php

namespace App\Policies;

use App\Models\User;
use Spatie\Permission\Models\Permission;  <=== NESTA LINHA VEM use App\Models\Permission; FOI ALTERADA
use Illuminate\Auth\Access\HandlesAuthorization;

class PermissionPolicy
{
    use HandlesAuthorization;

    /**
     * Determine whether the user can view any models.
     *
     * @param  \App\Models\User  $user
     * @return \Illuminate\Auth\Access\Response|bool
     */
    public function viewAny(User $user) {
        return $user->hasAnyRole(['super-admin', 'admin', 'moderator']);
    }

    /**
     * Determine whether the user can create models.
     *
     * @param  \App\Models\User  $user
     * @return \Illuminate\Auth\Access\Response|bool
     */
    public function create(User $user) {
        return $user->hasAnyRole(['super-admin', 'admin']);
    }

    /**
     * Determine whether the user can update the model.
     *
     * @param  \App\Models\User  $user
     * @param  \Spatie\Permission\Models\Permission  $permission
     * @return \Illuminate\Auth\Access\Response|bool
     */
    public function update(User $user, Permission $permission) {
        return $user->hasAnyRole(['super-admin', 'admin']);
    }

    /**
     * Determine whether the user can delete the model.
     *
     * @param  \App\Models\User  $user
     * @param  Spatie\Permission\Models\Permission  $permission
     * @return \Illuminate\Auth\Access\Response|bool
     */
    public function delete(User $user, Permission $permission) {
        return $user->hasAnyRole(['super-admin', 'admin']);
    }
}

* E EM App\Provider\AuthServiceProvider.php
AuthServiceProvider.php
<?php

namespace App\Providers;

// use Illuminate\Support\Facades\Gate;

use App\Models\User;
use App\Policies\RolePolicy;
use App\Policies\UserPolicy;
use App\Policies\PermissionPolicy;
use Spatie\Permission\Models\Role;
use Spatie\Permission\Models\Permission;
use Illuminate\Foundation\Support\Providers\AuthServiceProvider as ServiceProvider;

class AuthServiceProvider extends ServiceProvider
{
    /**
     * The model to policy mappings for the application.
     *
     * @var array<class-string, class-string>
     */
    protected $policies = [
        // 'App\Models\Model' => 'App\Policies\ModelPolicy',
        Permission::class => PermissionPolicy::class,
        Role::class => RolePolicy::class,
        User::class => UserPolicy::class,
    ];

    /**
     * Register any authentication / authorization services.
     *
     * @return void
     */
    public function boot()
    {
        $this->registerPolicies();

        //
    }
}

# A MESMA COISA PARA ROLE E USER
* php artisan make:policy RolePolicy --model=Role

App\Policies\RolePolicy.php
<?php

namespace App\Policies;

use App\Models\User;
use Spatie\Permission\Models\Role;
use Illuminate\Auth\Access\HandlesAuthorization;

class RolePolicy
{
    use HandlesAuthorization;

    /**
     * Determine whether the user can view any models.
     *
     * @param  \App\Models\User  $user
     * @return \Illuminate\Auth\Access\Response|bool
     */
    public function viewAny(User $user) {
        return $user->hasAnyRole(['super-admin', 'admin', 'moderator', 'developer']);
    }

    /**
     * Determine whether the user can create models.
     *
     * @param  \App\Models\User  $user
     * @return \Illuminate\Auth\Access\Response|bool
     */
    public function create(User $user) {
        return $user->hasAnyRole(['super-admin', 'admin']);
    }

    /**
     * Determine whether the user can update the model.
     *
     * @param  \App\Models\User  $user
     * @param  Spatie\Permission\Models\Role  $role
     * @return \Illuminate\Auth\Access\Response|bool
     */
    public function update(User $user, Role $role) {
        return $user->hasAnyRole(['super-admin', 'admin']);
    }

    /**
     * Determine whether the user can delete the model.
     *
     * @param  \App\Models\User  $user
     * @param  Spatie\Permission\Models\Role  $role
     * @return \Illuminate\Auth\Access\Response|bool
     */
    public function delete(User $user, Role $role) {
        return $user->hasAnyRole(['super-admin', 'admin']);
    }
}


* php artisan make:policy UserPolicy --model=User
App\Policies\UserPolicy.php
<?php

namespace App\Policies;

use App\Models\User;
use Illuminate\Auth\Access\HandlesAuthorization;

class UserPolicy
{
    use HandlesAuthorization;

    /**
     * Determine whether the user can view any models.
     *
     * @param  \App\Models\User  $user
     * @return \Illuminate\Auth\Access\Response|bool
     */
    public function viewAny(User $user) {
        return $user->hasAnyRole(['super-admin', 'admin', 'moderator']);
    }

    /**
     * Determine whether the user can create models.
     *
     * @param  \App\Models\User  $user
     * @return \Illuminate\Auth\Access\Response|bool
     */
    public function create(User $user) {
        return $user->hasAnyRole(['super-admin', 'admin']);
    }

    /**
     * Determine whether the user can update the model.
     *
     * @param  \App\Models\User  $user
     * @param  \App\Models\User  $model
     * @return \Illuminate\Auth\Access\Response|bool
     */
    public function update(User $user, User $model) {
        return $user->hasAnyRole(['super-admin', 'admin']);
    }

    /**
     * Determine whether the user can delete the model.
     *
     * @param  \App\Models\User  $user
     * @param  \App\Models\User  $model
     * @return \Illuminate\Auth\Access\Response|bool
     */
    public function delete(User $user, User $model) {
        return $user->hasAnyRole(['super-admin', 'admin']);
    }

    /**
     * Determine whether the user can restore the model.
     *
     * @param  \App\Models\User  $user
     * @param  \App\Models\User  $model
     * @return \Illuminate\Auth\Access\Response|bool
     */
    public function restore(User $user, User $model) {
        return $user->hasAnyRole(['super-admin', 'admin']);
    }
}

* importa as classes em App\Providers\AuthServiceProvider.php
AuthServiceProvider.php

<?php

namespace App\Providers;

// use Illuminate\Support\Facades\Gate;

use App\Models\User;
use App\Policies\RolePolicy;
use App\Policies\UserPolicy;
use App\Policies\PermissionPolicy;
use Spatie\Permission\Models\Role;
use Spatie\Permission\Models\Permission;
use Illuminate\Foundation\Support\Providers\AuthServiceProvider as ServiceProvider;

class AuthServiceProvider extends ServiceProvider
{
    /**
     * The model to policy mappings for the application.
     *
     * @var array<class-string, class-string>
     */
    protected $policies = [
        // 'App\Models\Model' => 'App\Policies\ModelPolicy',
        Permission::class => PermissionPolicy::class,
        Role::class => RolePolicy::class,
        User::class => UserPolicy::class,
    ];

    /**
     * Register any authentication / authorization services.
     *
     * @return void
     */
    public function boot()
    {
        $this->registerPolicies();

        //
    }
}

# TRADUÇÃO lang\vendor\filament basta configurar o config\app.php timezone, locale, ...

# em resources\views\layouts\app.blade.php (LARAVEL LOCALIZATION...)
app.blade.php
<!DOCTYPE html>
<html lang="{{ str_replace('_', '-', app()->getLocale()) }}">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="csrf-token" content="{{ csrf_token() }}">
//...

# CRIANDO WIDGETS config\filament.php
filament.php
<?php

use Filament\Http\Middleware\Authenticate;
use Filament\Http\Middleware\DispatchServingFilamentEvent;
use Filament\Http\Middleware\MirrorConfigToSubpackages;
use Filament\Pages;
use Filament\Widgets;
use Illuminate\Cookie\Middleware\AddQueuedCookiesToResponse;
use Illuminate\Cookie\Middleware\EncryptCookies;
use Illuminate\Foundation\Http\Middleware\VerifyCsrfToken;
use Illuminate\Routing\Middleware\SubstituteBindings;
use Illuminate\Session\Middleware\AuthenticateSession;
use Illuminate\Session\Middleware\StartSession;
use Illuminate\View\Middleware\ShareErrorsFromSession;

return [

    /*
    |--------------------------------------------------------------------------
    | Filament Path
    |--------------------------------------------------------------------------
    |
    | The default is `admin` but you can change it to whatever works best and
    | doesn't conflict with the routing in your application.
    |
    */

    'path' => env('FILAMENT_PATH', 'admin'),

    /*
    |--------------------------------------------------------------------------
    | Filament Core Path
    |--------------------------------------------------------------------------
    |
    | This is the path which Filament will use to load its core routes and assets.
    | You may change it if it conflicts with your other routes.
    |
    */

    'core_path' => env('FILAMENT_CORE_PATH', 'filament'),

    /*
    |--------------------------------------------------------------------------
    | Filament Domain
    |--------------------------------------------------------------------------
    |
    | You may change the domain where Filament should be active. If the domain
    | is empty, all domains will be valid.
    |
    */

    'domain' => env('FILAMENT_DOMAIN'),

    /*
    |--------------------------------------------------------------------------
    | Homepage URL
    |--------------------------------------------------------------------------
    |
    | This is the URL that Filament will redirect the user to when they click
    | on the sidebar's header.
    |
    */

    'home_url' => '/',

    /*
    |--------------------------------------------------------------------------
    | Brand Name
    |--------------------------------------------------------------------------
    |
    | This will be displayed on the login page and in the sidebar's header.
    |
    */

    'brand' => env('APP_NAME'),

    /*
    |--------------------------------------------------------------------------
    | Auth
    |--------------------------------------------------------------------------
    |
    | This is the configuration that Filament will use to handle authentication
    | into the admin panel.
    |
    */

    'auth' => [
        'guard' => env('FILAMENT_AUTH_GUARD', 'web'),
        'pages' => [
            'login' => \Filament\Http\Livewire\Auth\Login::class,
        ],
    ],

    /*
    |--------------------------------------------------------------------------
    | Pages
    |--------------------------------------------------------------------------
    |
    | This is the namespace and directory that Filament will automatically
    | register pages from. You may also register pages here.
    |
    */

    'pages' => [
        'namespace' => 'App\\Filament\\Pages',
        'path' => app_path('Filament/Pages'),
        'register' => [
            Pages\Dashboard::class,
        ],
    ],

    /*
    |--------------------------------------------------------------------------
    | Resources
    |--------------------------------------------------------------------------
    |
    | This is the namespace and directory that Filament will automatically
    | register resources from. You may also register resources here.
    |
    */

    'resources' => [
        'namespace' => 'App\\Filament\\Resources',
        'path' => app_path('Filament/Resources'),
        'register' => [],
    ],

    /*
    |--------------------------------------------------------------------------
    | Widgets
    |--------------------------------------------------------------------------
    |
    | This is the namespace and directory that Filament will automatically
    | register dashboard widgets from. You may also register widgets here.
    |
    */

    'widgets' => [
        'namespace' => 'App\\Filament\\Widgets',
        'path' => app_path('Filament/Widgets'),
        'register' => [
            // Widgets\AccountWidget::class,
            // Widgets\FilamentInfoWidget::class,
        ],
    ],

    /*
    |--------------------------------------------------------------------------
    | Livewire
    |--------------------------------------------------------------------------
    |
    | This is the namespace and directory that Filament will automatically
    | register Livewire components inside.
    |
    */

    'livewire' => [
        'namespace' => 'App\\Filament',
        'path' => app_path('Filament'),
    ],

    /*
    |--------------------------------------------------------------------------
    | Dark mode
    |--------------------------------------------------------------------------
    |
    | By enabling this feature, your users are able to select between a light
    | and dark appearance for the admin panel, or let their system decide.
    |
    */

    'dark_mode' => true,

    /*
    |--------------------------------------------------------------------------
    | Database notifications
    |--------------------------------------------------------------------------
    |
    | By enabling this feature, your users are able to open a slide-over within
    | the admin panel to view their database notifications.
    |
    */

    'database_notifications' => [
        'enabled' => false,
        'polling_interval' => '30s',
    ],

    /*
    |--------------------------------------------------------------------------
    | Broadcasting
    |--------------------------------------------------------------------------
    |
    | By uncommenting the Laravel Echo configuration, you may connect your
    | admin panel to any Pusher-compatible websockets server.
    |
    | This will allow your admin panel to receive real-time notifications.
    |
    */

    'broadcasting' => [

        // 'echo' => [
        //     'broadcaster' => 'pusher',
        //     'key' => env('VITE_PUSHER_APP_KEY'),
        //     'cluster' => env('VITE_PUSHER_APP_CLUSTER'),
        //     'forceTLS' => true,
        // ],

    ],

    /*
    |--------------------------------------------------------------------------
    | Layout
    |--------------------------------------------------------------------------
    |
    | This is the configuration for the general layout of the admin panel.
    |
    | You may configure the max content width from `xl` to `7xl`, or `full`
    | for no max width.
    |
    */

    'layout' => [
        'actions' => [
            'modal' => [
                'actions' => [
                    'alignment' => 'left',
                ],
            ],
        ],
        'forms' => [
            'actions' => [
                'alignment' => 'left',
            ],
            'have_inline_labels' => false,
        ],
        'footer' => [
            'should_show_logo' => false,
        ],
        'max_content_width' => null,
        'notifications' => [
            'vertical_alignment' => 'top',
            'alignment' => 'right',
        ],
        'sidebar' => [
            'is_collapsible_on_desktop' => false,
            'groups' => [
                'are_collapsible' => true,
            ],
            'width' => null,
            'collapsed_width' => null,
        ],
    ],

    /*
    |--------------------------------------------------------------------------
    | Favicon
    |--------------------------------------------------------------------------
    |
    | This is the path to the favicon used for pages in the admin panel.
    |
    */

    'favicon' => null,

    /*
    |--------------------------------------------------------------------------
    | Default Avatar Provider
    |--------------------------------------------------------------------------
    |
    | This is the service that will be used to retrieve default avatars if one
    | has not been uploaded.
    |
    */

    'default_avatar_provider' => \Filament\AvatarProviders\UiAvatarsProvider::class,

    /*
    |--------------------------------------------------------------------------
    | Default Filesystem Disk
    |--------------------------------------------------------------------------
    |
    | This is the storage disk Filament will use to put media. You may use any
    | of the disks defined in the `config/filesystems.php`.
    |
    */

    'default_filesystem_disk' => env('FILAMENT_FILESYSTEM_DRIVER', 'public'),

    /*
    |--------------------------------------------------------------------------
    | Google Fonts
    |--------------------------------------------------------------------------
    |
    | This is the URL for Google Fonts that should be loaded. You may use any
    | font, or set to `null` to prevent any Google Fonts from loading.
    |
    | When using a custom font, you should also set the font family in your
    | custom theme's `tailwind.config.js` file.
    |
    */

    'google_fonts' => 'https://fonts.googleapis.com/css2?family=DM+Sans:ital,wght@0,400;0,500;0,700;1,400;1,500;1,700&display=swap',

    /*
    |--------------------------------------------------------------------------
    | Middleware
    |--------------------------------------------------------------------------
    |
    | You may customise the middleware stack that Filament uses to handle
    | requests.
    |
    */

    'middleware' => [
        'auth' => [
            Authenticate::class,
        ],
        'base' => [
            EncryptCookies::class,
            AddQueuedCookiesToResponse::class,
            StartSession::class,
            AuthenticateSession::class,
            ShareErrorsFromSession::class,
            VerifyCsrfToken::class,
            SubstituteBindings::class,
            DispatchServingFilamentEvent::class,
            MirrorConfigToSubpackages::class,
        ],
    ],

];

 * php artisan make:filament-widget StatsOverview --satats-overview
App\Filament\Widget\StatsOverview.php
StatsOverview.php
<?php

namespace App\Filament\Widgets;

use Filament\Widgets\StatsOverviewWidget as BaseWidget;
use Filament\Widgets\StatsOverviewWidget\Card;

class StatsOverview extends BaseWidget
{
    protected function getCards(): array {
        return [
            Card::make('Unique views', '192.1k')
                ->description('32k increase')
                ->chart([7, 2, 10, 3, 15, 4, 17])
                ->descriptionIcon('heroicon-s-trending-up'),
            Card::make('Bounce rate', '21%')
                ->description('7% increase')
                ->descriptionIcon('heroicon-s-trending-down'),
            Card::make('Average time on page', '3:12')
                ->description('3% increase')
                ->descriptionIcon('heroicon-s-trending-up'),
        ];
    }
}

# MODELOS EM: https://filament.com/docs/2.x/admin/dashbord/stats

php artisan make:filament-widget UsersChart --chart

App/Filament/Widgets/UserChart.php
UserChart.php
<?php

namespace App\Filament\Widgets;

use Carbon\Carbon;
use App\Models\User;
use Filament\Widgets\BarChartWidget;

class UsersChart extends BarChartWidget
{
    protected static ?string $heading = 'Users';

    protected function getData(): array {
        $users = User::select('created_at')->get()->groupBy(function($users) {
            return Carbon::parse($users->created_at)->format('F');
        });
        $quantities = [];
        foreach ($users as $user => $value) {
            array_push($quantities, $value->count());
        }
        return [
            'datasets' => [
                [
                    'label' => 'Users Joined',
                    'data' => $quantities,
                    'backgroundColor' => [
                        'rgba(255, 99, 132, 0.2)',
                        'rgba(255, 159, 64, 0.2)',
                        'rgba(255, 205, 86, 0.2)',
                        'rgba(75, 192, 192, 0.2)',
                        'rgba(54, 162, 235, 0.2)',
                        'rgba(153, 102, 255, 0.2)',
                        'rgba(201, 203, 207, 0.2)'
                    ],
                    'borderColor' => [
                        'rgb(255, 99, 132)',
                        'rgb(255, 159, 64)',
                        'rgb(255, 205, 86)',
                        'rgb(75, 192, 192)',
                        'rgb(54, 162, 235)',
                        'rgb(153, 102, 255)',
                        'rgb(201, 203, 207)'
                    ],
                    'borderWidth' => 1
                ],
            ],
            'labels' => $users->keys(),
        ];
    }
}


##### filament.com/plugins
* shield -> verifica por baixo do capô...
### heroicons.com
# FIM 2 FILAMENT 

&&&&&

# ##################################################################################################
# ##################################################################################################
# ##################################################################################################
# ##################################################################################################
# ##################################################################################################
# ##################################################################################################
# ##################################################################################################
# ##################################################################################################






[NOTAS.md](https://github.com/albertogomesdasilva/notas/files/9947969/NOTAS.md)
 ->  AULA 125

### composer require laravel/breeze --dev



### ./vendor/bin/sail artisan breeze:install vue  (instala autenticação, rota autentica, talwingcss e inértia).

## Laravel Sponsors


# composer 
# php artisan serve --port=9000  => Roda a aplicação na porta especificada
#  
### PROJETO EM LARAVEL
ROTA DE CONTINGÊNCIA (FALLBACK)

Route::fallback(function() {
    echo 'A Rota acessada não existe.  <a href=" ' .route('site.index').' "> clique aqui </a> para retornar';
  });

### PASSANDO VALORES DA ROTA PARA O CONTROLLER
<?php

use Illuminate\Support\Facades\Route;


Route::get('/', [\App\Http\Controllers\PrincipalController::class, 'index'])->name('site.index');

Route::get('/sobre-nos', [\App\Http\Controllers\SobrenosController::class, 'sobrenos'])->name('site.sobrenos');

Route::get('/contato', [\App\Http\Controllers\ContatoController::class, 'contato'])->name('site.contato');



Route::get('/login', function (){ return 'Login'; })->name('site.login');


Route::prefix('/app')->group(function(){

    Route::get('/clientes', function (){ return 'Clientes'; })->name('app.clientes');
    Route::get('/fornecedores', function (){ return 'Fornecedores'; })->name('app.fornecedores');
    Route::get('/produtos', function (){ return 'Produtos'; })->name('app.produtos');

});

Route::get('/teste/{param1?}/{param2?}', [\App\Http\Controllers\TesteController::class, 'teste'])->name('teste');

Route::fallback(function() {
    echo 'A Rota acessada não existe.  <a href=" ' .route('site.index').' "> clique aqui </a> para retornar';
  });




CONTROLLER
<?php

namespace App\Http\Controllers;

use Illuminate\Http\Request;

class TesteController extends Controller
{
    public function teste(int $p1, int $p2) {
        echo 'A soma dos valores é: ' . $p1 + $p2;
    }
}


<?php

use Illuminate\Support\Facades\Route;
use App\Http\Controllers\UserController; 

Route::get('/', function(){
    return view('welcome');
});


Route::get('user/{user?}', [UserController::class, 'show'])->name('user');

CONTROLLER
<?php

namespace App\Http\Controllers;

use App\Models\User;
use Illuminate\Http\Request;

class UserController extends Controller
{
    public function show(User $user){
        
        return view('user', [
            'name' => 'Paulo',
            'user' => $user
        
        ]);       
    }
}

### PASSANDO VALORES DA ROTA PARA O CONTROLLER DAÍ PARA A VIEW
ROTA PASSANDO VALORES:
Route::get('/teste/{param1?}/{param2?}', [\App\Http\Controllers\TesteController::class, 'teste'])->name('teste');

CONTROLLER RECEBENDO VALORES:
<?php

namespace App\Http\Controllers;

use Illuminate\Http\Request;

class TesteController extends Controller
{
    public function teste(int $p1, int $p2) {
       // echo 'A soma dos valores é: ' . $p1 + $p2;
       //return view('site.teste', ['x' => $p1 , 'y' => $p2 ] );   // MÉTODO ARRAY ASSOCIATIVO: ATRIBUI A VARIÁVEL RECEBIDA PARA UMA STRING QUALQUER 'x' => $p1, 'y' => $p2
       return view('site.teste', compact('p1', 'p2'));              // MÉTODO COMPACT: RECEBE A VARIÁVEL COMO UMA STRING 'p1', 'p2' E PASSA PARA A VIEW NOVAMENTE COMO VARIÁVEL $p1, $p2
      // return  view('site.teste')->with('a', $p1)->with('b', $p2);  // MÉTODO WITH: ATRIBUI O VALOR DA VARIÁVEL A UMA STRING QUALQUER 'a', 'b' E ESSA STRING SERÁ PASSADA PARA A VIEW COMO UMA VARÍÁVEL $a,$b

    }
}


VIEW RECEBENDO VALORES:
<h1>Teste </h1>

{{ $x }} <br>
{{  $y }}

{{ $a }}    // MÉTODO WITH FICARIA ASSIM
{{ $b }}


### COMENTÁRIOS E CODIFICAÇÃO PHP NO BLADE:
<h2>Fornecedor</h2>

{{ 'Texto ou variável aqui'}} <br>

<?= 'Teste' $x ?>

{{-- Comentário no Blade --}}

@php
    // Comentários dentro de uma tab php no blade
   
    /*
        Comentários de múltiplas
        linhas...
    */

@endphp

### @if @elseif @else @endif

FornecedorController.php
<?php

namespace App\Http\Controllers;

use Illuminate\Http\Request;

class FornecedorController extends Controller
{
    public function index(){
        $fornecedores = ['Fornecedor 1'];

        return view('app.fornecedor.index', compact('fornecedores'));
    }
}
abaixo a view que recebe os valores do controller
****************************
view.blade.php


<h2>Fornecedor</h2>

@if(count($fornecedores) > 0 && count($fornecedores) <= 10)
    <h3>Existem alguns fornecedores cadastrados.
@elseif(count($fornecedores) > 10)
    <h3>São vários os fornecedores cadastrados</h3>
@else 
    <h3> Ainda não existem fornecedores cadastrados.</h3> 
@endif

 <?php

namespace App\Http\Controllers;

use Illuminate\Http\Request;

class FornecedorController extends Controller
{
    public function index(){
        $fornecedores = [
            0 => [
                'nome' => 'Fornecedor 1',
            'status' => 'N',
            'cnpj' => '00.000.000/0001/00'
            ],
            1 => [
                'nome' => 'Fornecedor 2',
                'status' => 'S',
                ]
            ];

        return view('app.fornecedor.index', compact('fornecedores'));
    }
}

<h2>Fornecedor</h2>
<?php
    echo 'ALBERTO <br>';
    if(isset($fornecedores)){
        echo 'existe com php puro'. '<hr>';
    }
?>
@unless(isset($x))
    <h2>Bloco com h2 - Não existe a 'x'</h2><br>
@endunless

@php
    if(isset($fornecedores))
    echo 'Bloco php endphp' . '<br>'
@endphp
 {{-- //@dd($fornecedores) --}}

{{ 'Fornecedor: '  }} <br>

<?= 'Teste' ?>

{{-- Comentário no Blade --}}

@php
    // Comentários dentro de uma tab php no blade
   
    /*
        Comentários de múltiplas
        linhas...
    */
@endphp

@if(count($fornecedores) > 0 && count($fornecedores) <= 10)
    <h3>Existem alguns fornecedores cadastrados.
@elseif(count($fornecedores) > 10)
    <h3>São vários os fornecedores cadastrados</h3>
@else 
    <h3> Ainda não existem fornecedores cadastrados.</h3> 
@endif
<hr>
@isset ($fornecedores[1]['cnpj'])
    CNPJ: {{ $fornecedorES[1]['cnpj'] }}
@unless  ($fornecedores[1]['cnpj'])
    Este fornecedor não tem CNPJ
@endunless
   
@endisset

<h2>Fornecedor</h2>
<?php
    echo 'ALBERTO <br>';
    if(isset($fornecedores)){
        echo 'existe com php puro'. '<hr>';
    }
?>
@unless(isset($x))
    <h2>Bloco com h2 - Não existe a 'x'</h2><br>
@endunless

@php
    if(isset($fornecedores))
    echo 'Bloco php endphp' . '<br>'
@endphp
 {{-- //@dd($fornecedores) --}}

{{ 'Fornecedor: '  }} <br>

<?= 'Teste' ?>

{{-- Comentário no Blade --}}

@php
    // Comentários dentro de uma tab php no blade
   
    /*
        Comentários de múltiplas
        linhas...
    */
@endphp

@if(count($fornecedores) > 0 && count($fornecedores) <= 10)
    <h3>Existem alguns fornecedores cadastrados.
@elseif(count($fornecedores) > 10)
    <h3>São vários os fornecedores cadastrados</h3>
@else 
    <h3> Ainda não existem fornecedores cadastrados.</h3> 
@endif
<hr>
@isset ($fornecedores[1]['cnpj'])
    CNPJ: {{ $fornecedorES[1]['cnpj'] }}
@endisset

@empty ($fornecedores[1]['cnpj'])
    -VAZIO
@endempty
<hr>
Operador condicional ternário:
## VALOR DEFAULT
<hr>
CNPJ: {{ $fornecedores[0]['cnpj'] ?? 'Não existe CNPJ' }}  // valor default

### CASE:
<h2>Fornecedor</h2>
<?php
    echo 'ALBERTO <br>';
    if(isset($fornecedores)){
        echo 'existe com php puro'. '<hr>';
    }
?>
@unless(isset($x))
    <h2>Bloco com h2 - Não existe a 'x'</h2><br>
@endunless

@php
    if(isset($fornecedores))
    echo 'Bloco php endphp' . '<br>'
@endphp
 {{-- //@dd($fornecedores) --}}

{{ 'Fornecedor: '  }} <br>

<?= 'Teste' ?>

{{-- Comentário no Blade --}}

@php
    // Comentários dentro de uma tab php no blade
   
    /*
        Comentários de múltiplas
        linhas...
    */
@endphp

@if(count($fornecedores) > 0 && count($fornecedores) <= 10)
    <h3>Existem alguns fornecedores cadastrados.
@elseif(count($fornecedores) > 10)
    <h3>São vários os fornecedores cadastrados</h3>
@else 
    <h3> Ainda não existem fornecedores cadastrados.</h3> 
@endif
<hr>
@isset ($fornecedores[1]['cnpj'])
    CNPJ: {{ $fornecedorES[1]['cnpj'] }}
@endisset

@empty ($fornecedores[1]['cnpj'])
    -VAZIO
@endempty
<hr>
Operador condicional ternário:
<hr>
CNPJ: {{ $fornecedores[0]['cnpj'] ?? 'Não existe CNPJ' }} <hr>  {{-- valor default --}}

@switch($fornecedores[1]['ddd'])
    @case ('11')
        - DDD: {{ $fornecedores[1]['ddd'] }} São Paulo - SP
        @break
    @case('32')
        - DDD: {{ $fornecedores[1]['ddd'] }} Juiz de Fora -MG
        @break
    @default
        Estado não informado
@endswitch

@@@ @for

<h2>Fornecedor</h2>
<?php
    echo 'ALBERTO <br>';
    if(isset($fornecedores)){
        echo 'existe com php puro'. '<hr>';
    }
?>
@unless(isset($x))
    <h2>Bloco com h2 - Não existe a 'x'</h2><br>
@endunless

@php
    if(isset($fornecedores))
    echo 'Bloco php endphp' . '<br>'
@endphp
 {{-- //@dd($fornecedores) --}}

{{ 'Fornecedor: '  }} <br>

<?= 'Teste' ?>

{{-- Comentário no Blade --}}

@php
    // Comentários dentro de uma tab php no blade
   
    /*
        Comentários de múltiplas
        linhas...
    */
@endphp

@if(count($fornecedores) > 0 && count($fornecedores) <= 10)
    <h3>Existem alguns fornecedores cadastrados.
@elseif(count($fornecedores) > 10)
    <h3>São vários os fornecedores cadastrados</h3>
@else 
    <h3> Ainda não existem fornecedores cadastrados.</h3> 
@endif
<hr>
@isset ($fornecedores[1]['cnpj'])
    CNPJ: {{ $fornecedores[1]['cnpj'] }}
@endisset

@empty ($fornecedores[1]['cnpj'])
    -VAZIO
@endempty
<hr>
Operador condicional ternário:
<hr>
CNPJ: {{ $fornecedores[0]['cnpj'] ?? 'Não existe CNPJ' }} <hr>  {{-- valor default --}}

@switch($fornecedores[1]['ddd'])
    @case ('11')
        - DDD: {{ $fornecedores[1]['ddd'] }} São Paulo - SP
        @break
    @case('32')
        - DDD: {{ $fornecedores[1]['ddd'] }} Juiz de Fora -MG
        @break
    @default
        Estado não informado
@endswitch

<hr>FOR: <br>


 @for ($i = 0 ; isset($fornecedores[$i]); $i++)
    Fornecedor:  {{ $fornecedores[$i]['nome'] }}  <br>
    Status:     {{ $fornecedores[$i]['status']}}  <br>
    DDD:     {{ $fornecedores[$i]['ddd']}}  <br>
    telefone:     {{ $fornecedores[$i]['telefone']}}  <hr>

    @endfor

### @WHILE
<h2>Fornecedor</h2>
<?php
    echo 'ALBERTO <br>';
    if(isset($fornecedores)){
        echo 'existe com php puro'. '<hr>';
    }
?>
@unless(isset($x))
    <h2>Bloco com h2 - Não existe a 'x'</h2><br>
@endunless

@php
    if(isset($fornecedores))
    echo 'Bloco php endphp' . '<br>'
@endphp
 {{-- //@dd($fornecedores) --}}

{{ 'Fornecedor: '  }} <br>

<?= 'Teste' ?>

{{-- Comentário no Blade --}}

@php
    // Comentários dentro de uma tab php no blade
   
    /*
        Comentários de múltiplas
        linhas...
    */
@endphp

@if(count($fornecedores) > 0 && count($fornecedores) <= 10)
    <h3>Existem alguns fornecedores cadastrados.
@elseif(count($fornecedores) > 10)
    <h3>São vários os fornecedores cadastrados</h3>
@else 
    <h3> Ainda não existem fornecedores cadastrados.</h3> 
@endif
<hr>
@isset ($fornecedores[1]['cnpj'])
    CNPJ: {{ $fornecedores[1]['cnpj'] }}
@endisset

@empty ($fornecedores[1]['cnpj'])
    -VAZIO
@endempty
<hr>
Operador condicional ternário:
<hr>
CNPJ: {{ $fornecedores[0]['cnpj'] ?? 'Não existe CNPJ' }} <hr>  {{-- valor default --}}

@switch($fornecedores[1]['ddd'])
    @case ('11')
        - DDD: {{ $fornecedores[1]['ddd'] }} São Paulo - SP
        @break
    @case('32')
        - DDD: {{ $fornecedores[1]['ddd'] }} Juiz de Fora -MG
        @break
    @default
        Estado não informado
@endswitch

<hr>FOR: <br>

 @for ($i = 0 ; isset($fornecedores[$i]); $i++)
    Fornecedor:  {{ $fornecedores[$i]['nome'] }}  <br>
    Status:     {{ $fornecedores[$i]['status']}}  <br>
    DDD:     {{ $fornecedores[$i]['ddd']}}  <br>
    telefone:     {{ $fornecedores[$i]['telefone']}}  <hr>

 @endfor
<hr> WHILE <hr>

@php $i = 0 @endphp
    @while (isset($fornecedores[$i]))
        Fornecedor:  {{ $fornecedores[$i]['nome'] }}  <br>
        Status:     {{ $fornecedores[$i]['status']}}  <br>
        DDD:     {{ $fornecedores[$i]['ddd']}}  <br>
        telefone:     {{ $fornecedores[$i]['telefone']}}  <br>
        @php $i++ @endphp
    @endwhile
<hr>

<hr>
FOREACH

FOREACH - Gera uma cópia do valor original <br>

@foreach ($fornecedores as $indice => $fornecedor)
  Fornecedor: {{ $fornecedor['nome']}} <br>
  Status: {{ $fornecedor['status'] }} <br>
  CNPJ: {{ $fornecedor['cnpj'] ?? '' }} <br>
  Telefone: ({{ $fornecedor['dd'] ?? '' }})  {{ $fornecedor['telefone'] ?? '' }} <br> <hr>

@endforeach

### @forelse
### FornecedorController.php
$fornecedores =[];
### index.blade.php

@forelse ($fornecedores as $indice => $fornecedor)
  Fornecedor: {{ $fornecedor['nome']}} <br>
  Status: {{ $fornecedor['status'] }} <br>
  CNPJ: {{ $fornecedor['cnpj'] ?? '' }} <br>
  Telefone: ({{ $fornecedor['dd'] ?? '' }})  {{ $fornecedor['telefone'] ?? '' }} <br> <hr>
@empty
        Não existem Registros

@endforelse


### ESCAPANDO A FORMA DE IMPRESSÃO
  Fornecedor: @{{ $fornecedor['nome']}} <br>
  Status: @{{ $fornecedor['status'] }} <br>
  CNPJ: @{{ $fornecedor['cnpj'] ?? '' }} <br>

### OBJETO LOOP CRIADO AUTOMATICAMENTE QUANDO USAMOS FOREACH E FORELSE
<h2>Fornecedor</h2>
### OBJETO LOOP -> Existe em @foreach e @forelse
    
@endforeach
@forelse ($fornecedores as $indice => $fornecedor)
@dd($loop)
    @if($loop->first)
        => Aqui é a primeira iteração do loop  
    @endif
    Iteração Atual: -> {{ $loop->iteration }}<br>
    Fornecedor: {{ $fornecedor['nome']}} <br>
    Status: {{ $fornecedor['status'] }} <br>
    CNPJ: {{ $fornecedor['cnpj'] ?? '' }} <br>  
    @if($loop->last)
        => Aqui é a última iteração do loop <hr>
    @else 
        <hr>
    @endif
@empty
    Telefone: ({{ $fornecedor['dd'] ?? '' }})  {{ $fornecedor['telefone'] ?? '' }} <br>  <hr>
        Não existem Registros

@endforelse


### LIMPAR AS VIEWS COMPILADAS NO CACHE 

php artisan view:clear

### ASSETS => Tudo aquilo que complementa os arquivos html ou a página web a pasta de assets(arquivos js, css, imagens, sons, etc ficam em /public do projeto)

  <body>
        <div class="topo">

            <div class="logo">
                <img src="img/logo.png">
                <img src="{{ asset('img/logo.png') }}">
            </div>

### CSS externo
  <link rel="stylesheet" href="{{asset('css/estilo_basico.css')}}" >

### layout_principal.php
<!DOCTYPE html>
<html lang="pt-br">
    <head>
        <title>Super Gestão - Sobre Nós</title>
        <meta charset="utf-8">

      <link rel="stylesheet" href="{{asset('css/estilo_basico.css')}}" >
       
    </head>

    <body>
        @yield('conteudo')
    </body>
</html>

### principal.php  /  contato.php / outras_paginas.php
@extends('site.layouts.basico')

@section('conteudo')
        <div class="topo">

            <div class="logo">
                <img src="{{asset('img/logo.png')}}">
            </div>

            <div class="menu">
                <ul>
                    <li><a href="{{ route('site.index') }}">Principal</a></li>
                    <li><a href="{{ route('site.sobrenos') }}">Sobre Nós</a></li>
                    <li><a href="{{ route('site.contato') }}">Contato</a></li>
                </ul>
            </div>
        </div>
 @endsection  

 ### PASSANDO PARÂMETROS PARA O LAYOUT PRINCIPAL
layout_principal.php
 @extends('site.layouts.basico')

@section('titulo', 'Página Principal')
@section('conteudo')
        <div class="topo">

            <div class="logo">
                <img src="img/logo.png">
            </div>

            <div class="menu">
                <ul>
                    <li><a href="{{ route('site.index') }}">Principal</a></li>
                    <li><a href="{{ route('site.sobrenos') }}">Sobre Nós</a></li>
                    <li><a href="{{ route('site.contato') }}">Contato</a></li>
                </ul>
            </div>
        </div>
@endsection

contato.php
@extends('site.layouts.basico')

@section('titulo', 'Contato')
@section('conteudo')
        <div class="topo">

            <div class="logo">
                <img src="{{asset('img/logo.png')}}">
            </div>
@endsection

sobre-nos.php
@extends('site.layouts.basico')

@section('titulo', 'Sobre Nos')
@section('conteudo')
        <div class="topo">

            <div class="logo">
                <img src="{{asset('img/logo.png')}}">
            </div>

            <div class="menu">
                <ul>
                    <li><a href="{{ route('site.index') }}">Principal</a></li>
                    <li><a href="{{ route('site.sobrenos') }}">Sobre Nós</a></li>
                    <li><a href="{{ route('site.contato') }}">Contato</a></li>
                </ul>
            </div>
      </div>
@endsection

######## Se quiser receber parâmetros vindo da view
CotatoController.php
<?php
namespace App\Http\Controllers;
use Illuminate\Http\Request;
class ContatoController extends Controller
{
    public function contato() {
        return view('site.contato', ['titulo' => 'Contato - titulo vindo do controlador']);
    }
}

/*** */
View recebendo parâmetro vindo do controlador 
contato.blade.php
@extends('site.layouts.basico')

@section('titulo', $titulo)
@section('titulo', 'Contato')
@section('conteudo')
        <div class="topo">




### INCLUINDO PÁGINAS include (é literalmente uma inclusão)

 @include('site.layouts._partials.topo')

### ENVIANDO O FORMULÁRIO DE CONTATO
form.blade.php
<form action={{ route('site.contato') }} method="get" > 
        <input type="text" name="nome" placeholder="Nome" class="borda-preta">
        <br>
        <input type="text" name="telefone" placeholder="Telefone" class="borda-preta">
        <br>
        <input type="text" name="email" placeholder="E-mail" class="borda-preta">
        <br>
        <select class="borda-preta">
            <option value="">Qual o motivo do contato?</option>
            <option value="1">Dúvida</option>
            <option value="2">Elogio</option>
            <option value="3">Reclamação</option>
        </select>
        <br>
        <textarea name="mensagem" class="borda-preta">Preencha aqui a sua mensagem</textarea>
        <br>
        <button type="submit" class="borda-preta">ENVIAR</button>
    </form>

web.php

Route::get('/contato', [\App\Http\Controllers\ContatoController::class, 'contato'])->name('site.contato');                    

ContatoController.php
<?php

namespace App\Http\Controllers;

use Illuminate\Http\Request;

class ContatoController extends Controller
{
    public function contato() {

        var_dump($_GET);
        return view('site.contato', ['titulo' => 'Contato - titulo vindo do controlador'], ['teste' => 'Alberto Gomes']);
    }
}




/**************** */
BLADE.PHP
<h1>Passando variável direto: {{ $name }} </h1>
<hr>
<h1>Listando o Retorno da Model User</h1>
<h2>{{ $user }} </h2>
<p>Selecionando o nome fica: {{ $user->name }} </p>
<p>Selecionando o Email fica: {{ $user->email }} </p>

DATABASE SEED
class DatabaseSeeder extends Seeder
{
    /**
     * Seed the application's database.
     *
     * @return void
     */
    public function run()
    {
        \App\Models\User::factory(10)->create();

        //  \App\Models\User::factory()->create([
        //      'name' => 'Test User',
        //      'email' => 'test@example.com',
        //  ]);
    }
}

## REDIRECIONAMENTO DE ROTAS
web.php

Route::get('/rota1', function(){
    echo 'Rota 1';
})->name('site.rota1');
Route::get('/rota2', function(){
    //echo 'Rota 2';
    return redirect()->route('site.rota1');
})->name('site.rota2');

//Route::redirect('/rota2', 'rota1');


### MÉTODO POST -> Exige o csrf (CROSS-SITE REQUEST FORGERY ou falsificação de solicitação entre sites)

<form action={{ route('site.contato') }} method="post" > 
@csrf
    <input type="text" name="nome" placeholder="Nome" class="borda-preta">
    <br>
    <input type="text" name="telefone" placeholder="Telefone" class="borda-preta">
    <br>
    <input type="text" name="email" placeholder="E-mail" class="borda-preta">
    <br>
    <select class="borda-preta">
        <option value="">Qual o motivo do contato?</option>
        <option value="1">Dúvida</option>
        <option value="2">Elogio</option>
        <option value="3">Reclamação</option>
    </select>
    <br>
    <textarea name="mensagem" class="borda-preta">Preencha aqui a sua mensagem</textarea>
    <br>
    <button type="submit" class="borda-preta">ENVIAR</button>
</form>

ContatoController.php
<?php

namespace App\Http\Controllers;

use Illuminate\Http\Request;

class ContatoController extends Controller
{
    public function contato() {

    use    var_dump($_POST);
    ou     dd($_POST);
        return view('site.contato', ['titulo' => 'Contato - titulo vindo do controlador'], ['teste' => 'Alberto Gomes']);
    }
}

### incluindo views ou partials @components
 @component('site.layouts._components.form_contato')
@endcomponent

### passando parâmetros por @components

   @component('site.layouts._components.form_contato')
                        <p>A nossa equipe analisará a sua mensagem e retornaremos o mais brevemente possível.</p>
                        <p> Nosso tempo médio de resposta é de 48horas.</p>
@endcomponent

NO COMPONENTE ADICIONAMOS A TAG {{ slot }} :
{{ $slot }}
<form action={{ route('site.contato') }} method="post" > 
            @csrf
            <input type="text" name="nome" placeholder="Nome" class="borda-preta">
            <br>
            <input type="text" name="telefone" placeholder="Telefone" class="borda-preta">
            <br>
            <input type="text" name="email" placeholder="E-mail" class="borda-preta">
            <br>
            <select class="borda-preta">
                <option value="">Qual o motivo do contato?</option>
                <option value="1">Dúvida</option>
                <option value="2">Elogio</option>
                <option value="3">Reclamação</option>
            </select>
            <br>
            <textarea name="mensagem" class="borda-preta">Preencha aqui a sua mensagem</textarea>
    <br>
    <button type="submit" class="borda-preta">ENVIAR</button>
</form>

principal.blade.php

@extends('site.layouts.basico')


@section('titulo', 'Página Principal')
@section('conteudo')
      {{-- @include('site.layouts._partials.topo') --}}
 
        <div class="conteudo-destaque">
        
            <div class="esquerda">
                <div class="informacoes">
                    <h1>Sistema Super Gestão</h1>
                    <p>Software para gestão empresarial ideal para sua empresa.<p>
                    <div class="chamada">
                        <img src="{{asset('/img/check.png') }}">
                        <span class="texto-branco">Gestão completa e descomplicada</span>
                    </div>
                    <div class="chamada">
                        <img src="{{asset('img/check.png') }}">
                        <span class="texto-branco">Sua empresa na nuvem</span>
                    </div>
                </div>

                <div class="video">
                    <img src="{{asset('img/player_video.jpg') }} ">
                </div>
            </div>

            <div class="direita">
                <div class="contato">
                    <h1>Contato</h1>
                    <p>Caso tenha qualquer dúvida por favor entre em contato com nossa equipe pelo formulário abaixo.<p>
                     @component('site.layouts._components.form_contato')
                        <h3> Entraremos em contato: aguarde 48 hs. </h3>
                    @endcomponent
                </div>
            </div>
        </div>
  @endsection

  ### SEGUNDA FORMA DE ENVIAR PARÂMETROS POR COMPONENTES @component

  principal.blade.php

    <h1>Contato</h1>
                    <p>Caso tenha qualquer dúvida por favor entre em contato com nossa equipe pelo formulário abaixo.<p>
                     @component('site.layouts._components.form_contato', ['x' => 10])
                        <h3> Entraremos em contato: aguarde 48 hs. </h3>
@endcomponent

ou 

 <p>Caso tenha qualquer dúvida por favor entre em contato com nossa equipe pelo formulário abaixo.<p>
                     @component('site.layouts._components.form_contato', ['x' => 'Entraremos em contato: aguarde 48 hs.'])
                      
                    @endcomponent


form_contato.ph
    {{ $slot }}
    {{ $x }}


    /************ */

contato.blade.php

@component('site.layouts._components.form_contato', ['x' => '48 horas.'])
    <p>A nossa equipe analisará a sua mensagem e retornaremos o mais brevemente possível.</p>
    <p> Nosso tempo médio de resposta é de</p>
@endcomponent

form_contato.blade.php
{{ $slot }}

{{ $x }}
<form action={{ route('site.contato') }} method="post" > 
    @csrf
    <input type="text" name="nome" placeholder="Nome" class="borda-preta">
    <br>
    <input type="text" name="telefone" placeholder="Telefone" class="borda-preta">
    <br>
    <input type="text" name="email" placeholder="E-mail" class="borda-preta">
    <br>
    <select class="borda-preta">
        <option value="">Qual o motivo do contato?</option>
        <option value="1">Dúvida</option>
        <option value="2">Elogio</option>
        <option value="3">Reclamação</option>
    </select>
    <br>
    <textarea name="mensagem" class="borda-preta">Preencha aqui a sua mensagem</textarea>
<br>
<button type="submit" class="borda-preta">ENVIAR</button>
</form>



### CRIANDO UMA MODEL E SUA MIGRATION
>php artisan make:model SiteContato -m

Dica - Resolvendo problema do php artisan migrate
Dica importante para próxima aula enviada pelo João Vitor Moraski. A dica se aplica a você caso você esteja utilizando o sistema operacional Linux na distro Ubuntu 20.04:



Tive um problema onde sempre que tentava executar a migrate aparecia algo do tipo could not find drive (SQL: PRAGMA foreign_keys = on;).

Algumas pessoas conseguem resolver o erro tirando o ";" de trás da escrita 'extension:pdo_sqlite' no php.ini. O arquivo php ini pode ser localizado por meio do comando php -i | grep 'php.ini' ou pelo comando php --ini (os comandos devem ser executado na linha de comando do sistema operacional).

Porém, se o procedimento acima não funcionar, tente realizar a instalação da extensão em seu sistema operacional. No meu caso, na versão 20.04 do Ubuntu, ocorreu que a extensão não estava instalada por padrão. O comando utilizado na linha de comando do sistema operacional para instalar a extensão é:

sudo apt install php7.4-sqlite3 <- comando para instalar a extensão certa

### SQLITE -> IDEAL PARA PEQUENOS PROJETOS SEM SEGURANÇA. /config/database.php (classe das configurações) -> alterções são feitas em .ven 
linha9 DB_CONNECTION=sqlite

Se DB_DATABASE não estiver configurada ele adotará o padrão.. Bastando criar um arquivo /database/database.sqlit Dentro da pasta database do projeto.

### Testa se o PDO está carregado:
>php -r "var_dump(extension_loaded('pdo_mysql'));" 

bool(true)




### CRIANDO E EXCECUTANDO migrations
2022_10_29_124933_create_site_contatos_table.php

<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     *
     * @return void
     */
    public function up()
    {
        Schema::create('site_contatos', function (Blueprint $table) {
            $table->id();
            $table->string('nome', 50);
            $table->string('telefone', 20);
            $table->string('email', 80);
            $table->integer('motivo_contato');
            $table->text('mensagem');
            $table->timestamps();
        });
    }

    /**
     * Reverse the migrations.
     *
     * @return void
     */
    public function down()
    {
        Schema::dropIfExists('site_contatos');
    }
};
 > php artisan migrate

 ### Criando Model e Migration uma de cada vez
>php artisan make:model Fornecedor 

>php artisan make:migration create_fornecedores_table

<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     *
     * @return void
     */
    public function up()
    {
        Schema::create('fornecedores', function (Blueprint $table) {
            $table->id();
            $table->string('nome', 50);
            $table->timestamps();
        });
    }
>php artisan migrate
 ### MIGRATION: Adicionando campos a uma tabela já existente (MÉTODO UP) e DESFAZENDO AS ADIÇÕES (MÉTOD DOWN):
 ==> COMANDOS: 
 * Executar a criação das tabelas: php artisan migrate -> acontece da mais antiga para a mais atual
 * Reverter as migrações: php artisan migrate:rollback -> acontece da mais atual para a mais antiga
 * Podemos indicar quantos passos(sterps) podemos reverter ou quantas migrates queremos reverter: 
    > php artisan migrate:rollback  ou php artisan migrate:rollback --step=2
    > php artisan migrate -> Executa novamente todas as migrations recriando as tabelas e colunas.

 - php artisan make:migration alter_fornecedores_novas_colunas

2022_10_30_144326_alter_fornecedores_novas_colunas.php
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     *
     * @return void
     */
    public function up()
    {
        // CRIANDO NOVA COLUNAS NA TABELA
        Schema::table('fornecedores', function (Blueprint $table) {
            $table->string('uf', 2);
            $table->string('email', 150);
        });
    }

    /**
     * Reverse the migrations.
     *
     * @return void
     */
    public function down()
    {
        // PARA REMOVER AS COLUNAS CRIADA NO MÉTODO UP
        Schema::table('fornecedores', function (Blueprint $table) {
           // $table->$table->dropColumn('uf');
           // $table->dropColumn('email'); ou podemos usar apenas o comando abaixo passando um array de colunas
            $table->dropColumn(['uf', 'email']);
        });
    }
};

### CRIANDO A MIGRATION 2022_10_30_151416_create_produtos_table.php COM VALORES NULOS E DEFAULT (VALOR PADRÃO):
> php artisan make:migration create_produtos_table <ENTER>
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     *
     * @return void
     */
    public function up()
    {
        Schema::create('produtos', function (Blueprint $table) {
            $table->id();
            $table->string('nome', 100);
            $table->text('descricao')->nullable();
            $table->integer('peso')->nullable();
            $table->float('preco_venda', 8, 2)->default(0.01);
            $table->integer('estoque_minimo')->default(1);
            $table->integer('estoque_maximo')->default(1);
            $table->timestamps();
        });
    }

    /**
     * Reverse the migrations.
     *
     * @return void
     */
    public function down()
    {
        Schema::dropIfExists('produtos');
    }
};
### EXECUTANDO A MIGRATION CRIADA:
> php artisan migrate







### CRIANDO MIGRATIONS COM RELACIONAMENTOS DE TABELAS
> php artisan make:migration create_produto_detalhes_table
2022_10_30_152706_create_produtos_detalhes_table.php

 * Para fazer o relacionamento de um para um entre tabelas, a chave primária de uma das tabelas do relacionamento, viage para a 
   outra tabela e lá, essa chave primária que viajou, seja recebida como chave estrageira. Vale lembra que no relacionamento de um para um tanto faz qual a tabela que vai receber a chave estrageira, mais o ideal, por convenção, o indicado é que a chave 
   primária da tabela mais forte do relacionamento, ou seja, aquela tabela que tem mais impacto no negócio, viage como chave 
   estrangeira para a tabela mais fraca do relacionamento, ou seja, aquela que tem menos impacto do ponto de vista do negócio.
   Sendo assim a tabela produto_detalhes tem que ter uma nova coluna "produto_id" para receber a chave primária da tabela "produtos":

<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     *
     * @return void
     */
    public function up()
    {
        Schema::create('produto_detalhes', function (Blueprint $table) {
            // Colunas
            $table->id();

            $table->unsignedBigInteger('produto_id'); // Por convensão usamos o singular do nome da tabela que envia a chave e o nome da coluna

            $table-> float('comprimento', 8, 2);
            $table-> float('largura', 8, 2);
            $table-> float('altura', 8, 2);

            $table->timestamps();

            // Constraint de de integridade referencial
            $table->foreign('produto_id')->references('id')->on('produtos');
            // Constraint para garantir que não tenha valor repetido
            $table->unique('produto_id');
        });
    }

    /**
     * Reverse the migrations.
     *
     * @return void
     */
    public function down()
    {
        Schema::dropIfExists('produto_detalhes');
    }
};

>php artisan migrate

### Migration - Adicionando Chaves Estrangeiras (Relacionamento de um para muitos):
### MÉTODOS UP E MÉTODO DOWN
>php artisan make:migration create_unicades_table
2022_10_30_163254_create_unidades_table.php

<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     *
     * @return void
     */
    public function up()
    {
        Schema::create('unidades', function (Blueprint $table) {
            $table->id();
            $table->string('unidade', 5);
            $table->string('decricao', 30);
            $table->timestamps();

        
        });

            // adicionar o relacionamento com a tabela produtos
        Schema::table('produtos', function (Blueprint $table) {
            $table->unsignedBigInteger('unidade_id');
            $table->foreign('unidade_id')->references('id')->on('unidades');
        });
        
        // RELACIONAMENTOS NECESSÁRIOS (vamos usar a mesma migration)
        // adicionar o relacionamento com a tabela produtos_detalhes
        Schema::table('produto_detalhes', function (Blueprint $table) {
            $table->unsignedBigInteger('unidade_id');
            $table->foreign('unidade_id')->references('id')->on('unidades');
        });

       
    }

    /**
     * Reverse the migrations.
     *
     * @return void
     */
    public function down()
    {
        /* DESFAZENDO TUDO FEITO NO MÉTODO UP */
        // REMOVENDO AS CHAVES ESTRANGEIRAS
        // adicionar o relacionamento com a tabela produtos_detalhes
        Schema::table('produto_detalhes', function(Blueprint $table) {
            // remover a forekey(fk)
            $table->dropForeign('produto_detalhes_unidade_id_foreign');   // [table]_[coluna]_foreign ->verificar o nome criado na tablela
            
            // remover a coluna unidade_id
            $table->dropColumn('unidade_id');
            
        });
        
       
        // remover o relacionamento com a tabela produtos
        Schema::table('produtos', function(Blueprint $table) {
            // remover a forekey(fk)
            $table->dropForeign('produtos_unidade_id_foreign');   // [table]_[coluna]_foreign ->verificar o nome criado na tablela
            
            // remover a coluna unidade_id
            $table->dropColumn('unidade_id');
            
        });

        Schema::dropIfExists('unidades');
    }
};

### >php artisan migrate                -> EXECUTA TODOS OS MÉTODO UP CRIANDO AS TABELAS NO BANCO DE DADOS
### >php artisan migrate:rollback       -> DESFAZ TODOS OS MÉTODOS DOWN DESFAZENDO AS TABELAS DO BANCO DE DADOS

>php artisan migrate:rollback 

### ESTRUTURA DAS TABELAS PRODUTOS, UNIDADES E PRODUTO_DETALHES
Table: produtos
Columns:
id bigint(20) UN AI PK 
nome varchar(100) 
descricao text 
peso int(11) 
preco_venda double(8,2) 
estoque_minimo int(11) 
estoque_maximo int(11) 
created_at timestamp 
updated_at timestamp 
unidade_id bigint(20) UN

Table: unidades
Columns:
id bigint(20) UN AI PK 
unidade varchar(5) 
decricao varchar(30) 
created_at timestamp 
updated_at timestamp

Table: produto_detalhes
Columns:
id bigint(20) UN AI PK 
produto_id bigint(20) UN 
comprimento double(8,2) 
largura double(8,2) 
altura double(8,2) 
created_at timestamp 
updated_at timestamp 
unidade_id bigint(20) UN

Table: unidades
Columns:
id bigint(20) UN AI PK 
unidade varchar(5) 
decricao varchar(30) 
created_at timestamp 
updated_at timestamp

### ADICIONANDO CHAVE ESTRANGEIRAS - RELACIONAMENTO MUITOS PARA MUITOS -> Este tipo de relacionamento sempre envolve uma terceira tabela: vamos criar a tabela filiais e produto_filiais e estabelecer este relacionamento:
php artisan make:migration ajuste_produtos_filiais

2022_10_30_175104_ajuste_produtos_filiais.php

<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     *
     * @return void
     */
    public function up()
    {
        //Criando a tabela filiais
        Schema::create('filiais', function (Blueprint $table) {
            $table->id();
            $table->string('filial', 30);
            $table->timestamps();
        });
       
        //Criando a tabela produto_filiais
        Schema::create('produto_filiais', function (Blueprint $table) {
            $table->id();
            $table->unsignedBigInteger('filial_id');
            $table->unsignedBigInteger('produto_id');
            $table->decimal('preco_venda', 8, 2);
            $table->integer('estoque_minimo');
            $table->integer('estoque_maximo');
            $table->timestamps();

            //  Constraint de Relacionamentos - foreign key
            $table->foreign('filial_id')->references('id')->on('filiais');
            $table->foreign('produto_id')->references('id')->on('produtos');
        });

        // Removendo colunas da tabela produtos
        Schema::table('produtos', function (Blueprint $table) {
           $table->dropColumn(['preco_venda', 'estoque_minimo', 'estoque_maximo']);
        });
    }

    /**
     * Reverse the migrations.
     *
     * @return void
     */
    public function down()
    {
        // Recriando as colunas da tabela produtos
        Schema::table('produtos', function (Blueprint $table) {
            $table->decimal('preco_venda', 8, 2)->default(0.01);
            $table->integer('estoque_minimo')->default(1);
            $table->integer('estoque_maximo')->default(1);
         });

         Schema::dropIfExists('produto_filiais');

         Schema::dropIfExists('filiais');
    }
};
### TESTANDO AS MIGRATES
>php artisan migrate
>php artisan migrate:rollback

### MIGRATION -> MODIFICADOR After: Permite que novas colunas sejam inseridas em pontos específicos de uma coluna pre existente: após(after) uma coluna já existente: 'uf' e 'email' que foram colunas adicionadas na tabela 'fornecedores' ficaram no final, vamos criar então uma nova coluna 'site' na tabela 'fornecedores' e indicar a posição que será criada:
>php artisan make:migration nova_coluna_site_com_after

2022_10_30_182603_nova_coluna_site_com_after.php

<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     *
     * @return void
     */
    public function up()
    {
        //
        Schema::table('fornecedores', function (Blueprint $table) {
            $table->string('site', 150)->after('nome')->nullable()->default('https://www.albertogomesdasilva.com.br');
        });
    }

    /**
     * Reverse the migrations.
     *
     * @return void
     */
    public function down()
    {
        //
        Schema::table('fornecedores', function (Blueprint $table) {
            $table->dropColumn('site');
        });

    }
};

### COMANDOS MIGRATIONS: STATUS, RESET, REFRESH E FRESH
- >php artisan migrate:status -> Verifica se a migration já foi executada;
- >php artisan migrate:reset -> Executa todos os métodos down da mais atual para a mais antiga e retorna o status das migrations para pedente- apaga o banco de dados por completo;
- >php artisan migrate:refresh -> Reverte todas as migrations e na sequência executa todos os métodos up - apaga o banco de dados e na sequência recria;
- >php artisan migrate:fresh -> Dropa o banco de dados e executa todas as migrations - zera os id's das tabelas do banco de dados;

### ENTENDENDO O ELOQUENT ORM -> Object Relacional Maping nativo do Framework Laravel. O ORM (Mapeamento Objeto Relacional ) é uma técnica para aproximar o paradigma de desenvolvimento de aplicações orientadas a objetos com um banco de dados relacional ( Orientação a Objetos <==> Banco de Dados Relacional). As bibliotecas e frameworks definem como os dados serão mapeados entre os dois ambientes possibilitando o CRUD dimiundo significativamente o tempo de desenvolvimento de aplicações utilizando os recursos do ORM que independente de linguagem de programação. Atualmente dois padrões se destacam no mercado: Data Mapper e Active Record. O Framework Laravel o ORM Eloquente segue o padrão Active Record.

### TINKER -> É um a ferramenta nativa do framework Laravel, é um console interativo que possibilita o acesso as classes do projeto através do terminal. Através do Tinker podemos facilmente manipular as classes relativas aos Models do projeto, podemos instanciar as classes e executar os métodos dos objetos instanciados e os métodos estáticos também, podemos também testar o Mapeamento Objeto Relacional entre as classes relativas ao Models do projeto e o Banco de Dados. Sem o Tinker precisaremos usar uma interface previamente criada ou diretamente no banco de dados, ou através de um script para esse propósito. O Tinker é um atalho para testarmos os Models com o Eloquent ORM fazendo a persistência de dados no banco.
### INSERINDO REGISTROS NO BANCO
>php artisan tinker
Psy Shell v0.11.8 (PHP 8.1.11 — cli) by Justin Hileman
>>> $contato = new SiteContato                                                 
[!] Aliasing 'SiteContato' to 'App\Models\SiteContato' for this Tinker session.
=> App\Models\SiteContato {#3680}

>>> $contato->nome = 'Alberto'                                                 
=> "Alberto"

>>> $contato->telefone = '98981188434'                                         
=> "98981188434"

>>> $contato->email = 'albertoogmesdasilva@gmail.com'                          
=> "albertoogmesdasilva@gmail.com"

>>> $contato->motivo_contato = 1                                               
=> 1

>>> $contato->mensagem = 'Olá. Gostaria de maiores detalhes..'                 
=> "Olá. Gostaria de maiores detalhes.."    
>>> print_r($contato->getAttributes())                                         
Array
(
    [nome] => Alberto
    [telefone] => 98981188434
    [email] => albertoogmesdasilva@gmail.com
    [motivo_contato] => 1
    [mensagem] => Olá. Gostaria de maiores detalhes..
)
=> true

>>> $contato->save()                                                           
=> true
### INSERINDO NOVO REGISTRO COM TINKER
>>> $contato2 = new SiteContato();                                             
=> App\Models\SiteContato {#4017}

>>> $contato2->nome = 'Maria'                                                  
=> "Maria"

>>> $contato2->telefone = '98998887777'                                        
=> "98998887777"

>>> $contato2->email = 'maria@gmail.com'                                       
=> "maria@gmail.com"

>>> $contato2->mensagem = 'tudo ok..'                                          
=> "tudo ok.."

>>> $contato2->motivo_contato = 2                                              
=> 2

>>> print_r($contato2->getAttributes())                                        
Array
(
    [nome] => Maria
    [telefone] => 98998887777
    [email] => maria@gmail.com
    [mensagem] => tudo ok..
    [motivo_contato] => 2
)
=> true

>>> $contato2->save()                                                          
=> true

### AJUSTANDO O NOME DA TABELA NO MODEL PARA UM CORRETO ORM
* MODEL: SiteContato.php  ==> site_contato -> nome da tabela no banco de dados.
* MODEL: Fornecedor.php   ==> fornecedores -> nome da tabela no banco -> Neste caso vamos tentar salvar com o tinker na tabela fornecedores irá gerar um erro:
>>> $f->save()                                                                 
Illuminate\Database\QueryException with message 'SQLSTATE[42S02]: Base table or view not found: 1146 Table 'sg.fornecedors' doesn't exist (SQL: insert into `fornecedors` (`nome`, `site`, `uf`, `email`, `updated_at`, `created_at`) values (Fornecedor XYZ, http://fornecedorxyz.com.br, MA, fornecedorxyz@gmail.com.br, 2022-10-30 19:53:51, 2022-10-30 19:53:51))'

para corrigir isto no Model Fornecedor.php incluiremos a linha 
    protected $table = 'fornecedores';


<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;

class SiteContato extends Model   //site_contato -> nome da tabela no banco de dados.
{
    use HasFactory;
    protected $table = 'fornecedores';  // Ajustar quando o ORM não consegue salvar na tabela.

}


### SALVANDO NO BANCO DE DADOS USANDO O MÉTODO ESTÁTICO HERDADO DA CLASSE MODEL - CREATE (não depende da instância do objeto -> seu uso é mais comum - já usamos na criação das migrations.)
PARA ISSO ACRESCENTAMOS UMA LINHA DE PERMISSÃO PARA INSERÇÃO DE DADOS NO BANCO:   protected $fillable = ['nome', 'site', 'uf', 'email'];
Fornecedor.php
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;

class Fornecedor extends Model
{
    use HasFactory;
    protected $table = 'fornecedores';

    protected $fillable = ['nome', 'site', 'uf', 'email'];

}


>php artisan tinker

Psy Shell v0.11.8 (PHP 8.1.11 — cli) by Justin Hileman
>>> Fornecedor::create(['nome'=>'Fornecedro ABC', 'site'=>'fornecedor.com.br', 'uf'=>'SP', 'email'=>'contato@abc.com.br']) 

* OBS.: QUALQUER ERRO SAI DO TINKER COM 'quit' e retorna para que o tinker recarregue os Models.

### RECUPERANDO REGISTROS NO BANCO DE DADOS
* MÉTODO ESTÁTICO ALL -> Recupera todos os registros de uma tabela

>>> $fornecedores = Fornecedor::all()                                          
=> Illuminate\Database\Eloquent\Collection {#3695
     all: [
       App\Models\Fornecedor {#3692
         id: 1,
         nome: "Fornecedor XYZ",
         site: "https://www.albertogomesdasilva.com.br",
         created_at: "2022-10-30 20:01:42",
         updated_at: "2022-10-30 20:01:42",
         uf: "MA",
         email: "fornecedorxyz@gmail.com.br",
       },
       App\Models\Fornecedor {#3689
         id: 2,
         nome: "Brascopper-SLZ",
         site: "https://brascopper-slz.com.br",
         created_at: "2022-10-30 20:06:03",
         updated_at: "2022-10-30 20:06:03",
         updated_at: "2022-10-30 20:14:19",
         uf: "SP",
         email: "contato@abc.com.br",
       },
     ],
   }

>>>>>> $r=SiteContato::all()                                                      
[!] Aliasing 'SiteContato' to 'App\Models\SiteContato' for this Tinker session.
=> Illuminate\Database\Eloquent\Collection {#4022
     all: [
       App\Models\SiteContato {#4637
         id: 1,
         nome: "Alberto",
         telefone: "98981188434",
         email: "albertoogmesdasilva@gmail.com",
         motivo_contato: 1,
         mensagem: "Olá. Gostaria de maiores detalhes..",
         created_at: "2022-10-30 19:34:37",
         updated_at: "2022-10-30 19:34:37",
       },
       App\Models\SiteContato {#4638
         id: 2,
         nome: "Maria",
         telefone: "98998887777",
         email: "maria@gmail.com",
         motivo_contato: 2,
         mensagem: "tudo ok..",
         created_at: "2022-10-30 19:40:45",
         updated_at: "2022-10-30 19:40:45",
       },
     ],
   }

   - CLASSIFICANDO:
   >>> $registros->toArray()                                                            
=> [
     [
       "id" => 1,
       "nome" => "Fornecedor XYZ",
       "site" => "https://www.albertogomesdasilva.com.br",
       "created_at" => "2022-10-30T20:01:42.000000Z",
       "updated_at" => "2022-10-30T20:01:42.000000Z",
       "uf" => "MA",
       "email" => "fornecedorxyz@gmail.com.br",
     ],
     [
       "id" => 2,
       "nome" => "Brascopper-SLZ",
       "site" => "https://brascopper-slz.com.br",
       "created_at" => "2022-10-30T20:06:03.000000Z",
       "updated_at" => "2022-10-30T20:06:03.000000Z",
       "uf" => "MA",
       "email" => "brascopperslz@gmail.com.br",
     ],
       "email" => "contato@abc.com.br",
     ],
   ]

>>> foreach($registros as $r) { echo $r-nome; echo '-';}                             
                         
Fornecedor XYZ-Brascopper-SLZ-Fornecedro ABC-⏎
>>>                                                                                  


* MÉTODO ESTÁTICO FIND:
>>> $buscar = Fornecedor::find(2)                                                    
=> App\Models\Fornecedor {#5020
     id: 2,
     nome: "Brascopper-SLZ",
     site: "https://brascopper-slz.com.br",
     created_at: "2022-10-30 20:06:03",
     updated_at: "2022-10-30 20:06:03",
     uf: "MA",
     email: "brascopperslz@gmail.com.br",
   }

>>>echo $buscar->nome                                                               
Brascopper-SLZ⏎                  

ou ainda..
>>> $buscar = Fornecedor::find([1,2,3,4])                                            
=> Illuminate\Database\Eloquent\Collection {#5019
     all: [
       App\Models\Fornecedor {#5014
         id: 1,
         nome: "Fornecedor XYZ",
         site: "https://www.albertogomesdasilva.com.br",
         created_at: "2022-10-30 20:01:42",
         updated_at: "2022-10-30 20:01:42",
         uf: "MA",
         email: "fornecedorxyz@gmail.com.br",
       },
       App\Models\Fornecedor {#5021
         id: 2,
         nome: "Brascopper-SLZ",
         site: "https://brascopper-slz.com.br",
         created_at: "2022-10-30 20:06:03",
         updated_at: "2022-10-30 20:06:03",
         uf: "MA",
         email: "brascopperslz@gmail.com.br",
       },
       App\Models\Fornecedor {#4637
         id: 3,
         nome: "Fornecedro ABC",
         site: "fornecedor.com.br",
         created_at: "2022-10-30 20:14:19",
         updated_at: "2022-10-30 20:14:19",
         uf: "SP",
         email: "contato@abc.com.br",
       },
     ],
   }

* MÉTODO ESTÁTICO WHERE:          

>>> $contatos = SiteContato::where('id', '>=', 1)->get()                             
=> Illuminate\Database\Eloquent\Collection {#5012
     all: [
       App\Models\SiteContato {#3688
         id: 1,
         nome: "Alberto",
         telefone: "98981188434",
         email: "albertoogmesdasilva@gmail.com",
         motivo_contato: 1,
         mensagem: "Olá. Gostaria de maiores detalhes..",
         created_at: "2022-10-30 19:34:37",
         updated_at: "2022-10-30 19:34:37",
       },
       App\Models\SiteContato {#5011
         id: 2,
         nome: "Maria",
         telefone: "98998887777",
         email: "maria@gmail.com",
         motivo_contato: 2,
         mensagem: "tudo ok..",
         created_at: "2022-10-30 19:40:45",
         updated_at: "2022-10-30 19:40:45",
       },
     ],
   }

>>>>>> $contatos = SiteContato::where('nome', '=','Maria')->get()                       
=> Illuminate\Database\Eloquent\Collection {#5012
     all: [
       App\Models\SiteContato {#5020
         id: 2,
         nome: "Maria",
         telefone: "98998887777",
         email: "maria@gmail.com",
         motivo_contato: 2,
         mensagem: "tudo ok..",
         created_at: "2022-10-30 19:40:45",
         updated_at: "2022-10-30 19:40:45",
       },
     ],
   }

>>> $contatos = SiteContato::where('nome', '<>','Maria')->get()                      
=> Illuminate\Database\Eloquent\Collection {#5006
     all: [
       App\Models\SiteContato {#4645
         id: 1,
         nome: "Alberto",
         telefone: "98981188434",
         email: "albertoogmesdasilva@gmail.com",
         motivo_contato: 1,
         mensagem: "Olá. Gostaria de maiores detalhes..",
         created_at: "2022-10-30 19:34:37",
         updated_at: "2022-10-30 19:34:37",
       },
     ],
   }

* OBS.: QUANDO USAR IGUAL PODEMOS OMITIR O SEGUNDO PARÂMETRO, SIMPLIFICANDO A CONSULTA:
>>> $contatos = SiteContato::where('nome', 'Maria')->get()                           
=> Illuminate\Database\Eloquent\Collection {#4999
     all: [
       App\Models\SiteContato {#5001
         id: 2,
         nome: "Maria",
         telefone: "98998887777",
         email: "maria@gmail.com",
         motivo_contato: 2,
         mensagem: "tudo ok..",
         created_at: "2022-10-30 19:40:45",
         updated_at: "2022-10-30 19:40:45",
       },
     ],
   }
   >>> $contatos = SiteContato::where('email', 'like', '%gmail%')->get()                
=> Illuminate\Database\Eloquent\Collection {#4998
     all: [
       App\Models\SiteContato {#5009
         id: 1,
         nome: "Alberto",
         telefone: "98981188434",
         email: "albertoogmesdasilva@gmail.com",
         motivo_contato: 1,
         mensagem: "Olá. Gostaria de maiores detalhes..",
         created_at: "2022-10-30 19:34:37",
         updated_at: "2022-10-30 19:34:37",
       },
       App\Models\SiteContato {#5016
         id: 2,
         nome: "Maria",
         telefone: "98998887777",
         email: "maria@gmail.com",
         motivo_contato: 2,
         mensagem: "tudo ok..",
         created_at: "2022-10-30 19:40:45",
         updated_at: "2022-10-30 19:40:45",
       },
     ],
   }

### WHEREIN => É UMA COMPARAÇÃO POR IGUALDADE
>php artisan tinker
Psy Shell v0.11.8 (PHP 8.1.11 — cli) by Justin Hileman
>>> $contato = SiteContato::whereIn('motivo_contato', [1, 3])                                                                          
[!] Aliasing 'SiteContato' to 'App\Models\SiteContato' for this Tinker session.
=> Illuminate\Database\Eloquent\Builder {#3683}

>>> $contato = SiteContato::whereIn('motivo_contato', [1, 3])->get()

=> Illuminate\Database\Eloquent\Collection {#4633
     all: [
       App\Models\SiteContato {#4635
         id: 1,
         nome: "Alberto",
         telefone: "98981188434",
         email: "albertoogmesdasilva@gmail.com",
         motivo_contato: 1,
         mensagem: "Olá. Gostaria de maiores detalhes..",
         created_at: "2022-10-30 19:34:37",
         updated_at: "2022-10-30 19:34:37",
       },
       App\Models\SiteContato {#4636
         id: 3,
         nome: "João",
         telefone: "(88) 91111-2222",
         email: "joao@contato.com.br",
         motivo_contato: 3,
         mensagem: "É muito difícil localizar a opção de listar todos os produtos",
         created_at: null,
         updated_at: null,
       },
       App\Models\SiteContato {#4637
         id: 4,
         nome: "Rosa",
         telefone: "(33) 92222-3333",
         email: "rosa@contato.com.br",
         motivo_contato: 1,
         mensagem: "Quando custa essa aplicação?",
         created_at: null,
         updated_at: null,
       },
       App\Models\SiteContato {#3684
         id: 5,
         nome: "Fernando",
         telefone: "(11) 94444-5555",
         email: "fernando@contato.com.br",
         motivo_contato: 1,
         mensagem: "Como consigo criar multiplos usuários para minha empresa?",
         created_at: null,
         updated_at: null,
       },
       App\Models\SiteContato {#4640
         id: 7,
         nome: "Ana",
     ],
   }

### WHERE NOTIN => COMPARAÇÃO POR DIFERENÇA

* É possível passar quantos parâmetros forem necessários, basta separar os parâmetros por vírgula.
* O In e NotIn suportam comparações com valores numéricos, strings e datas.

>>> $contatos = SiteContato::whereNotIn('motivo_contato', [1,3])->get()                           
[!] Aliasing 'SiteContato' to 'App\Models\SiteContato' for this Tinker session.
=> Illuminate\Database\Eloquent\Collection {#4017
     all: [
       App\Models\SiteContato {#4633
         id: 2,
         nome: "Maria",
         telefone: "98998887777",
         email: "maria@gmail.com",
         motivo_contato: 2,
         mensagem: "tudo ok..",
         created_at: "2022-10-30 19:40:45",
         updated_at: "2022-10-30 19:40:45",
       },
       App\Models\SiteContato {#4634
         id: 6,
         nome: "André",
         telefone: "(88) 95555-6666",
         email: "andre@contato.com.br",
         motivo_contato: 2,
         mensagem: "Parabéns pela ferramenta, estou obtendo ótimos resultados!",
         created_at: null,
         updated_at: null,
       },
       App\Models\SiteContato {#4635
         id: 8,
         nome: "Helena",
         telefone: "(11) 97777-8888",
         email: "helena@contato.com.br",
         motivo_contato: 2,
         mensagem: "Consigo controlar toda a minha empresa de modo fácil e prático.",
         created_at: null,
         updated_at: null,
       },
     ],
   }

>>> $contatos = SiteContato::whereNotIn('created_at', ['2022-10-30 19:40:45','2022-10-30 19:40:45'
])->get()                                                                                         
=> Illuminate\Database\Eloquent\Collection {#3694
     all: [
       App\Models\SiteContato {#3685
         id: 1,
         nome: "Alberto",
         telefone: "98981188434",
         email: "albertoogmesdasilva@gmail.com",
         motivo_contato: 1,
         mensagem: "Olá. Gostaria de maiores detalhes..",
         created_at: "2022-10-30 19:34:37",
         updated_at: "2022-10-30 19:34:37",
       },
     ],
   }

### COMPARAÇÃO POR: ESTÁ ENTRE E INCLUSIVE:
* Pode ser usado tanto para números quanto para datas
- O EXEMPLO A SEGUIR RETORNARÁ OS ID's 3,4,5,6:
>>> $res = SiteContato::whereBetween('id', [3, 6])->get()                                         
=> Illuminate\Database\Eloquent\Collection {#4420
     all: [
       App\Models\SiteContato {#3684
         id: 3,
         nome: "João",
         telefone: "(88) 91111-2222",
         email: "joao@contato.com.br",
         motivo_contato: 3,
         mensagem: "É muito difícil localizar a opção de listar todos os produtos",
         created_at: null,
         updated_at: null,
       },
       App\Models\SiteContato {#3693
         id: 4,
         nome: "Rosa",
         telefone: "(33) 92222-3333",
         email: "rosa@contato.com.br",
         motivo_contato: 1,
         mensagem: "Quando custa essa aplicação?",
         created_at: null,
         updated_at: null,
       },
       App\Models\SiteContato {#4017
         id: 5,
         nome: "Fernando",
         telefone: "(11) 94444-5555",
         email: "fernando@contato.com.br",
         motivo_contato: 1,
         mensagem: "Como consigo criar multiplos usuários para minha empresa?",
         created_at: null,
         updated_at: null,
       },
       App\Models\SiteContato {#4633
         id: 6,
         nome: "André",
         telefone: "(88) 95555-6666",
         email: "andre@contato.com.br",
         motivo_contato: 2,
         mensagem: "Parabéns pela ferramenta, estou obtendo ótimos resultados!",
         created_at: null,
         updated_at: null,
       },
     ],
   }

### WHERENOTBETWIN: RETORNARÁ TUDO QUE NÃO ESTÁ ENTRE O RESCPECTIVO INTERVALO E INCLUSIVE:
* Pode ser usado tanto para números quanto para datas
- O EXEMPLO A SEGUIR RETORNARÁ OS ID's 1, 2, 7, 8  EXCLUINDO  3,4,5,6

>>> $res = SiteContato::whereNotBetween('id', [3, 6])->get()                                      
=> Illuminate\Database\Eloquent\Collection {#4640
     all: [
       App\Models\SiteContato {#4636
         id: 1,
         nome: "Alberto",
         telefone: "98981188434",
         email: "albertoogmesdasilva@gmail.com",
         motivo_contato: 1,
         mensagem: "Olá. Gostaria de maiores detalhes..",
         created_at: "2022-10-30 19:34:37",
         updated_at: "2022-10-30 19:34:37",
       },
       App\Models\SiteContato {#4635
         id: 2,
         nome: "Maria",
         telefone: "98998887777",
         email: "maria@gmail.com",
         motivo_contato: 2,
         mensagem: "tudo ok..",
         created_at: "2022-10-30 19:40:45",
         updated_at: "2022-10-30 19:40:45",
       },
       App\Models\SiteContato {#4641
         id: 7,
         nome: "Ana",
         telefone: "(33) 96666-7777",
         email: "ana@contato.com.br",
         motivo_contato: 3,
         mensagem: "Não gostei muito das cores, consigo mudar de tema?",
         created_at: null,
         updated_at: null,
       },
       App\Models\SiteContato {#4651
         id: 8,
         nome: "Helena",
         telefone: "(11) 97777-8888",
         email: "helena@contato.com.br",
         motivo_contato: 2,
         mensagem: "Consigo controlar toda a minha empresa de modo fácil e prático.",
         created_at: null,
         updated_at: null,
       },
     ],
   }

### SELECIONANDO REGISTROS COM DOIS OU MAIS WHERES - através do objeto query builder do ORM: 
SELECT * FROM site_contatos WHERE nome <> 'Fernando' and motivo_contato in (1,2) and creted_at between '2022-10-21 00:00:00' and '2022-10-31 23:59:59'; -> Esta consulta SQL retorna dois registros.
* Neste caso todas operações precisam ser verdadeiras para que o registro seja retornado.
>>>>>> $contatos = SiteContato::where('nome', '<>', 'Fernando')->whereIn('motivo_contato', [1,2])->w
hereBetween('created_at', ['2022-10-21 00:00:00', '2022-10-31 00:00:00'])->get()                  
[!] Aliasing 'SiteContato' to 'App\Models\SiteContato' for this Tinker session.
=> Illuminate\Database\Eloquent\Collection {#4017
     all: [
       App\Models\SiteContato {#4632
         id: 1,
         nome: "Alberto",
         telefone: "98981188434",
         email: "albertoogmesdasilva@gmail.com",
         motivo_contato: 1,
         mensagem: "Olá. Gostaria de maiores detalhes..",
         created_at: "2022-10-30 19:34:37",
         updated_at: "2022-10-30 19:34:37",
       },
       App\Models\SiteContato {#4633
         id: 2,
         nome: "Maria",
         telefone: "98998887777",
         email: "maria@gmail.com",
         motivo_contato: 2,
         mensagem: "tudo ok..",
         created_at: "2022-10-30 19:40:45",
         updated_at: "2022-10-30 19:40:45",
       },
     ],
   }

>>>                    

### SELECIONANDO REGISTROS COM DOIS OU MAIS ORWHERES - através do objeto query builder do ORM:    
SELECT * FROM site_contatos WHERE nome <> 'Fernando' or motivo_contato in (1,2) or creted_at between '2022-10-21 00:00:00' and '2022-10-31 23:59:59';
* Neste caso apenas uma das operações precisa ser verdadeira para que o registro seja retornado.
>>>  $contatos = SiteContato::where('nome', '<>', 'Fernando')->orwhereIn('motivo_contato', [1,2])-
>orwhereBetween('created_at', ['2022-10-21 00:00:00', '2022-10-31 00:00:00'])->get()              
=> Illuminate\Database\Eloquent\Collection {#4632
     all: [
       App\Models\SiteContato {#4421
         id: 1,
         nome: "Alberto",
         telefone: "98981188434",
         email: "albertoogmesdasilva@gmail.com",
         motivo_contato: 1,
         mensagem: "Olá. Gostaria de maiores detalhes..",
         created_at: "2022-10-30 19:34:37",
         updated_at: "2022-10-30 19:34:37",
       },
       App\Models\SiteContato {#3681
         id: 2,
         nome: "Maria",
         telefone: "98998887777",
         email: "maria@gmail.com",
         motivo_contato: 2,
         mensagem: "tudo ok..",
         created_at: "2022-10-30 19:40:45",
         updated_at: "2022-10-30 19:40:45",
       },
       App\Models\SiteContato {#4649
         id: 3,
         nome: "João",
         telefone: "(88) 91111-2222",
         email: "joao@contato.com.br",
         motivo_contato: 3,
         mensagem: "É muito difícil localizar a opção de listar todos os produtos",
         created_at: null,
         updated_at: null,
       },
       App\Models\SiteContato {#4650
         id: 4,
         nome: "Rosa",
         telefone: "(33) 92222-3333",
         email: "rosa@contato.com.br",
         motivo_contato: 1,
         mensagem: "Quando custa essa aplicação?",
         created_at: null,
         updated_at: null,
       },
       App\Models\SiteContato {#4651
         id: 5,
         nome: "Fernando",
         telefone: "(11) 94444-5555",
         email: "fernando@contato.com.br",
         motivo_contato: 1,
         mensagem: "Como consigo criar multiplos usuários para minha empresa?",
         created_at: null,
         updated_at: null,
       },
       App\Models\SiteContato {#4652
         id: 6,
         nome: "André",
         telefone: "(88) 95555-6666",
         email: "andre@contato.com.br",
         motivo_contato: 2,
         mensagem: "Parabéns pela ferramenta, estou obtendo ótimos resultados!",
         created_at: null,
         updated_at: null,
       },
       App\Models\SiteContato {#4653
         id: 7,
         nome: "Ana",
         telefone: "(33) 96666-7777",
         email: "ana@contato.com.br",
         motivo_contato: 3,
         mensagem: "Não gostei muito das cores, consigo mudar de tema?",
         created_at: null,
       },
     ],
   }

>>>Podemos ter:
* OBS.: orWhere, orWhereIn, orWhereNotIn, orWhereBetween ou orWhereNotBetween se não informarmos o 'or' o operador será o 'and' 
where->

### WHRENULL e WHERENOTNULL
SELECT * FROM site_contatos WHERE updated_at is null;  (null <> vazio)
SELECT * FROM site_contatos WHERE updated_at is not null;
SELECT * FROM site_contatos WHERE updated_at is null;

>>> $contatos = SiteContato::whereNull('updated_at')->get();                                      
=> Illuminate\Database\Eloquent\Collection {#4638
     all: [
       App\Models\SiteContato {#4640
         id: 3,
         nome: "João",
         telefone: "(88) 91111-2222",
         email: "joao@contato.com.br",
         motivo_contato: 3,
         mensagem: "É muito difícil localizar a opção de listar todos os produtos",
         created_at: null,
         updated_at: null,
       },
       App\Models\SiteContato {#4641
         id: 4,
         nome: "Rosa",
         telefone: "(33) 92222-3333",
         email: "rosa@contato.com.br",
         motivo_contato: 1,
         mensagem: "Quando custa essa aplicação?",
         created_at: null,
         updated_at: null,
       },
       App\Models\SiteContato {#4642
         id: 5,
         nome: "Fernando",
         telefone: "(11) 94444-5555",
         email: "fernando@contato.com.br",
         motivo_contato: 1,
         mensagem: "Como consigo criar multiplos usuários para minha empresa?",
         created_at: null,
         updated_at: null,
       },
       App\Models\SiteContato {#4643
         id: 6,
         nome: "André",
         telefone: "(88) 95555-6666",
         email: "andre@contato.com.br",
         motivo_contato: 2,
         mensagem: "Parabéns pela ferramenta, estou obtendo ótimos resultados!",
         created_at: null,
         updated_at: null,
       },
       App\Models\SiteContato {#4644
         id: 7,
         nome: "Ana",
         telefone: "(33) 96666-7777",
         email: "ana@contato.com.br",
         motivo_contato: 3,
         mensagem: "Não gostei muito das cores, consigo mudar de tema?",
         created_at: null,
         updated_at: null,
       },
       App\Models\SiteContato {#4645
         id: 8,
         nome: "Helena",
         telefone: "(11) 97777-8888",
         email: "helena@contato.com.br",
         motivo_contato: 2,
         mensagem: "Consigo controlar toda a minha empresa de modo fácil e prático.",
         created_at: null,
         updated_at: null,
       },
     ],
   }

### NOTNULL
>>> $contatos = SiteContato::whereNotNull('updated_at')->get();                                   
=> Illuminate\Database\Eloquent\Collection {#4646
     all: [
       App\Models\SiteContato {#4637
         id: 1,
         nome: "Alberto",
         telefone: "98981188434",
         email: "albertoogmesdasilva@gmail.com",
         motivo_contato: 1,
         mensagem: "Olá. Gostaria de maiores detalhes..",
         created_at: "2022-10-30 19:34:37",
         updated_at: "2022-10-30 19:34:37",
       },
       App\Models\SiteContato {#3682
         id: 2,
         nome: "Maria",
         telefone: "98998887777",
         email: "maria@gmail.com",
         motivo_contato: 2,
         mensagem: "tudo ok..",
         created_at: "2022-10-30 19:40:45",
         updated_at: "2022-10-30 19:40:45",
       },
     ],
   }

>>> $contatos = SiteContato::whereNotNull('updated_at')->orWhereNull('created_at')->get();        
=> Illuminate\Database\Eloquent\Collection {#4637
     all: [
       App\Models\SiteContato {#4641
         id: 1,
         nome: "Alberto",
         telefone: "98981188434",
         email: "albertoogmesdasilva@gmail.com",
         motivo_contato: 1,
         mensagem: "Olá. Gostaria de maiores detalhes..",
         created_at: "2022-10-30 19:34:37",
         updated_at: "2022-10-30 19:34:37",
       },
       App\Models\SiteContato {#4658
         id: 2,
         nome: "Maria",
         telefone: "98998887777",
         email: "maria@gmail.com",
         motivo_contato: 2,
         mensagem: "tudo ok..",
         created_at: "2022-10-30 19:40:45",
         updated_at: "2022-10-30 19:40:45",
       },
       App\Models\SiteContato {#4659
         id: 3,
         nome: "João",
         telefone: "(88) 91111-2222",
         email: "joao@contato.com.br",
         motivo_contato: 3,
         mensagem: "É muito difícil localizar a opção de listar todos os produtos",
         created_at: null,
         updated_at: null,
       },
       App\Models\SiteContato {#4660
         id: 4,
         nome: "Rosa",
         telefone: "(33) 92222-3333",
         email: "rosa@contato.com.br",
         motivo_contato: 1,
         mensagem: "Quando custa essa aplicação?",
         created_at: null,
         updated_at: null,
       },
       App\Models\SiteContato {#4661
         id: 5,
         nome: "Fernando",
         telefone: "(11) 94444-5555",
         email: "fernando@contato.com.br",
         motivo_contato: 1,
         mensagem: "Como consigo criar multiplos usuários para minha empresa?",
         created_at: null,
         updated_at: null,
       },
       App\Models\SiteContato {#4662
         id: 6,
         nome: "André",
         telefone: "(88) 95555-6666",
         email: "andre@contato.com.br",
         motivo_contato: 2,
         mensagem: "Parabéns pela ferramenta, estou obtendo ótimos resultados!",
         created_at: null,
         updated_at: null,
       },
       App\Models\SiteContato {#4663
         id: 7,
         nome: "Ana",
         telefone: "(33) 96666-7777",
         email: "ana@contato.com.br",
         motivo_contato: 3,
         mensagem: "Não gostei muito das cores, consigo mudar de tema?",
         created_at: null,
         updated_at: null,
       },
       App\Models\SiteContato {#4664
         id: 8,
         nome: "Helena",
         telefone: "(11) 97777-8888",
         email: "helena@contato.com.br",
         motivo_contato: 2,
         mensagem: "Consigo controlar toda a minha empresa de modo fácil e prático.",
         created_at: null,
         updated_at: null,
       },
     ],
   }

### SELECIONANDO REGISTROS COM BASE EM PARÂMETROS DO TIPO DATA E HORA
### WHEREDATE
o>php artisan tinker
Psy Shell v0.11.8 (PHP 8.1.11 — cli) by Justin Hileman
>>> $contatos = SiteContato::whereDate('created_at', '2022-10-30')->get()                         
[!] Aliasing 'SiteContato' to 'App\Models\SiteContato' for this Tinker session.
=> Illuminate\Database\Eloquent\Collection {#4418
     all: [
       App\Models\SiteContato {#4630
         id: 1,
         nome: "Alberto",
         telefone: "98981188434",
         email: "albertoogmesdasilva@gmail.com",
         motivo_contato: 1,
         mensagem: "Olá. Gostaria de maiores detalhes..",
         created_at: "2022-10-30 19:34:37",
         updated_at: "2022-10-30 19:34:37",
       },
       App\Models\SiteContato {#4631
         id: 2,
         nome: "Maria",
         telefone: "98998887777",
         email: "maria@gmail.com",
         motivo_contato: 2,
         mensagem: "tudo ok..",
         created_at: "2022-10-30 19:40:45",
         updated_at: "2022-10-30 19:40:45",
       },
     ],
   }

### WHEREDAY
>>> $contatos = SiteContato::whereDay('created_at', '30')->get()                                  
=> Illuminate\Database\Eloquent\Collection {#4639
     all: [
       App\Models\SiteContato {#4637
         id: 1,
         nome: "Alberto",
         telefone: "98981188434",
         email: "albertoogmesdasilva@gmail.com",
         motivo_contato: 1,
         mensagem: "Olá. Gostaria de maiores detalhes..",
         created_at: "2022-10-30 19:34:37",
         updated_at: "2022-10-30 19:34:37",
       },
       App\Models\SiteContato {#4636
         id: 2,
         nome: "Maria",
         telefone: "98998887777",
         email: "maria@gmail.com",
         motivo_contato: 2,
         mensagem: "tudo ok..",
         created_at: "2022-10-30 19:40:45",
         updated_at: "2022-10-30 19:40:45",
       },
     ],
   }

### WHEREMONTH
>>> $contatos = SiteContato::whereMonth('created_at', '10')->get()                                
=> Illuminate\Database\Eloquent\Collection {#4417
     all: [
       App\Models\SiteContato {#4484
         id: 1,
         nome: "Alberto",
         telefone: "98981188434",
         email: "albertoogmesdasilva@gmail.com",
         motivo_contato: 1,
         mensagem: "Olá. Gostaria de maiores detalhes..",
         created_at: "2022-10-30 19:34:37",
         updated_at: "2022-10-30 19:34:37",
       },
       App\Models\SiteContato {#3683
         id: 2,
         nome: "Maria",
         telefone: "98998887777",
         email: "maria@gmail.com",
         motivo_contato: 2,
         mensagem: "tudo ok..",
         created_at: "2022-10-30 19:40:45",
         updated_at: "2022-10-30 19:40:45",
       },
     ],
   }

### WHEREYEAR
>> $contatos = SiteContato::whereYear('created_at', '2022')->get()                               
=> Illuminate\Database\Eloquent\Collection {#4639
     all: [
       App\Models\SiteContato {#4640
         id: 1,
         nome: "Alberto",
         telefone: "98981188434",
         email: "albertoogmesdasilva@gmail.com",
         motivo_contato: 1,
         mensagem: "Olá. Gostaria de maiores detalhes..",
         created_at: "2022-10-30 19:34:37",
         updated_at: "2022-10-30 19:34:37",
       },
       App\Models\SiteContato {#4641
         id: 2,
         nome: "Maria",
         telefone: "98998887777",
         email: "maria@gmail.com",
         motivo_contato: 2,
         mensagem: "tudo ok..",
         created_at: "2022-10-30 19:40:45",
         updated_at: "2022-10-30 19:40:45",
       },
     ],
   }

>>> $contatos = SiteContato::whereTime('created_at', '19:40:45')->get()                           
=> Illuminate\Database\Eloquent\Collection {#3676
     all: [
       App\Models\SiteContato {#3687
         id: 2,
         nome: "Maria",
         telefone: "98998887777",
         email: "maria@gmail.com",
         motivo_contato: 2,
         mensagem: "tudo ok..",
         created_at: "2022-10-30 19:40:45",
         updated_at: "2022-10-30 19:40:45",
       },
     ],
   }

>>> $contatos = SiteContato::whereTime('created_at', '<>', '19:40:45')->get()                     
=> Illuminate\Database\Eloquent\Collection {#4639
     all: [
       App\Models\SiteContato {#3676
         id: 1,
         nome: "Alberto",
         telefone: "98981188434",
         email: "albertoogmesdasilva@gmail.com",
         motivo_contato: 1,
         mensagem: "Olá. Gostaria de maiores detalhes..",
         created_at: "2022-10-30 19:34:37",
         updated_at: "2022-10-30 19:34:37",
       },
     ],
   }

>>> $contatos = SiteContato::whereTime('created_at', '<>', '19:40:45')->get()                     
=> Illuminate\Database\Eloquent\Collection {#4639
     all: [
       App\Models\SiteContato {#3676
         id: 1,
         nome: "Alberto",
         telefone: "98981188434",
         email: "albertoogmesdasilva@gmail.com",
         motivo_contato: 1,
         mensagem: "Olá. Gostaria de maiores detalhes..",
         created_at: "2022-10-30 19:34:37",
         updated_at: "2022-10-30 19:34:37",
       },
     ],
   }

### ELOQUENT - SELECIONANDO REGISTROS COM WHERECOLUMN(): Filtra registros comparando valores de colunas do mesmo registro.
-> Trará registros onde 'created_at' e 'updated_at' com valores iguais
### passando apenas dois parâmetros significa ter subtendido o perador de igauldade:
>>> $contato = SiteContato::whereColumn('created_at', 'updated_at')->get();                       
[!] Aliasing 'SiteContato' to 'App\Models\SiteContato' for this Tinker session.
=> Illuminate\Database\Eloquent\Collection {#4383
     all: [
       App\Models\SiteContato {#4636
         id: 1,
         nome: "Alberto",
         telefone: "98981188434",
         email: "albertoogmesdasilva@gmail.com",
         motivo_contato: 1,
         mensagem: "Olá. Gostaria de maiores detalhes..",
         created_at: "2022-10-30 19:34:37",
         updated_at: "2022-10-30 19:34:37",
       },
       App\Models\SiteContato {#4637
         id: 2,
         nome: "Maria",
         telefone: "98998887777",
         email: "maria@gmail.com",
         motivo_contato: 2,
         mensagem: "tudo ok..",
         created_at: "2022-10-30 19:40:45",
         updated_at: "2022-10-30 19:40:45",
       },
     ],
   }

   >>> $contato = SiteContato::whereColumn('created_at', 'updated_at')->get();                       
[!] Aliasing 'SiteContato' to 'App\Models\SiteContato' for this Tinker session.
=> Illuminate\Database\Eloquent\Collection {#4383
     all: [
       App\Models\SiteContato {#4636
         id: 1,
         nome: "Alberto",
         telefone: "98981188434",
         email: "albertoogmesdasilva@gmail.com",
         motivo_contato: 1,
         mensagem: "Olá. Gostaria de maiores detalhes..",
         created_at: "2022-10-30 19:34:37",
         updated_at: "2022-10-30 19:34:37",
       },
       App\Models\SiteContato {#4637
         id: 2,
         nome: "Maria",
         telefone: "98998887777",
         email: "maria@gmail.com",
         motivo_contato: 2,
         mensagem: "tudo ok..",
         created_at: "2022-10-30 19:40:45",
         updated_at: "2022-10-30 19:40:45",
       },
     ],
   }

### ELOQUENT - SELECIONANDO REGISTROS COM WHERECOLUMN() -> Suporta 3 parâmetros, podemos usar o operador:
>>> $contact = SiteContato::whereColumn('created_at', '<>', 'updated_at')->get();                                                             
=> Illuminate\Database\Eloquent\Collection {#3676
     all: [
       App\Models\SiteContato {#3682
         id: 2,
         nome: "Maria",
         telefone: "98998887777",
         email: "maria@gmail.com",
         motivo_contato: 2,
         mensagem: "tudo ok..",
         created_at: "2022-10-31 19:40:45",
         updated_at: "2022-10-30 19:40:45",
       },
     ],
   }

   >>> $contact = SiteContato::where('id', '>', 1)->whereColumn('created_at', '>=', 'updated_at')->get();                                        
=> Illuminate\Database\Eloquent\Collection {#4647
     all: [
       App\Models\SiteContato {#4645
         id: 2,
         nome: "Maria",
         telefone: "98998887777",
         email: "maria@gmail.com",
         motivo_contato: 2,
         mensagem: "tudo ok..",
         created_at: "2022-10-31 19:40:45",
         updated_at: "2022-10-30 19:40:45",
       },
     ],
   }

### SELECIONANDO REGISTROS APLICANDO PRECEDÊNCIAS EM OPERAÇÕES LÓGICAS

SELECT * FROM site_contatos WHERE (nome = 'Jorge' OR nome = 'Ana') and (motivo_contato in (1, 2) or id between 4 and 7); ==> Resulta o registro de id=7 (Ana).



SELECT * FROM site_contatos WHERE nome = 'Jorge' OR nome 'Ana' and (motivo_contato in (1, 2) or id between 4 and 7;  ===> Resulta os registros 4, 5, 6 e 7 ( Rosa, Fernando, André e Ana).

>>> $contatos = SiteContato::where(function($query){ $query->where('nome', 'Jorge')->orWhere('nome', 'Ana'); })->where(function($query){ $query->whereIn('motivo_contato', [1, 2])->orWhereBeteen('id', [4, 7]); })->get();                                                           
BadMethodCallException with message 'Call to undefined method Illuminate\Database\Eloquent\Builder::orWhereBeteen()'
>>> $contatos = SiteContato::where(function($query){ $query->where('nome', 'Jorge')->orWhere('nome', 'Ana'); })->where(function($query){ $q
uery->whereIn('motivo_contato', [1, 2])->orWhereBetween('id', [4, 7]); })->get();                                                          
=> Illuminate\Database\Eloquent\Collection {#4652
     all: [
       App\Models\SiteContato {#4643
         id: 7,
         nome: "Ana",
         telefone: "(33) 96666-7777",
         email: "ana@contato.com.br",
         motivo_contato: 3,
         mensagem: "Não gostei muito das cores, consigo mudar de tema?",
         created_at: null,
         updated_at: null,
       },
     ],
   }
### ELOQUENT - ORDENANDO REGISTROS -> A ordenação pode ser feita com base em uma coluna podendo ser ascendente ou descendente, e é possível também combinar várias ordenações, ou seja, primeiro ordenamos com base em uma coluna e com base nesse resultado utilizamos uma segunda coluna para ordenação e assim consecutivamente de modo encadeado.

- $contatos = SiteContato::all();    -> o método all() exibe tudo;
- $contatos = SiteContato::orderBy('nome', 'asc')->get();  -> Ordena por nome (padrão é ascendente se não passar o segundo parâmetro 'asc');
- $contatos = SiteContato::orderBy('nome', 'desc')->get();
- $contatos = SiteContato::orderBy('motivo_contato')->orderBy('nome', 'asc')->get();

### FILTROS E ORDENAÇÃO:
>>> $contatos = SiteContato::whereBetween('id', [2,4])->orderBy('motivo_contato')->orderBy('nome','desc')->get();                          
=> Illuminate\Database\Eloquent\Collection {#4630
     all: [
       App\Models\SiteContato {#4638
         id: 4,
         nome: "Rosa",
         telefone: "(33) 92222-3333",
         email: "rosa@contato.com.br",
         motivo_contato: 1,
         mensagem: "Quando custa essa aplicação?",
         created_at: null,
         updated_at: null,
       },
       App\Models\SiteContato {#4642
         id: 2,
         nome: "Maria",
         telefone: "98998887777",
         email: "maria@gmail.com",
         motivo_contato: 2,
         mensagem: "tudo ok..",
         created_at: "2022-10-31 19:40:45",
         updated_at: "2022-10-30 19:40:45",
       },
       App\Models\SiteContato {#3685
         id: 3,
         nome: "João",
         telefone: "(88) 91111-2222",
         email: "joao@contato.com.br",
         motivo_contato: 3,
         mensagem: "É muito difícil localizar a opção de listar todos os produtos",
         created_at: null,
         updated_at: null,
       },
     ],
   }

### ELOQUENT ORM -> COLLECTIONS: (laravel.com/docs/8.x/collections) - Available Methods(Métodos disponíveis) -> Quando estamos construindo uma Query nós temos um objeto do tipo 'Builder', no instante em que executamos o método 'get' nós recuperamos com base na query que foi construída um objeto do tipo 'collection', a partir de um objeto do tipo collection podemo aplicar sobre esse objeto os métodos que são nativos dele:
>>> $resultado = SiteContato::where('id', '>', 5)       
=> Illuminate\Database\Eloquent\Builder {#4377}  ==> Objeto do tipo Builder
>>>                             
=> Illuminate\Database\Eloquent\Collection {#4654
     all: [
       App\Models\SiteContato {#4657
         id: 6,
         nome: "André",
         telefone: "(88) 95555-6666",
         email: "andre@contato.com.br",
         motivo_contato: 2,
         mensagem: "Parabéns pela ferramenta, estou obtendo ótimos resultados!",
         created_at: null,
         updated_at: null,
       },
       App\Models\SiteContato {#4653
         id: 7,
         nome: "Ana",
         telefone: "(33) 96666-7777",
         email: "ana@contato.com.br",
         motivo_contato: 3,
         mensagem: "Não gostei muito das cores, consigo mudar de tema?",
         created_at: null,
         updated_at: null,
       },
       App\Models\SiteContato {#4015
         id: 8,
         nome: "Helena",
         telefone: "(11) 97777-8888",
         email: "helena@contato.com.br",
         motivo_contato: 2,
         mensagem: "Consigo controlar toda a minha empresa de modo fácil e prático.",
         created_at: null,
         updated_at: null,
       },
     ],
   }

>>> $resultado->get()  ==> Obtenho uma coleção                                         
* first, last e reverse: 
>>> $resultador->first()  => Retorna o primeiro elemento
>>> $resultador->last()  => Retorna o último elemento
>>> $resultador->reverse() => Inverte a ordem na exibição

### ELOQUENT = COLLECTION TO ARRAY E TO JSON  => Convertem uma coleção de objetos para um array e para um json respectivamente:
$resultado = SiteContato::all()   -> Retorna uma collection
>>> $resultado = SiteContato::all()->toArray()  -> A Collection é convertida para um objeto do tipo Array. Quando é feita essa conversão os métodos estáticos de uma coleção, todos os métodos nativos nativos não se aplicam aqui.
=> [
     [
       "id" => 1,
       "nome" => "Alberto",
       "telefone" => "98981188434",
       "email" => "albertoogmesdasilva@gmail.com",
       "motivo_contato" => 1,
       "mensagem" => "Olá. Gostaria de maiores detalhes..",
       "created_at" => "2022-10-30T19:34:37.000000Z",
       "updated_at" => "2022-10-30T19:34:37.000000Z",
     ],
     [
       "id" => 2,
       "nome" => "Maria",
       "telefone" => "98998887777",
       "email" => "maria@gmail.com",
       "motivo_contato" => 2,
       "mensagem" => "tudo ok..",
       "created_at" => "2022-10-31T19:40:45.000000Z",
       "updated_at" => "2022-10-30T19:40:45.000000Z",
     ],
     [
       "id" => 3,
       "nome" => "João",
       "telefone" => "(88) 91111-2222",
       "email" => "joao@contato.com.br",
       "motivo_contato" => 3,
       "mensagem" => "É muito difícil localizar a opção de listar todos os produtos",
       "created_at" => null,
       "updated_at" => null,
     ],
     [
       "id" => 4,
       "nome" => "Rosa",
       "telefone" => "(33) 92222-3333",
       "email" => "rosa@contato.com.br",
       "motivo_contato" => 1,
       "mensagem" => "Quando custa essa aplicação?",
       "created_at" => null,
       "updated_at" => null,
     ],
     [
       "id" => 5,
       "nome" => "Fernando",
       "telefone" => "(11) 94444-5555",
       "email" => "fernando@contato.com.br",
       "motivo_contato" => 1,
       "mensagem" => "Como consigo criar multiplos usuários para minha empresa?",
       "created_at" => null,
       "updated_at" => null,
     ],
     [
       "id" => 6,
       "nome" => "André",
       "telefone" => "(88) 95555-6666",
       "email" => "andre@contato.com.br",
       "motivo_contato" => 2,
       "mensagem" => "Parabéns pela ferramenta, estou obtendo ótimos resultados!",
       "created_at" => null,
       "updated_at" => null,
     ],
     [
       "id" => 7,
       "nome" => "Ana",
       "telefone" => "(33) 96666-7777",
       "email" => "ana@contato.com.br",
       "motivo_contato" => 3,
       "mensagem" => "Não gostei muito das cores, consigo mudar de tema?",
       "created_at" => null,
       "updated_at" => null,
     ],
     [
       "id" => 8,
       "nome" => "Helena",
       "telefone" => "(11) 97777-8888",
       "email" => "helena@contato.com.br",
       "motivo_contato" => 2,
       "mensagem" => "Consigo controlar toda a minha empresa de modo fácil e prático.",
       "created_at" => null,
       "updated_at" => null,
     ],
   ]
### Convertendo a coleção para Json:
>>>>>> $resultado = SiteContato::all()->toJson()
=> "[{"id":1,"nome":"Alberto","telefone":"98981188434","email":"albertoogmesdasilva@gmail.com","motivo_contato":1,"mensagem":"Ol\u00e1. Gostaria de maiores detalhes..","created_at":"2022-10-30T19:34:37.000000Z","updated_at":"2022-10-30T19:34:37.000000Z"},{"id":2,"nome":"Maria","telefone":"98998887777","email":"maria@gmail.com","motivo_contato":2,"mensagem":"tudo ok..","created_at":"2022-10-31T19:40:45.000000Z","updated_at":"2022-10-30T19:40:45.000000Z"},{"id":3,"nome":"Jo\u00e3o","telefone":"(88) 91111-2222","email":"joao@contato.com.br","motivo_contato":3,"mensagem":"\u00c9 muito dif\u00edcil localizar a op\u00e7\u00e3o de listar todos os produtos","created_at":null,"updated_at":null},{"id":4,"nome":"Rosa","telefone":"(33) 92222-3333","email":"rosa@contato.com.br","motivo_contato":1,"mensagem":"Quando custa essa aplica\u00e7\u00e3o?","created_at":null,"updated_at":null},{"id":5,"nome":"Fernando","telefone":"(11) 94444-5555","email":"fernando@contato.com.br","motivo_contato":1,"mensagem":"Como consigo criar multiplos usu\u00e1rios para minha empresa?","created_at":null,"updated_at":null},{"id":6,"nome":"Andr\u00e9","telefone":"(88) 95555-6666","email":"andre@contato.com.br","motivo_contato":2,"mensagem":"Parab\u00e9ns pela ferramenta, estou obtendo \u00f3timos resultados!","created_at":null,"updated_at":null},{"id":7,"nome":"Ana","telefone":"(33) 96666-7777","email":"ana@contato.com.br","motivo_contato":3,"mensagem":"N\u00e3o gostei muito das cores, consigo mudar de tema?","created_at":null,"updated_at":null},{"id":8,"nome":"Helena","telefone":"(11) 97777-8888","email":"helena@contato.com.br","motivo_contato":2,"mensagem":"Consigo controlar toda a minha empresa de modo f\u00e1cil e pr\u00e1tico.","created_at":null,"updated_at":null}]"

### PLUCK -> Permite recuperar todos os valores de uma determinada chave. por exemplo: todos os emails, a partir daí combinar com outros métodos:
>>> SiteContato::all()->pluck('email')         
=> Illuminate\Support\Collection {#4657
     all: [
       "albertoogmesdasilva@gmail.com",
       "maria@gmail.com",
       "joao@contato.com.br",
       "rosa@contato.com.br",
       "fernando@contato.com.br",
       "andre@contato.com.br",
       "ana@contato.com.br",
       "helena@contato.com.br",
     ],
   }

>>> SiteContato::all()->pluck('email')->first() 
=> "albertoogmesdasilva@gmail.com"

* OBS.: APÓS CONVERTER EM ARRAY NÃO POSSO CHAMAR OUTROS MÉTODOS NATIVOS, SOMENTE ENQUANTO FOR UMA COLLECTION POSSO ENCADEAR MÉTODOS.

>>> SiteContato::all()->pluck('email')->toArray()->first()
PHP Error:  Call to a member function first() on array in C:\Users\alber\Desktop\PHP E LARAVEL-9eval()'d code on line 1

>>> SiteContato::all()->pluck('email')->reverse()->first()
=> "helena@contato.com.br"

### ATRIBUINDO UMA CHAVE PARA A CONSULTA
>>> SiteContato::all()->pluck('email', 'nome')
=> Illuminate\Support\Collection {#4663
     all: [
       "Alberto" => "albertoogmesdasilva@gmail.com",
       "Maria" => "maria@gmail.com",
       "João" => "joao@contato.com.br",
       "Rosa" => "rosa@contato.com.br",
       "Fernando" => "fernando@contato.com.br",
       "André" => "andre@contato.com.br",
       "Ana" => "ana@contato.com.br",
       "Helena" => "helena@contato.com.br",
     ],
   }                                                                                                                                        
### PARA CONHECER UM POUCO MAIS SOBRE OS MÉTODOS NATIVOS DOS OBJETOS COLLECTION
https://laravel.com/docs/8.x/collections

* ex.: >>> SiteContato::all()->pluck('id')                                                                                                        
=> Illuminate\Support\Collection {#5024
     all: [
       1,
       2,
       3,
       4,
       5,
       6,
       7,
       8,
     ],
   }

>>> SiteContato::all()->pluck('id')->sum() 
=> 36

### ATUALIZANDO REGISTROS - save()
>> $res = SiteContato::all()->first()                                                                                                     
=> App\Models\SiteContato {#4647
     id: 1,
     nome: "Alberto",
     telefone: "98981188434",
     email: "albertoogmesdasilva@gmail.com",
     motivo_contato: 1,
     mensagem: "Olá. Gostaria de maiores detalhes..",
     created_at: "2022-10-30 19:34:37",
     updated_at: "2022-10-30 19:34:37",
   }

>>>$res = SiteContato::all()->first()
=> App\Models\SiteContato {#4647
     id: 1,
     nome: "Alberto",
     telefone: "98981188434",
     email: "albertoogmesdasilva@gmail.com",
     motivo_contato: 1,
     mensagem: "Olá. Gostaria de maiores detalhes..",
     created_at: "2022-10-30 19:34:37",
     updated_at: "2022-10-30 19:34:37",
   }

>>> $res -> nome
=> "Alberto"

>>> $res -> nome = 'Adalberto'
=> "Adalberto"
>>> $res->save()
=> true

>>> dd($res)                                                                                                                               
App\Models\SiteContato^ {#4647 // vendor\psy\psysh\src\ExecutionLoopClosure.php(55) : eval()'d code:1
  #connection: "mysql"
  #table: "site_contatos"
  #primaryKey: "id"
  #keyType: "int"
  +incrementing: true
  #with: []
  #withCount: []
  +preventsLazyLoading: false
  #perPage: 15
  +exists: true
  +wasRecentlyCreated: false
  #escapeWhenCastingToString: false
  #attributes: array:8 [
    "id" => 1
    "nome" => "Adalberto"
    "telefone" => "98981188434"
    "email" => "adalberto@gmail.com"
    "motivo_contato" => 1
    "mensagem" => "Olá. Gostaria de maiores detalhes.."
    "created_at" => "2022-10-30 19:34:37"
    "updated_at" => "2022-10-31 20:53:29"
  ]
  #original: array:8 [
    "id" => 1
    "nome" => "Adalberto"
    "telefone" => "98981188434"
    "email" => "adalberto@gmail.com"
    "motivo_contato" => 1
    "mensagem" => "Olá. Gostaria de maiores detalhes.."
    "created_at" => "2022-10-30 19:34:37"
    "updated_at" => "2022-10-31 20:53:29"
  ]
  #changes: array:2 [
    "email" => "adalberto@gmail.com"
    "updated_at" => "2022-10-31 20:53:29"
  ]
  #casts: []
  #classCastCache: []
  #attributeCastCache: []
  #dates: []
  #dateFormat: null
  #appends: []
  #dispatchesEvents: []
  #observables: []
  #relations: []
  #touches: []
  +timestamps: true
  #hidden: []
  #visible: []
  #fillable: []
  #guarded: array:1 [
    0 => "*"
  ]
}

>>> print_r($res)                                                                                                                          
App\Models\SiteContato Object
(
    [connection:protected] => mysql
    [table:protected] => site_contatos
    [primaryKey:protected] => id
    [keyType:protected] => int
    [incrementing] => 1
    [with:protected] => Array
        (
        )

    [withCount:protected] => Array
        (
        )

    [preventsLazyLoading] =>
    [perPage:protected] => 15
    [exists] => 1
    [wasRecentlyCreated] =>
    [escapeWhenCastingToString:protected] =>
    [attributes:protected] => Array
        (
            [id] => 1
            [nome] => Adalberto
            [telefone] => 98981188434
            [email] => adalberto@gmail.com
            [motivo_contato] => 1
            [mensagem] => Olá. Gostaria de maiores detalhes..
            [created_at] => 2022-10-30 19:34:37
            [updated_at] => 2022-10-31 20:53:29
        )

    [original:protected] => Array
        (
            [id] => 1
            [nome] => Adalberto
            [telefone] => 98981188434
            [email] => adalberto@gmail.com
            [motivo_contato] => 1
            [mensagem] => Olá. Gostaria de maiores detalhes..
            [created_at] => 2022-10-30 19:34:37
            [updated_at] => 2022-10-31 20:53:29
        )

    [changes:protected] => Array
        (
        )

    [casts:protected] => Array
        (
        )

    [classCastCache:protected] => Array
        (
        )

    [attributeCastCache:protected] => Array
        (
        )

    [dates:protected] => Array
        (
        )

    [dateFormat:protected] =>
    [appends:protected] => Array
        (
        )

    [dispatchesEvents:protected] => Array
        (
        )

    [observables:protected] => Array
        (
        )

    [relations:protected] => Array
        (
        )

    [touches:protected] => Array
        (
        )

    [timestamps] => 1
    [hidden:protected] => Array
        (
        )

    [visible:protected] => Array
        (
        )

    [fillable:protected] => Array
        (
        )

    [guarded:protected] => Array
        (
            [0] => *
        )

)
=> true
>>> SiteContato::find(1)                                                                                                                   
=> App\Models\SiteContato {#4631
     id: 1,
     nome: "Adalberto",
     telefone: "98981188434",
     email: "adalberto@gmail.com",
     motivo_contato: 1,
     mensagem: "Olá. Gostaria de maiores detalhes..",
     created_at: "2022-10-30 19:34:37",
     updated_at: "2022-10-31 20:53:29",
   }

### ATUALIZANDO REGISTROS fill e save
>>> $res = Fornecedor::find(1)                                                                                                             
[!] Aliasing 'Fornecedor' to 'App\Models\Fornecedor' for this Tinker session.
=> App\Models\Fornecedor {#4646
     id: 1,
     nome: "Fornecedor XYZ",
     site: "https://www.albertogomesdasilva.com.br",
     created_at: "2022-10-30 20:01:42",
     updated_at: "2022-10-30 20:01:42",
     uf: "MA",
=> App\Models\Fornecedor {#4646
     id: 1,
     nome: "AGS - Fornecedores",
     site: "https://www.albertogomesdasilva.com.br",
     created_at: "2022-10-30 20:01:42",
     updated_at: "2022-10-30 20:01:42",
     uf: "MA",
     email: "fornecedorxyz@gmail.com.br",
   }

>>> $res->save()
=> true

### ATUALIZANDO REGISTROS WHERE E UPDATE
>>> Fornecedor::whereIn('id', [1, 2])                                                                                                      
=> Illuminate\Database\Eloquent\Builder {#4639}
>>> Fornecedor::whereIn('id', [1, 2])->get()                                                                                               
=> Illuminate\Database\Eloquent\Collection {#4635
     all: [
       App\Models\Fornecedor {#3681
         id: 1,
         nome: "AGS - Logística",
         site: "http://agslog.com.br",
         created_at: "2022-10-30 20:01:42",
         updated_at: "2022-10-31 21:15:09",
         uf: "MA",
         email: "agslog@gmail.com",
       },
       App\Models\Fornecedor {#4648
         id: 2,
         nome: "Brascopper-SLZ",
         site: "https://brascopper-slz.com.br",
         created_at: "2022-10-30 20:06:03",
         updated_at: "2022-10-30 20:06:03",
         uf: "MA",
         email: "brascopperslz@gmail.com.br",
       },
     ],
   }

>>> Fornecedor::whereIn('id', [1, 2])->update(['nome'=>'Nova Log', 'site'=>'http://nlog.com.br', 'email'=>'nlog@hotmail.com'])             
=> 2

>>> Fornecedor::whereIn('id', [1, 2])->get()                                                                                               
=> Illuminate\Database\Eloquent\Collection {#4418
     all: [
       App\Models\Fornecedor {#4631
         id: 1,
         nome: "Nova Log",
         site: "http://nlog.com.br",
         created_at: "2022-10-30 20:01:42",
         updated_at: "2022-10-31 21:21:31",
         uf: "MA",
         email: "nlog@hotmail.com",
       },
       App\Models\Fornecedor {#4641
         id: 2,
         nome: "Nova Log",
         site: "http://nlog.com.br",
         created_at: "2022-10-30 20:06:03",
         updated_at: "2022-10-31 21:21:31",
         uf: "MA",
         email: "nlog@hotmail.com",
       },
     ],
   }

   >>> Fornecedor::where('id', 1)->update(['nome' => 'AGS - Logística', 'site'=>'http://agslog.com.br', 'email'=>'agslog@gmail.com' ])        
=> 1

### DELETANDO REGISTROS - DELETE E DESTROY
>>> SiteContato::where('id', 1)->delete()
=> 1

>>> SiteContato::find(2)->delete('id', 2)
=> true

>>> $res = SiteContato::find(4)->delete()
=> true
>>> SiteContato::destroy(5)             
=> 1

>>> SiteContato::destroy(7, 8)   
=> 2
# php artisan make:seeder SiteContatoSeeder
# php artisan make:seeder Fornecedor
### SEEDERS (DatabaseSeeder) - (classes conhecidas como sementes) -> Inserindo poucos registros:
- Com o banco de dados completamente limpo vamos começar criando o nosso primeiro seed para popular a tabela 'fornecedores':

### php artisan make:seeder FornecedorSeeder  // Não existe convenção, mais o ideal é colocar no final do nome o nome seeder
# 3 FORMAS DIFERENTES:

FornecedorSeeder.php
<?php

namespace Database\Seeders;

use Illuminate\Database\Console\Seeds\WithoutModelEvents;
use Illuminate\Database\Seeder;

use App\Fornecedor;

class FornecedorSeeder extends Seeder
{
    /**
     * Run the database seeds.
     *
     * @return void
     */
    public function run()
    {
        // MÉTODO 1 DE FAZER -> Instanciando o objeto
        $fornecedor = new Fornecedor;

        $fornecedor->nome = 'Fornecedor 100';
        $fornecedor->site = 'https://fornecedor100.com.br';
        $fornecedor->uf = 'MA';
        $fornecedor->emal = 'fornecedor100@gmail.com';
        $fornecedor->save();

        // MÉTODO 2 DE FAZER => MÉTODO CREATE -> DESTA FORMA NO MODEL Fornecedor.php  DEVE INSERIR A LINHA:
        // protected $fillable = ['nome', 'site', 'uf', 'email'];
        Fornecedor::create([
            'nome'=>'Fornecedor200',
            'site' => 'https://forn200.com.br',
            'uf'=> 'RS',
            'email'=>'forn200@gmail.com'
        ]);

        // MÉTODO 3 -> USANDO O MÉTODO INSERT
        DB::table('fornecedores')->insert([
            'nome'=>'Fornecedor300',
            'site' => 'https://fornec300.com.br',
            'uf'=> 'SP',
            'email'=>'fornec300@hotmail.com'
        ]);
    }
}

# \App\Models\SiteContato::factory(100)->create(); -> esta instrução pode está no DatabaseSeeder.php ou no SiteContatoSeeder.php
# \App\Models\Fornecedor::factory(100)->create(); -> esta instrução pode está no DatabaseSeeder.php ou no FonnecedorSeeder.php;

->  $this->call(FornecedorSeeder::class);
->  $this->call(SiteContatoSeeder::class);
# CONFIGURAR O DatabaseSeeder.php

# para executar a seeder: php artisan db:seed   =>  $this->call(FornecedorSeeder::class);  
# php artisan db:seed -> Executa todas as seeders
# >php artisan db:seed --class=SiteContatoSeeder -> Executa uma seed específicada pelo nome

<?php

namespace Database\Seeders;

// use Illuminate\Database\Console\Seeds\WithoutModelEvents;
use Illuminate\Database\Seeder;

class DatabaseSeeder extends Seeder
{
    /**
     * Seed the application's database.
     *
     * @return void
     */
    public function run()
    {
         $this->call(FornecedorSeeder::class);  

        //   \App\Models\User::factory(10)->create();
        //   \App\Models\SiteContato::factory(100)->create();
        //   \App\Models\Fornecedor::factory(100)->create();
        //   \App\Models\FornecedorSeeder::class;

        // \App\Models\User::factory()->create([
        //     'name' => 'Test User',
        //     'email' => 'test@example.com',
        // ]);
    }
}

# FornecedorSeeder.php
<?php

namespace Database\Seeders;

use Illuminate\Database\Console\Seeds\WithoutModelEvents;
use Illuminate\Database\Seeder;

use App\Models\Fornecedor;

class FornecedorSeeder extends Seeder
{
    /**
     * Run the database seeds.
     *
     * @return void
     */
    public function run()
    {
        $fornecedor = new Fornecedor;

        $fornecedor->nome = 'Fornecedor 100';
        $fornecedor->site = 'https://fornecedor100.com.br';
        $fornecedor->uf = 'MA';
        $fornecedor->email = 'fornecedor100@gmail.com';
        $fornecedor->save();

        Fornecedor::create([
            'nome'=>'Fornecedor200',
            'site' => 'https://forn200.com.br',
            'uf'=> 'RS',
            'email'=>'forn200@gmail.com'
        ]);

    }
}

# SiteContatoSeeder.php
<?php

namespace Database\Seeders;

use Illuminate\Database\Console\Seeds\WithoutModelEvents;
use Illuminate\Database\Seeder;

use App\Models\SiteContato;

class SiteContatoSeeder extends Seeder
{
    /**
     * Run the database seeds.
     *
     * @return void
     */
    public function run()
    {
        $sitecontato = new SiteContato;

        $sitecontato->nome = 'Alberto Gomes';
        $sitecontato->telefone = '98981188434';
        $sitecontato->email = 'ags@silva.com.br';
        $sitecontato->motivo_contato = 2;
        $sitecontato->mensagem = 'Detalhes do produto';
        $sitecontato->save();

        SiteContato::create([
            'nome'=>'agsilva',
            'telefone' => '98988445577',
            'email'=> 'agsilva@gmail.com',
            'motivo_contato'=>1,
            'mensagem'=>'Mais informações.'
        ]);

    }
}

# DatabaseSeeder.php
<?php

namespace Database\Seeders;

// use Illuminate\Database\Console\Seeds\WithoutModelEvents;
use Illuminate\Database\Seeder;

class DatabaseSeeder extends Seeder
{
    /**
     * Seed the application's database.
     *
     * @return void
     */
    public function run()
    {
        // $this->call(FornecedorSeeder::class);
         $this->call(SiteContatoSeeder::class);

        //   \App\Models\User::factory(10)->create();
        //   \App\Models\SiteContato::factory(100)->create();
        //   \App\Models\Fornecedor::factory(100)->create();
        //   \App\Models\FornecedorSeeder::class;

        // \App\Models\User::factory()->create([
        //     'name' => 'Test User',
        //     'email' => 'test@example.com',
        // ]);
    }
}

>php artisan migrate:rollback
>php artisan migrate:fresh
>php artisan migrate --seed   

   INFO  Running migrations.

  2014_10_12_000000_create_users_table ..................................................... 71ms DONE
  2014_10_12_100000_create_password_resets_table ........................................... 59ms DONE
  2019_08_19_000000_create_failed_jobs_table ............................................... 58ms DONE
  2019_12_14_000001_create_personal_access_tokens_table .................................... 75ms DONE
  2022_10_29_124933_create_site_contatos_table ............................................. 27ms DONE
  2022_10_29_141119_create_fornecedores_table .............................................. 26ms DONE
  2022_10_30_144326_alter_fornecedores_novas_colunas ....................................... 50ms DONE
  2022_10_30_151416_create_produtos_table .................................................. 30ms DONE
  2022_10_30_152706_create_produtos_detalhes_table ........................................ 144ms DONE
  2022_10_30_163254_create_unidades_table ................................................. 291ms DONE
  2022_10_30_175104_ajuste_produtos_filiais ............................................... 269ms DONE
  2022_10_30_182603_nova_coluna_site_com_after ............................................. 51ms DONE
  2022_10_31_230638_alter_fornecedores_softdelete .......................................... 49ms DONE

   INFO  Seeding database.

  Database\Seeders\FornecedorSeeder .................................................... RUNNING  
  Database\Seeders\FornecedorSeeder .............................................. 11.04 ms DONE  

  Database\Seeders\SiteContatoSeeder ................................................... RUNNING  
  Database\Seeders\SiteContatoSeeder ............................................. 13.34 ms DONE  



### FACTORIES - FACTORY -> para popular o banco de dados criamos as factory

### https://github.com/fzaninotto/Faker/

# php artisan make:factory SiteContatoFactory --model SiteContato
# php artisan make:factory SiteContatoFactory --model SiteContato

>php artisan make:factory SiteContatoFactory --model SiteContato
<?php

namespace Database\Factories;

use Illuminate\Database\Eloquent\Factories\Factory;

/**
 * @extends \Illuminate\Database\Eloquent\Factories\Factory<\App\Models\SiteContato>
 */
class SiteContatoFactory extends Factory
{
    /**
     * Define the model's default state.
     *
     * @return array<string, mixed>
     */
    public function definition()
    {
        return [
            'nome' => fake()->name(),
            'telefone' => fake()->tollFreePhoneNumber(),
            'email' => fake()->email(),
            'motivo_contato' => fake()->numberBetween(1,3),
            'mensagem' => fake()->text(200)
        ];
    }
}


>php artisan make:factory FornecedorFactory --model Fornecedor

<?php

### https://github.com/fzaninotto/Faker/

namespace Database\Factories;

use Illuminate\Database\Eloquent\Factories\Factory;

/**
 * @extends \Illuminate\Database\Eloquent\Factories\Factory<\App\Models\Fornecedor>
 */
class FornecedorFactory extends Factory
{
    /**
     * Define the model's default state.
     *
     * @return array<string, mixed>
     */
    public function definition()
    {
        return [
            'nome' => fake()->name(),
            'site' => fake()->tollFreePhoneNumber(),
            'uf' => fake()->stateAbbr(),
            'email' => fake()->email(),
           
        ];
    }
}

### ALTERAMOS O ARQUIVO DatabaseSeeder.php para poder executar:
/database/seeders/DatabaseSeeder.php

<?php

namespace Database\Seeders;

// use Illuminate\Database\Console\Seeds\WithoutModelEvents;
use Illuminate\Database\Seeder;

class DatabaseSeeder extends Seeder
{
    /**
     * Seed the application's database.
     *
     * @return void
     */
    public function run()
    {
        // \App\Models\User::factory(10)->create();
         \App\Models\SiteContato::factory(100)->create();
         \App\Models\Fornecedor::factory(100)->create();

        // \App\Models\User::factory()->create([
        //     'name' => 'Test User',
        //     'email' => 'test@example.com',
        // ]);
    }
}

### EXECUTANDO A SEED E POPULANDO DADOS NO BANCO 

>php  artisan db:seed


### DELETANDO REGISTROS - SOFTDELETE -> Criamos uma coluna para marcamos um registro ao invés de excluir.
importamos com a linha:
 use Illuminate\Database\Eloquent\SoftDeletes; 
no Model Fornecedor.php

* Trait -> São pedaços de códigos que definem propriedades e métodos e que podem ser utilizados dentro de uma classe como um especie de include, de CTRL+C CTRL+V, com isso, a classe se expande incorporando as propriedades e métodos dessa respectiva trait. É parecida com extends, mas como não podemos ter herança múltiplas, as traits são utilizadas para poder contornar isso. Na O.O. temos essa restrição de herança multiplas. Implementa uma herança horizontal em vez da vertical de herança múltipla.

Fornecedor.php (Model)
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\SoftDeletes;

class Fornecedor extends Model
{
    use SoftDeletes;
    
    use HasFactory;
    protected $table = 'fornecedores';

    protected $fillable = ['nome', 'site', 'uf', 'email'];

}

O PRÓXIMO PASSO É AJUSTAR A MIGRATION DE CRIAÇÃO DA TABELA fornecedores:

$table->softDeletes();   //Cria a coluna deleted_at na tabela fornecedores

2022_10_29_141119_create_fornecedores_table.php

<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     *
     * @return void
     */
    public function up()
    {
        Schema::create('fornecedores', function (Blueprint $table) {
            $table->id();
            $table->string('nome', 50);
            $table->timestamps();
          //  $table->softDeletes();   //Cria a coluna deleted_at na tabela fornecedores
        });
    }

    /**
     * Reverse the migrations.
     *
     * @return void
     */
    public function down()
    {
        Schema::dropIfExists('fornecedores');
    }
};

Fazendo assim teremos que dá refresh no banco como um todo... 

### criando a migration para acrescentar a coluna deleted_at ao invés de acrescentar na migration de criação da tabela:

>php artisan make:migration alter_fornecedores_softdelete  


2022_10_31_230638_alter_fornecedores_softdelete.php

<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     *
     * @return void
     */
    public function up()
    {
        Schema::table('fornecedores', function(Blueprint $table) {
            $table->softDeletes();
        });
    }
    
    /**
     * Reverse the migrations.
     *
     * @return void
     */
    public function down()
    {
        Schema::table('fornecedores', function(Blueprint $table) {
            $table->dropSoftDeletes();
        });
        
    }
};


>php artisan migrate:status

Migration name ............................................................... Batch / Status  
  2014_10_12_000000_create_users_table ....................................... [1] Ran  
  2014_10_12_100000_create_password_resets_table ............................. [1] Ran  
  2019_08_19_000000_create_failed_jobs_table ................................. [1] Ran  
  2019_12_14_000001_create_personal_access_tokens_table ...................... [1] Ran  
  2022_10_29_124933_create_site_contatos_table ............................... [1] Ran  
  2022_10_29_141119_create_fornecedores_table ................................ [1] Ran  
  2022_10_30_144326_alter_fornecedores_novas_colunas ......................... [1] Ran  
  2022_10_30_151416_create_produtos_table .................................... [1] Ran  
  2022_10_30_152706_create_produtos_detalhes_table ........................... [1] Ran  
  2022_10_30_163254_create_unidades_table .................................... [1] Ran  
  2022_10_30_175104_ajuste_produtos_filiais .................................. [1] Ran  
  2022_10_30_182603_nova_coluna_site_com_after ................................ [1] Ran  
  2022_10_31_230638_alter_fornecedores_softdelete ............................. Pending  


> php artisan migrate

### DELETANDO E PREENCHENDO A COLUNA deleted_at
>>> $res = Fornecedor::find(1)                                                                                           
=> App\Models\Fornecedor {#3707
     id: 1,
     nome: "Santiago Wintheiser",
     site: "(888) 524-2135",
     created_at: "2022-10-31 22:40:51",
     updated_at: "2022-10-31 22:40:51",
     uf: "NC",
     email: "awalsh@yahoo.com",
     deleted_at: null,
   }

>>> $res->delete()                                                                                                       
=> true
ID   NOME          SITE      CREATED_AT UPDATED_AT  UF      EMAIL             DELETED_AT
1	Santiago Winth https.ww.com 22:40:51 23:13:33	    NC	awalsh@yahoo.com	2022-10-31 23:13:33

>>> Fornecedor::find(1)                                                                                                  
=> null

### RESTAURANDO OS REGISTROS REMOVIDOS DE MODO SUAVE (SOFTDELETE)
* Exibindo os deletados com softDelete
>>> Fornecedor::withTrashed()->get()                                                                                     
         updated_at: "2022-10-31 23:13:33",
         uf: "NC",
         email: "awalsh@yahoo.com",
         deleted_at: "2022-10-31 23:13:33",
       },
     ],
   }
* criando um novo registro:

>>> Fornecedor::create(['nome' => 'Fornec123', 'site'=>'fornec123.com.br', 'uf'=>'MA', 'email'=>'f123@gmail.com'])     
=> App\Models\Fornecedor {#4079
     nome: "Fornec123",
     site: "fornec123.com.br",
     uf: "MA",
     email: "f123@gmail.com",
     updated_at: "2022-10-31 23:30:02",
     created_at: "2022-10-31 23:30:02",
     id: 201,
   }                                                                                                     

* EXIBINDO SOMENTE OS DELETADOS COM SOFTDELETES
>>> Fornecedor::onlyTrashed()->get()                                                                                   
=> Illuminate\Database\Eloquent\Collection {#3706
     all: [
       App\Models\Fornecedor {#4097
         id: 1,
         nome: "Santiago Wintheiser",
         site: "(888) 524-2135",
         created_at: "2022-10-31 22:40:51",
         updated_at: "2022-10-31 23:13:33",
         uf: "NC",
         email: "awalsh@yahoo.com",
         deleted_at: "2022-10-31 23:13:33",   // QUANDO DELETA INSERI A DATA E HORA SOMENTE
       },
     ],
   }

### RESTAURANDO O REGISTRO DELETADO (SOFTDELETES)          
>>> $res = Fornecedor::withTrashed()->get()                                                                            
=> Illuminate\Database\Eloquent\Collection {#4077
     all: [
       App\Models\Fornecedor {#4100
         id: 1,
         nome: "Santiago Wintheiser",
         site: "(888) 524-2135",
         created_at: "2022-10-31 22:40:51",
         email: "f123@gmail.com",
         deleted_at: null,
       },
     ],
   }

>>> $res[0]->restore()
=> true

>>> SIMPLISMENTE DELETA O REGISTRO DA COLUNA deleted_at

### ENTENDENDO O OBJETO REQUEST
# ROTA -> web.php
Route::get('/contato', [\App\Http\Controllers\ContatoController::class, 'contato'])->name('site.contato');

# ContatoController.php
<?php

namespace App\Http\Controllers;

use Illuminate\Http\Request;

class ContatoController extends Controller
{
    public function contato(Request $request) {

      //  var_dump($_POST);
      // dd($_POST);
      echo '<pre>';
       print_r($request->all());
       echo '<hr>';
       print_r($_POST);
      echo '</pre>';
      echo $request->input('nome') . '<br>';
      echo $request->input('email') . '<hr>';
        return view('site.contato', ['titulo' => 'Contato - titulo vindo do controlador'], ['teste' => 'Alberto Gomes']);
    }
}

# view localhost:8000/contato (depois de preenchido e enviado) - Exibição na view contato;
Array
(
    [_token] => iseKKj7lQwd4Jm0tpCp4q1qAdjHj20ANtLLZtVo9
    [nome] => Alberto Gomes
    [telefone] => 9999999999
    [email] => albe@gmail.com
    [mensagem] => aestou com uma dúvida
)
Array
(
    [_token] => iseKKj7lQwd4Jm0tpCp4q1qAdjHj20ANtLLZtVo9
    [nome] => Alberto Gomes
    [telefone] => 9999999999
    [email] => albe@gmail.com
    [mensagem] => aestou com uma dúvida
)
Alberto Gomes
albe@gmail.com

### GRAVANDO OS DADOS DO FORMULÁRIO NO BANCO DE DADOS:
<?php

namespace App\Http\Controllers;

use Illuminate\Http\Request;

use App\Models\SiteContato;

class ContatoController extends Controller
{
    public function contato(Request $request) {

      // //  var_dump($_POST);
      // // dd($_POST);
      // echo '<pre>';
      //  print_r($request->all());
      //  echo '<hr>';
      //  print_r($_POST);
      // echo '</pre>';
      // echo $request->input('nome') . '<br>';
      // echo $request->input('email') . '<hr>';
       
      $contato = new SiteContato;
      // $contato->nome = $request->input('nome');
      // $contato->telefone = $request->input('telefone');
      // $contato->email = $request->input('email');
      // $contato->motivo_contato = $request->input('motivo_contato');
      // $contato->mensagem = $request->input('mensagem');

      $contato->fill($request->all());      // PRECISO DA LINHA '$contato->save();' PARA USAR ESTE MÉTODO, 
                                             //   USANDO ESSE   MÉTODO E O 'fill' NA MODEL SiteContato.php ADICIONAR 
                                              // O ATTRUBUTO $fillable
      $contato->create($request->all());    AQUI NÃO PRECISO DA LINHA: $contato->save();  //TAMBÉM PARA USAR ESTE MÉTODO 'create' NA MODEL SiteContato.php ADICIONAR O ATTRUBUTO $fillable
      
      $contato->save();  // ==> SALVA NO BANCO DE DADOS

     print_r($contato->getAttributes());
    //  print_r($_POST);

        return view('site.contato', ['titulo' => 'Contato (teste)']);   // PASSANDO O TÍTULO POR VARIÁVEL COMO PARÂMETRO 
    }
}

# MODEL SiteContato.php

<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;

class SiteContato extends Model
{
    use HasFactory;
    // protected $table = 'site_contatos';

     protected $fillable = ['nome', 'telefone','email', 'motivo_contato', 'mensagem']; // necessário para os métodos fill e create
}

### VAIDAÇÃO DE CAMPOS OBRIGATÓRIOS - required
laravel.com/docs/7.x/validation

#Available Validation Rules

-> Validação de dados do lado do backend da aplicação
ContatoController.php
<?php

namespace App\Http\Controllers;

use Illuminate\Http\Request;

use App\Models\SiteContato;

class ContatoController extends Controller

    public function salvar(Request $request) {

      // REALIZAR A VALIDAÇÃO DOS DADOS RECEBIDOS - A VARIÁVEL $erros DO lARAVEL ESTÁ DISPONIVEL PARA ISSO EM QUALQUER VIEW
        $request->validate([
          'nome' => 'required',
          'telefone' => 'required',
          'email' => 'required',
          'motivo_contato' => 'required',
          'mensagem' => 'required',
        ]);

### VALIDAÇÃO DE QUANTIDADES MÍNIMAS E MÁXIMSA DE CARACTERES (min e max)

laravel.com/docs/7.x/validation

#Available Validation Rules

   'nome' => 'required|min:3|max:40',  //Nomes de 3 a 40 caracteres permitido nesse campo

### REPOPULAR O FORMULÁRIO COM O CONTEÚDO ANTES DO ERRO
Recuperando os dados do formulário com o conteúdo que foi digitado ao ocorrer o erro.

* old()

for_contato.php
{{ $slot }}

{{ $x }}

<form action={{ route('site.contato') }} method="post" > 
            @csrf
            <input name="nome" value="{{ old('nome') }}"  type="text" placeholder="Nome" class="{{ $classe }}">
            <br>
            <input type="text" name="telefone" value="{{ old('telefone') }}" placeholder="Telefone" class="{{ $classe }}">
            <br>
            <input type="text" name="email" value="{{ old('email') }}" placeholder="E-mail" class="{{ $classe }}">
            <br>
            <select name="motivo_contato" class="{{ $classe }}">
                <option value="">Qual o motivo do contato?</option>
                <option value="1">Dúvida</option>
                <option value="2">Elogio</option>
                <option value="3">Reclamação</option>
            </select>
            <br>
            <textarea name="mensagem" value="{{ old('mensagem') }}" class="{{ $classe }}" placeholder="Preencha aqui a sua mensagem"> {{ (old('mensagem') != '') ?  old('mensagem')  :'' }} </textarea>
    <br>
    <button type="submit" class="btn btn-suces">ENVIAR</button>
</form>
<div style="position:absolute; top:0px; left:0px; width:100%; height: 150px; background: orange; color: red;">
{{ print_r($errors); }}
</div>














 
###********************-> FIM LARAVEL UDEMY  END <-******************###

<!--  DOCKER INÍCIO:

1 instalar o docker

2 abrir wsl2/Windows ou linux
 curl -s "https://laravel.build/olw?with=mysql,redis,mailhog,minio" | bash

3 cd olw
./vendor/bin/sail up -d
	ou
4 cd olw && ./vendor/bin/sail up -d

5 ATRIBUINDO PERMISSÃO PARA A PASTA
cd .. -> sai da pasta
sudo chmod 777 olw/ -R ou sem o 'sudo' chmod 777 olw/ -R

6 CRIANDO ALIAS PARA O COMANDO ANTERIOR
alias sail='[ -f sail ] && sh sail || sh vendor/bin/sail'
passa a usar assim: sail ps

7 CONFIGURAR PORTAS PARA A APLICAÇÃO NO NAVEGADOR E MYSQL
.env
APP_PORT=8000

*porta do myql
FORWARD_DB_PORT=3307

8 INSTALANDO DEPENDÊNCIA AO PROJETO
./vendor/bin/sail composer require laravel/breeze --dev 

e depois tem que 


9 DEIXAR TELA DE AUTENTICAÇÃO PRONTA, ROTA AUTENTICADA, TAWINDCSS INSTALADO E INERTIA INSTALADO
./vendor/bin/sail artisan breeze:install vue 
ou
./vendor/bin/sail art breeze:install vue




10 RODAR AS MIGRATES PADRÕES DO PROJETO AI JÁ PODE CADASTRAR USUÁRIOS PARA LOGIN:
./vendor/bin/sail art migrate

-->

 /***************************************** */
 Route::prefix('usuarios')->group(function() {
    Route::get('', function(){
        return 'usuarios';
    })->name('usuarios');
    
    Route::get('/{id}', function($id){
        return 'mostrar detalhes do usuário';
    })->name('usuario-detalhes');

    Route::get('/{id}/tags', function($id){
        return 'mostrar tags do usuário';
    })->name('usuario_tags');

});


/*******************************************/
2a AULA:

O PROJETO CONSISTE EM RECEBER DADOS DE UMA API (punkapi.com) DE INFORMAÇÕES SOBRE CERVEJAS, VAMOS CONSTRUIR AS ROTAS PARA CONSUMIR A API E CRIAR A ESTRUTURA PARA O RELATÓRIO QUE IREMOS GERAR EM EXCEL E ENVIAR PARA O STORAGE...
1 CRIAR ROTAS:
code .
olw/routes/web.php


sail up -d -> SOBE O CONTAINER localhost:8000 (nesse projeto)

Route::get('/beers', fn()=> 'Olw - testando a rota /beers');

**************************************************
obs:
- laravel.com/api -> acesso a documentação do código;
- in line paramets for vscode -> extensão para vscode para exibir o nome dos métodos na hora que codificar;
- fira code -> extensão para fonte no vscode

git Hub Copilot vs Tabnine -> (pesquisar sobre)
Link para extensões vscode:
https://github.com/icarojobs/vscode-useful-extensions
*************************************************


Route::get('/beers', fn()=> 'Olw - testando a rota /beers')
                             ->middleware(['auth']);

* FLUXO PADRÃO DO MVC-LARAVEL: 
life cicle: sai do usuário pelo navegador, insomnia ou postman -> passa pelo index.php(pasta public) -> passa pelos arquivos do bootstrap retornando uma instância da aplicação -> passa pelo kernel do http (carrega mais instâncias) -> Service provider -> despacha a requisição pro Router -> Cai no arquivo Web.php -> Middleware (se tiver, geralmente tem os globais) -> Controller (faz as regras de negócio e pode chamar outras classes como Serviços por exemplo)
-> Retorna uma view ou um json (No caso estamos usando inértia, ele não vai reinderizar a 'view.blade' padrão, ele vai reinderizar componente vue.js através do inértia.).


* EM VEZ DE USAR A FUNÇÃO AQUI NA ROTA CRIAMOS UM CONTROLLER:

* ROTAS:
Route::prefix('usuarios')->group(function() {
    Route::get('', function(){
        return 'usuário';
    })->name('usuarios');
    Route::get('/{id}', function($id){
        return $id;
    })->name('usuario_id');

});



Route::get('/users/{id?}', function ($id = null) {
    return $id;
});


obs.: ​dica: php artisan make:controller -r cria o Resource também.
dica: limpar o cache do container:
./vendor/bin/sail art config:cache 
./vendor/bin/sail art optimize:clear
ou
./vendor/bin/sail art config:cache && art optimize:clear

sail artisan make:controller BeerController
ou 
sail art make:controller BeerController -> CRIA O ARQUIVO BeerController.php na pasta app/Http/Controllers
->
<?php

namespace App\Http\Controllers;

use Illuminate\Http\Request;

class BeerController extends Controller
{
    public function index()
    {
    return 'Virgu & Beer & Code'
    }
}

* NO ARQUIVO DE ROTAS Web.php CHAMA O BeersController:

importante importar o Controller <nomeDoController>+<CTRL=ENTER:
use App\Http\Controllers\BeerController;

Route::get('/beers', [BeerController::class, 'index'])
                        ->middleware(['auth']);


* PRECISAMOS CRIAR UM MÉTODO PARA PEGAR A LISTA, LISTAR OS DADOS DA API (listar as bebidas de https://api.punkapi.com/v2 ->
VAMOS CRIAR UMA NOVA CLASSE de serviços em app/Sevices/PunkapiService.php

* O LARAVEL POSSUI UM RECURSO CHAMADO HTTPClient que abstrai o uso de uma ferramenta chama guzeo, esse guzeo é o client http mais comum para php, com ele fazemos requisições pra diversos serviços web dentro do php para outras url, ele é robusto, então o laravel simplifica importando o recurso que faz tudo por 'detrás dos panos':

PunkapiService.php

<?php

namespace App\Services;

use Illuminate\Support\Facades\Http;

class PunkapiService
{
    public function getBeers()
    {
        return Http::get('https://api.punkapi.com/v2/beers');
    }
}

E NO BeerController.php fica:
<?php

namespace App\Http\Controllers;

use App\Services\PunkapiService;
use Illuminate\Http\Request;

class BeerController extends Controller
{
    public function index()
    {
    //return 'Virgu & Beer & Code';
    $service = new PunkapiService;

    return $service->getBeers();
    }
}

* TRATE É CARACTERÍSTICA QUE A CLASSE ADQUIRE (pode ter mesmos métodos e atributos substituindo o recurso de um classe extender várias classes que não tem no php, a trate é uma forma de fazer isso. O service  é uma outra camada na maioria das vezes abstrair seviços que vc vai consumir, por exemplo API.

Estando logado, os dados da api já serão exibidos em localhost:8000/beers, se usar um aplicativo cliente tipo insomnia pode apresentar os dados também, melhor comentar a linha de de autenticação da rota:
Route::get('/beers', [BeerController::class, 'index']);
linha de autenticação da rota // ->middleware(['auth']);

* ESSA API PERMITE FAZER FILTROS VIA PARÂMETROS NA PRÓPRIA ROTA. PRIMEIRO VAMOS REFATORAR O CÓDIO, A CLASSE PunkapiService.php:

USO DE CONFIG E MACRO


Vamos alterar a url, primeiro acessando a pasta config da raiz do projeto e criar o arquivo punkapi.php. O que acontece é que o config(pasta config da raiz) carrega todos os arquivos da pasta e permite que sejam acessados via funções simples(HELPERS), isso é muito legal porque podemos acessar esses arquivos de configurações de qualquer lugar do projeto: 

<?php

return [
    'url' => env('PUNK_BASE_URL', 'https://api.punkapi.com/v2')
];

Usando o helper env significa dizer que, se não houver a constante PUNK_BASE_URL setada no arquivo .env do projeto, seu valor será o segundo parâmetro: http://api.punkapi.com/v2 e no arquivo PunkapiService.php da pasta app/Services fica:

<?php

namespace App\Services;

use Illuminate\Support\Facades\Http;

class PunkapiService
{
    public function getBeers()
    {
        return Http::get('/beers');
    }
}

MACRO é uma forma de criar funções customizadas:
 em app\Providers vamos acessar o arquivo AppServiceProvider.php que é uma classe que tem dois métodos register e boot. No método boot vamos chamar o método Http do laravel e chamar o método macro, no primeiro parâmetro será um nome atribuído à função e e o segundo uma clausure (uma função).
Neste arquivo é passado o arquivo de configuração da url (em 'config/punkapi.php') além de tokens, headers,...
 

use Illuminate\Support\Facades\Http; -> deve ser importado
E a função boot fica:

  public function boot()
    {
        Http::macro('punkapi', function(){
            return Http::acceptJson()
            ->baseUrl(config('punkapi.url'));
        });
    }

Então criamos uma macro(uma função customizada) chamada punkapi que já retorna o client com accept/Json no Header e com o baseUrl configurado lá do arquivo /config/punkapi.php e se estiver setado no .env pegará de lá.

/app/Services/PunkapiService.php fica:

<?php

namespace App\Services;

use Illuminate\Support\Facades\Http;

class PunkapiService
{
    public function getBeers()
    {
        return Http::punkapi()->get('/beers');
    }
}

*obs.: a baseUrl poderia ser setada no construtor, que pode setar token também.(uma outra abordagem para versão sem macros);

->Testamos o retorno Json em localhost:8000/beers.

Refatorando o arquivo PunkapiService.php: O client Http não lança exceção e podemos forçar o retorno em modo Json:
<?php

namespace App\Services;

use Illuminate\Support\Facades\Http;

class PunkapiService
{
    public function getBeers()
    {
       // return Http::punkapi()->get('/beers');
       return Http::punkapi()
            ->get('/beers')
            ->throw()  // Exceção em caso de erro
            ->json();   // Força o retorno em formato Json
    }
}

Podemos testar forçando um erro alterando a constante PUNKAPI_BASE_URL criada em /config/punkapi.php, vamos atribuir um valor diferente no arquivo .env:

PUNKAPI_BASE_URL="adfjklj878"

Podemos usar a função retry tem dois parâmetros, o número de tentativas pra buscar a requisição e o intervalo entre elas. Refatorando o código fica:
<?php

namespace App\Services;

use Illuminate\Support\Facades\Http;

class PunkapiService
{
    public function getBeers()
    {
       // return Http::punkapi()->get('/beers');
       return Http::punkapi()
            ->get('/beers')
            ->throw()  // Exceção em caso de erro
            ->json();   // Força o retorno em formato Json
    }
}

- Quando sai a exceção nao deveriamos retornar o erro em json por ser um api neste caso estamos usamos um app web e não uma api. E usaríamos o Route Api.

Refatorando o método boot de /app/Providers/AppServiceProvider.php, inserindo o retry():

     */
    public function boot()
    {
        Http::macro('punkapi', function(){
            return Http::acceptJson()
            ->baseUrl(config('punkapi.url'))
            ->retry(3,100);
        });
    }
}

comando de help

* ./vendor/bin/sail composer dump-autoload
* Verificar Nome do arquivo se bate com o nome das rotas(Classes criadas e importar o nome errado);
* inteliphense

Refatorando BeerController.php
<?php

namespace App\Http\Controllers;

use App\Services\PunkapiService;

class BeerController extends Controller
{
    public function index()
    {

    $service = new PunkapiService();

    return $service->getBeers();
    }
}

Em vez de instanciar o método PunkapiService() dentro de index, vamos passar por parâmetro de index() declarando seu Próprio nome (PunkapiService) como tipo. Fica assim:

<?php

namespace App\Http\Controllers;

use App\Services\PunkapiService;

class BeerController extends Controller
{
    public function index(PunkapiService $service)
    {
    return $service->getBeers();
    }
}

Assim usamos feactures do php(injeção de dependências) e ao mesmo tempo feactures do laravel. Em vez de criar uma instância dentro do método index, vamos injetar a classe como parâmetro para o método index(), ficando index($service) e a instância de dentro da função passa como parâmetro de 'tipo da variável'. Isso quebra a cadeia de dependência entre as classes.
Assim, o método index ganha independência não mais dependendo da instância de new PunkapiService e passamos a olhar a função index em si.
Assim, o Laravel tenta fazer um binding, um match, o laravel tenta encontrar alguma classe PunkapiService e cria uma instância dessa classe e usa ali como parâmetro. Se não fizer assim, lá em Rotas teria que ser passado como parâmetro o que fica desnecessário.
Não poderia ser feito se na classe PunkapiService existisse o construtor para atribuir valores automaticamente à classe. Assim podemos usar porque não precisamos passar nenhum valor.

ADICIONAR OS FILTROS:
Vamos filtrar o retorno api com os seguintes itens: beer_name, food, ibu_gt, malte:

var_dump($v)
die();
dd($variável)
benchmarck -> ?

/*****REFATORA PARA TESTE alterando BeerController.php e PunkapiService.php
BeerController.php
<?php

namespace App\Http\Controllers;

use App\Services\PunkapiService;

class BeerController extends Controller
{
    public function index(PunkapiService $service)
    {
    return $service->getBeers(
        'heineken',
        'cheese',
        'corn',
        45
    );
    }
}

PunkapiService.php
<?php

namespace App\Services;

use Illuminate\Support\Facades\Http;

class PunkapiService
{
    public function getBeers(
        string $beer_name,
        string $food,
        string $malt,
        string $ibu_gt
    )
    {
        $params = get_defined_vars();

        dd($params);

        return Http::punkapi()
            ->get('/beers', $params)
            ->throw()  // Exceção em caso de erro
            ->json();   // Força o retorno em formato Json
    }
}

Resultado do debug no insomnia ou no navegador:
array:4 [▼ // app/Services/PunkapiService.php:18
  "beer_name" => "heineken"
  "food" => "cheese"
  "malt" => "corn"
  "ibu_gt" => "45"
]
//* fim teste

Refatorando:

class PunkapiService
{
    public function getBeers(
        string $beer_name = null,
        string $food = null,
        string $malt = null,
        string $ibu_gt = null
    )
    {
        $params = get_defined_vars();

        dd($params);

        return Http::punkapi()
            ->get('/beers', $params)
            ->throw()  // Exceção em caso de erro
            ->json();   // Força o retorno em formato Json
    }
}

Assim quando não passar o valor para a chave ele exibirá a chave e o valor Null, vamos refatorar para não exibir nem a chave englobando get_defined_vers() com array_filter no arquivo PunkapiService.php:

$params = array_filter(get_defined_vars());

<?php

namespace App\Http\Controllers;

use App\Services\PunkapiService;

class BeerController extends Controller
{
    public function index(PunkapiService $service)
    {
    return $service->getBeers(
        'heineken',
        'cheese',
        'corn',
       // 45 -> Esse não é passado
    );
    }
}


array:3 [▼ // app/Services/PunkapiService.php:18
  "beer_name" => "heineken"
  "food" => "cheese"
  "malt" => "corn"
	Aqui não exibiu o valor 45
]


USANDO A FUNÇÃO NAMED_ARGS passamos só os parâmetros que precisamos retornar da api e o php com essa função saberá qual a posição dela no array de argumentos passados como parâmetro sem a necessidade de seguir a mesma sequência dos argumentos:
class BeerController extends Controller
{
    public function index(PunkapiService $service)
    {
    return $service->getBeers(food: 'cheese');
    }
}

REFATORANDO:
BeerController.php
<?php

namespace App\Http\Controllers;

use App\Services\PunkapiService;
use Illuminate\Http\Request;

class BeerController extends Controller
{
    public function index( Request $request, PunkapiService $service)
    {
    return $service->getBeers(...$request->all());
    }
}

PunkapiService.php
<?php

namespace App\Services;

use Illuminate\Support\Facades\Http;

class PunkapiService
{
    public function getBeers(
        string $beer_name = null,
        string $food = null,
        string $malt = null,
        string $ibu_gt = null
    )
    {
        $params = array_filter(get_defined_vars());

     //   dd($params);

        return Http::punkapi()
            ->get('/beers', $params)
            ->throw()  // Exceção em caso de erro
            ->json();   // Força o retorno em formato Json
    }
}

CRIANDO UMA REQUEST
sail artisan make:request BeerRequest
/app/Http/Requests/BeerRequest.php

* Funções anônimas, também conhecidas como closures , permitem a criação de funções que não tem o nome especificado. Elas são mais úteis como o valor de parâmetros callable, mas podem ter vários outros usos.. É uma função passada como parâmetro

CRIANDO NOVA ROTA PARA SALVAR COMO EXCEL
* https://docs.laravel-excel.com/3.1/getting-started/installation.html

Route::group([
    'prefix' => 'beers',
], function() {

    Route::get('/', [BeerController::class, 'index']); //-> Se houver necessidade de salvar dados por essa rota mudamos o método(verbo html) para post(os dados não serão expostos na url).
                          //  ->middleware(['auth']);
    Route::get('/export', [BeerController::class, 'export']);

});

Então passamos a ter duas rotas: localhost:8000/beers
localhost:8000/beers/export

No BeerController incluimos o método export():
class BeerController extends Controller
{
    public function index( BeerRequest $request, PunkapiService $service)
    {
    // return $service->getBeers(...$request->all());
    return $service->getBeers(...$request->validated());
    }

    public function export()
    {
        return 'Relatório criado.';
    }
}



INSTALANDO PACOTE LARAVEL-EXCEL PARA GERAR OS RELATÓRIO EM EXCEL FILTRADOS DA API:

* https://docs.laravel-excel.com/3.1/getting-started/installation.html

COMANDO PARA INSTALAR VIA COMPOSER:
./vendor/bin/sail composer require psr/simple-cache:^2.0 maatwebsite/excel

CRIAR A CLASSE DO EXCEL
./vendor/bin/sail artisan make:export BeerExport  --> Cria o arquivo em  /app/Exports/BeerExport.php

<?php

namespace App\Exports;

use Maatwebsite\Excel\Concerns\FromCollection;

class BeerExport implements FromCollection
{


    /**
    * @return \I¢lluminate\Support\Collection
    */
    public function collection()
    {
        //
    }
}

-> Dentro de colletion buscaremos as informações que serão salvas no arquivo do excel, um array de dados;

criamos um __construct() que vai ter uma propriedade privada do tipo array chamamos de $reportData.

O retorn será uma collection como informa o comentário:
 /**
    * @return \I¢lluminate\Support\Collection
    */

Na função colletion(), está recebendo um array return $this->reportData; 
Observe que não precisa mais declarar uma propriedade que vai se setada via construct(), basta defifinir o escopo junto do argumento e o php faz isso pra você. Como o retorno da função é um array usamos o helper collect para o $this->reportData:

BeerExport.php

<?php

namespace App\Exports;

use Maatwebsite\Excel\Concerns\FromCollection;

class BeerExport implements FromCollection
{

    public function __construct(
        private array $reportData
    ){}

    /**
    * @return \Illuminate\Support\Collection
    */
    public function collection()
    {
       return collect($this->reportData);
    }
}
 

Consultamos a documentação do Laravel-excel em 'Exporting collections':
em Excel Store passa o nome da classe e o nome do arquivo:

BeerController.php
<?php

namespace App\Http\Controllers;


use App\Exports\BeerExport;
use App\Http\Requests\BeerRequest;
use App\Services\PunkapiService;
use Maatwebsite\Excel\Facades\Excel;


class BeerController extends Controller
{
    public function index( BeerRequest $request, PunkapiService $service)
    {
    // return $service->getBeers(...$request->all());
    return $service->getBeers(...$request->validated());
    }

    public function export()
    {
      $params = [
        ['name' => 'Tom', 'age' => '30'],
        ['name' => 'Virgu', 'age' => '27']
       ];

       Excel::store(new BeerExport($params), 'olw-report.xlsx');
       return "Relatório criado";

    }


}

********************************************
* REFATORANDO E SALVANDO O ARQUIVO EXCEL EM /storage/app

BeerExport.php
<?php

namespace App\Exports;

use Maatwebsite\Excel\Concerns\FromCollection;

class BeerExport implements FromCollection
{

    public function __construct(
        private array $reportData
    ){}

    /**
    * @return \Illuminate\Support\Collection
    */
    public function collection()
    {
       return collect($this->reportData);
    }
}
*****************************

BeerController.php

<?php

namespace App\Http\Controllers;


use App\Exports\BeerExport;
use App\Http\Requests\BeerRequest;
use App\Services\PunkapiService;
use Maatwebsite\Excel\Facades\Excel;


class BeerController extends Controller
{
    public function index( BeerRequest $request, PunkapiService $service)
    {
        return $service->getBeers(...$request->all());

    }

    public function export(BeerRequest $request, PunkapiService $service)
    {
        $beers = $service->getBeers(...$request->validated());

        $filteredBeers = collect($beers)->map(function($value, $key){
        return collect($value)
                ->only(['name', 'tagline', 'first_brewed', 'description'])
                ->toArray();
    })->toArray();

    //dd($filteredBeers);

      $params = [
        ['name' => 'Tom', 'age' => '30'],
        ['name' => 'Virgu', 'age' => '27']
       ];

       Excel::store(new BeerExport($filteredBeers), 'olw-report.xlsx');

           return "Relatório criado";

    }


}

PARA SALVAR O ARQUIVO EXCEL EM UM STORAGE S3:
ALTERA BeerController.php

<?php

namespace App\Http\Controllers;


use App\Exports\BeerExport;
use App\Http\Requests\BeerRequest;
use App\Services\PunkapiService;
use Maatwebsite\Excel\Facades\Excel;


class BeerController extends Controller
{
    public function index( BeerRequest $request, PunkapiService $service)
    {
        return $service->getBeers(...$request->all());

    }

    public function export(BeerRequest $request, PunkapiService $service)
    {
        $beers = $service->getBeers(...$request->validated());

        $filteredBeers = collect($beers)->map(function($value, $key){
        return collect($value)
                ->only(['name', 'tagline', 'first_brewed', 'description'])
                ->toArray();
    })->toArray();


       Excel::store(
            new BeerExport($filteredBeers),
             'olw-report.xlsx',
             's3');

           return "Relatório criado";

    }


}

************
O REPOSITÓRIO DE ARQUIVOS minio:
NO DOCKER COMPOSER TEMOS O minio, um S3 que tem
MINIO_ROOT_USER: 'sail'
MINIO_ROOT_PASSWORD: 'password' e roda na porta 9000
localhost:9000
usuário: sail
senha: password

vamos criar um buncket(uma pasta)

e configurar o .env da raiz da aplicação:
originalmente é assim:
AWS_ACCESS_KEY_ID=
AWS_SECRET_ACCESS_KEY=
AWS_DEFAULT_REGION=us-east-1
AWS_BUCKET=
AWS_USE_PATH_STYLE_ENDPOINT=false

 e acrescentamos as informações para:


AWS_ACCESS_KEY_ID=sail
AWS_SECRET_ACCESS_KEY=password
AWS_DEFAULT_REGION=us-east-1
AWS_BUCKET=local
AWS_ENDPOINT=http://minio:9000
AWS_URL=http://minio:9000/local
AWS_USE_PATH_STYLE_ENDPOINT=true

altera tambem:

FILESYSTEM_DISK=local 
para:
FILESYSTEM_DISK=s3

INSTALAR UMA DEPENDÊNCIA (ADAPTER) PARA FAZER CORRESPONDÊNCIA COM A AWS:

Flysystem 3.x em laravel.com/docs/9.x/upgrade
./vendor/bin/sail composer require -W league/flysystem-aws-s3-v3 "^3.0"

em caso de erro:
 artisan vendor:publish --tag=laravel-assets --ansi --force

.env
APP_NAME=Laravel
APP_ENV=local
APP_KEY=base64:UbVvTP6Cu+LF5GamJdB4dsZZvW05ep4bZqcCEhmiDCg=
APP_DEBUG=true
APP_URL=http://localhost
APP_PORT=8000

# PUNKAPI_BASE_URL="httpadfjkljdsdfdfasf878"

LOG_CHANNEL=stack
LOG_DEPRECATIONS_CHANNEL=null
LOG_LEVEL=debug

DB_CONNECTION=mysql
FORWARD_DB_PORT=3307
DB_HOST=mysql
DB_PORT=3306
DB_DATABASE=olw
DB_USERNAME=sail
DB_PASSWORD=password

BROADCAST_DRIVER=log
CACHE_DRIVER=file
FILESYSTEM_DISK=s3
QUEUE_CONNECTION=sync
SESSION_DRIVER=file
SESSION_LIFETIME=120

MEMCACHED_HOST=memcached

REDIS_HOST=redis
REDIS_PASSWORD=null
REDIS_PORT=6379

MAIL_MAILER=smtp
MAIL_HOST=mailhog
MAIL_PORT=1025
MAIL_USERNAME=null
MAIL_PASSWORD=null
MAIL_ENCRYPTION=null
MAIL_FROM_ADDRESS="hello@example.com"
MAIL_FROM_NAME="${APP_NAME}"

AWS_ACCESS_KEY_ID=sail
AWS_SECRET_ACCESS_KEY=password
AWS_DEFAULT_REGION=us-east-1
AWS_BUCKET=local
AWS_ENDPOINT=http://minio:9000
AWS_URL=http://minio:9000/local
AWS_USE_PATH_STYLE_ENDPOINT=true

PUSHER_APP_ID=
PUSHER_APP_KEY=
PUSHER_APP_SECRET=
PUSHER_HOST=
PUSHER_PORT=443
PUSHER_SCHEME=https
PUSHER_APP_CLUSTER=mt1

VITE_PUSHER_APP_KEY="${PUSHER_APP_KEY}"
VITE_PUSHER_HOST="${PUSHER_HOST}"
VITE_PUSHER_PORT="${PUSHER_PORT}"
VITE_PUSHER_SCHEME="${PUSHER_SCHEME}"
VITE_PUSHER_APP_CLUSTER="${PUSHER_APP_CLUSTER}"

PRONTO. ENVIANDO PARA O MINIO.

/**** Criando as Migrations com Virgu e tabela de históricos

























 







/***********************************************************
QUINTA FEIRA: 20/10/22

Open Laravel Week | Deploy com Terraform, EC2 e RDS | Fermentação

****
https://portal.aws.amazon.com/billing/signup?nc2=h_ct&src=header_signup&redirect_url=https%3A%2F%2Faws.amazon.com%2Fregistration-confirmation&language=pt_br#/start/email

Com terraform pode mudar de infra e configurar no git.

PROGRMAR A CONFIGURAÇÃO DO SERVIDOR: É basicamente construir uma nova aplicação para fazer isso, mais fácil de entender.
Terraform serve para (linguagem HCL -> linguagem própria - linguagem descritiva, descreve o resultado e não como irá ser feito), ou seja, descrever o que queremos.
Terraspace é o framework pra terraform.
Quando criamos o Terraform, ele pode variar conforme a infra cloud (aws, azure, google cloud). sua estrutura é a mesma para todos. mas cada provider tem a sua forma de usar, não consegue usar o mesmo código para mais de uma cloud.
Vamos rodar Terraform via container:

1. clonar do git: git clone 
Criar uma pasta para a infraestrutura

sail   (script que vamos usar)
#!/usr/bin/env bash

docker run -rm -it
	-u $(id -u):$(id -g) \
	-v $PWD:/workspace \
	-w /workspace
	hashicorp/terraform:light "%@"


	<no terminal

Logar em: aws.amazon.com
busca: iam
iam dashboard -> mysecurity credencials (root user) -> Acces keys ->clicar em create access keys -> salva o access key e secret access key
e coloca no arquivo credencials na maquina local.. .aws/credencials
















































//////////////////////////////////////////////////////////////////////////////////////////////////////
CONTEÚDO QUE FALTA ORGANIZAR:



/**************************************/

sail share

sail artisan sail:publish ->coloca em uma pasta na raiz chamada docker

sail --help

sail artisan optimizer:clear

sail ps

sail build --no-cache -> faz o bild da aplicação. (dá um sail down  por precaução antes.)










/*********************************

root@DELLAGS:~# curl -s "https://laravel.build/laravel-9-course?with=mysql,redis,mailhog" | bash

Dockerfile

root@DELLAGS:~/example-app# docker exec -it example-app-mysql-1 bash


FROM wyveo/nginx-php-fpm:latest
WORKDIR /usr/share/nginx
RUN rm -rf /usr/share/nginx/html
COPY . /usr/share/nginx
RUN chmod -R 755 /usr/share/nginx/storage/*
RUN ln -s public html

.env (do composer)

DB_CONNECTION=mysql
DB_HOST=mysql-app (serviço do mysql no docker-compose.yaml)
DB_PORT=3306
DB_DATABASE=laraveldockerdb
DB_USERNAME=root
DB_PASSWORD=123456



docker-compose.yaml

version: '3'

services:
  laraveldocker-app:
    build: .
    ports:
      - "3003:80"
    volumes:
      - ./:/usr/share/nginx
      - .docker/nginx:/etc/nginx/conf.d/
    networks:
      - app-network
  mysql-app:
    image: mysql:5.7.22
    ports:
      - "3306:3306"
    volumes:
      - .docker/dbdata:/var/lib/mysql
    environment:
      MYSQL_DATABASE: laraveldocker
      MYSQL_ROOT_PASSWORD: 123456
    networks:
      - app-network
networks:
  app-network:
    driver: bridge
    
https://calculator.aws/#/addService
################



/*************************************************
#criando um serviço com um nome qualquer
version: '3'

services:
  laravel-app:                    #criando um serviço com um nome qualquer
    build: . ou image: wyveo/nginx-php-fpm:latest -> neste caso sem Dockerfile.                    # endereço da imagem ou local do Dockerfile (neste caso o ponto siginifica a raiz do projeto)
    ports:
      - "8080:80"                 # 8080 porta do meu host: 80 é a porta do docker nginx
    volumes:                      # docker-compose up -d -> sobe a imagem e libera o terminal  
      - ./:/usr/share/nginx       # TUDO QUE ESTIVE NA RAIZ (na rais tem o meu projeto laravel) './' IRÁ SER REFLETIDO NA PASTA /usr/share/nginx (pasta de acesso da página html)
                                  # C:\Laravel-docker\laravel-docker>docker compose up -d --build atualiza a minha imagem

  mysql-app:
      image: mysql:5.7
      ports:
        - "3306:3306"
      volumes:
        - .docker/dbdata:/var/lib/mysql          # qualqer nome (para persistir -guardar os dados do banco de dados)


      environment:
        MYSQL_DATABASE: laravel
        MYSQL_ROOT_PASSWORD: laravel
    
      

      /***************************///


  
C:\Laravel-docker\laravel-docker>docker compose up -d --build

                                
                               

    

/******************************** Dockerfile
FROM wyveo/nginx-php-fpm:latest

/***************************///
  COMANDOS

docker compose down -> para todos os containers
C:\Laravel-docker\laravel-docker>docker exec -it laravel-docker-laravel-app-1 bash 
root@612ea0ea3340:/# cd /usr/share/nginx/
root@612ea0ea3340:/usr/share/nginx# php artisan migrate
root@612ea0ea3340:/usr/share/nginx# php artisan serve

		
/***********/
PS C:\Users\alber> docker run -e MYSQL_ROOT_PASSWORD=root --name meu-mysql -d mysql:5.7

docker inspect meu-mysql ou | grep IPAddress

PS C:\Users\alber> docker run -e MYSQL_ROOT_PASSWORD=root --name meu-mysql -d -p 3306:3306 mysql:5.7

docker ps
docker ps -l
docker ps -a
docker rm -f nomecd


/*** LARAVEL */
### CRIANDO UM PROJETO NO LARAVEL 
laravel new projeto_laravel_via_installer (ESTA É UM AOPÇÃO)
composer create-project --prefer-dist laravel/laravel app_controle_tarefas "8.5.9"
cd app_controle_tarefas
cd public
php -S localhost:8000

ou 
da raiz do projeto:
php artisan serve 
ou
php artisan serve --port=3000

### PARA ABRIR PORTA EM OUTRO SERVIDOR
php artisan serve --host test.com --port 8080

 **********************************************************************
cd app_controle_tarefas
cd public
php artisan serve
- acessa o navegador http://localhost:8000

### DENTRO DO PROJETO CRIADO INSTALAR O LARAVEL/UI:^3.2 - versão 3.2
composer require laravel/ui:^3.2

### SE OCORRER ERRO AUMENTAR A MEMÓRIA DISPONIVEL PARA O php

-php --ini -> localiza o arquivo de configuração do php
LOCALIZA memory_limit = 1000 e altera para 
         memory_limit  = -1 e Salva

### LISTA A RELAÇÃO DE COMANDOS 
php artisan list 

DEVERA SURGIR AS OPÇÕES ABAIXO:

 ui
  ui:auth               Scaffold basic login and registration views and routes
  ui:controllers        Scaffold the authentication controllers
 vendor

### ENTENDENDO O PACOTE UI E INICIANDO A AUTENTICAÇÃO WEB NATIVA DO LARAVEL

COMANDO PARA LISTAR ROUTES: 
php artisan route:list

### php artisan ui bootstrap --auth (bootstrap ou react ou vue)
aplicando o bootstrap incluindo os recursos de autenticação;
poderia ser aplicado o bootstrap sem os recursos de autenticação;

### php artisan route:list -> mostra as rotas - ver que aumentaram as rotas

### APÓS ESSE PROCESSO O SISTEMA PEDE PARA RODAR
npm install -> instala as dependências do package.json (inclusive o bootstrap)
npm run dev -> gera os assets da aplicação de acordo com a tecnologia selecionada (bootstrap, react ou vue) -> Geralmente roda mais de uma vez para compilar tudo.

<!DOCTYPE html>
<html lang="{{ str_replace('_', '-', app()->getLocale()) }}">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <title>Laravel</title>

        <!-- Fonts -->
        <link rel="preconnect" href="https://fonts.bunny.net">
        <link href="https://fonts.bunny.net/css?family=figtree:400,600&display=swap" rel="stylesheet" />

        <!-- Styles -->
        <style>
            /* ! tailwindcss v3.2.4 | MIT License | https://tailwindcss.com */*,::after,::before{box-sizing:border-box;border-width:0;border-style:solid;border-color:#e5e7eb}::after,::before{--tw-content:''}html{line-height:1.5;-webkit-text-size-adjust:100%;-moz-tab-size:4;tab-size:4;font-family:Figtree, sans-serif;font-feature-settings:normal}body{margin:0;line-height:inherit}hr{height:0;color:inherit;border-top-width:1px}abbr:where([title]){-webkit-text-decoration:underline dotted;text-decoration:underline dotted}h1,h2,h3,h4,h5,h6{font-size:inherit;font-weight:inherit}a{color:inherit;text-decoration:inherit}b,strong{font-weight:bolder}code,kbd,pre,samp{font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;font-size:1em}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sub{bottom:-.25em}sup{top:-.5em}table{text-indent:0;border-color:inherit;border-collapse:collapse}button,input,optgroup,select,textarea{font-family:inherit;font-size:100%;font-weight:inherit;line-height:inherit;color:inherit;margin:0;padding:0}button,select{text-transform:none}[type=button],[type=reset],[type=submit],button{-webkit-appearance:button;background-color:transparent;background-image:none}:-moz-focusring{outline:auto}:-moz-ui-invalid{box-shadow:none}progress{vertical-align:baseline}::-webkit-inner-spin-button,::-webkit-outer-spin-button{height:auto}[type=search]{-webkit-appearance:textfield;outline-offset:-2px}::-webkit-search-decoration{-webkit-appearance:none}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}summary{display:list-item}blockquote,dd,dl,figure,h1,h2,h3,h4,h5,h6,hr,p,pre{margin:0}fieldset{margin:0;padding:0}legend{padding:0}menu,ol,ul{list-style:none;margin:0;padding:0}textarea{resize:vertical}input::placeholder,textarea::placeholder{opacity:1;color:#9ca3af}[role=button],button{cursor:pointer}:disabled{cursor:default}audio,canvas,embed,iframe,img,object,svg,video{display:block;vertical-align:middle}img,video{max-width:100%;height:auto}[hidden]{display:none}*, ::before, ::after{--tw-border-spacing-x:0;--tw-border-spacing-y:0;--tw-translate-x:0;--tw-translate-y:0;--tw-rotate:0;--tw-skew-x:0;--tw-skew-y:0;--tw-scale-x:1;--tw-scale-y:1;--tw-pan-x: ;--tw-pan-y: ;--tw-pinch-zoom: ;--tw-scroll-snap-strictness:proximity;--tw-ordinal: ;--tw-slashed-zero: ;--tw-numeric-figure: ;--tw-numeric-spacing: ;--tw-numeric-fraction: ;--tw-ring-inset: ;--tw-ring-offset-width:0px;--tw-ring-offset-color:#fff;--tw-ring-color:rgb(59 130 246 / 0.5);--tw-ring-offset-shadow:0 0 #0000;--tw-ring-shadow:0 0 #0000;--tw-shadow:0 0 #0000;--tw-shadow-colored:0 0 #0000;--tw-blur: ;--tw-brightness: ;--tw-contrast: ;--tw-grayscale: ;--tw-hue-rotate: ;--tw-invert: ;--tw-saturate: ;--tw-sepia: ;--tw-drop-shadow: ;--tw-backdrop-blur: ;--tw-backdrop-brightness: ;--tw-backdrop-contrast: ;--tw-backdrop-grayscale: ;--tw-backdrop-hue-rotate: ;--tw-backdrop-invert: ;--tw-backdrop-opacity: ;--tw-backdrop-saturate: ;--tw-backdrop-sepia: }::-webkit-backdrop{--tw-border-spacing-x:0;--tw-border-spacing-y:0;--tw-translate-x:0;--tw-translate-y:0;--tw-rotate:0;--tw-skew-x:0;--tw-skew-y:0;--tw-scale-x:1;--tw-scale-y:1;--tw-pan-x: ;--tw-pan-y: ;--tw-pinch-zoom: ;--tw-scroll-snap-strictness:proximity;--tw-ordinal: ;--tw-slashed-zero: ;--tw-numeric-figure: ;--tw-numeric-spacing: ;--tw-numeric-fraction: ;--tw-ring-inset: ;--tw-ring-offset-width:0px;--tw-ring-offset-color:#fff;--tw-ring-color:rgb(59 130 246 / 0.5);--tw-ring-offset-shadow:0 0 #0000;--tw-ring-shadow:0 0 #0000;--tw-shadow:0 0 #0000;--tw-shadow-colored:0 0 #0000;--tw-blur: ;--tw-brightness: ;--tw-contrast: ;--tw-grayscale: ;--tw-hue-rotate: ;--tw-invert: ;--tw-saturate: ;--tw-sepia: ;--tw-drop-shadow: ;--tw-backdrop-blur: ;--tw-backdrop-brightness: ;--tw-backdrop-contrast: ;--tw-backdrop-grayscale: ;--tw-backdrop-hue-rotate: ;--tw-backdrop-invert: ;--tw-backdrop-opacity: ;--tw-backdrop-saturate: ;--tw-backdrop-sepia: }::backdrop{--tw-border-spacing-x:0;--tw-border-spacing-y:0;--tw-translate-x:0;--tw-translate-y:0;--tw-rotate:0;--tw-skew-x:0;--tw-skew-y:0;--tw-scale-x:1;--tw-scale-y:1;--tw-pan-x: ;--tw-pan-y: ;--tw-pinch-zoom: ;--tw-scroll-snap-strictness:proximity;--tw-ordinal: ;--tw-slashed-zero: ;--tw-numeric-figure: ;--tw-numeric-spacing: ;--tw-numeric-fraction: ;--tw-ring-inset: ;--tw-ring-offset-width:0px;--tw-ring-offset-color:#fff;--tw-ring-color:rgb(59 130 246 / 0.5);--tw-ring-offset-shadow:0 0 #0000;--tw-ring-shadow:0 0 #0000;--tw-shadow:0 0 #0000;--tw-shadow-colored:0 0 #0000;--tw-blur: ;--tw-brightness: ;--tw-contrast: ;--tw-grayscale: ;--tw-hue-rotate: ;--tw-invert: ;--tw-saturate: ;--tw-sepia: ;--tw-drop-shadow: ;--tw-backdrop-blur: ;--tw-backdrop-brightness: ;--tw-backdrop-contrast: ;--tw-backdrop-grayscale: ;--tw-backdrop-hue-rotate: ;--tw-backdrop-invert: ;--tw-backdrop-opacity: ;--tw-backdrop-saturate: ;--tw-backdrop-sepia: }.relative{position:relative}.mx-auto{margin-left:auto;margin-right:auto}.mx-6{margin-left:1.5rem;margin-right:1.5rem}.ml-4{margin-left:1rem}.mt-16{margin-top:4rem}.mt-6{margin-top:1.5rem}.mt-4{margin-top:1rem}.-mt-px{margin-top:-1px}.mr-1{margin-right:0.25rem}.flex{display:flex}.inline-flex{display:inline-flex}.grid{display:grid}.h-16{height:4rem}.h-7{height:1.75rem}.h-6{height:1.5rem}.h-5{height:1.25rem}.min-h-screen{min-height:100vh}.w-auto{width:auto}.w-16{width:4rem}.w-7{width:1.75rem}.w-6{width:1.5rem}.w-5{width:1.25rem}.max-w-7xl{max-width:80rem}.shrink-0{flex-shrink:0}.scale-100{--tw-scale-x:1;--tw-scale-y:1;transform:translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}.grid-cols-1{grid-template-columns:repeat(1, minmax(0, 1fr))}.items-center{align-items:center}.justify-center{justify-content:center}.gap-6{gap:1.5rem}.gap-4{gap:1rem}.self-center{align-self:center}.rounded-lg{border-radius:0.5rem}.rounded-full{border-radius:9999px}.bg-gray-100{--tw-bg-opacity:1;background-color:rgb(243 244 246 / var(--tw-bg-opacity))}.bg-white{--tw-bg-opacity:1;background-color:rgb(255 255 255 / var(--tw-bg-opacity))}.bg-red-50{--tw-bg-opacity:1;background-color:rgb(254 242 242 / var(--tw-bg-opacity))}.bg-dots-darker{background-image:url("data:image/svg+xml,%3Csvg width='30' height='30' viewBox='0 0 30 30' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M1.22676 0C1.91374 0 2.45351 0.539773 2.45351 1.22676C2.45351 1.91374 1.91374 2.45351 1.22676 2.45351C0.539773 2.45351 0 1.91374 0 1.22676C0 0.539773 0.539773 0 1.22676 0Z' fill='rgba(0,0,0,0.07)'/%3E%3C/svg%3E")}.from-gray-700\/50{--tw-gradient-from:rgb(55 65 81 / 0.5);--tw-gradient-to:rgb(55 65 81 / 0);--tw-gradient-stops:var(--tw-gradient-from), var(--tw-gradient-to)}.via-transparent{--tw-gradient-to:rgb(0 0 0 / 0);--tw-gradient-stops:var(--tw-gradient-from), transparent, var(--tw-gradient-to)}.bg-center{background-position:center}.stroke-red-500{stroke:#ef4444}.stroke-gray-400{stroke:#9ca3af}.p-6{padding:1.5rem}.px-6{padding-left:1.5rem;padding-right:1.5rem}.text-center{text-align:center}.text-right{text-align:right}.text-xl{font-size:1.25rem;line-height:1.75rem}.text-sm{font-size:0.875rem;line-height:1.25rem}.font-semibold{font-weight:600}.leading-relaxed{line-height:1.625}.text-gray-600{--tw-text-opacity:1;color:rgb(75 85 99 / var(--tw-text-opacity))}.text-gray-900{--tw-text-opacity:1;color:rgb(17 24 39 / var(--tw-text-opacity))}.text-gray-500{--tw-text-opacity:1;color:rgb(107 114 128 / var(--tw-text-opacity))}.underline{-webkit-text-decoration-line:underline;text-decoration-line:underline}.antialiased{-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}.shadow-2xl{--tw-shadow:0 25px 50px -12px rgb(0 0 0 / 0.25);--tw-shadow-colored:0 25px 50px -12px var(--tw-shadow-color);box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow)}.shadow-gray-500\/20{--tw-shadow-color:rgb(107 114 128 / 0.2);--tw-shadow:var(--tw-shadow-colored)}.transition-all{transition-property:all;transition-timing-function:cubic-bezier(0.4, 0, 0.2, 1);transition-duration:150ms}.selection\:bg-red-500 *::selection{--tw-bg-opacity:1;background-color:rgb(239 68 68 / var(--tw-bg-opacity))}.selection\:text-white *::selection{--tw-text-opacity:1;color:rgb(255 255 255 / var(--tw-text-opacity))}.selection\:bg-red-500::selection{--tw-bg-opacity:1;background-color:rgb(239 68 68 / var(--tw-bg-opacity))}.selection\:text-white::selection{--tw-text-opacity:1;color:rgb(255 255 255 / var(--tw-text-opacity))}.hover\:text-gray-900:hover{--tw-text-opacity:1;color:rgb(17 24 39 / var(--tw-text-opacity))}.hover\:text-gray-700:hover{--tw-text-opacity:1;color:rgb(55 65 81 / var(--tw-text-opacity))}.focus\:rounded-sm:focus{border-radius:0.125rem}.focus\:outline:focus{outline-style:solid}.focus\:outline-2:focus{outline-width:2px}.focus\:outline-red-500:focus{outline-color:#ef4444}.group:hover .group-hover\:stroke-gray-600{stroke:#4b5563}.z-10{z-index: 10}@media (prefers-reduced-motion: no-preference){.motion-safe\:hover\:scale-\[1\.01\]:hover{--tw-scale-x:1.01;--tw-scale-y:1.01;transform:translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}}@media (prefers-color-scheme: dark){.dark\:bg-gray-900{--tw-bg-opacity:1;background-color:rgb(17 24 39 / var(--tw-bg-opacity))}.dark\:bg-gray-800\/50{background-color:rgb(31 41 55 / 0.5)}.dark\:bg-red-800\/20{background-color:rgb(153 27 27 / 0.2)}.dark\:bg-dots-lighter{background-image:url("data:image/svg+xml,%3Csvg width='30' height='30' viewBox='0 0 30 30' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M1.22676 0C1.91374 0 2.45351 0.539773 2.45351 1.22676C2.45351 1.91374 1.91374 2.45351 1.22676 2.45351C0.539773 2.45351 0 1.91374 0 1.22676C0 0.539773 0.539773 0 1.22676 0Z' fill='rgba(255,255,255,0.07)'/%3E%3C/svg%3E")}.dark\:bg-gradient-to-bl{background-image:linear-gradient(to bottom left, var(--tw-gradient-stops))}.dark\:stroke-gray-600{stroke:#4b5563}.dark\:text-gray-400{--tw-text-opacity:1;color:rgb(156 163 175 / var(--tw-text-opacity))}.dark\:text-white{--tw-text-opacity:1;color:rgb(255 255 255 / var(--tw-text-opacity))}.dark\:shadow-none{--tw-shadow:0 0 #0000;--tw-shadow-colored:0 0 #0000;box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow)}.dark\:ring-1{--tw-ring-offset-shadow:var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);--tw-ring-shadow:var(--tw-ring-inset) 0 0 0 calc(1px + var(--tw-ring-offset-width)) var(--tw-ring-color);box-shadow:var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow, 0 0 #0000)}.dark\:ring-inset{--tw-ring-inset:inset}.dark\:ring-white\/5{--tw-ring-color:rgb(255 255 255 / 0.05)}.dark\:hover\:text-white:hover{--tw-text-opacity:1;color:rgb(255 255 255 / var(--tw-text-opacity))}.group:hover .dark\:group-hover\:stroke-gray-400{stroke:#9ca3af}}@media (min-width: 640px){.sm\:fixed{position:fixed}.sm\:top-0{top:0px}.sm\:right-0{right:0px}.sm\:ml-0{margin-left:0px}.sm\:flex{display:flex}.sm\:items-center{align-items:center}.sm\:justify-center{justify-content:center}.sm\:justify-between{justify-content:space-between}.sm\:text-left{text-align:left}.sm\:text-right{text-align:right}}@media (min-width: 768px){.md\:grid-cols-2{grid-template-columns:repeat(2, minmax(0, 1fr))}}@media (min-width: 1024px){.lg\:gap-8{gap:2rem}.lg\:p-8{padding:2rem}}
        </style>
        

         @vite(['resources/sass/app.scss','resources/js/app.js']);
    </head>
    <body class="antialiased">

### CRIA O BANCO DE DADOS NORMALMENTE

### EXECUTA AS MIGRATIONS PADRÕES CRIADAS PARA O SISTEMA DE login
php artisan migrate -> CRIA AS TABELAS NO BANCO DE DADOS


************************************** 
INSTALANDO O COMPOSER NO UBUNTU
**************************************
sudo apt update
sudo apt install php-cli unzip

cd ~

curl -sS https://getcomposer.org/installer -o composer-setup.php

HASH=`curl -sS https://composer.github.io/installer.sig`

echo $HASH ->saída: Output
e0012edf3e80b6978849f5eff0d4b4e4c79ff1609dd1e613307e16318854d24ae64f26d17af3ef0bf7cfb710ca74



php -r "if (hash_file('SHA384', 'composer-setup.php') === '$HASH') { echo 'Installer verified'; } else { echo 'Installer corrupt'; unlink('composer-setup.php'); } echo PHP_EOL;"

sudo php composer-setup.php --install-dir=/usr/local/bin --filename=composer





***********************

DigitalOcean Kubernetes: novo plano de controle é mais rápido e gratuito, habilita HA para SLA de 99,95% de tempo de atividade
Produtos
Preços

Documentos
divisa suspensa

Entrar
divisa suspensa

// Tutorial //
Como Instalar e Utilizar o Composer no Ubuntu 20.04
Publicado em 21 de maio de 2020
Ubuntu
PHP
Ubuntu 20.04
Avatar padrão
Por Erika Heidi
Advogado Desenvolvedor
Português
Como Instalar e Utilizar o Composer no Ubuntu 20.04
Introdução
O Composer é uma ferramenta popular de gerenciamento de dependências para o PHP, criado para facilitar a instalação e a atualização das dependências principalmente do projeto. Ele controla quais outros pacotes de projeto específico dependem e são instalados para você, usando as opções apropriadas de acordo com os requisitos do projeto. O Composer também é comumente utilizado para inicializar novos projetos em frameworks PHP populares, como o Symfon e o Laravel .

Neste tutorial, você instalará e começará a usar o Composer em um sistema Ubuntu 20.04.

Pré-requisitos
Para seguir este guia, você pode acessar um servidor como usuário Ubuntu20.04 como usuário sudonão-root um firewall habilitado em seu servidor Para configurar isto, siga nosso guia Configuração do servidor inicial para o Ubuntu 20.04

Passo 1 — Instalando o PHP e as Dependências Adicionais
Além das dependências que já devem estar incluídas em seu sistema Ubuntu 20.04, como o , o Composer exige ou gitexecuta scripts PHP na linha de comando e para extrair arquivos zipados. Vamos instalar essas dependências agora.curlphp-cliunzip

primeiro, atual, gerenciador de pacotes de soluções: o cache do gerenciador de pacotes

sudo apt update
Em seguida, o seguinte comando para instalar os pacotes, execute:

sudo apt install php-cli unzip
Você será solicitado a confirmar a instalação digitando Ye, depois, ENTER.

Assim que os pré-requisitos para instalação do Composer forem instalados, você poderá seguir.

Passo 2 — Baixando e Instalando o Compositor
O Composer fornece um instalador de script escrito em PHP. Vamos baixá-lo, verificar se ele não está danificado e, em seguida, o usaremos para instalar o Composer.

Certifique-se de estar em sua pasta home. Em seguida, baixe o instalador usando o curl:

cd ~
curl -sS https://getcomposer.org/installer -o composer-setup.php
Em seguida, vamos verificar se o instalador baixado corresponde ao hash SHA-384 para o instalador mais recente encontrado na página Composer Public Keys / Signatures . Para facilitar o passo de seleção, você pode usar o seguinte comando para obter programaticamente o hash mais recente da página do Composer e armazená-lo em uma variável do shell:

HASH=`curl -sS https://composer.github.io/installer.sig`
Se você quiser verificar o valor realizado, execute:

echo $HASH
Output
e0012edf3e80b6978849f5eff0d4b4e4c79ff1609dd1e613307e16318854d24ae64f26d17af3ef0bf7cfb710ca74755a
Agora o código PHP a seguir, execute conforme a página de download do Composer, para verificar se o script de instalação está seguro para ser executado:

php -r "if (hash_file('SHA384', 'composer-setup.php') === '$HASH') { echo 'Installer verified'; } else { echo 'Installer corrupt'; unlink('composer-setup.php'); } echo PHP_EOL;"
Você verá o seguinte resultado:

Resultado
Installer verified
Se Installer corruptvocê estiver usando o hash correto, verifique se você está usando o hash correto. Em seguida, repita o processo de verificação. Quando você tiver um instalador selecionado, você pode continuar.

Para instalar o composerglobalmente, use o seguinte comando que baixará e instalará o Composer como um comando disponível em todo o sistema chamado composer, sob /usr/local/bin:

sudo php composer-setup.php --install-dir=/usr/local/bin --filename=composer
Você verá um resultado semelhante com este:

Output
All settings correct for using Composer
Downloading...

Composer (version 1.10.5) successfully installed to: /usr/local/bin/composer
Use it: php /usr/local/bin/composer
Para testar sua instalação, execute:

composer
Output
   ______
  / ____/___  ____ ___  ____  ____  ________  _____
 / /   / __ \/ __ `__ \/ __ \/ __ \/ ___/ _ \/ ___/
/ /___/ /_/ / / / / / / /_/ / /_/ (__  )  __/ /
\____/\____/_/ /_/ /_/ .___/\____/____/\___/_/
                    /_/
Composer version 1.10.5 2020-04-10 11:44:22

Usage:
  command [options] [arguments]

Options:
  -h, --help                     Display this help message
  -q, --quiet                    Do not output any message
  -V, --version                  Display this application version
      --ansi                     Force ANSI output
      --no-ansi                  Disable ANSI output
  -n, --no-interaction           Do not ask any interactive question
      --profile                  Display timing and memory usage information
      --no-plugins               Whether to disable plugins.
  -d, --working-dir=WORKING-DIR  If specified, use the given directory as working directory.
      --no-cache                 Prevent use of the cache
  -v|vv|vvv, --verbose           Increase the verbosity of messages: 1 for normal output, 2 for more verbose output and 3 for debug
...
Isso verifica que o Composer foi instalado com sucesso em seu sistema e está disponível em todo o sistema.

Nota: se você preferirá ter-lhe-ão separados separados do Composer para projeto hospedado neste servidor, você pode instalar localmente, em uma base por projeto. Este método também é útil quando o usuário do sistema não possui permissão para instalar o software disponível em todo o sistema.

Para fazer isso, use o comando php composer-setup.php. Isso irá gerar um arquivo composer.pharem seu diretório atual, que pode ser executado com o seu atual php composer.phar.

Agora podemos dar uma dependência em como usar o Compose como gerenciar.

Passo 3 — Usando o Compositor em um Projeto PHP
Os projetos PHP geralmente dependentes de bibliotecas externas, e o gerenciamento de dependências e suas versões podem ser complicados. O Composer resolve esse problema de manter um controle de projeto de extensões e dependências, também facilita o processo de descoberta, instalação e atualização de pacotes que são definidos por enquanto.

Para usar o seu projeto, você pode compor um arquivo composer.json. O arquivo composer.jsonComposer quais dependências precisa para baixar seu projeto quais serão as versões de cada pacote tem permissão para instalações e instalações. Isso é muito importante para manter seu projeto consistente e evitar a instalação de versões instáveis ​​que podem causar problemas de compatibilidade retroativa.

Você não precisa criar este arquivo manualmente - é comum ocorrer erros de sintaxe quando fizer isso. O Composer oferece uma maneira de criar um novo arquivo composer.jsoncom base na entrada do usuário, o que é uma boa escolha se você planeja compartilhar seu projeto mais tarde como um pacote público no Packagist . O Composer gera automaticamente um arquivo básico composer.jsonquando você executa um comando composer requirepara incluir uma dependência em um projeto recém-criado.

O processo de uso do Composer para instalar um pacote como uma dependência em um projeto envolve os passos a seguir:

Identifique o tipo de biblioteca que o aplicativo precisa.
uma biblioteca de código aberto adequada no agist.org , o responsável oficial de pacotes para o Compose.
Escolha o pacote de dependência.
Execute composer requirepara incluir a dependência no arquivo composer.jsone instalar o pacote.
Vamos testar isso com uma aplicação de demonstração.

O objetivo desta aplicação é transformar uma determinação determinada em uma string de URL amigável - um slug . Isso é comumente usado para converter os títulos de página para caminhos de URL (Assim como a parte final da URL para este tutorial).

Vamos começar a criar um diretório para o nosso projeto. Vamos chamá-lo de slugify :

cd ~
mkdir slugify
cd slugify
Embora não seja necessário, você pode executar agora um comando composer init para criar um arquivo composer.json detalhado para seu projeto. Como o único objetivo do nosso projeto é demonstrar como instalar dependências com o Composer, usaremos um arquivo composer.json mais simples que será gerado automaticamente quando exigirmos nosso primeiro pacote.

Agora é hora de procurar no Packagist.org por um pacote que pode nos ajudar a gerar slugs. Se você procurar pelo termo “slug” no Packagist, receberá um resultado parecido com este:

Resultados da Pesquisa do Packagist para o termo "slug"

Você verá dois números no lado direito de cada pacote na lista. O número no topo representa quantas vezes o pacote foi instalado através do Composer, e o número em baixo mostra quantas vezes um pacote foi estrelado no GitHub. De um modo geral, os pacotes com mais instalações e mais estrelas tendem a ser mais estáveis, pois mais pessoas os utilizam. Também é importante verificar a descrição do pacote para relevância para garantir que ele é o que você precisa.

Precisamos de um conversor string-to-slug A partir dos resultados da pesquisa, o pacote cocur/slugify, que aparece como o primeiro resultado naquela página, parece ser um bom candidato, com uma quantidade razoável de instalações e estrelas.

Os pacotes no Packagist têm um nome de vendor e um nome de package. Cada pacote tem um identificador único (um namespace) no mesmo formato que o GitHub utiliza para seus repositórios: vendor/package. A biblioteca que queremos instalar utiliza o namespace cocur/slugify. Você precisa de um namespace do pacote para exigi-lo em seu projeto.

Agora que você sabe exatamente qual pacote deseja instalar, você pode executar o composer require para incluí-lo como uma dependência e gerar também o arquivo composer.json para seu projeto. Uma coisa importante é observar a exigência de pacotes. O Composer rastreia as dependências no nível da aplicação e do sistema. As dependências no nível do sistema são importantes para indicar de quais módulos PHP um pacote depende. No caso do pacote cocur/slugify, ele exige um módulo PHP que ainda não instalamos.

Quando um pacote necessário depende de uma biblioteca de sistema que não está atualmente instalada em seu servidor, você receberá um erro informando qual requisito está faltando:

composer require cocur/slugify
Output
Using version ^4.0 for cocur/slugify
./composer.json has been updated
Loading composer repositories with package information
Updating dependencies (including require-dev)
Your requirements could not be resolved to an installable set of packages.

  Problem 1
    - Installation request for cocur/slugify ^4.0 -> satisfiable by cocur/slugify[v4.0.0].
    - cocur/slugify v4.0.0 requires ext-mbstring * -> the requested PHP extension mbstring is missing from your system.
...
Para resolver o problema de dependência do sistema, podemos procurar pelo pacote que falta usando o apt search:

apt search mbstring
Output
Sorting... Done
Full Text Search... Done
php-mbstring/focal 2:7.4+75 all
  MBSTRING module for PHP [default]

php-patchwork-utf8/focal 1.3.1-1 all
  UTF-8 strings handling for PHP

php7.4-mbstring/focal 7.4.3-4ubuntu1 amd64
  MBSTRING module for PHP
Após localizar o nome do pacote correto, você pode utilizar o apt novamente para instalar a dependência de sistema:

sudo apt install php-mbstring
Assim que a instalação terminar, você pode executar novamente o comando composer require:

composer require cocur/slugify
Output
Using version ^4.0 for cocur/slugify
./composer.json has been created
Loading composer repositories with package information
Updating dependencies (including require-dev)
Package operations: 1 install, 0 updates, 0 removals
  - Installing cocur/slugify (v4.0.0): Downloading (100%)         
Writing lock file
Generating autoload files
Como você pode ver na saída, o Composer decidiu automaticamente qual versão do pacote utilizar. Se você verificar o diretório do seu projeto agora, ele irá conter dois arquivos novos: composer.json e composer.lock, e um diretório vendor:

ls -l
Output
total 12
-rw-rw-r-- 1 sammy sammy   59 May  4 13:56 composer.json
-rw-rw-r-- 1 sammy sammy 3229 May  4 13:56 composer.lock
drwxrwxr-x 4 sammy sammy 4096 May  4 13:56 vendor
O arquivo composer.lock é usado para armazenar informações sobre quais versões de cada pacote estão instaladas, e garantir que as mesmas versões sejam usadas se outra pessoa clonar seu projeto e instalar suas dependências. O diretório vendor é onde as dependências do projeto estão localizadas. Você não deve fazer commit da pasta vendor no controle de versão - você precisa apenas incluir os arquivos composer.json e composer.lock.

Ao instalar um projeto que já contém um arquivo composer.json, execute o composer install para baixar as dependências do projeto.

Vamos dar uma olhada rápida em restrições de versão. Se você verificar o conteúdo do seu arquivo composer.json, verá algo parecido com isto:

cat composer.json
Output
{
    "require": {
        "cocur/slugify": "^4.0"
    }
}
Note que há o caractere especial ^ antes do número da versão no composer.json. O Composer suporta várias restrições diferentes e formatos para definir a versão necessária do pacote, para fornecer flexibilidade enquanto também mantém seu projeto estável. O operador circunflexo (^) utilizado pelo arquivo composer.json criado automaticamente é o operador recomendado para a interoperabilidade máxima, seguindo o versionamento semântico. Neste caso, ele define 4.0 como a versão mínima compatível e permite atualizações para qualquer versão futura abaixo de 5.0.

De um modo geral, você não precisará alterar as restrições de versão em seu arquivo composer.json. No entanto, algumas situações podem exigir que você edite manualmente as restrições – por exemplo, quando uma nova versão principal da sua biblioteca requerida é liberada e você deseja atualizar, ou quando a biblioteca que você deseja usar não segue o versionamento semântico.

Aqui estão alguns exemplos para lhe dar um melhor entendimento sobre como as restrições de versão do Composer funcionam:

Restrição	Significado	Exemplo de Versões Permitidas
^1.0	>= 1.0 < 2.0	1.0, 1.2.3, 1.9.9
^1.1.0	>= 1.1.0 < 2.0	1.1.0, 1.5.6, 1.9.9
~1.0	>= 1.0 < 2.0.0	1.0, 1.4.1, 1.9.9
~1.0.0	>= 1.0.0 < 1.1	1.0.0, 1.0.4, 1.0.9
1.2.1	1.2.1	1.2.1
1.*	>= 1.0 < 2.0	1.0.0, 1.4.5, 1.9.9
1.2. *	>= 1.2 < 1.3	1.2.0, 1.2.3, 1.2.9
Para uma visualização mais detalhada das restrições de versão do Composer, consulte a documentação oficial.

A seguir, vamos ver como carregar dependências automaticamente com o Composer.

Passo 4 — Incluindo o Script Autoload
Como o PHP por si só não carrega classes automaticamente, o Composer fornece um script autoload que você pode incluir em seu projeto para obter o carregamento automático para ele. Este arquivo é gerado automaticamente pelo Composer quando você adiciona sua primeira dependência.

A única coisa que você precisa fazer é incluir o arquivo vendor/autoload.php em seus scripts PHP antes de qualquer instância de classe.

Vamos testar isso em nossa aplicação de demonstração. Abra um novo arquivo chamado test.php em seu editor de texto:

nano test.php
Adicione o código a seguir que vem no arquivo vendor/autoload.php, carrega a dependência cocur/slugify, e o utiliza para criar um slug:

test.php
<?php
require __DIR__ . '/vendor/autoload.php';

use Cocur\Slugify\Slugify;

$slugify = new Slugify();

echo $slugify->slugify('Hello World, this is a long sentence and I need to make a slug from it!');
Salve o arquivo e saia do seu editor.

Agora, execute o script.

php test.php
Isso produz a saída hello-world-this-is-a-long-sentence-and-i-need-to-make-a-slug-from-it.

As dependências precisam de atualizações quando novas versões são liberadas. Dessa forma, vamos ver como lidar com isso.

Passo 5 — Atualizando as Dependências do Projeto
Sempre que você quiser atualizar suas dependências do projeto para versões mais recentes, execute o comando update:

composer update
Isso irá verificar por versões mais recentes das bibliotecas que você requer em seu projeto. Se uma versão mais recente for encontrada e ela for compatível com a restrição de versão definida no arquivo composer.json, o Composer substituirá a versão anterior instalada. O arquivo composer.lock será atualizado para refletir essas alterações.

Você também pode atualizar uma ou mais bibliotecas específicas, especificando-as desta forma:

composer update vendor/package vendor2/package2
Certifique-se de verificar em seus arquivos composer.json e composer.lock dentro do seu sistema de controle de versão após atualizar suas dependências de modo que outros também possam instalar essas versões mais recentes.

Conclusão





***********
Algoritmo "CalculoMedia2"
// Disciplina: Lógica de programação
// Professor : Antonio Carlos Nicolodi
// Descrição : calculo da média aritimética
// Autor     : Professor Antonio
// Data atual: 01/04/2015
var
// Seção de Declarações
   v1, v2, total: Real
   sinal : Caracter
Inicio
// Seção dos Comandos
   Escreva ("Digite o primeiro valor: ")
   Leia (v1)
   Escreva ("Digite a operação + - * / : ")
   Leia (sinal)
   Escreva ("Digite o segundo valor: ")
   Leia (v2)

   Se sinal = "+" entao
   total <- v1 + v2
   Escreva("O Resultado é: ", total)
   Senao
   Se sinal = "-" entao
   total <- v1 - v2
   Escreva("O Resultado é: ", total)
   Senao
   Se sinal = "*" entao
   total <- v1 * v2
   Escreva("O Resultado é: ", total)


   Senao
     Escreva("OPERAÇÃO INVÁLIDA! ")



      Escreval("total")
   fimse
Fimalgoritmo

****
COMANDOS DOCKER
root@DELLAGS:~# curl -s "https://laravel.build/laravel-9-course?with=mysql,redis,mailhog" | bash

root@DELLAGS:~/example-app# ./vendor/bin/sail  artisan migrate --seed -> criar o banco de dados e copular dados;


### DatabaseSeeder.php
class DatabaseSeeder extends Seeder
{
    /**
     * Seed the application's database.
     *
     * @return void
     */
    public function run()
    {
        \App\Models\User::factory(10)->create();

        //  \App\Models\User::factory()->create([
        //      'name' => 'Test User',
        //      'email' => 'test@example.com',
        //  ]);
    }
}

### Rota get por id ou email
// Route::get('user/{user:email}', function(\App\Models\User $user){
Route::get('user/{user}', function(\App\Models\User $user){
    
  //  ddd($user);
  //  dd($user);
    var_dump($user);
    die();

    return $user;
})->name('user');

Dockerfile

root@DELLAGS:~/example-app# docker exec -it example-app-mysql-1 bash


FROM wyveo/nginx-php-fpm:latest
WORKDIR /usr/share/nginx
RUN rm -rf /usr/share/nginx/html
COPY . /usr/share/nginx
RUN chmod -R 755 /usr/share/nginx/storage/*
RUN ln -s public html

.env (do composer)

DB_CONNECTION=mysql
DB_HOST=mysql-app (serviço do mysql no docker-compose.yaml)
DB_PORT=3306
DB_DATABASE=laraveldockerdb
DB_USERNAME=root
DB_PASSWORD=123456



docker-compose.yaml

version: '3'

services:
  laraveldocker-app:
    build: .
    ports:
      - "3003:80"
    volumes:
      - ./:/usr/share/nginx
      - .docker/nginx:/etc/nginx/conf.d/
    networks:
      - app-network
  mysql-app:
    image: mysql:5.7.22
    ports:
      - "3306:3306"
    volumes:
      - .docker/dbdata:/var/lib/mysql
    environment:
      MYSQL_DATABASE: laraveldocker
      MYSQL_ROOT_PASSWORD: 123456
    networks:
      - app-network
networks:
  app-network:
    driver: bridge
    



/*************************************************
#criando um serviço com um nome qualquer
version: '3'

services:
  laravel-app:                    #criando um serviço com um nome qualquer
    build: . ou image: wyveo/nginx-php-fpm:latest -> neste caso sem Dockerfile.                    # endereço da imagem ou local do Dockerfile (neste caso o ponto siginifica a raiz do projeto)
    ports:
      - "8080:80"                 # 8080 porta do meu host: 80 é a porta do docker nginx
    volumes:                      # docker-compose up -d -> sobe a imagem e libera o terminal  
      - ./:/usr/share/nginx       # TUDO QUE ESTIVE NA RAIZ (na rais tem o meu projeto laravel) './' IRÁ SER REFLETIDO NA PASTA /usr/share/nginx (pasta de acesso da página html)
                                  # C:\Laravel-docker\laravel-docker>docker compose up -d --build atualiza a minha imagem

  mysql-app:
      image: mysql:5.7
      ports:
        - "3306:3306"
      volumes:
        - .docker/dbdata:/var/lib/mysql          # qualqer nome (para persistir -guardar os dados do banco de dados)


      environment:
        MYSQL_DATABASE: laravel
        MYSQL_ROOT_PASSWORD: laravel
    
      

      /***************************///


  
C:\Laravel-docker\laravel-docker>docker compose up -d --build

                                
                               

    

/******************************** Dockerfile
FROM wyveo/nginx-php-fpm:latest

/***************************///
  COMANDOS

docker compose down -> para todos os containers
C:\Laravel-docker\laravel-docker>docker exec -it laravel-docker-laravel-app-1 bash 
root@612ea0ea3340:/# cd /usr/share/nginx/
root@612ea0ea3340:/usr/share/nginx# php artisan migrate
root@612ea0ea3340:/usr/share/nginx# php artisan serve

		
/***********/
PS C:\Users\alber> docker run -e MYSQL_ROOT_PASSWORD=root --name meu-mysql -d mysql:5.7

docker inspect meu-mysql ou | grep IPAddress

PS C:\Users\alber> docker run -e MYSQL_ROOT_PASSWORD=root --name meu-mysql -d -p 3306:3306 mysql:5.7

docker ps
docker ps -l
docker ps -a
docker rm -f nome


/*** LARAVEL */
### CRIANDO UM PROJETO NO LARAVEL 
laravel new projeto_laravel_via_installer (ESTA É UM AOPÇÃO)
composer create-project --prefer-dist laravel/laravel app_controle_tarefas "8.5.9"
cd app_controle_tarefas
cd public
php -S localhost:8000

ou 
da raiz do projeto:
php artisan serve 
ou
php artisan serve --port=3000

### PARA ABRIR PORTA EM OUTRO SERVIDOR
php artisan serve --host test.com --port 8080

 **********************************************************************
cd app_controle_tarefas
cd public
php artisan serve
- acessa o navegador http://localhost:8000

### DENTRO DO PROJETO CRIADO INSTALAR O LARAVEL/UI:^3.2 - versão 3.2
composer require laravel/ui:^3.2

### SE OCORRER ERRO AUMENTAR A MEMÓRIA DISPONIVEL PARA O php

-php --ini -> localiza o arquivo de configuração do php
LOCALIZA memory_limit = 1000 e altera para 
         memory_limit  = -1 e Salva

### LISTA A RELAÇÃO DE COMANDOS 
php artisan list 

DEVERA SURGIR AS OPÇÕES ABAIXO:

 ui
  ui:auth               Scaffold basic login and registration views and routes
  ui:controllers        Scaffold the authentication controllers
 vendor

### ENTENDENDO O PACOTE UI E INICIANDO A AUTENTICAÇÃO WEB NATIVA DO LARAVEL

COMANDO PARA LISTAR ROUTES: 
php artisan route:list

### php artisan ui bootstrap --auth (bootstrap ou react ou vue)
aplicando o bootstrap incluindo os recursos de autenticação;
poderia ser aplicado o bootstrap sem os recursos de autenticação;

### php artisan route:list -> mostra as rotas - ver que aumentaram as rotas

### APÓS ESSE PROCESSO O SISTEMA PEDE PARA RODAR
npm install -> instala as dependências do package.json (inclusive o bootstrap)
npm run dev -> gera os assets da aplicação de acordo com a tecnologia selecionada (bootstrap, react ou vue) -> Geralmente roda mais de uma vez para compilar tudo.

### CRIA O BANCO DE DADOS NORMALMENTE

### EXECUTA AS MIGRATIONS PADRÕES CRIADAS PARA O SISTEMA DE login
php artisan migrate -> CRIA AS TABELAS NO BANCO DE DADOS


************************************** 
INSTALANDO O COMPOSER NO UBUNTU
**************************************
sudo apt update
sudo apt install php-cli unzip

cd ~

curl -sS https://getcomposer.org/installer -o composer-setup.php

HASH=`curl -sS https://composer.github.io/installer.sig`

echo $HASH ->saída: Output
e0012edf3e80b6978849f5eff0d4b4e4c79ff1609dd1e613307e16318854d24ae64f26d17af3ef0bf7cfb710ca74



php -r "if (hash_file('SHA384', 'composer-setup.php') === '$HASH') { echo 'Installer verified'; } else { echo 'Installer corrupt'; unlink('composer-setup.php'); } echo PHP_EOL;"

sudo php composer-setup.php --install-dir=/usr/local/bin --filename=composer





***********************

DigitalOcean Kubernetes: novo plano de controle é mais rápido e gratuito, habilita HA para SLA de 99,95% de tempo de atividade
Produtos
Preços

Documentos
divisa suspensa

Entrar
divisa suspensa

// Tutorial //
Como Instalar e Utilizar o Composer no Ubuntu 20.04
Publicado em 21 de maio de 2020
Ubuntu
PHP
Ubuntu 20.04
Avatar padrão
Por Erika Heidi
Advogado Desenvolvedor
Português
Como Instalar e Utilizar o Composer no Ubuntu 20.04
Introdução
O Composer é uma ferramenta popular de gerenciamento de dependências para o PHP, criado para facilitar a instalação e a atualização das dependências principalmente do projeto. Ele controla quais outros pacotes de projeto específico dependem e são instalados para você, usando as opções apropriadas de acordo com os requisitos do projeto. O Composer também é comumente utilizado para inicializar novos projetos em frameworks PHP populares, como o Symfon e o Laravel .

Neste tutorial, você instalará e começará a usar o Composer em um sistema Ubuntu 20.04.

Pré-requisitos
Para seguir este guia, você pode acessar um servidor como usuário Ubuntu20.04 como usuário sudonão-root um firewall habilitado em seu servidor Para configurar isto, siga nosso guia Configuração do servidor inicial para o Ubuntu 20.04

Passo 1 — Instalando o PHP e as Dependências Adicionais
Além das dependências que já devem estar incluídas em seu sistema Ubuntu 20.04, como o , o Composer exige ou gitexecuta scripts PHP na linha de comando e para extrair arquivos zipados. Vamos instalar essas dependências agora.curlphp-cliunzip

primeiro, atual, gerenciador de pacotes de soluções: o cache do gerenciador de pacotes

sudo apt update
Em seguida, o seguinte comando para instalar os pacotes, execute:

sudo apt install php-cli unzip
Você será solicitado a confirmar a instalação digitando Ye, depois, ENTER.

Assim que os pré-requisitos para instalação do Composer forem instalados, você poderá seguir.

Passo 2 — Baixando e Instalando o Compositor
O Composer fornece um instalador de script escrito em PHP. Vamos baixá-lo, verificar se ele não está danificado e, em seguida, o usaremos para instalar o Composer.

Certifique-se de estar em sua pasta home. Em seguida, baixe o instalador usando o curl:

cd ~
curl -sS https://getcomposer.org/installer -o composer-setup.php
Em seguida, vamos verificar se o instalador baixado corresponde ao hash SHA-384 para o instalador mais recente encontrado na página Composer Public Keys / Signatures . Para facilitar o passo de seleção, você pode usar o seguinte comando para obter programaticamente o hash mais recente da página do Composer e armazená-lo em uma variável do shell:

HASH=`curl -sS https://composer.github.io/installer.sig`
Se você quiser verificar o valor realizado, execute:

echo $HASH
Output
e0012edf3e80b6978849f5eff0d4b4e4c79ff1609dd1e613307e16318854d24ae64f26d17af3ef0bf7cfb710ca74755a
Agora o código PHP a seguir, execute conforme a página de download do Composer, para verificar se o script de instalação está seguro para ser executado:

php -r "if (hash_file('SHA384', 'composer-setup.php') === '$HASH') { echo 'Installer verified'; } else { echo 'Installer corrupt'; unlink('composer-setup.php'); } echo PHP_EOL;"
Você verá o seguinte resultado:

Resultado
Installer verified
Se Installer corruptvocê estiver usando o hash correto, verifique se você está usando o hash correto. Em seguida, repita o processo de verificação. Quando você tiver um instalador selecionado, você pode continuar.

Para instalar o composerglobalmente, use o seguinte comando que baixará e instalará o Composer como um comando disponível em todo o sistema chamado composer, sob /usr/local/bin:

sudo php composer-setup.php --install-dir=/usr/local/bin --filename=composer
Você verá um resultado semelhante com este:

Output
All settings correct for using Composer
Downloading...

Composer (version 1.10.5) successfully installed to: /usr/local/bin/composer
Use it: php /usr/local/bin/composer
Para testar sua instalação, execute:

composer
Output
   ______
  / ____/___  ____ ___  ____  ____  ________  _____
 / /   / __ \/ __ `__ \/ __ \/ __ \/ ___/ _ \/ ___/
/ /___/ /_/ / / / / / / /_/ / /_/ (__  )  __/ /
\____/\____/_/ /_/ /_/ .___/\____/____/\___/_/
                    /_/
Composer version 1.10.5 2020-04-10 11:44:22

Usage:
  command [options] [arguments]

Options:
  -h, --help                     Display this help message
  -q, --quiet                    Do not output any message
  -V, --version                  Display this application version
      --ansi                     Force ANSI output
      --no-ansi                  Disable ANSI output
  -n, --no-interaction           Do not ask any interactive question
      --profile                  Display timing and memory usage information
      --no-plugins               Whether to disable plugins.
  -d, --working-dir=WORKING-DIR  If specified, use the given directory as working directory.
      --no-cache                 Prevent use of the cache
  -v|vv|vvv, --verbose           Increase the verbosity of messages: 1 for normal output, 2 for more verbose output and 3 for debug
...
Isso verifica que o Composer foi instalado com sucesso em seu sistema e está disponível em todo o sistema.

Nota: se você preferirá ter-lhe-ão separados separados do Composer para projeto hospedado neste servidor, você pode instalar localmente, em uma base por projeto. Este método também é útil quando o usuário do sistema não possui permissão para instalar o software disponível em todo o sistema.

Para fazer isso, use o comando php composer-setup.php. Isso irá gerar um arquivo composer.pharem seu diretório atual, que pode ser executado com o seu atual php composer.phar.

Agora podemos dar uma dependência em como usar o Compose como gerenciar.

Passo 3 — Usando o Compositor em um Projeto PHP
Os projetos PHP geralmente dependentes de bibliotecas externas, e o gerenciamento de dependências e suas versões podem ser complicados. O Composer resolve esse problema de manter um controle de projeto de extensões e dependências, também facilita o processo de descoberta, instalação e atualização de pacotes que são definidos por enquanto.

Para usar o seu projeto, você pode compor um arquivo composer.json. O arquivo composer.jsonComposer quais dependências precisa para baixar seu projeto quais serão as versões de cada pacote tem permissão para instalações e instalações. Isso é muito importante para manter seu projeto consistente e evitar a instalação de versões instáveis ​​que podem causar problemas de compatibilidade retroativa.

Você não precisa criar este arquivo manualmente - é comum ocorrer erros de sintaxe quando fizer isso. O Composer oferece uma maneira de criar um novo arquivo composer.jsoncom base na entrada do usuário, o que é uma boa escolha se você planeja compartilhar seu projeto mais tarde como um pacote público no Packagist . O Composer gera automaticamente um arquivo básico composer.jsonquando você executa um comando composer requirepara incluir uma dependência em um projeto recém-criado.

O processo de uso do Composer para instalar um pacote como uma dependência em um projeto envolve os passos a seguir:

Identifique o tipo de biblioteca que o aplicativo precisa.
uma biblioteca de código aberto adequada no agist.org , o responsável oficial de pacotes para o Compose.
Escolha o pacote de dependência.
Execute composer requirepara incluir a dependência no arquivo composer.jsone instalar o pacote.
Vamos testar isso com uma aplicação de demonstração.

O objetivo desta aplicação é transformar uma determinação determinada em uma string de URL amigável - um slug . Isso é comumente usado para converter os títulos de página para caminhos de URL (Assim como a parte final da URL para este tutorial).

Vamos começar a criar um diretório para o nosso projeto. Vamos chamá-lo de slugify :

cd ~
mkdir slugify
cd slugify
Embora não seja necessário, você pode executar agora um comando composer init para criar um arquivo composer.json detalhado para seu projeto. Como o único objetivo do nosso projeto é demonstrar como instalar dependências com o Composer, usaremos um arquivo composer.json mais simples que será gerado automaticamente quando exigirmos nosso primeiro pacote.

Agora é hora de procurar no Packagist.org por um pacote que pode nos ajudar a gerar slugs. Se você procurar pelo termo “slug” no Packagist, receberá um resultado parecido com este:

Resultados da Pesquisa do Packagist para o termo "slug"

Você verá dois números no lado direito de cada pacote na lista. O número no topo representa quantas vezes o pacote foi instalado através do Composer, e o número em baixo mostra quantas vezes um pacote foi estrelado no GitHub. De um modo geral, os pacotes com mais instalações e mais estrelas tendem a ser mais estáveis, pois mais pessoas os utilizam. Também é importante verificar a descrição do pacote para relevância para garantir que ele é o que você precisa.

Precisamos de um conversor string-to-slug A partir dos resultados da pesquisa, o pacote cocur/slugify, que aparece como o primeiro resultado naquela página, parece ser um bom candidato, com uma quantidade razoável de instalações e estrelas.

Os pacotes no Packagist têm um nome de vendor e um nome de package. Cada pacote tem um identificador único (um namespace) no mesmo formato que o GitHub utiliza para seus repositórios: vendor/package. A biblioteca que queremos instalar utiliza o namespace cocur/slugify. Você precisa de um namespace do pacote para exigi-lo em seu projeto.

Agora que você sabe exatamente qual pacote deseja instalar, você pode executar o composer require para incluí-lo como uma dependência e gerar também o arquivo composer.json para seu projeto. Uma coisa importante é observar a exigência de pacotes. O Composer rastreia as dependências no nível da aplicação e do sistema. As dependências no nível do sistema são importantes para indicar de quais módulos PHP um pacote depende. No caso do pacote cocur/slugify, ele exige um módulo PHP que ainda não instalamos.

Quando um pacote necessário depende de uma biblioteca de sistema que não está atualmente instalada em seu servidor, você receberá um erro informando qual requisito está faltando:

composer require cocur/slugify
Output
Using version ^4.0 for cocur/slugify
./composer.json has been updated
Loading composer repositories with package information
Updating dependencies (including require-dev)
Your requirements could not be resolved to an installable set of packages.

  Problem 1
    - Installation request for cocur/slugify ^4.0 -> satisfiable by cocur/slugify[v4.0.0].
    - cocur/slugify v4.0.0 requires ext-mbstring * -> the requested PHP extension mbstring is missing from your system.
...
Para resolver o problema de dependência do sistema, podemos procurar pelo pacote que falta usando o apt search:

apt search mbstring
Output
Sorting... Done
Full Text Search... Done
php-mbstring/focal 2:7.4+75 all
  MBSTRING module for PHP [default]

php-patchwork-utf8/focal 1.3.1-1 all
  UTF-8 strings handling for PHP

php7.4-mbstring/focal 7.4.3-4ubuntu1 amd64
  MBSTRING module for PHP
Após localizar o nome do pacote correto, você pode utilizar o apt novamente para instalar a dependência de sistema:

sudo apt install php-mbstring
Assim que a instalação terminar, você pode executar novamente o comando composer require:

composer require cocur/slugify
Output
Using version ^4.0 for cocur/slugify
./composer.json has been created
Loading composer repositories with package information
Updating dependencies (including require-dev)
Package operations: 1 install, 0 updates, 0 removals
  - Installing cocur/slugify (v4.0.0): Downloading (100%)         
Writing lock file
Generating autoload files
Como você pode ver na saída, o Composer decidiu automaticamente qual versão do pacote utilizar. Se você verificar o diretório do seu projeto agora, ele irá conter dois arquivos novos: composer.json e composer.lock, e um diretório vendor:

ls -l
Output
total 12
-rw-rw-r-- 1 sammy sammy   59 May  4 13:56 composer.json
-rw-rw-r-- 1 sammy sammy 3229 May  4 13:56 composer.lock
drwxrwxr-x 4 sammy sammy 4096 May  4 13:56 vendor
O arquivo composer.lock é usado para armazenar informações sobre quais versões de cada pacote estão instaladas, e garantir que as mesmas versões sejam usadas se outra pessoa clonar seu projeto e instalar suas dependências. O diretório vendor é onde as dependências do projeto estão localizadas. Você não deve fazer commit da pasta vendor no controle de versão - você precisa apenas incluir os arquivos composer.json e composer.lock.

Ao instalar um projeto que já contém um arquivo composer.json, execute o composer install para baixar as dependências do projeto.

Vamos dar uma olhada rápida em restrições de versão. Se você verificar o conteúdo do seu arquivo composer.json, verá algo parecido com isto:

cat composer.json
Output
{
    "require": {
        "cocur/slugify": "^4.0"
    }
}
Note que há o caractere especial ^ antes do número da versão no composer.json. O Composer suporta várias restrições diferentes e formatos para definir a versão necessária do pacote, para fornecer flexibilidade enquanto também mantém seu projeto estável. O operador circunflexo (^) utilizado pelo arquivo composer.json criado automaticamente é o operador recomendado para a interoperabilidade máxima, seguindo o versionamento semântico. Neste caso, ele define 4.0 como a versão mínima compatível e permite atualizações para qualquer versão futura abaixo de 5.0.

De um modo geral, você não precisará alterar as restrições de versão em seu arquivo composer.json. No entanto, algumas situações podem exigir que você edite manualmente as restrições – por exemplo, quando uma nova versão principal da sua biblioteca requerida é liberada e você deseja atualizar, ou quando a biblioteca que você deseja usar não segue o versionamento semântico.

Aqui estão alguns exemplos para lhe dar um melhor entendimento sobre como as restrições de versão do Composer funcionam:

Restrição	Significado	Exemplo de Versões Permitidas
^1.0	>= 1.0 < 2.0	1.0, 1.2.3, 1.9.9
^1.1.0	>= 1.1.0 < 2.0	1.1.0, 1.5.6, 1.9.9
~1.0	>= 1.0 < 2.0.0	1.0, 1.4.1, 1.9.9
~1.0.0	>= 1.0.0 < 1.1	1.0.0, 1.0.4, 1.0.9
1.2.1	1.2.1	1.2.1
1.*	>= 1.0 < 2.0	1.0.0, 1.4.5, 1.9.9
1.2. *	>= 1.2 < 1.3	1.2.0, 1.2.3, 1.2.9
Para uma visualização mais detalhada das restrições de versão do Composer, consulte a documentação oficial.

A seguir, vamos ver como carregar dependências automaticamente com o Composer.

Passo 4 — Incluindo o Script Autoload
Como o PHP por si só não carrega classes automaticamente, o Composer fornece um script autoload que você pode incluir em seu projeto para obter o carregamento automático para ele. Este arquivo é gerado automaticamente pelo Composer quando você adiciona sua primeira dependência.

A única coisa que você precisa fazer é incluir o arquivo vendor/autoload.php em seus scripts PHP antes de qualquer instância de classe.

Vamos testar isso em nossa aplicação de demonstração. Abra um novo arquivo chamado test.php em seu editor de texto:

nano test.php
Adicione o código a seguir que vem no arquivo vendor/autoload.php, carrega a dependência cocur/slugify, e o utiliza para criar um slug:

test.php
<?php
require __DIR__ . '/vendor/autoload.php';

use Cocur\Slugify\Slugify;

$slugify = new Slugify();

echo $slugify->slugify('Hello World, this is a long sentence and I need to make a slug from it!');
Salve o arquivo e saia do seu editor.

Agora, execute o script.

php test.php
Isso produz a saída hello-world-this-is-a-long-sentence-and-i-need-to-make-a-slug-from-it.

As dependências precisam de atualizações quando novas versões são liberadas. Dessa forma, vamos ver como lidar com isso.

Passo 5 — Atualizando as Dependências do Projeto
Sempre que você quiser atualizar suas dependências do projeto para versões mais recentes, execute o comando update:

composer update
Isso irá verificar por versões mais recentes das bibliotecas que você requer em seu projeto. Se uma versão mais recente for encontrada e ela for compatível com a restrição de versão definida no arquivo composer.json, o Composer substituirá a versão anterior instalada. O arquivo composer.lock será atualizado para refletir essas alterações.

Você também pode atualizar uma ou mais bibliotecas específicas, especificando-as desta forma:

composer update vendor/package vendor2/package2
Certifique-se de verificar em seus arquivos composer.json e composer.lock dentro do seu sistema de controle de versão após atualizar suas dependências de modo que outros também possam instalar essas versões mais recentes.








INÍCIO:

1 instalar o docker

2 abrir wsl2/Windows ou linux
 curl -s "https://laravel.build/olw?with=mysql,redis,mailhog,minio" | bash

3 cd olw
./vendor/bin/sail up -d
	ou
4 cd olw && ./vendor/bin/sail up -d

5 ATRIBUINDO PERMISSÃO PARA A PASTA
cd .. -> sai da pasta
sudo chmod 777 olw/ -R ou sem o 'sudo' chmod 777 olw/ -R

6 CRIANDO ALIAS PARA O COMANDO ANTERIOR
alias sail='[ -f sail ] && sh sail || sh vendor/bin/sail'
passa a usar assim: sail ps

7 CONFIGURAR PORTAS PARA A APLICAÇÃO NO NAVEGADOR E MYSQL
.env
APP_PORT=8000

*porta do myql
FORWARD_DB_PORT=3307

8 INSTALANDO DEPENDÊNCIA AO PROJETO
./vendor/bin/sail composer require laravel/breeze --dev

9 DEIXAR TELA DE AUTENTICAÇÃO PRONTA, ROTA AUTENTICADA, TAWINDCSS INSTALADO E INERTIA INSTALADO
./vendor/bin/sail artisan breeze:install vue 
ou
./vendor/bin/sail art breeze:install vue


10 RODAR AS MIGRATES PADRÕES DO PROJETO AI JÁ PODE CADASTRAR USUÁRIOS PARA LOGIN:
./vendor/bin/sail art migrate

11 


/*******************************************/
2a AULA:

O PROJETO CONSISTE EM RECEBER DADOS DE UMA API (punkapi.com) DE INFORMAÇÕES SOBRE CERVEJAS, VAMOS CONSTRUIR AS ROTAS PARA CONSUMIR A API E CRIAR A ESTRUTURA PARA O RELATÓRIO QUE IREMOS GERAR EM EXCEL E ENVIAR PARA O STORAGE...
1 CRIAR ROTAS:
code .
olw/routes/web.php


sail up -d -> SOBE O CONTAINER localhost:8000 (nesse projeto)

Route::get('/beers', fn()=> 'Olw - testando a rota /beers');

**************************************************
obs:
- laravel.com/api -> acesso a documentação do código;
- in line paramets for vscode -> extensão para vscode para exibir o nome dos métodos na hora que codificar;
- fira code -> extensão para fonte no vscode

git Hub Copilot vs Tabnine -> (pesquisar sobre)
Link para extensões vscode:
https://github.com/icarojobs/vscode-useful-extensions
*************************************************


Route::get('/beers', fn()=> 'Olw - testando a rota /beers')
                             ->middleware(['auth']);

* FLUXO PADRÃO DO MVC-LARAVEL: 
life cicle: sai do usuário pelo navegador, insomnia ou postman -> passa pelo index.php(pasta public) -> passa pelos arquivos do bootstrap retornando uma instância da aplicação -> passa pelo kernel do http (carrega mais instâncias) -> Service provider -> despacha a requisição pro Router -> Cai no arquivo Web.php -> Middleware (se tiver, geralmente tem os globais) -> Controller (faz as regras de negócio e pode chamar outras classes como Serviços por exemplo)
-> Retorna uma view ou um json (No caso estamos usando inértia, ele não vai reinderizar a 'view.blade' padrão, ele vai reinderizar componente vue.js através do inértia.).


* EM VEZ DE USAR A FUNÇÃO AQUI NA ROTA CRIAMOS UM CONTROLLER:

obs.: ​dica: php artisan make:controller -r cria o Resource também.
dica: limpar o cache do container:
./vendor/bin/sail art config:cache
./vendor/bin/sail art optimize:clear


sail artisan make:controller BeerController
ou 
sail art make:controller BeerController -> CRIA O ARQUIVO BeerController.php na pasta app/Http/Controllers
->
<?php

namespace App\Http\Controllers;

use Illuminate\Http\Request;

class BeerController extends Controller
{
    public function index()
    {
    return 'Virgu & Beer & Code'
    }
}

* NO ARQUIVO DE ROTAS Web.php CHAMA O BeersController:

importante importar o Controller <nomeDoController>+<CTRL=ENTER:
use App\Http\Controllers\BeerController;

Route::get('/beers', [BeerController::class, 'index'])
                        ->middleware(['auth']);


* PRECISAMOS CRIAR UM MÉTODO PARA PEGAR A LISTA, LISTAR OS DADOS DA API (listar as bebidas de https://api.punkapi.com/v2 ->
VAMOS CRIAR UMA NOVA CLASSE de serviços em app/Sevices/PunkapiService.php

* O LARAVEL POSSUI UM RECURSO CHAMADO HTTPClient que abstrai o uso de uma ferramenta chama guzeo, esse guzeo é o client http mais comum para php, com ele fazemos requisições pra diversos serviços web dentro do php para outras url, ele é robusto, então o laravel simplifica importando o recurso que faz tudo por 'detrás dos panos':

PunkapiService.php

<?php

namespace App\Services;

use Illuminate\Support\Facades\Http;

class PunkapiService
{
    public function getBeers()
    {
        return Http::get('https://api.punkapi.com/v2/beers');
    }
}

E NO BeerController.php fica:
<?php

namespace App\Http\Controllers;

use App\Services\PunkapiService;
use Illuminate\Http\Request;

class BeerController extends Controller
{
    public function index()
    {
    //return 'Virgu & Beer & Code';
    $service = new PunkapiService;

    return $service->getBeers();
    }
}

* TRATE É CARACTERÍSTICA QUE A CLASSE ADQUIRE (pode ter mesmos métodos e atributos substituindo o recurso de um classe extender várias classes que não tem no php, a trate é uma forma de fazer isso. O service  é uma outra camada na maioria das vezes abstrair seviços que vc vai consumir, por exemplo API.

Estando logado, os dados da api já serão exibidos em localhost:8000/beers, se usar um aplicativo cliente tipo insomnia pode apresentar os dados também, melhor comentar a linha de de autenticação da rota:
Route::get('/beers', [BeerController::class, 'index']);
linha de autenticação da rota // ->middleware(['auth']);

* ESSA API PERMITE FAZER FILTROS VIA PARÂMETROS NA PRÓPRIA ROTA. PRIMEIRO VAMOS REFATORAR O CÓDIO, A CLASSE PunkapiService.php:

USO DE CONFIG E MACRO


Vamos alterar a url, primeiro acessando a pasta config da raiz do projeto e criar o arquivo punkapi.php. O que acontece é que o config(pasta config da raiz) carrega todos os arquivos da pasta e permite que sejam acessados via funções simples(HELPERS), isso é muito legal porque podemos acessar esses arquivos de configurações de qualquer lugar do projeto: 

<?php

return [
    'url' => env('PUNK_BASE_URL', 'https://api.punkapi.com/v2')
];

Usando o helper env significa dizer que, se não houver a constante PUNK_BASE_URL setada no arquivo .env do projeto, seu valor será o segundo parâmetro: http://api.punkapi.com/v2 e no arquivo PunkapiService.php da pasta app/Services fica:

<?php

namespace App\Services;

use Illuminate\Support\Facades\Http;

class PunkapiService
{
    public function getBeers()
    {
        return Http::get('/beers');
    }
}

MACRO é uma forma de criar funções customizadas:
 em app\Providers vamos acessar o arquivo AppServiceProvider.php que é uma classe que tem dois métodos register e boot. No método boot vamos chamar o método Http do laravel e chamar o método macro, no primeiro parâmetro será um nome atribuído à função e e o segundo uma clausure (uma função).
Neste arquivo é passado o arquivo de configuração da url (em 'config/punkapi.php') além de tokens, headers,...
 

use Illuminate\Support\Facades\Http; -> deve ser importado
E a função boot fica:

  public function boot()
    {
        Http::macro('punkapi', function(){
            return Http::acceptJson()
            ->baseUrl(config('punkapi.url'));
        });
    }

Então criamos uma macro(uma função customizada) chamada punkapi que já retorna o client com accept/Json no Header e com o baseUrl configurado lá do arquivo /config/punkapi.php e se estiver setado no .env pegará de lá.

/app/Services/PunkapiService.php fica:

<?php

namespace App\Services;

use Illuminate\Support\Facades\Http;

class PunkapiService
{
    public function getBeers()
    {
        return Http::punkapi()->get('/beers');
    }
}

*obs.: a baseUrl poderia ser setada no construtor, que pode setar token também.(uma outra abordagem para versão sem macros);

->Testamos o retorno Json em localhost:8000/beers.

Refatorando o arquivo PunkapiService.php: O client Http não lança exceção e podemos forçar o retorno em modo Json:
<?php

namespace App\Services;

use Illuminate\Support\Facades\Http;

class PunkapiService
{
    public function getBeers()
    {
       // return Http::punkapi()->get('/beers');
       return Http::punkapi()
            ->get('/beers')
            ->throw()  // Exceção em caso de erro
            ->json();   // Força o retorno em formato Json
    }
}

Podemos testar forçando um erro alterando a constante PUNKAPI_BASE_URL criada em /config/punkapi.php, vamos atribuir um valor diferente no arquivo .env:

PUNKAPI_BASE_URL="adfjklj878"

Podemos usar a função retry tem dois parâmetros, o número de tentativas pra buscar a requisição e o intervalo entre elas. Refatorando o código fica:
<?php

namespace App\Services;

use Illuminate\Support\Facades\Http;

class PunkapiService
{
    public function getBeers()
    {
       // return Http::punkapi()->get('/beers');
       return Http::punkapi()
            ->get('/beers')
            ->throw()  // Exceção em caso de erro
            ->json();   // Força o retorno em formato Json
    }
}

- Quando sai a exceção nao deveriamos retornar o erro em json por ser um api neste caso estamos usamos um app web e não uma api. E usaríamos o Route Api.

Refatorando o método boot de /app/Providers/AppServiceProvider.php, inserindo o retry():

     */
    public function boot()
    {
        Http::macro('punkapi', function(){
            return Http::acceptJson()
            ->baseUrl(config('punkapi.url'))
            ->retry(3,100);
        });
    }
}

comando de help

* ./vendor/bin/sail composer dump-autoload
* Verificar Nome do arquivo se bate com o nome das rotas(Classes criadas e importar o nome errado);
* inteliphense

Refatorando BeerController.php
<?php

namespace App\Http\Controllers;

use App\Services\PunkapiService;

class BeerController extends Controller
{
    public function index()
    {

    $service = new PunkapiService();

    return $service->getBeers();
    }
}

Em vez de instanciar o método PunkapiService() dentro de index, vamos passar por parâmetro de index() declarando seu Próprio nome (PunkapiService) como tipo. Fica assim:

<?php

namespace App\Http\Controllers;

use App\Services\PunkapiService;

class BeerController extends Controller
{
    public function index(PunkapiService $service)
    {
    return $service->getBeers();
    }
}

Assim usamos feactures do php(injeção de dependências) e ao mesmo tempo feactures do laravel. Em vez de criar uma instância dentro do método index, vamos injetar a classe como parâmetro para o método index(), ficando index($service) e a instância de dentro da função passa como parâmetro de 'tipo da variável'. Isso quebra a cadeia de dependência entre as classes.
Assim, o método index ganha independência não mais dependendo da instância de new PunkapiService e passamos a olhar a função index em si.
Assim, o Laravel tenta fazer um binding, um match, o laravel tenta encontrar alguma classe PunkapiService e cria uma instância dessa classe e usa ali como parâmetro. Se não fizer assim, lá em Rotas teria que ser passado como parâmetro o que fica desnecessário.
Não poderia ser feito se na classe PunkapiService existisse o construtor para atribuir valores automaticamente à classe. Assim podemos usar porque não precisamos passar nenhum valor.

ADICIONAR OS FILTROS:
Vamos filtrar o retorno api com os seguintes itens: beer_name, food, ibu_gt, malte:

var_dump($v)
die();
dd($variável)
benchmarck -> ?

/*****REFATORA PARA TESTE alterando BeerController.php e PunkapiService.php
BeerController.php
<?php

namespace App\Http\Controllers;

use App\Services\PunkapiService;

class BeerController extends Controller
{
    public function index(PunkapiService $service)
    {
    return $service->getBeers(
        'heineken',
        'cheese',
        'corn',
        45
    );
    }
}

PunkapiService.php
<?php

namespace App\Services;

use Illuminate\Support\Facades\Http;

class PunkapiService
{
    public function getBeers(
        string $beer_name,
        string $food,
        string $malt,
        string $ibu_gt
    )
    {
        $params = get_defined_vars();

        dd($params);

        return Http::punkapi()
            ->get('/beers', $params)
            ->throw()  // Exceção em caso de erro
            ->json();   // Força o retorno em formato Json
    }
}

Resultado do debug no insomnia ou no navegador:
array:4 [▼ // app/Services/PunkapiService.php:18
  "beer_name" => "heineken"
  "food" => "cheese"
  "malt" => "corn"
  "ibu_gt" => "45"
]
//* fim teste

Refatorando:

class PunkapiService
{
    public function getBeers(
        string $beer_name = null,
        string $food = null,
        string $malt = null,
        string $ibu_gt = null
    )
    {
        $params = get_defined_vars();

        dd($params);

        return Http::punkapi()
            ->get('/beers', $params)
            ->throw()  // Exceção em caso de erro
            ->json();   // Força o retorno em formato Json
    }
}

Assim quando não passar o valor para a chave ele exibirá a chave e o valor Null, vamos refatorar para não exibir nem a chave englobando get_defined_vers() com array_filter no arquivo PunkapiService.php:

$params = array_filter(get_defined_vars());

<?php

namespace App\Http\Controllers;

use App\Services\PunkapiService;

class BeerController extends Controller
{
    public function index(PunkapiService $service)
    {
    return $service->getBeers(
        'heineken',
        'cheese',
        'corn',
       // 45 -> Esse não é passado
    );
    }
}


array:3 [▼ // app/Services/PunkapiService.php:18
  "beer_name" => "heineken"
  "food" => "cheese"
  "malt" => "corn"
	Aqui não exibiu o valor 45
]


USANDO A FUNÇÃO NAMED_ARGS passamos só os parâmetros que precisamos retornar da api e o php com essa função saberá qual a posição dela no array de argumentos passados como parâmetro sem a necessidade de seguir a mesma sequência dos argumentos:
class BeerController extends Controller
{
    public function index(PunkapiService $service)
    {
    return $service->getBeers(food: 'cheese');
    }
}

REFATORANDO:
BeerController.php
<?php

namespace App\Http\Controllers;

use App\Services\PunkapiService;
use Illuminate\Http\Request;

class BeerController extends Controller
{
    public function index( Request $request, PunkapiService $service)
    {
    return $service->getBeers(...$request->all());
    }
}

PunkapiService.php
<?php

namespace App\Services;

use Illuminate\Support\Facades\Http;

class PunkapiService
{
    public function getBeers(
        string $beer_name = null,
        string $food = null,
        string $malt = null,
        string $ibu_gt = null
    )
    {
        $params = array_filter(get_defined_vars());

     //   dd($params);

        return Http::punkapi()
            ->get('/beers', $params)
            ->throw()  // Exceção em caso de erro
            ->json();   // Força o retorno em formato Json
    }
}

CRIANDO UMA REQUEST
sail artisan make:request BeerRequest
/app/Http/Requests/BeerRequest.php

* Funções anônimas, também conhecidas como closures , permitem a criação de funções que não tem o nome especificado. Elas são mais úteis como o valor de parâmetros callable, mas podem ter vários outros usos.. É uma função passada como parâmetro

CRIANDO NOVA ROTA PARA SALVAR COMO EXCEL
* https://docs.laravel-excel.com/3.1/getting-started/installation.html

Route::group([
    'prefix' => 'beers',
], function() {

    Route::get('/', [BeerController::class, 'index']); //-> Se houver necessidade de salvar dados por essa rota mudamos o método(verbo html) para post(os dados não serão expostos na url).
                          //  ->middleware(['auth']);
    Route::get('/export', [BeerController::class, 'export']);

});

Então passamos a ter duas rotas: localhost:8000/beers
localhost:8000/beers/export

No BeerController incluimos o método export():
class BeerController extends Controller
{
    public function index( BeerRequest $request, PunkapiService $service)
    {
    // return $service->getBeers(...$request->all());
    return $service->getBeers(...$request->validated());
    }

    public function export()
    {
        return 'Relatório criado.';
    }
}



INSTALANDO PACOTE LARAVEL-EXCEL PARA GERAR OS RELATÓRIO EM EXCEL FILTRADOS DA API:

* https://docs.laravel-excel.com/3.1/getting-started/installation.html

COMANDO PARA INSTALAR VIA COMPOSER:
./vendor/bin/sail composer require psr/simple-cache:^2.0 maatwebsite/excel

CRIAR A CLASSE DO EXCEL
./vendor/bin/sail artisan make:export BeerExport  --> Cria o arquivo em  /app/Exports/BeerExport.php

<?php

namespace App\Exports;

use Maatwebsite\Excel\Concerns\FromCollection;

class BeerExport implements FromCollection
{


    /**
    * @return \I¢lluminate\Support\Collection
    */
    public function collection()
    {
        //
    }
}

-> Dentro de colletion buscaremos as informações que serão salvas no arquivo do excel, um array de dados;

criamos um __construct() que vai ter uma propriedade privada do tipo array chamamos de $reportData.

O retorn será uma collection como informa o comentário:
 /**
    * @return \I¢lluminate\Support\Collection
    */

Na função colletion(), está recebendo um array return $this->reportData; 
Observe que não precisa mais declarar uma propriedade que vai se setada via construct(), basta defifinir o escopo junto do argumento e o php faz isso pra você. Como o retorno da função é um array usamos o helper collect para o $this->reportData:

BeerExport.php

<?php

namespace App\Exports;

use Maatwebsite\Excel\Concerns\FromCollection;

class BeerExport implements FromCollection
{

    public function __construct(
        private array $reportData
    ){}

    /**
    * @return \Illuminate\Support\Collection
    */
    public function collection()
    {
       return collect($this->reportData);
    }
}
 

Consultamos a documentação do Laravel-excel em 'Exporting collections':
em Excel Store passa o nome da classe e o nome do arquivo:

BeerController.php
<?php

namespace App\Http\Controllers;


use App\Exports\BeerExport;
use App\Http\Requests\BeerRequest;
use App\Services\PunkapiService;
use Maatwebsite\Excel\Facades\Excel;


class BeerController extends Controller
{
    public function index( BeerRequest $request, PunkapiService $service)
    {
    // return $service->getBeers(...$request->all());
    return $service->getBeers(...$request->validated());
    }

    public function export()
    {
      $params = [
        ['name' => 'Tom', 'age' => '30'],
        ['name' => 'Virgu', 'age' => '27']
       ];

       Excel::store(new BeerExport($params), 'olw-report.xlsx');
       return "Relatório criado";

    }


}

********************************************
* REFATORANDO E SALVANDO O ARQUIVO EXCEL EM /storage/app

BeerExport.php
<?php

namespace App\Exports;

use Maatwebsite\Excel\Concerns\FromCollection;

class BeerExport implements FromCollection
{

    public function __construct(
        private array $reportData
    ){}

    /**
    * @return \Illuminate\Support\Collection
    */
    public function collection()
    {
       return collect($this->reportData);
    }
}
*****************************

BeerController.php

<?php

namespace App\Http\Controllers;


use App\Exports\BeerExport;
use App\Http\Requests\BeerRequest;
use App\Services\PunkapiService;
use Maatwebsite\Excel\Facades\Excel;


class BeerController extends Controller
{
    public function index( BeerRequest $request, PunkapiService $service)
    {
        return $service->getBeers(...$request->all());

    }

    public function export(BeerRequest $request, PunkapiService $service)
    {
        $beers = $service->getBeers(...$request->validated());

        $filteredBeers = collect($beers)->map(function($value, $key){
        return collect($value)
                ->only(['name', 'tagline', 'first_brewed', 'description'])
                ->toArray();
    })->toArray();

    //dd($filteredBeers);

      $params = [
        ['name' => 'Tom', 'age' => '30'],
        ['name' => 'Virgu', 'age' => '27']
       ];

       Excel::store(new BeerExport($filteredBeers), 'olw-report.xlsx');

           return "Relatório criado";

    }


}

PARA SALVAR O ARQUIVO EXCEL EM UM STORAGE S3:
ALTERA BeerController.php

<?php

namespace App\Http\Controllers;


use App\Exports\BeerExport;
use App\Http\Requests\BeerRequest;
use App\Services\PunkapiService;
use Maatwebsite\Excel\Facades\Excel;


class BeerController extends Controller
{
    public function index( BeerRequest $request, PunkapiService $service)
    {
        return $service->getBeers(...$request->all());

    }

    public function export(BeerRequest $request, PunkapiService $service)
    {
        $beers = $service->getBeers(...$request->validated());

        $filteredBeers = collect($beers)->map(function($value, $key){
        return collect($value)
                ->only(['name', 'tagline', 'first_brewed', 'description'])
                ->toArray();
    })->toArray();


       Excel::store(
            new BeerExport($filteredBeers),
             'olw-report.xlsx',
             's3');

           return "Relatório criado";

    }


}

************
O REPOSITÓRIO DE ARQUIVOS minio:
NO DOCKER COMPOSER TEMOS O minio, um S3 que tem
MINIO_ROOT_USER: 'sail'
MINIO_ROOT_PASSWORD: 'password' e roda na porta 9000
localhost:9000
usuário: sail
senha: password

vamos criar um buncket(uma pasta)

e configurar o .env da raiz da aplicação:
originalmente é assim:
AWS_ACCESS_KEY_ID=
AWS_SECRET_ACCESS_KEY=
AWS_DEFAULT_REGION=us-east-1
AWS_BUCKET=
AWS_USE_PATH_STYLE_ENDPOINT=false

 e acrescentamos as informações para:


AWS_ACCESS_KEY_ID=sail
AWS_SECRET_ACCESS_KEY=password
AWS_DEFAULT_REGION=us-east-1
AWS_BUCKET=local
AWS_ENDPOINT=http://minio:9000
AWS_URL=http://minio:9000/local
AWS_USE_PATH_STYLE_ENDPOINT=true

altera tambem:

FILESYSTEM_DISK=local 
para:
FILESYSTEM_DISK=s3

INSTALAR UMA DEPENDÊNCIA (ADAPTER) PARA FAZER CORRESPONDÊNCIA COM A AWS:

Flysystem 3.x em laravel.com/docs/9.x/upgrade
./vendor/bin/sail composer require -W league/flysystem-aws-s3-v3 "^3.0"

em caso de erro:
 artisan vendor:publish --tag=laravel-assets --ansi --force

.env
APP_NAME=Laravel
APP_ENV=local
APP_KEY=base64:UbVvTP6Cu+LF5GamJdB4dsZZvW05ep4bZqcCEhmiDCg=
APP_DEBUG=true
APP_URL=http://localhost
APP_PORT=8000

# PUNKAPI_BASE_URL="httpadfjkljdsdfdfasf878"

LOG_CHANNEL=stack
LOG_DEPRECATIONS_CHANNEL=null
LOG_LEVEL=debug

DB_CONNECTION=mysql
FORWARD_DB_PORT=3307
DB_HOST=mysql
DB_PORT=3306
DB_DATABASE=olw
DB_USERNAME=sail
DB_PASSWORD=password

BROADCAST_DRIVER=log
CACHE_DRIVER=file
FILESYSTEM_DISK=s3
QUEUE_CONNECTION=sync
SESSION_DRIVER=file
SESSION_LIFETIME=120

MEMCACHED_HOST=memcached

REDIS_HOST=redis
REDIS_PASSWORD=null
REDIS_PORT=6379

MAIL_MAILER=smtp
MAIL_HOST=mailhog
MAIL_PORT=1025
MAIL_USERNAME=null
MAIL_PASSWORD=null
MAIL_ENCRYPTION=null
MAIL_FROM_ADDRESS="hello@example.com"
MAIL_FROM_NAME="${APP_NAME}"

AWS_ACCESS_KEY_ID=sail
AWS_SECRET_ACCESS_KEY=password
AWS_DEFAULT_REGION=us-east-1
AWS_BUCKET=local
AWS_ENDPOINT=http://minio:9000
AWS_URL=http://minio:9000/local
AWS_USE_PATH_STYLE_ENDPOINT=true

PUSHER_APP_ID=
PUSHER_APP_KEY=
PUSHER_APP_SECRET=
PUSHER_HOST=
PUSHER_PORT=443
PUSHER_SCHEME=https
PUSHER_APP_CLUSTER=mt1

VITE_PUSHER_APP_KEY="${PUSHER_APP_KEY}"
VITE_PUSHER_HOST="${PUSHER_HOST}"
VITE_PUSHER_PORT="${PUSHER_PORT}"
VITE_PUSHER_SCHEME="${PUSHER_SCHEME}"
VITE_PUSHER_APP_CLUSTER="${PUSHER_APP_CLUSTER}"

PRONTO. ENVIANDO PARA O MINIO.


### /**** ABAIXO AULA DE FRONT END -> FALTA
virgu 3a. aula seed model factory

olw# sail art make:migration create_history_table
/olw# sail art make:model Export -mr

/olw# sail art migrate:fresh --seed ->


























 







/***********************************************************
QUINTA FEIRA: 20/10/22

Open Laravel Week | Deploy com Terraform, EC2 e RDS | Fermentação

****
https://portal.aws.amazon.com/billing/signup?nc2=h_ct&src=header_signup&redirect_url=https%3A%2F%2Faws.amazon.com%2Fregistration-confirmation&language=pt_br#/start/email

Com terraform pode mudar de infra e configurar no git.

PROGRMAR A CONFIGURAÇÃO DO SERVIDOR: É basicamente construir uma nova aplicação para fazer isso, mais fácil de entender.
Terraform serve para (linguagem HCL -> linguagem própria - linguagem descritiva, descreve o resultado e não como irá ser feito), ou seja, descrever o que queremos.
Terraspace é o framework pra terraform.
Quando criamos o Terraform, ele pode variar conforme a infra cloud (aws, azure, google cloud). sua estrutura é a mesma para todos. mas cada provider tem a sua forma de usar, não consegue usar o mesmo código para mais de uma cloud.
Vamos rodar Terraform via container:

1. clonar do git: git clone 
Criar uma pasta para a infraestrutura

sail   (script que vamos usar)
#!/usr/bin/env bash

docker run -rm -it
	-u $(id -u):$(id -g) \
	-v $PWD:/workspace \
	-w /workspace
	hashicorp/terraform:light "%@"


	<no terminal

Logar em: aws.amazon.com
busca: iam
iam dashboard -> mysecurity credencials (root user) -> Acces keys ->clicar em create access keys -> salva o access key e secret access key
e coloca no arquivo credencials na maquina local.. .aws/credencials
















































//////////////////////////////////////////////////////////////////////////////////////////////////////
CONTEÚDO QUE FALTA ORGANIZAR:



/**************************************/

sail share

sail artisan sail:publish ->coloca em uma pasta na raiz chamada docker

sail --help

sail artisan optimizer:clear

sail ps

sail build --no-cache -> faz o bild da aplicação. (dá um sail down  por precaução antes.)










/*********************************

root@DELLAGS:~# curl -s "https://laravel.build/laravel-9-course?with=mysql,redis,mailhog" | bash

Dockerfile

root@DELLAGS:~/example-app# docker exec -it example-app-mysql-1 bash


FROM wyveo/nginx-php-fpm:latest
WORKDIR /usr/share/nginx
RUN rm -rf /usr/share/nginx/html
COPY . /usr/share/nginx
RUN chmod -R 755 /usr/share/nginx/storage/*
RUN ln -s public html

.env (do composer)

DB_CONNECTION=mysql
DB_HOST=mysql-app (serviço do mysql no docker-compose.yaml)
DB_PORT=3306
DB_DATABASE=laraveldockerdb
DB_USERNAME=root
DB_PASSWORD=123456



docker-compose.yaml

version: '3'

services:
  laraveldocker-app:
    build: .
    ports:
      - "3003:80"
    volumes:
      - ./:/usr/share/nginx
      - .docker/nginx:/etc/nginx/conf.d/
    networks:
      - app-network
  mysql-app:
    image: mysql:5.7.22
    ports:
      - "3306:3306"
    volumes:
      - .docker/dbdata:/var/lib/mysql
    environment:
      MYSQL_DATABASE: laraveldocker
      MYSQL_ROOT_PASSWORD: 123456
    networks:
      - app-network
networks:
  app-network:
    driver: bridge
    



/*************************************************
#criando um serviço com um nome qualquer
version: '3'

services:
  laravel-app:                    #criando um serviço com um nome qualquer
    build: . ou image: wyveo/nginx-php-fpm:latest -> neste caso sem Dockerfile.                    # endereço da imagem ou local do Dockerfile (neste caso o ponto siginifica a raiz do projeto)
    ports:
      - "8080:80"                 # 8080 porta do meu host: 80 é a porta do docker nginx
    volumes:                      # docker-compose up -d -> sobe a imagem e libera o terminal  
      - ./:/usr/share/nginx       # TUDO QUE ESTIVE NA RAIZ (na rais tem o meu projeto laravel) './' IRÁ SER REFLETIDO NA PASTA /usr/share/nginx (pasta de acesso da página html)
                                  # C:\Laravel-docker\laravel-docker>docker compose up -d --build atualiza a minha imagem

  mysql-app:
      image: mysql:5.7
      ports:
        - "3306:3306"
      volumes:
        - .docker/dbdata:/var/lib/mysql          # qualqer nome (para persistir -guardar os dados do banco de dados)


      environment:
        MYSQL_DATABASE: laravel
        MYSQL_ROOT_PASSWORD: laravel
    
      

      /***************************///


  
C:\Laravel-docker\laravel-docker>docker compose up -d --build

                                
                               

    

/******************************** Dockerfile
FROM wyveo/nginx-php-fpm:latest

/***************************///
  COMANDOS

docker compose down -> para todos os containers
C:\Laravel-docker\laravel-docker>docker exec -it laravel-docker-laravel-app-1 bash 
root@612ea0ea3340:/# cd /usr/share/nginx/
root@612ea0ea3340:/usr/share/nginx# php artisan migrate
root@612ea0ea3340:/usr/share/nginx# php artisan serve

		
/***********/
PS C:\Users\alber> docker run -e MYSQL_ROOT_PASSWORD=root --name meu-mysql -d mysql:5.7

docker inspect meu-mysql ou | grep IPAddress

PS C:\Users\alber> docker run -e MYSQL_ROOT_PASSWORD=root --name meu-mysql -d -p 3306:3306 mysql:5.7

docker ps
docker ps -l
docker ps -a
docker rm -f nome


/*** LARAVEL */
### CRIANDO UM PROJETO NO LARAVEL 
laravel new projeto_laravel_via_installer (ESTA É UM AOPÇÃO)
composer create-project --prefer-dist laravel/laravel app_controle_tarefas "8.5.9"
cd app_controle_tarefas
cd public
php -S localhost:8000

ou 
da raiz do projeto:
php artisan serve 
ou
php artisan serve --port=3000

### PARA ABRIR PORTA EM OUTRO SERVIDOR
php artisan serve --host test.com --port 8080

 **********************************************************************
cd app_controle_tarefas
cd public
php artisan serve
- acessa o navegador http://localhost:8000

### DENTRO DO PROJETO CRIADO INSTALAR O LARAVEL/UI:^3.2 - versão 3.2
composer require laravel/ui:^3.2

### SE OCORRER ERRO AUMENTAR A MEMÓRIA DISPONIVEL PARA O php

-php --ini -> localiza o arquivo de configuração do php
LOCALIZA memory_limit = 1000 e altera para 
         memory_limit  = -1 e Salva

### LISTA A RELAÇÃO DE COMANDOS 
php artisan list 

DEVERA SURGIR AS OPÇÕES ABAIXO:

 ui
  ui:auth               Scaffold basic login and registration views and routes
  ui:controllers        Scaffold the authentication controllers
 vendor

### ENTENDENDO O PACOTE UI E INICIANDO A AUTENTICAÇÃO WEB NATIVA DO LARAVEL

COMANDO PARA LISTAR ROUTES: 
php artisan route:list

### php artisan ui bootstrap --auth (bootstrap ou react ou vue)
aplicando o bootstrap incluindo os recursos de autenticação;
poderia ser aplicado o bootstrap sem os recursos de autenticação;

### php artisan route:list -> mostra as rotas - ver que aumentaram as rotas

### APÓS ESSE PROCESSO O SISTEMA PEDE PARA RODAR
npm install -> instala as dependências do package.json (inclusive o bootstrap)
npm run dev -> gera os assets da aplicação de acordo com a tecnologia selecionada (bootstrap, react ou vue) -> Geralmente roda mais de uma vez para compilar tudo.

### CRIA O BANCO DE DADOS NORMALMENTE

### EXECUTA AS MIGRATIONS PADRÕES CRIADAS PARA O SISTEMA DE login
php artisan migrate -> CRIA AS TABELAS NO BANCO DE DADOS


************************************** 
INSTALANDO O COMPOSER NO UBUNTU
**************************************
sudo apt update
sudo apt install php-cli unzip

cd ~

curl -sS https://getcomposer.org/installer -o composer-setup.php

HASH=`curl -sS https://composer.github.io/installer.sig`

echo $HASH ->saída: Output
e0012edf3e80b6978849f5eff0d4b4e4c79ff1609dd1e613307e16318854d24ae64f26d17af3ef0bf7cfb710ca74



php -r "if (hash_file('SHA384', 'composer-setup.php') === '$HASH') { echo 'Installer verified'; } else { echo 'Installer corrupt'; unlink('composer-setup.php'); } echo PHP_EOL;"

sudo php composer-setup.php --install-dir=/usr/local/bin --filename=composer





***********************

DigitalOcean Kubernetes: novo plano de controle é mais rápido e gratuito, habilita HA para SLA de 99,95% de tempo de atividade
Produtos
Preços

Documentos
divisa suspensa

Entrar
divisa suspensa

// Tutorial //
Como Instalar e Utilizar o Composer no Ubuntu 20.04
Publicado em 21 de maio de 2020
Ubuntu
PHP
Ubuntu 20.04
Avatar padrão
Por Erika Heidi
Advogado Desenvolvedor
Português
Como Instalar e Utilizar o Composer no Ubuntu 20.04
Introdução
O Composer é uma ferramenta popular de gerenciamento de dependências para o PHP, criado para facilitar a instalação e a atualização das dependências principalmente do projeto. Ele controla quais outros pacotes de projeto específico dependem e são instalados para você, usando as opções apropriadas de acordo com os requisitos do projeto. O Composer também é comumente utilizado para inicializar novos projetos em frameworks PHP populares, como o Symfon e o Laravel .

Neste tutorial, você instalará e começará a usar o Composer em um sistema Ubuntu 20.04.

Pré-requisitos
Para seguir este guia, você pode acessar um servidor como usuário Ubuntu20.04 como usuário sudonão-root um firewall habilitado em seu servidor Para configurar isto, siga nosso guia Configuração do servidor inicial para o Ubuntu 20.04

Passo 1 — Instalando o PHP e as Dependências Adicionais
Além das dependências que já devem estar incluídas em seu sistema Ubuntu 20.04, como o , o Composer exige ou gitexecuta scripts PHP na linha de comando e para extrair arquivos zipados. Vamos instalar essas dependências agora.curlphp-cliunzip

primeiro, atual, gerenciador de pacotes de soluções: o cache do gerenciador de pacotes

sudo apt update
Em seguida, o seguinte comando para instalar os pacotes, execute:

sudo apt install php-cli unzip
Você será solicitado a confirmar a instalação digitando Ye, depois, ENTER.

Assim que os pré-requisitos para instalação do Composer forem instalados, você poderá seguir.

Passo 2 — Baixando e Instalando o Compositor
O Composer fornece um instalador de script escrito em PHP. Vamos baixá-lo, verificar se ele não está danificado e, em seguida, o usaremos para instalar o Composer.

Certifique-se de estar em sua pasta home. Em seguida, baixe o instalador usando o curl:

cd ~
curl -sS https://getcomposer.org/installer -o composer-setup.php
Em seguida, vamos verificar se o instalador baixado corresponde ao hash SHA-384 para o instalador mais recente encontrado na página Composer Public Keys / Signatures . Para facilitar o passo de seleção, você pode usar o seguinte comando para obter programaticamente o hash mais recente da página do Composer e armazená-lo em uma variável do shell:

HASH=`curl -sS https://composer.github.io/installer.sig`
Se você quiser verificar o valor realizado, execute:

echo $HASH
Output
e0012edf3e80b6978849f5eff0d4b4e4c79ff1609dd1e613307e16318854d24ae64f26d17af3ef0bf7cfb710ca74755a
Agora o código PHP a seguir, execute conforme a página de download do Composer, para verificar se o script de instalação está seguro para ser executado:

php -r "if (hash_file('SHA384', 'composer-setup.php') === '$HASH') { echo 'Installer verified'; } else { echo 'Installer corrupt'; unlink('composer-setup.php'); } echo PHP_EOL;"
Você verá o seguinte resultado:

Resultado
Installer verified
Se Installer corruptvocê estiver usando o hash correto, verifique se você está usando o hash correto. Em seguida, repita o processo de verificação. Quando você tiver um instalador selecionado, você pode continuar.

Para instalar o composerglobalmente, use o seguinte comando que baixará e instalará o Composer como um comando disponível em todo o sistema chamado composer, sob /usr/local/bin:

sudo php composer-setup.php --install-dir=/usr/local/bin --filename=composer
Você verá um resultado semelhante com este:

Output
All settings correct for using Composer
Downloading...

Composer (version 1.10.5) successfully installed to: /usr/local/bin/composer
Use it: php /usr/local/bin/composer
Para testar sua instalação, execute:

composer
Output
   ______
  / ____/___  ____ ___  ____  ____  ________  _____
 / /   / __ \/ __ `__ \/ __ \/ __ \/ ___/ _ \/ ___/
/ /___/ /_/ / / / / / / /_/ / /_/ (__  )  __/ /
\____/\____/_/ /_/ /_/ .___/\____/____/\___/_/
                    /_/
Composer version 1.10.5 2020-04-10 11:44:22

Usage:
  command [options] [arguments]

Options:
  -h, --help                     Display this help message
  -q, --quiet                    Do not output any message
  -V, --version                  Display this application version
      --ansi                     Force ANSI output
      --no-ansi                  Disable ANSI output
  -n, --no-interaction           Do not ask any interactive question
      --profile                  Display timing and memory usage information
      --no-plugins               Whether to disable plugins.
  -d, --working-dir=WORKING-DIR  If specified, use the given directory as working directory.
      --no-cache                 Prevent use of the cache
  -v|vv|vvv, --verbose           Increase the verbosity of messages: 1 for normal output, 2 for more verbose output and 3 for debug
...
Isso verifica que o Composer foi instalado com sucesso em seu sistema e está disponível em todo o sistema.

Nota: se você preferirá ter-lhe-ão separados separados do Composer para projeto hospedado neste servidor, você pode instalar localmente, em uma base por projeto. Este método também é útil quando o usuário do sistema não possui permissão para instalar o software disponível em todo o sistema.

Para fazer isso, use o comando php composer-setup.php. Isso irá gerar um arquivo composer.pharem seu diretório atual, que pode ser executado com o seu atual php composer.phar.

Agora podemos dar uma dependência em como usar o Compose como gerenciar.

Passo 3 — Usando o Compositor em um Projeto PHP
Os projetos PHP geralmente dependentes de bibliotecas externas, e o gerenciamento de dependências e suas versões podem ser complicados. O Composer resolve esse problema de manter um controle de projeto de extensões e dependências, também facilita o processo de descoberta, instalação e atualização de pacotes que são definidos por enquanto.

Para usar o seu projeto, você pode compor um arquivo composer.json. O arquivo composer.jsonComposer quais dependências precisa para baixar seu projeto quais serão as versões de cada pacote tem permissão para instalações e instalações. Isso é muito importante para manter seu projeto consistente e evitar a instalação de versões instáveis ​​que podem causar problemas de compatibilidade retroativa.

Você não precisa criar este arquivo manualmente - é comum ocorrer erros de sintaxe quando fizer isso. O Composer oferece uma maneira de criar um novo arquivo composer.jsoncom base na entrada do usuário, o que é uma boa escolha se você planeja compartilhar seu projeto mais tarde como um pacote público no Packagist . O Composer gera automaticamente um arquivo básico composer.jsonquando você executa um comando composer requirepara incluir uma dependência em um projeto recém-criado.

O processo de uso do Composer para instalar um pacote como uma dependência em um projeto envolve os passos a seguir:

Identifique o tipo de biblioteca que o aplicativo precisa.
uma biblioteca de código aberto adequada no agist.org , o responsável oficial de pacotes para o Compose.
Escolha o pacote de dependência.
Execute composer requirepara incluir a dependência no arquivo composer.jsone instalar o pacote.
Vamos testar isso com uma aplicação de demonstração.

O objetivo desta aplicação é transformar uma determinação determinada em uma string de URL amigável - um slug . Isso é comumente usado para converter os títulos de página para caminhos de URL (Assim como a parte final da URL para este tutorial).

Vamos começar a criar um diretório para o nosso projeto. Vamos chamá-lo de slugify :

cd ~
mkdir slugify
cd slugify
Embora não seja necessário, você pode executar agora um comando composer init para criar um arquivo composer.json detalhado para seu projeto. Como o único objetivo do nosso projeto é demonstrar como instalar dependências com o Composer, usaremos um arquivo composer.json mais simples que será gerado automaticamente quando exigirmos nosso primeiro pacote.

Agora é hora de procurar no Packagist.org por um pacote que pode nos ajudar a gerar slugs. Se você procurar pelo termo “slug” no Packagist, receberá um resultado parecido com este:

Resultados da Pesquisa do Packagist para o termo "slug"

Você verá dois números no lado direito de cada pacote na lista. O número no topo representa quantas vezes o pacote foi instalado através do Composer, e o número em baixo mostra quantas vezes um pacote foi estrelado no GitHub. De um modo geral, os pacotes com mais instalações e mais estrelas tendem a ser mais estáveis, pois mais pessoas os utilizam. Também é importante verificar a descrição do pacote para relevância para garantir que ele é o que você precisa.

Precisamos de um conversor string-to-slug A partir dos resultados da pesquisa, o pacote cocur/slugify, que aparece como o primeiro resultado naquela página, parece ser um bom candidato, com uma quantidade razoável de instalações e estrelas.

Os pacotes no Packagist têm um nome de vendor e um nome de package. Cada pacote tem um identificador único (um namespace) no mesmo formato que o GitHub utiliza para seus repositórios: vendor/package. A biblioteca que queremos instalar utiliza o namespace cocur/slugify. Você precisa de um namespace do pacote para exigi-lo em seu projeto.

Agora que você sabe exatamente qual pacote deseja instalar, você pode executar o composer require para incluí-lo como uma dependência e gerar também o arquivo composer.json para seu projeto. Uma coisa importante é observar a exigência de pacotes. O Composer rastreia as dependências no nível da aplicação e do sistema. As dependências no nível do sistema são importantes para indicar de quais módulos PHP um pacote depende. No caso do pacote cocur/slugify, ele exige um módulo PHP que ainda não instalamos.

Quando um pacote necessário depende de uma biblioteca de sistema que não está atualmente instalada em seu servidor, você receberá um erro informando qual requisito está faltando:

composer require cocur/slugify
Output
Using version ^4.0 for cocur/slugify
./composer.json has been updated
Loading composer repositories with package information
Updating dependencies (including require-dev)
Your requirements could not be resolved to an installable set of packages.

  Problem 1
    - Installation request for cocur/slugify ^4.0 -> satisfiable by cocur/slugify[v4.0.0].
    - cocur/slugify v4.0.0 requires ext-mbstring * -> the requested PHP extension mbstring is missing from your system.
...
Para resolver o problema de dependência do sistema, podemos procurar pelo pacote que falta usando o apt search:

apt search mbstring
Output
Sorting... Done
Full Text Search... Done
php-mbstring/focal 2:7.4+75 all
  MBSTRING module for PHP [default]

php-patchwork-utf8/focal 1.3.1-1 all
  UTF-8 strings handling for PHP

php7.4-mbstring/focal 7.4.3-4ubuntu1 amd64
  MBSTRING module for PHP
Após localizar o nome do pacote correto, você pode utilizar o apt novamente para instalar a dependência de sistema:

sudo apt install php-mbstring
Assim que a instalação terminar, você pode executar novamente o comando composer require:

composer require cocur/slugify
Output
Using version ^4.0 for cocur/slugify
./composer.json has been created
Loading composer repositories with package information
Updating dependencies (including require-dev)
Package operations: 1 install, 0 updates, 0 removals
  - Installing cocur/slugify (v4.0.0): Downloading (100%)         
Writing lock file
Generating autoload files
Como você pode ver na saída, o Composer decidiu automaticamente qual versão do pacote utilizar. Se você verificar o diretório do seu projeto agora, ele irá conter dois arquivos novos: composer.json e composer.lock, e um diretório vendor:

ls -l
Output
total 12
-rw-rw-r-- 1 sammy sammy   59 May  4 13:56 composer.json
-rw-rw-r-- 1 sammy sammy 3229 May  4 13:56 composer.lock
drwxrwxr-x 4 sammy sammy 4096 May  4 13:56 vendor
O arquivo composer.lock é usado para armazenar informações sobre quais versões de cada pacote estão instaladas, e garantir que as mesmas versões sejam usadas se outra pessoa clonar seu projeto e instalar suas dependências. O diretório vendor é onde as dependências do projeto estão localizadas. Você não deve fazer commit da pasta vendor no controle de versão - você precisa apenas incluir os arquivos composer.json e composer.lock.

Ao instalar um projeto que já contém um arquivo composer.json, execute o composer install para baixar as dependências do projeto.

Vamos dar uma olhada rápida em restrições de versão. Se você verificar o conteúdo do seu arquivo composer.json, verá algo parecido com isto:

cat composer.json
Output
{
    "require": {
        "cocur/slugify": "^4.0"
    }
}
Note que há o caractere especial ^ antes do número da versão no composer.json. O Composer suporta várias restrições diferentes e formatos para definir a versão necessária do pacote, para fornecer flexibilidade enquanto também mantém seu projeto estável. O operador circunflexo (^) utilizado pelo arquivo composer.json criado automaticamente é o operador recomendado para a interoperabilidade máxima, seguindo o versionamento semântico. Neste caso, ele define 4.0 como a versão mínima compatível e permite atualizações para qualquer versão futura abaixo de 5.0.

De um modo geral, você não precisará alterar as restrições de versão em seu arquivo composer.json. No entanto, algumas situações podem exigir que você edite manualmente as restrições – por exemplo, quando uma nova versão principal da sua biblioteca requerida é liberada e você deseja atualizar, ou quando a biblioteca que você deseja usar não segue o versionamento semântico.

Aqui estão alguns exemplos para lhe dar um melhor entendimento sobre como as restrições de versão do Composer funcionam:

Restrição	Significado	Exemplo de Versões Permitidas
^1.0	>= 1.0 < 2.0	1.0, 1.2.3, 1.9.9
^1.1.0	>= 1.1.0 < 2.0	1.1.0, 1.5.6, 1.9.9
~1.0	>= 1.0 < 2.0.0	1.0, 1.4.1, 1.9.9
~1.0.0	>= 1.0.0 < 1.1	1.0.0, 1.0.4, 1.0.9
1.2.1	1.2.1	1.2.1
1.*	>= 1.0 < 2.0	1.0.0, 1.4.5, 1.9.9
1.2. *	>= 1.2 < 1.3	1.2.0, 1.2.3, 1.2.9
Para uma visualização mais detalhada das restrições de versão do Composer, consulte a documentação oficial.

A seguir, vamos ver como carregar dependências automaticamente com o Composer.

Passo 4 — Incluindo o Script Autoload
Como o PHP por si só não carrega classes automaticamente, o Composer fornece um script autoload que você pode incluir em seu projeto para obter o carregamento automático para ele. Este arquivo é gerado automaticamente pelo Composer quando você adiciona sua primeira dependência.

A única coisa que você precisa fazer é incluir o arquivo vendor/autoload.php em seus scripts PHP antes de qualquer instância de classe.

Vamos testar isso em nossa aplicação de demonstração. Abra um novo arquivo chamado test.php em seu editor de texto:

nano test.php
Adicione o código a seguir que vem no arquivo vendor/autoload.php, carrega a dependência cocur/slugify, e o utiliza para criar um slug:

test.php
<?php
require __DIR__ . '/vendor/autoload.php';

use Cocur\Slugify\Slugify;

$slugify = new Slugify();

echo $slugify->slugify('Hello World, this is a long sentence and I need to make a slug from it!');
Salve o arquivo e saia do seu editor.

Agora, execute o script.

php test.php
Isso produz a saída hello-world-this-is-a-long-sentence-and-i-need-to-make-a-slug-from-it.

As dependências precisam de atualizações quando novas versões são liberadas. Dessa forma, vamos ver como lidar com isso.

Passo 5 — Atualizando as Dependências do Projeto
Sempre que você quiser atualizar suas dependências do projeto para versões mais recentes, execute o comando update:

composer update
Isso irá verificar por versões mais recentes das bibliotecas que você requer em seu projeto. Se uma versão mais recente for encontrada e ela for compatível com a restrição de versão definida no arquivo composer.json, o Composer substituirá a versão anterior instalada. O arquivo composer.lock será atualizado para refletir essas alterações.

Você também pode atualizar uma ou mais bibliotecas específicas, especificando-as desta forma:

composer update vendor/package vendor2/package2
Certifique-se de verificar em seus arquivos composer.json e composer.lock dentro do seu sistema de controle de versão após atualizar suas dependências de modo que outros também possam instalar essas versões mais recentes.

Conclusão





***********
Algoritmo "CalculoMedia2"
// Disciplina: Lógica de programação
// Professor : Antonio Carlos Nicolodi
// Descrição : calculo da média aritimética
// Autor     : Professor Antonio
// Data atual: 01/04/2015
var
// Seção de Declarações
   v1, v2, total: Real
   sinal : Caracter
Inicio
// Seção dos Comandos
   Escreva ("Digite o primeiro valor: ")
   Leia (v1)
   Escreva ("Digite a operação + - * / : ")
   Leia (sinal)
   Escreva ("Digite o segundo valor: ")
   Leia (v2)

   Se sinal = "+" entao
   total <- v1 + v2
   Escreva("O Resultado é: ", total)
   Senao
   Se sinal = "-" entao
   total <- v1 - v2
   Escreva("O Resultado é: ", total)
   Senao
   Se sinal = "*" entao
   total <- v1 * v2
   Escreva("O Resultado é: ", total)


   Senao
     Escreva("OPERAÇÃO INVÁLIDA! ")



      Escreval("total")
   fimse
Fimalgoritmo

****
COMANDOS DOCKER
root@DELLAGS:~# curl -s "https://laravel.build/laravel-9-course?with=mysql,redis,mailhog" | bash

root@DELLAGS:~/example-app# ./vendor/bin/sail  artisan migrate --seed -> criar o banco de dados e copular dados;

Dockerfile

root@DELLAGS:~/example-app# docker exec -it example-app-mysql-1 bash


FROM wyveo/nginx-php-fpm:latest
WORKDIR /usr/share/nginx
RUN rm -rf /usr/share/nginx/html
COPY . /usr/share/nginx
RUN chmod -R 755 /usr/share/nginx/storage/*
RUN ln -s public html

.env (do composer)

DB_CONNECTION=mysql
DB_HOST=mysql-app (serviço do mysql no docker-compose.yaml)
DB_PORT=3306
DB_DATABASE=laraveldockerdb
DB_USERNAME=root
DB_PASSWORD=123456



docker-compose.yaml

version: '3'

services:
  laraveldocker-app:
    build: .
    ports:
      - "3003:80"
    volumes:
      - ./:/usr/share/nginx
      - .docker/nginx:/etc/nginx/conf.d/
    networks:
      - app-network
  mysql-app:
    image: mysql:5.7.22
    ports:
      - "3306:3306"
    volumes:
      - .docker/dbdata:/var/lib/mysql
    environment:
      MYSQL_DATABASE: laraveldocker
      MYSQL_ROOT_PASSWORD: 123456
    networks:
      - app-network
networks:
  app-network:
    driver: bridge
    



/*************************************************
#criando um serviço com um nome qualquer
version: '3'

services:
  laravel-app:                    #criando um serviço com um nome qualquer
    build: . ou image: wyveo/nginx-php-fpm:latest -> neste caso sem Dockerfile.                    # endereço da imagem ou local do Dockerfile (neste caso o ponto siginifica a raiz do projeto)
    ports:
      - "8080:80"                 # 8080 porta do meu host: 80 é a porta do docker nginx
    volumes:                      # docker-compose up -d -> sobe a imagem e libera o terminal  
      - ./:/usr/share/nginx       # TUDO QUE ESTIVE NA RAIZ (na rais tem o meu projeto laravel) './' IRÁ SER REFLETIDO NA PASTA /usr/share/nginx (pasta de acesso da página html)
                                  # C:\Laravel-docker\laravel-docker>docker compose up -d --build atualiza a minha imagem

  mysql-app:
      image: mysql:5.7
      ports:
        - "3306:3306"
      volumes:
        - .docker/dbdata:/var/lib/mysql          # qualqer nome (para persistir -guardar os dados do banco de dados)


      environment:
        MYSQL_DATABASE: laravel
        MYSQL_ROOT_PASSWORD: laravel
    
      

      /***************************///


  
C:\Laravel-docker\laravel-docker>docker compose up -d --build

                                
                               

    

/******************************** Dockerfile
FROM wyveo/nginx-php-fpm:latest

/***************************///
  COMANDOS

docker compose down -> para todos os containers
C:\Laravel-docker\laravel-docker>docker exec -it laravel-docker-laravel-app-1 bash 
root@612ea0ea3340:/# cd /usr/share/nginx/
root@612ea0ea3340:/usr/share/nginx# php artisan migrate
root@612ea0ea3340:/usr/share/nginx# php artisan serve

		
/***********/
PS C:\Users\alber> docker run -e MYSQL_ROOT_PASSWORD=root --name meu-mysql -d mysql:5.7

docker inspect meu-mysql ou | grep IPAddress

PS C:\Users\alber> docker run -e MYSQL_ROOT_PASSWORD=root --name meu-mysql -d -p 3306:3306 mysql:5.7

docker ps
docker ps -l
docker ps -a
docker rm -f nome


/*** LARAVEL */
### CRIANDO UM PROJETO NO LARAVEL 
laravel new projeto_laravel_via_installer (ESTA É UM AOPÇÃO)
composer create-project --prefer-dist laravel/laravel app_controle_tarefas "8.5.9"
cd app_controle_tarefas
cd public
php -S localhost:8000

ou 
da raiz do projeto:
php artisan serve 
ou
php artisan serve --port=3000

### PARA ABRIR PORTA EM OUTRO SERVIDOR
php artisan serve --host test.com --port 8080

 **********************************************************************
cd app_controle_tarefas
cd public
php artisan serve
- acessa o navegador http://localhost:8000

### DENTRO DO PROJETO CRIADO INSTALAR O LARAVEL/UI:^3.2 - versão 3.2
composer require laravel/ui:^3.2

### SE OCORRER ERRO AUMENTAR A MEMÓRIA DISPONIVEL PARA O php

-php --ini -> localiza o arquivo de configuração do php
LOCALIZA memory_limit = 1000 e altera para 
         memory_limit  = -1 e Salva

### LISTA A RELAÇÃO DE COMANDOS 
php artisan list 

DEVERA SURGIR AS OPÇÕES ABAIXO:

 ui
  ui:auth               Scaffold basic login and registration views and routes
  ui:controllers        Scaffold the authentication controllers
 vendor

### ENTENDENDO O PACOTE UI E INICIANDO A AUTENTICAÇÃO WEB NATIVA DO LARAVEL

COMANDO PARA LISTAR ROUTES: 
php artisan route:list

### php artisan ui bootstrap --auth (bootstrap ou react ou vue)
aplicando o bootstrap incluindo os recursos de autenticação;
poderia ser aplicado o bootstrap sem os recursos de autenticação;

### php artisan route:list -> mostra as rotas - ver que aumentaram as rotas

### APÓS ESSE PROCESSO O SISTEMA PEDE PARA RODAR
npm install -> instala as dependências do package.json (inclusive o bootstrap)
npm run dev -> gera os assets da aplicação de acordo com a tecnologia selecionada (bootstrap, react ou vue) -> Geralmente roda mais de uma vez para compilar tudo.

### CRIA O BANCO DE DADOS NORMALMENTE

### EXECUTA AS MIGRATIONS PADRÕES CRIADAS PARA O SISTEMA DE login
php artisan migrate -> CRIA AS TABELAS NO BANCO DE DADOS


************************************** 
INSTALANDO O COMPOSER NO UBUNTU
**************************************
sudo apt update
sudo apt install php-cli unzip

cd ~

curl -sS https://getcomposer.org/installer -o composer-setup.php

HASH=`curl -sS https://composer.github.io/installer.sig`

echo $HASH ->saída: Output
e0012edf3e80b6978849f5eff0d4b4e4c79ff1609dd1e613307e16318854d24ae64f26d17af3ef0bf7cfb710ca74



php -r "if (hash_file('SHA384', 'composer-setup.php') === '$HASH') { echo 'Installer verified'; } else { echo 'Installer corrupt'; unlink('composer-setup.php'); } echo PHP_EOL;"

sudo php composer-setup.php --install-dir=/usr/local/bin --filename=composer





***********************

DigitalOcean Kubernetes: novo plano de controle é mais rápido e gratuito, habilita HA para SLA de 99,95% de tempo de atividade
Produtos
Preços

Documentos
divisa suspensa

Entrar
divisa suspensa

// Tutorial //
Como Instalar e Utilizar o Composer no Ubuntu 20.04
Publicado em 21 de maio de 2020
Ubuntu
PHP
Ubuntu 20.04
Avatar padrão
Por Erika Heidi
Advogado Desenvolvedor
Português
Como Instalar e Utilizar o Composer no Ubuntu 20.04
Introdução
O Composer é uma ferramenta popular de gerenciamento de dependências para o PHP, criado para facilitar a instalação e a atualização das dependências principalmente do projeto. Ele controla quais outros pacotes de projeto específico dependem e são instalados para você, usando as opções apropriadas de acordo com os requisitos do projeto. O Composer também é comumente utilizado para inicializar novos projetos em frameworks PHP populares, como o Symfon e o Laravel .

Neste tutorial, você instalará e começará a usar o Composer em um sistema Ubuntu 20.04.

Pré-requisitos
Para seguir este guia, você pode acessar um servidor como usuário Ubuntu20.04 como usuário sudonão-root um firewall habilitado em seu servidor Para configurar isto, siga nosso guia Configuração do servidor inicial para o Ubuntu 20.04

Passo 1 — Instalando o PHP e as Dependências Adicionais
Além das dependências que já devem estar incluídas em seu sistema Ubuntu 20.04, como o , o Composer exige ou gitexecuta scripts PHP na linha de comando e para extrair arquivos zipados. Vamos instalar essas dependências agora.curlphp-cliunzip

primeiro, atual, gerenciador de pacotes de soluções: o cache do gerenciador de pacotes

sudo apt update
Em seguida, o seguinte comando para instalar os pacotes, execute:

sudo apt install php-cli unzip
Você será solicitado a confirmar a instalação digitando Ye, depois, ENTER.

Assim que os pré-requisitos para instalação do Composer forem instalados, você poderá seguir.

Passo 2 — Baixando e Instalando o Compositor
O Composer fornece um instalador de script escrito em PHP. Vamos baixá-lo, verificar se ele não está danificado e, em seguida, o usaremos para instalar o Composer.

Certifique-se de estar em sua pasta home. Em seguida, baixe o instalador usando o curl:

cd ~
curl -sS https://getcomposer.org/installer -o composer-setup.php
Em seguida, vamos verificar se o instalador baixado corresponde ao hash SHA-384 para o instalador mais recente encontrado na página Composer Public Keys / Signatures . Para facilitar o passo de seleção, você pode usar o seguinte comando para obter programaticamente o hash mais recente da página do Composer e armazená-lo em uma variável do shell:

HASH=`curl -sS https://composer.github.io/installer.sig`
Se você quiser verificar o valor realizado, execute:

echo $HASH
Output
e0012edf3e80b6978849f5eff0d4b4e4c79ff1609dd1e613307e16318854d24ae64f26d17af3ef0bf7cfb710ca74755a
Agora o código PHP a seguir, execute conforme a página de download do Composer, para verificar se o script de instalação está seguro para ser executado:

php -r "if (hash_file('SHA384', 'composer-setup.php') === '$HASH') { echo 'Installer verified'; } else { echo 'Installer corrupt'; unlink('composer-setup.php'); } echo PHP_EOL;"
Você verá o seguinte resultado:

Resultado
Installer verified
Se Installer corruptvocê estiver usando o hash correto, verifique se você está usando o hash correto. Em seguida, repita o processo de verificação. Quando você tiver um instalador selecionado, você pode continuar.

Para instalar o composerglobalmente, use o seguinte comando que baixará e instalará o Composer como um comando disponível em todo o sistema chamado composer, sob /usr/local/bin:

sudo php composer-setup.php --install-dir=/usr/local/bin --filename=composer
Você verá um resultado semelhante com este:

Output
All settings correct for using Composer
Downloading...

Composer (version 1.10.5) successfully installed to: /usr/local/bin/composer
Use it: php /usr/local/bin/composer
Para testar sua instalação, execute:

composer
Output
   ______
  / ____/___  ____ ___  ____  ____  ________  _____
 / /   / __ \/ __ `__ \/ __ \/ __ \/ ___/ _ \/ ___/
/ /___/ /_/ / / / / / / /_/ / /_/ (__  )  __/ /
\____/\____/_/ /_/ /_/ .___/\____/____/\___/_/
                    /_/
Composer version 1.10.5 2020-04-10 11:44:22

Usage:
  command [options] [arguments]

Options:
  -h, --help                     Display this help message
  -q, --quiet                    Do not output any message
  -V, --version                  Display this application version
      --ansi                     Force ANSI output
      --no-ansi                  Disable ANSI output
  -n, --no-interaction           Do not ask any interactive question
      --profile                  Display timing and memory usage information
      --no-plugins               Whether to disable plugins.
  -d, --working-dir=WORKING-DIR  If specified, use the given directory as working directory.
      --no-cache                 Prevent use of the cache
  -v|vv|vvv, --verbose           Increase the verbosity of messages: 1 for normal output, 2 for more verbose output and 3 for debug
...
Isso verifica que o Composer foi instalado com sucesso em seu sistema e está disponível em todo o sistema.

Nota: se você preferirá ter-lhe-ão separados separados do Composer para projeto hospedado neste servidor, você pode instalar localmente, em uma base por projeto. Este método também é útil quando o usuário do sistema não possui permissão para instalar o software disponível em todo o sistema.

Para fazer isso, use o comando php composer-setup.php. Isso irá gerar um arquivo composer.pharem seu diretório atual, que pode ser executado com o seu atual php composer.phar.

Agora podemos dar uma dependência em como usar o Compose como gerenciar.

Passo 3 — Usando o Compositor em um Projeto PHP
Os projetos PHP geralmente dependentes de bibliotecas externas, e o gerenciamento de dependências e suas versões podem ser complicados. O Composer resolve esse problema de manter um controle de projeto de extensões e dependências, também facilita o processo de descoberta, instalação e atualização de pacotes que são definidos por enquanto.

Para usar o seu projeto, você pode compor um arquivo composer.json. O arquivo composer.jsonComposer quais dependências precisa para baixar seu projeto quais serão as versões de cada pacote tem permissão para instalações e instalações. Isso é muito importante para manter seu projeto consistente e evitar a instalação de versões instáveis ​​que podem causar problemas de compatibilidade retroativa.

Você não precisa criar este arquivo manualmente - é comum ocorrer erros de sintaxe quando fizer isso. O Composer oferece uma maneira de criar um novo arquivo composer.jsoncom base na entrada do usuário, o que é uma boa escolha se você planeja compartilhar seu projeto mais tarde como um pacote público no Packagist . O Composer gera automaticamente um arquivo básico composer.jsonquando você executa um comando composer requirepara incluir uma dependência em um projeto recém-criado.

O processo de uso do Composer para instalar um pacote como uma dependência em um projeto envolve os passos a seguir:

Identifique o tipo de biblioteca que o aplicativo precisa.
uma biblioteca de código aberto adequada no agist.org , o responsável oficial de pacotes para o Compose.
Escolha o pacote de dependência.
Execute composer requirepara incluir a dependência no arquivo composer.jsone instalar o pacote.
Vamos testar isso com uma aplicação de demonstração.

O objetivo desta aplicação é transformar uma determinação determinada em uma string de URL amigável - um slug . Isso é comumente usado para converter os títulos de página para caminhos de URL (Assim como a parte final da URL para este tutorial).

Vamos começar a criar um diretório para o nosso projeto. Vamos chamá-lo de slugify :

cd ~
mkdir slugify
cd slugify
Embora não seja necessário, você pode executar agora um comando composer init para criar um arquivo composer.json detalhado para seu projeto. Como o único objetivo do nosso projeto é demonstrar como instalar dependências com o Composer, usaremos um arquivo composer.json mais simples que será gerado automaticamente quando exigirmos nosso primeiro pacote.

Agora é hora de procurar no Packagist.org por um pacote que pode nos ajudar a gerar slugs. Se você procurar pelo termo “slug” no Packagist, receberá um resultado parecido com este:

Resultados da Pesquisa do Packagist para o termo "slug"

Você verá dois números no lado direito de cada pacote na lista. O número no topo representa quantas vezes o pacote foi instalado através do Composer, e o número em baixo mostra quantas vezes um pacote foi estrelado no GitHub. De um modo geral, os pacotes com mais instalações e mais estrelas tendem a ser mais estáveis, pois mais pessoas os utilizam. Também é importante verificar a descrição do pacote para relevância para garantir que ele é o que você precisa.

Precisamos de um conversor string-to-slug A partir dos resultados da pesquisa, o pacote cocur/slugify, que aparece como o primeiro resultado naquela página, parece ser um bom candidato, com uma quantidade razoável de instalações e estrelas.

Os pacotes no Packagist têm um nome de vendor e um nome de package. Cada pacote tem um identificador único (um namespace) no mesmo formato que o GitHub utiliza para seus repositórios: vendor/package. A biblioteca que queremos instalar utiliza o namespace cocur/slugify. Você precisa de um namespace do pacote para exigi-lo em seu projeto.

Agora que você sabe exatamente qual pacote deseja instalar, você pode executar o composer require para incluí-lo como uma dependência e gerar também o arquivo composer.json para seu projeto. Uma coisa importante é observar a exigência de pacotes. O Composer rastreia as dependências no nível da aplicação e do sistema. As dependências no nível do sistema são importantes para indicar de quais módulos PHP um pacote depende. No caso do pacote cocur/slugify, ele exige um módulo PHP que ainda não instalamos.

Quando um pacote necessário depende de uma biblioteca de sistema que não está atualmente instalada em seu servidor, você receberá um erro informando qual requisito está faltando:

composer require cocur/slugify
Output
Using version ^4.0 for cocur/slugify
./composer.json has been updated
Loading composer repositories with package information
Updating dependencies (including require-dev)
Your requirements could not be resolved to an installable set of packages.

  Problem 1
    - Installation request for cocur/slugify ^4.0 -> satisfiable by cocur/slugify[v4.0.0].
    - cocur/slugify v4.0.0 requires ext-mbstring * -> the requested PHP extension mbstring is missing from your system.
...
Para resolver o problema de dependência do sistema, podemos procurar pelo pacote que falta usando o apt search:

apt search mbstring
Output
Sorting... Done
Full Text Search... Done
php-mbstring/focal 2:7.4+75 all
  MBSTRING module for PHP [default]

php-patchwork-utf8/focal 1.3.1-1 all
  UTF-8 strings handling for PHP

php7.4-mbstring/focal 7.4.3-4ubuntu1 amd64
  MBSTRING module for PHP
Após localizar o nome do pacote correto, você pode utilizar o apt novamente para instalar a dependência de sistema:

sudo apt install php-mbstring
Assim que a instalação terminar, você pode executar novamente o comando composer require:

composer require cocur/slugify
Output
Using version ^4.0 for cocur/slugify
./composer.json has been created
Loading composer repositories with package information
Updating dependencies (including require-dev)
Package operations: 1 install, 0 updates, 0 removals
  - Installing cocur/slugify (v4.0.0): Downloading (100%)         
Writing lock file
Generating autoload files
Como você pode ver na saída, o Composer decidiu automaticamente qual versão do pacote utilizar. Se você verificar o diretório do seu projeto agora, ele irá conter dois arquivos novos: composer.json e composer.lock, e um diretório vendor:

ls -l
Output
total 12
-rw-rw-r-- 1 sammy sammy   59 May  4 13:56 composer.json
-rw-rw-r-- 1 sammy sammy 3229 May  4 13:56 composer.lock
drwxrwxr-x 4 sammy sammy 4096 May  4 13:56 vendor
O arquivo composer.lock é usado para armazenar informações sobre quais versões de cada pacote estão instaladas, e garantir que as mesmas versões sejam usadas se outra pessoa clonar seu projeto e instalar suas dependências. O diretório vendor é onde as dependências do projeto estão localizadas. Você não deve fazer commit da pasta vendor no controle de versão - você precisa apenas incluir os arquivos composer.json e composer.lock.

Ao instalar um projeto que já contém um arquivo composer.json, execute o composer install para baixar as dependências do projeto.

Vamos dar uma olhada rápida em restrições de versão. Se você verificar o conteúdo do seu arquivo composer.json, verá algo parecido com isto:

cat composer.json
Output
{
    "require": {
        "cocur/slugify": "^4.0"
    }
}
Note que há o caractere especial ^ antes do número da versão no composer.json. O Composer suporta várias restrições diferentes e formatos para definir a versão necessária do pacote, para fornecer flexibilidade enquanto também mantém seu projeto estável. O operador circunflexo (^) utilizado pelo arquivo composer.json criado automaticamente é o operador recomendado para a interoperabilidade máxima, seguindo o versionamento semântico. Neste caso, ele define 4.0 como a versão mínima compatível e permite atualizações para qualquer versão futura abaixo de 5.0.

De um modo geral, você não precisará alterar as restrições de versão em seu arquivo composer.json. No entanto, algumas situações podem exigir que você edite manualmente as restrições – por exemplo, quando uma nova versão principal da sua biblioteca requerida é liberada e você deseja atualizar, ou quando a biblioteca que você deseja usar não segue o versionamento semântico.

Aqui estão alguns exemplos para lhe dar um melhor entendimento sobre como as restrições de versão do Composer funcionam:

Restrição	Significado	Exemplo de Versões Permitidas
^1.0	>= 1.0 < 2.0	1.0, 1.2.3, 1.9.9
^1.1.0	>= 1.1.0 < 2.0	1.1.0, 1.5.6, 1.9.9
~1.0	>= 1.0 < 2.0.0	1.0, 1.4.1, 1.9.9
~1.0.0	>= 1.0.0 < 1.1	1.0.0, 1.0.4, 1.0.9
1.2.1	1.2.1	1.2.1
1.*	>= 1.0 < 2.0	1.0.0, 1.4.5, 1.9.9
1.2. *	>= 1.2 < 1.3	1.2.0, 1.2.3, 1.2.9
Para uma visualização mais detalhada das restrições de versão do Composer, consulte a documentação oficial.

A seguir, vamos ver como carregar dependências automaticamente com o Composer.

Passo 4 — Incluindo o Script Autoload
Como o PHP por si só não carrega classes automaticamente, o Composer fornece um script autoload que você pode incluir em seu projeto para obter o carregamento automático para ele. Este arquivo é gerado automaticamente pelo Composer quando você adiciona sua primeira dependência.

A única coisa que você precisa fazer é incluir o arquivo vendor/autoload.php em seus scripts PHP antes de qualquer instância de classe.

Vamos testar isso em nossa aplicação de demonstração. Abra um novo arquivo chamado test.php em seu editor de texto:

nano test.php
Adicione o código a seguir que vem no arquivo vendor/autoload.php, carrega a dependência cocur/slugify, e o utiliza para criar um slug:

test.php
<?php
require __DIR__ . '/vendor/autoload.php';

use Cocur\Slugify\Slugify;

$slugify = new Slugify();

echo $slugify->slugify('Hello World, this is a long sentence and I need to make a slug from it!');
Salve o arquivo e saia do seu editor.

Agora, execute o script.

php test.php
Isso produz a saída hello-world-this-is-a-long-sentence-and-i-need-to-make-a-slug-from-it.

As dependências precisam de atualizações quando novas versões são liberadas. Dessa forma, vamos ver como lidar com isso.

Passo 5 — Atualizando as Dependências do Projeto
Sempre que você quiser atualizar suas dependências do projeto para versões mais recentes, execute o comando update:

composer update
Isso irá verificar por versões mais recentes das bibliotecas que você requer em seu projeto. Se uma versão mais recente for encontrada e ela for compatível com a restrição de versão definida no arquivo composer.json, o Composer substituirá a versão anterior instalada. O arquivo composer.lock será atualizado para refletir essas alterações.

Você também pode atualizar uma ou mais bibliotecas específicas, especificando-as desta forma:

composer update vendor/package vendor2/package2
Certifique-se de verificar em seus arquivos composer.json e composer.lock dentro do seu sistema de controle de versão após atualizar suas dependências de modo que outros também possam instalar essas versões mais recentes.








INÍCIO:

1 instalar o docker

2 abrir wsl2/Windows ou linux
 curl -s "https://laravel.build/olw?with=mysql,redis,mailhog,minio" | bash

3 cd olw
./vendor/bin/sail up -d
	ou
4 cd olw && ./vendor/bin/sail up -d

5 ATRIBUINDO PERMISSÃO PARA A PASTA
cd .. -> sai da pasta
sudo chmod 777 olw/ -R ou sem o 'sudo' chmod 777 olw/ -R

6 CRIANDO ALIAS PARA O COMANDO ANTERIOR
alias sail='[ -f sail ] && sh sail || sh vendor/bin/sail'
passa a usar assim: sail ps

7 CONFIGURAR PORTAS PARA A APLICAÇÃO NO NAVEGADOR E MYSQL
.env
APP_PORT=8000

*porta do myql
FORWARD_DB_PORT=3307

8 INSTALANDO DEPENDÊNCIA AO PROJETO
./vendor/bin/sail composer require laravel/breeze --dev

9 DEIXAR TELA DE AUTENTICAÇÃO PRONTA, ROTA AUTENTICADA, TAWINDCSS INSTALADO E INERTIA INSTALADO
./vendor/bin/sail artisan breeze:install vue 
ou
./vendor/bin/sail art breeze:install vue


10 RODAR AS MIGRATES PADRÕES DO PROJETO AI JÁ PODE CADASTRAR USUÁRIOS PARA LOGIN:
./vendor/bin/sail art migrate

11 


/*******************************************/
2a AULA:

O PROJETO CONSISTE EM RECEBER DADOS DE UMA API (punkapi.com) DE INFORMAÇÕES SOBRE CERVEJAS, VAMOS CONSTRUIR AS ROTAS PARA CONSUMIR A API E CRIAR A ESTRUTURA PARA O RELATÓRIO QUE IREMOS GERAR EM EXCEL E ENVIAR PARA O STORAGE...
1 CRIAR ROTAS:
code .
olw/routes/web.php


sail up -d -> SOBE O CONTAINER localhost:8000 (nesse projeto)

Route::get('/beers', fn()=> 'Olw - testando a rota /beers');

**************************************************
obs:
- laravel.com/api -> acesso a documentação do código;
- Inline Parameters for VSCode-> extensão para vscode para exibir o nome dos métodos na hora que codificar;
- fira code -> extensão para fonte no vscode

git Hub Copilot vs Tabnine -> (pesquisar sobre)
Link para extensões vscode:
https://github.com/icarojobs/vscode-useful-extensions
*************************************************


Route::get('/beers', fn()=> 'Olw - testando a rota /beers')
                             ->middleware(['auth']);

* FLUXO PADRÃO DO MVC-LARAVEL: 
life cicle: sai do usuário pelo navegador, insomnia ou postman -> passa pelo index.php(pasta public) -> passa pelos arquivos do bootstrap retornando uma instância da aplicação -> passa pelo kernel do http (carrega mais instâncias) -> Service provider -> despacha a requisição pro Router -> Cai no arquivo Web.php -> Middleware (se tiver, geralmente tem os globais) -> Controller (faz as regras de negócio e pode chamar outras classes como Serviços por exemplo)
-> Retorna uma view ou um json (No caso estamos usando inértia, ele não vai reinderizar a 'view.blade' padrão, ele vai reinderizar componente vue.js através do inértia.).


* EM VEZ DE USAR A FUNÇÃO AQUI NA ROTA CRIAMOS UM CONTROLLER:

obs.: ​dica: php artisan make:controller -r cria o Resource também.
dica: limpar o cache do container:
./vendor/bin/sail art config:cache
./vendor/bin/sail art optimize:clear


sail artisan make:controller BeerController
ou 
sail art make:controller BeerController -> CRIA O ARQUIVO BeerController.php na pasta app/Http/Controllers
->
<?php

namespace App\Http\Controllers;

use Illuminate\Http\Request;

class BeerController extends Controller
{
    public function index()
    {
    return 'Virgu & Beer & Code'
    }
}

* NO ARQUIVO DE ROTAS Web.php CHAMA O BeersController:

importante importar o Controller <nomeDoController>+<CTRL=ENTER:
use App\Http\Controllers\BeerController;

Route::get('/beers', [BeerController::class, 'index'])
                        ->middleware(['auth']);


* PRECISAMOS CRIAR UM MÉTODO PARA PEGAR A LISTA, LISTAR OS DADOS DA API (listar as bebidas de https://api.punkapi.com/v2 ->
VAMOS CRIAR UMA NOVA CLASSE de serviços em app/Sevices/PunkapiService.php

* O LARAVEL POSSUI UM RECURSO CHAMADO HTTPClient que abstrai o uso de uma ferramenta chama guzeo, esse guzeo é o client http mais comum para php, com ele fazemos requisições pra diversos serviços web dentro do php para outras url, ele é robusto, então o laravel simplifica importando o recurso que faz tudo por 'detrás dos panos':

PunkapiService.php

<?php

namespace App\Services;

use Illuminate\Support\Facades\Http;

class PunkapiService
{
    public function getBeers()
    {
        return Http::get('https://api.punkapi.com/v2/beers');
    }
}

E NO BeerController.php fica:
<?php

namespace App\Http\Controllers;

use App\Services\PunkapiService;
use Illuminate\Http\Request;

class BeerController extends Controller
{
    public function index()
    {
    //return 'Virgu & Beer & Code';
    $service = new PunkapiService;

    return $service->getBeers();
    }
}

* TRATE É CARACTERÍSTICA QUE A CLASSE ADQUIRE (pode ter mesmos métodos e atributos substituindo o recurso de um classe extender várias classes que não tem no php, a trate é uma forma de fazer isso. O service  é uma outra camada na maioria das vezes abstrair seviços que vc vai consumir, por exemplo API.

Estando logado, os dados da api já serão exibidos em localhost:8000/beers, se usar um aplicativo cliente tipo insomnia pode apresentar os dados também, melhor comentar a linha de de autenticação da rota:
Route::get('/beers', [BeerController::class, 'index']);
linha de autenticação da rota // ->middleware(['auth']);

* ESSA API PERMITE FAZER FILTROS VIA PARÂMETROS NA PRÓPRIA ROTA. PRIMEIRO VAMOS REFATORAR O CÓDIO, A CLASSE PunkapiService.php:

USO DE CONFIG E MACRO


Vamos alterar a url, primeiro acessando a pasta config da raiz do projeto e criar o arquivo punkapi.php. O que acontece é que o config(pasta config da raiz) carrega todos os arquivos da pasta e permite que sejam acessados via funções simples(HELPERS), isso é muito legal porque podemos acessar esses arquivos de configurações de qualquer lugar do projeto: 

<?php

return [
    'url' => env('PUNK_BASE_URL', 'https://api.punkapi.com/v2')
];

Usando o helper env significa dizer que, se não houver a constante PUNK_BASE_URL setada no arquivo .env do projeto, seu valor será o segundo parâmetro: http://api.punkapi.com/v2 e no arquivo PunkapiService.php da pasta app/Services fica:

<?php

namespace App\Services;

use Illuminate\Support\Facades\Http;

class PunkapiService
{
    public function getBeers()
    {
        return Http::get('/beers');
    }
}

MACRO é uma forma de criar funções customizadas:
 em app\Providers vamos acessar o arquivo AppServiceProvider.php que é uma classe que tem dois métodos register e boot. No método boot vamos chamar o método Http do laravel e chamar o método macro, no primeiro parâmetro será um nome atribuído à função e e o segundo uma clausure (uma função).
Neste arquivo é passado o arquivo de configuração da url (em 'config/punkapi.php') além de tokens, headers,...
 

use Illuminate\Support\Facades\Http; -> deve ser importado
E a função boot fica:

  public function boot()
    {
        Http::macro('punkapi', function(){
            return Http::acceptJson()
            ->baseUrl(config('punkapi.url'));
        });
    }

Então criamos uma macro(uma função customizada) chamada punkapi que já retorna o client com accept/Json no Header e com o baseUrl configurado lá do arquivo /config/punkapi.php e se estiver setado no .env pegará de lá.

/app/Services/PunkapiService.php fica:

<?php

namespace App\Services;

use Illuminate\Support\Facades\Http;

class PunkapiService
{
    public function getBeers()
    {
        return Http::punkapi()->get('/beers');
    }
}

*obs.: a baseUrl poderia ser setada no construtor, que pode setar token também.(uma outra abordagem para versão sem macros);

->Testamos o retorno Json em localhost:8000/beers.

Refatorando o arquivo PunkapiService.php: O client Http não lança exceção e podemos forçar o retorno em modo Json:
<?php

namespace App\Services;

use Illuminate\Support\Facades\Http;

class PunkapiService
{
    public function getBeers()
    {
       // return Http::punkapi()->get('/beers');
       return Http::punkapi()
            ->get('/beers')
            ->throw()  // Exceção em caso de erro
            ->json();   // Força o retorno em formato Json
    }
}

Podemos testar forçando um erro alterando a constante PUNKAPI_BASE_URL criada em /config/punkapi.php, vamos atribuir um valor diferente no arquivo .env:

PUNKAPI_BASE_URL="adfjklj878"

Podemos usar a função retry tem dois parâmetros, o número de tentativas pra buscar a requisição e o intervalo entre elas. Refatorando o código fica:
<?php

namespace App\Services;

use Illuminate\Support\Facades\Http;

class PunkapiService
{
    public function getBeers()
    {
       // return Http::punkapi()->get('/beers');
       return Http::punkapi()
            ->get('/beers')
            ->throw()  // Exceção em caso de erro
            ->json();   // Força o retorno em formato Json
    }
}

- Quando sai a exceção nao deveriamos retornar o erro em json por ser um api neste caso estamos usamos um app web e não uma api. E usaríamos o Route Api.

Refatorando o método boot de /app/Providers/AppServiceProvider.php, inserindo o retry():

     */
    public function boot()
    {
        Http::macro('punkapi', function(){
            return Http::acceptJson()
            ->baseUrl(config('punkapi.url'))
            ->retry(3,100);
        });
    }
}

comando de help

* ./vendor/bin/sail composer dump-autoload
* Verificar Nome do arquivo se bate com o nome das rotas(Classes criadas e importar o nome errado);
* inteliphense

Refatorando BeerController.php
<?php

namespace App\Http\Controllers;

use App\Services\PunkapiService;

class BeerController extends Controller
{
    public function index()
    {

    $service = new PunkapiService();

    return $service->getBeers();
    }
}

Em vez de instanciar o método PunkapiService() dentro de index, vamos passar por parâmetro de index() declarando seu Próprio nome (PunkapiService) como tipo. Fica assim:

<?php

namespace App\Http\Controllers;

use App\Services\PunkapiService;

class BeerController extends Controller
{
    public function index(PunkapiService $service)
    {
    return $service->getBeers();
    }
}

Assim usamos feactures do php(injeção de dependências) e ao mesmo tempo feactures do laravel. Em vez de criar uma instância dentro do método index, vamos injetar a classe como parâmetro para o método index(), ficando index($service) e a instância de dentro da função passa como parâmetro de 'tipo da variável'. Isso quebra a cadeia de dependência entre as classes.
Assim, o método index ganha independência não mais dependendo da instância de new PunkapiService e passamos a olhar a função index em si.
Assim, o Laravel tenta fazer um binding, um match, o laravel tenta encontrar alguma classe PunkapiService e cria uma instância dessa classe e usa ali como parâmetro. Se não fizer assim, lá em Rotas teria que ser passado como parâmetro o que fica desnecessário.
Não poderia ser feito se na classe PunkapiService existisse o construtor para atribuir valores automaticamente à classe. Assim podemos usar porque não precisamos passar nenhum valor.

ADICIONAR OS FILTROS:
Vamos filtrar o retorno api com os seguintes itens: beer_name, food, ibu_gt, malte:

var_dump($v)
die();
dd($variável)
benchmarck -> ?

/*****REFATORA PARA TESTE alterando BeerController.php e PunkapiService.php
BeerController.php
<?php

namespace App\Http\Controllers;

use App\Services\PunkapiService;

class BeerController extends Controller
{
    public function index(PunkapiService $service)
    {
    return $service->getBeers(
        'heineken',
        'cheese',
        'corn',
        45
    );
    }
}

PunkapiService.php
<?php

namespace App\Services;

use Illuminate\Support\Facades\Http;

class PunkapiService
{
    public function getBeers(
        string $beer_name,
        string $food,
        string $malt,
        string $ibu_gt
    )
    {
        $params = get_defined_vars();

        dd($params);

        return Http::punkapi()
            ->get('/beers', $params)
            ->throw()  // Exceção em caso de erro
            ->json();   // Força o retorno em formato Json
    }
}

Resultado do debug no insomnia ou no navegador:
array:4 [▼ // app/Services/PunkapiService.php:18
  "beer_name" => "heineken"
  "food" => "cheese"
  "malt" => "corn"
  "ibu_gt" => "45"
]
//* fim teste

Refatorando:

class PunkapiService
{
    public function getBeers(
        string $beer_name = null,
        string $food = null,
        string $malt = null,
        string $ibu_gt = null
    )
    {
        $params = get_defined_vars();

        dd($params);

        return Http::punkapi()
            ->get('/beers', $params)
            ->throw()  // Exceção em caso de erro
            ->json();   // Força o retorno em formato Json
    }
}

Assim quando não passar o valor para a chave ele exibirá a chave e o valor Null, vamos refatorar para não exibir nem a chave englobando get_defined_vers() com array_filter no arquivo PunkapiService.php:

$params = array_filter(get_defined_vars());

<?php

namespace App\Http\Controllers;

use App\Services\PunkapiService;

class BeerController extends Controller
{
    public function index(PunkapiService $service)
    {
    return $service->getBeers(
        'heineken',
        'cheese',
        'corn',
       // 45 -> Esse não é passado
    );
    }
}


array:3 [▼ // app/Services/PunkapiService.php:18
  "beer_name" => "heineken"
  "food" => "cheese"
  "malt" => "corn"
	Aqui não exibiu o valor 45
]


USANDO A FUNÇÃO NAMED_ARGS passamos só os parâmetros que precisamos retornar da api e o php com essa função saberá qual a posição dela no array de argumentos passados como parâmetro sem a necessidade de seguir a mesma sequência dos argumentos:
class BeerController extends Controller
{
    public function index(PunkapiService $service)
    {
    return $service->getBeers(food: 'cheese');
    }
}

REFATORANDO:
BeerController.php
<?php

namespace App\Http\Controllers;

use App\Services\PunkapiService;
use Illuminate\Http\Request;

class BeerController extends Controller
{
    public function index( Request $request, PunkapiService $service)
    {
    return $service->getBeers(...$request->all());
    }
}

PunkapiService.php
<?php

namespace App\Services;

use Illuminate\Support\Facades\Http;

class PunkapiService
{
    public function getBeers(
        string $beer_name = null,
        string $food = null,
        string $malt = null,
        string $ibu_gt = null
    )
    {
        $params = array_filter(get_defined_vars());

     //   dd($params);

        return Http::punkapi()
            ->get('/beers', $params)
            ->throw()  // Exceção em caso de erro
            ->json();   // Força o retorno em formato Json
    }
}

CRIANDO UMA REQUEST
sail artisan make:request BeerRequest
/app/Http/Requests/BeerRequest.php

* Funções anônimas, também conhecidas como closures , permitem a criação de funções que não tem o nome especificado. Elas são mais úteis como o valor de parâmetros callable, mas podem ter vários outros usos.. É uma função passada como parâmetro

CRIANDO NOVA ROTA PARA SALVAR COMO EXCEL
* https://docs.laravel-excel.com/3.1/getting-started/installation.html

Route::group([
    'prefix' => 'beers',
], function() {

    Route::get('/', [BeerController::class, 'index']); //-> Se houver necessidade de salvar dados por essa rota mudamos o método(verbo html) para post(os dados não serão expostos na url).
                          //  ->middleware(['auth']);
    Route::get('/export', [BeerController::class, 'export']);

});

Então passamos a ter duas rotas: localhost:8000/beers
localhost:8000/beers/export

No BeerController incluimos o método export():
class BeerController extends Controller
{
    public function index( BeerRequest $request, PunkapiService $service)
    {
    // return $service->getBeers(...$request->all());
    return $service->getBeers(...$request->validated());
    }

    public function export()
    {
        return 'Relatório criado.';
    }
}



INSTALANDO PACOTE LARAVEL-EXCEL PARA GERAR OS RELATÓRIO EM EXCEL FILTRADOS DA API:

* https://docs.laravel-excel.com/3.1/getting-started/installation.html

COMANDO PARA INSTALAR VIA COMPOSER:
./vendor/bin/sail composer require psr/simple-cache:^2.0 maatwebsite/excel

CRIAR A CLASSE DO EXCEL
./vendor/bin/sail artisan make:export BeerExport  --> Cria o arquivo em  /app/Exports/BeerExport.php

<?php

namespace App\Exports;

use Maatwebsite\Excel\Concerns\FromCollection;

class BeerExport implements FromCollection
{


    /**
    * @return \I¢lluminate\Support\Collection
    */
    public function collection()
    {
        //
    }
}

-> Dentro de colletion buscaremos as informações que serão salvas no arquivo do excel, um array de dados;

criamos um __construct() que vai ter uma propriedade privada do tipo array chamamos de $reportData.

O retorn será uma collection como informa o comentário:
 /**
    * @return \I¢lluminate\Support\Collection
    */

Na função colletion(), está recebendo um array return $this->reportData; 
Observe que não precisa mais declarar uma propriedade que vai se setada via construct(), basta defifinir o escopo junto do argumento e o php faz isso pra você. Como o retorno da função é um array usamos o helper collect para o $this->reportData:

BeerExport.php

<?php

namespace App\Exports;

use Maatwebsite\Excel\Concerns\FromCollection;

class BeerExport implements FromCollection
{

    public function __construct(
        private array $reportData
    ){}

    /**
    * @return \Illuminate\Support\Collection
    */
    public function collection()
    {
       return collect($this->reportData);
    }
}
 

Consultamos a documentação do Laravel-excel em 'Exporting collections':
em Excel Store passa o nome da classe e o nome do arquivo:

BeerController.php
<?php

namespace App\Http\Controllers;


use App\Exports\BeerExport;
use App\Http\Requests\BeerRequest;
use App\Services\PunkapiService;
use Maatwebsite\Excel\Facades\Excel;


class BeerController extends Controller
{
    public function index( BeerRequest $request, PunkapiService $service)
    {
    // return $service->getBeers(...$request->all());
    return $service->getBeers(...$request->validated());
    }

    public function export()
    {
      $params = [
        ['name' => 'Tom', 'age' => '30'],
        ['name' => 'Virgu', 'age' => '27']
       ];

       Excel::store(new BeerExport($params), 'olw-report.xlsx');
       return "Relatório criado";

    }


}

********************************************
* REFATORANDO E SALVANDO O ARQUIVO EXCEL EM /storage/app

BeerExport.php
<?php

namespace App\Exports;

use Maatwebsite\Excel\Concerns\FromCollection;

class BeerExport implements FromCollection
{

    public function __construct(
        private array $reportData
    ){}

    /**
    * @return \Illuminate\Support\Collection
    */
    public function collection()
    {
       return collect($this->reportData);
    }
}
*****************************

BeerController.php

<?php

namespace App\Http\Controllers;


use App\Exports\BeerExport;
use App\Http\Requests\BeerRequest;
use App\Services\PunkapiService;
use Maatwebsite\Excel\Facades\Excel;


class BeerController extends Controller
{
    public function index( BeerRequest $request, PunkapiService $service)
    {
        return $service->getBeers(...$request->all());

    }

    public function export(BeerRequest $request, PunkapiService $service)
    {
        $beers = $service->getBeers(...$request->validated());

        $filteredBeers = collect($beers)->map(function($value, $key){
        return collect($value)
                ->only(['name', 'tagline', 'first_brewed', 'description'])
                ->toArray();
    })->toArray();

    //dd($filteredBeers);

      $params = [
        ['name' => 'Tom', 'age' => '30'],
        ['name' => 'Virgu', 'age' => '27']
       ];

       Excel::store(new BeerExport($filteredBeers), 'olw-report.xlsx');

           return "Relatório criado";

    }


}

PARA SALVAR O ARQUIVO EXCEL EM UM STORAGE S3:
ALTERA BeerController.php

<?php

namespace App\Http\Controllers;


use App\Exports\BeerExport;
use App\Http\Requests\BeerRequest;
use App\Services\PunkapiService;
use Maatwebsite\Excel\Facades\Excel;


class BeerController extends Controller
{
    public function index( BeerRequest $request, PunkapiService $service)
    {
        return $service->getBeers(...$request->all());

    }

    public function export(BeerRequest $request, PunkapiService $service)
    {
        $beers = $service->getBeers(...$request->validated());

        $filteredBeers = collect($beers)->map(function($value, $key){
        return collect($value)
                ->only(['name', 'tagline', 'first_brewed', 'description'])
                ->toArray();
    })->toArray();


       Excel::store(
            new BeerExport($filteredBeers),
             'olw-report.xlsx',
             's3');

           return "Relatório criado";

    }


}

************
O REPOSITÓRIO DE ARQUIVOS minio:
NO DOCKER COMPOSER TEMOS O minio, um S3 que tem
MINIO_ROOT_USER: 'sail'
MINIO_ROOT_PASSWORD: 'password' e roda na porta 9000
localhost:9000
usuário: sail
senha: password

vamos criar um buncket(uma pasta)

e configurar o .env da raiz da aplicação:
originalmente é assim:
AWS_ACCESS_KEY_ID=
AWS_SECRET_ACCESS_KEY=
AWS_DEFAULT_REGION=us-east-1
AWS_BUCKET=
AWS_USE_PATH_STYLE_ENDPOINT=false

 e acrescentamos as informações para:


AWS_ACCESS_KEY_ID=sail
AWS_SECRET_ACCESS_KEY=password
AWS_DEFAULT_REGION=us-east-1
AWS_BUCKET=local
AWS_ENDPOINT=http://minio:9000
AWS_URL=http://minio:9000/local
AWS_USE_PATH_STYLE_ENDPOINT=true

altera tambem:

FILESYSTEM_DISK=local 
para:
FILESYSTEM_DISK=s3

INSTALAR UMA DEPENDÊNCIA (ADAPTER) PARA FAZER CORRESPONDÊNCIA COM A AWS:

Flysystem 3.x em laravel.com/docs/9.x/upgrade
./vendor/bin/sail composer require -W league/flysystem-aws-s3-v3 "^3.0"

em caso de erro:
 artisan vendor:publish --tag=laravel-assets --ansi --force

.env
APP_NAME=Laravel
APP_ENV=local
APP_KEY=base64:UbVvTP6Cu+LF5GamJdB4dsZZvW05ep4bZqcCEhmiDCg=
APP_DEBUG=true
APP_URL=http://localhost
APP_PORT=8000

# PUNKAPI_BASE_URL="httpadfjkljdsdfdfasf878"

LOG_CHANNEL=stack
LOG_DEPRECATIONS_CHANNEL=null
LOG_LEVEL=debug

DB_CONNECTION=mysql
FORWARD_DB_PORT=3307
DB_HOST=mysql
DB_PORT=3306
DB_DATABASE=olw
DB_USERNAME=sail
DB_PASSWORD=password

BROADCAST_DRIVER=log
CACHE_DRIVER=file
FILESYSTEM_DISK=s3
QUEUE_CONNECTION=sync
SESSION_DRIVER=file
SESSION_LIFETIME=120

MEMCACHED_HOST=memcached

REDIS_HOST=redis
REDIS_PASSWORD=null
REDIS_PORT=6379

MAIL_MAILER=smtp
MAIL_HOST=mailhog
MAIL_PORT=1025
MAIL_USERNAME=null
MAIL_PASSWORD=null
MAIL_ENCRYPTION=null
MAIL_FROM_ADDRESS="hello@example.com"
MAIL_FROM_NAME="${APP_NAME}"

AWS_ACCESS_KEY_ID=sail
AWS_SECRET_ACCESS_KEY=password
AWS_DEFAULT_REGION=us-east-1
AWS_BUCKET=local
AWS_ENDPOINT=http://minio:9000
AWS_URL=http://minio:9000/local
AWS_USE_PATH_STYLE_ENDPOINT=true

PUSHER_APP_ID=
PUSHER_APP_KEY=
PUSHER_APP_SECRET=
PUSHER_HOST=
PUSHER_PORT=443
PUSHER_SCHEME=https
PUSHER_APP_CLUSTER=mt1

VITE_PUSHER_APP_KEY="${PUSHER_APP_KEY}"
VITE_PUSHER_HOST="${PUSHER_HOST}"
VITE_PUSHER_PORT="${PUSHER_PORT}"
VITE_PUSHER_SCHEME="${PUSHER_SCHEME}"
VITE_PUSHER_APP_CLUSTER="${PUSHER_APP_CLUSTER}"

PRONTO. ENVIANDO PARA O MINIO.


/**** ABAIXO AULA DE FRONT END -> FALTA
























 







/***********************************************************
QUINTA FEIRA: 20/10/22

Open Laravel Week | Deploy com Terraform, EC2 e RDS | Fermentação

****
https://portal.aws.amazon.com/billing/signup?nc2=h_ct&src=header_signup&redirect_url=https%3A%2F%2Faws.amazon.com%2Fregistration-confirmation&language=pt_br#/start/email

Com terraform pode mudar de infra e configurar no git.

PROGRMAR A CONFIGURAÇÃO DO SERVIDOR: É basicamente construir uma nova aplicação para fazer isso, mais fácil de entender.
Terraform serve para (linguagem HCL -> linguagem própria - linguagem descritiva, descreve o resultado e não como irá ser feito), ou seja, descrever o que queremos.
Terraspace é o framework pra terraform.
Quando criamos o Terraform, ele pode variar conforme a infra cloud (aws, azure, google cloud). sua estrutura é a mesma para todos. mas cada provider tem a sua forma de usar, não consegue usar o mesmo código para mais de uma cloud.
Vamos rodar Terraform via container:

1. clonar do git: git clone 
Criar uma pasta para a infraestrutura

sail   (script que vamos usar)
#!/usr/bin/env bash

docker run -rm -it
	-u $(id -u):$(id -g) \
	-v $PWD:/workspace \
	-w /workspace
	hashicorp/terraform:light "%@"


	<no terminal

Logar em: aws.amazon.com
busca: iam
iam dashboard -> mysecurity credencials (root user) -> Acces keys ->clicar em create access keys -> salva o access key e secret access key
e coloca no arquivo credencials na maquina local.. .aws/credencials
















































//////////////////////////////////////////////////////////////////////////////////////////////////////
CONTEÚDO QUE FALTA ORGANIZAR:



/**************************************/

sail share

sail artisan sail:publish ->coloca em uma pasta na raiz chamada docker

sail --help

sail artisan optimizer:clear

sail ps

sail build --no-cache -> faz o bild da aplicação. (dá um sail down  por precaução antes.)










/*********************************

root@DELLAGS:~# curl -s "https://laravel.build/laravel-9-course?with=mysql,redis,mailhog" | bash

Dockerfile

root@DELLAGS:~/example-app# docker exec -it example-app-mysql-1 bash


FROM wyveo/nginx-php-fpm:latest
WORKDIR /usr/share/nginx
RUN rm -rf /usr/share/nginx/html
COPY . /usr/share/nginx
RUN chmod -R 755 /usr/share/nginx/storage/*
RUN ln -s public html

.env (do composer)

DB_CONNECTION=mysql
DB_HOST=mysql-app (serviço do mysql no docker-compose.yaml)
DB_PORT=3306
DB_DATABASE=laraveldockerdb
DB_USERNAME=root
DB_PASSWORD=123456



docker-compose.yaml

version: '3'

services:
  laraveldocker-app:
    build: .
    ports:
      - "3003:80"
    volumes:
      - ./:/usr/share/nginx
      - .docker/nginx:/etc/nginx/conf.d/
    networks:
      - app-network
  mysql-app:
    image: mysql:5.7.22
    ports:
      - "3306:3306"
    volumes:
      - .docker/dbdata:/var/lib/mysql
    environment:
      MYSQL_DATABASE: laraveldocker
      MYSQL_ROOT_PASSWORD: 123456
    networks:
      - app-network
networks:
  app-network:
    driver: bridge
    



/*************************************************
#criando um serviço com um nome qualquer
version: '3'

services:
  laravel-app:                    #criando um serviço com um nome qualquer
    build: . ou image: wyveo/nginx-php-fpm:latest -> neste caso sem Dockerfile.                    # endereço da imagem ou local do Dockerfile (neste caso o ponto siginifica a raiz do projeto)
    ports:
      - "8080:80"                 # 8080 porta do meu host: 80 é a porta do docker nginx
    volumes:                      # docker-compose up -d -> sobe a imagem e libera o terminal  
      - ./:/usr/share/nginx       # TUDO QUE ESTIVE NA RAIZ (na rais tem o meu projeto laravel) './' IRÁ SER REFLETIDO NA PASTA /usr/share/nginx (pasta de acesso da página html)
                                  # C:\Laravel-docker\laravel-docker>docker compose up -d --build atualiza a minha imagem

  mysql-app:
      image: mysql:5.7
      ports:
        - "3306:3306"
      volumes:
        - .docker/dbdata:/var/lib/mysql          # qualqer nome (para persistir -guardar os dados do banco de dados)


      environment:
        MYSQL_DATABASE: laravel
        MYSQL_ROOT_PASSWORD: laravel
    
      

      /***************************///


  
C:\Laravel-docker\laravel-docker>docker compose up -d --build

                                
                               

    

/******************************** Dockerfile
FROM wyveo/nginx-php-fpm:latest

/***************************///
  COMANDOS

docker compose down -> para todos os containers
C:\Laravel-docker\laravel-docker>docker exec -it laravel-docker-laravel-app-1 bash 
root@612ea0ea3340:/# cd /usr/share/nginx/
root@612ea0ea3340:/usr/share/nginx# php artisan migrate
root@612ea0ea3340:/usr/share/nginx# php artisan serve

		
/***********/
PS C:\Users\alber> docker run -e MYSQL_ROOT_PASSWORD=root --name meu-mysql -d mysql:5.7

docker inspect meu-mysql ou | grep IPAddress

PS C:\Users\alber> docker run -e MYSQL_ROOT_PASSWORD=root --name meu-mysql -d -p 3306:3306 mysql:5.7

docker ps
docker ps -l
docker ps -a
docker rm -f nome


/*** LARAVEL */
### CRIANDO UM PROJETO NO LARAVEL 
laravel new projeto_laravel_via_installer (ESTA É UM AOPÇÃO)
composer create-project --prefer-dist laravel/laravel app_controle_tarefas "8.5.9"
cd app_controle_tarefas
cd public
php -S localhost:8000

ou 
da raiz do projeto:
php artisan serve 
ou
php artisan serve --port=3000

### PARA ABRIR PORTA EM OUTRO SERVIDOR
php artisan serve --host test.com --port 8080

 **********************************************************************
cd app_controle_tarefas
cd public
php artisan serve
- acessa o navegador http://localhost:8000

### DENTRO DO PROJETO CRIADO INSTALAR O LARAVEL/UI:^3.2 - versão 3.2
composer require laravel/ui:^3.2

### SE OCORRER ERRO AUMENTAR A MEMÓRIA DISPONIVEL PARA O php

-php --ini -> localiza o arquivo de configuração do php
LOCALIZA memory_limit = 1000 e altera para 
         memory_limit  = -1 e Salva

### LISTA A RELAÇÃO DE COMANDOS 
php artisan list 

DEVERA SURGIR AS OPÇÕES ABAIXO:

 ui
  ui:auth               Scaffold basic login and registration views and routes
  ui:controllers        Scaffold the authentication controllers
 vendor

### ENTENDENDO O PACOTE UI E INICIANDO A AUTENTICAÇÃO WEB NATIVA DO LARAVEL

COMANDO PARA LISTAR ROUTES: 
php artisan route:list

### php artisan ui bootstrap --auth (bootstrap ou react ou vue)
aplicando o bootstrap incluindo os recursos de autenticação;
poderia ser aplicado o bootstrap sem os recursos de autenticação;

### php artisan route:list -> mostra as rotas - ver que aumentaram as rotas

### APÓS ESSE PROCESSO O SISTEMA PEDE PARA RODAR
npm install -> instala as dependências do package.json (inclusive o bootstrap)
npm run dev -> gera os assets da aplicação de acordo com a tecnologia selecionada (bootstrap, react ou vue) -> Geralmente roda mais de uma vez para compilar tudo.

### CRIA O BANCO DE DADOS NORMALMENTE

### EXECUTA AS MIGRATIONS PADRÕES CRIADAS PARA O SISTEMA DE login
php artisan migrate -> CRIA AS TABELAS NO BANCO DE DADOS


************************************** 
INSTALANDO O COMPOSER NO UBUNTU
**************************************
sudo apt update
sudo apt install php-cli unzip

cd ~

curl -sS https://getcomposer.org/installer -o composer-setup.php

HASH=`curl -sS https://composer.github.io/installer.sig`

echo $HASH ->saída: Output
e0012edf3e80b6978849f5eff0d4b4e4c79ff1609dd1e613307e16318854d24ae64f26d17af3ef0bf7cfb710ca74



php -r "if (hash_file('SHA384', 'composer-setup.php') === '$HASH') { echo 'Installer verified'; } else { echo 'Installer corrupt'; unlink('composer-setup.php'); } echo PHP_EOL;"

sudo php composer-setup.php --install-dir=/usr/local/bin --filename=composer





***********************

DigitalOcean Kubernetes: novo plano de controle é mais rápido e gratuito, habilita HA para SLA de 99,95% de tempo de atividade
Produtos
Preços

Documentos
divisa suspensa

Entrar
divisa suspensa

// Tutorial //
Como Instalar e Utilizar o Composer no Ubuntu 20.04
Publicado em 21 de maio de 2020
Ubuntu
PHP
Ubuntu 20.04
Avatar padrão
Por Erika Heidi
Advogado Desenvolvedor
Português
Como Instalar e Utilizar o Composer no Ubuntu 20.04
Introdução
O Composer é uma ferramenta popular de gerenciamento de dependências para o PHP, criado para facilitar a instalação e a atualização das dependências principalmente do projeto. Ele controla quais outros pacotes de projeto específico dependem e são instalados para você, usando as opções apropriadas de acordo com os requisitos do projeto. O Composer também é comumente utilizado para inicializar novos projetos em frameworks PHP populares, como o Symfon e o Laravel .

Neste tutorial, você instalará e começará a usar o Composer em um sistema Ubuntu 20.04.

Pré-requisitos
Para seguir este guia, você pode acessar um servidor como usuário Ubuntu20.04 como usuário sudonão-root um firewall habilitado em seu servidor Para configurar isto, siga nosso guia Configuração do servidor inicial para o Ubuntu 20.04

Passo 1 — Instalando o PHP e as Dependências Adicionais
Além das dependências que já devem estar incluídas em seu sistema Ubuntu 20.04, como o , o Composer exige ou gitexecuta scripts PHP na linha de comando e para extrair arquivos zipados. Vamos instalar essas dependências agora.curlphp-cliunzip

primeiro, atual, gerenciador de pacotes de soluções: o cache do gerenciador de pacotes

sudo apt update
Em seguida, o seguinte comando para instalar os pacotes, execute:

sudo apt install php-cli unzip
Você será solicitado a confirmar a instalação digitando Ye, depois, ENTER.

Assim que os pré-requisitos para instalação do Composer forem instalados, você poderá seguir.

Passo 2 — Baixando e Instalando o Compositor
O Composer fornece um instalador de script escrito em PHP. Vamos baixá-lo, verificar se ele não está danificado e, em seguida, o usaremos para instalar o Composer.

Certifique-se de estar em sua pasta home. Em seguida, baixe o instalador usando o curl:

cd ~
curl -sS https://getcomposer.org/installer -o composer-setup.php
Em seguida, vamos verificar se o instalador baixado corresponde ao hash SHA-384 para o instalador mais recente encontrado na página Composer Public Keys / Signatures . Para facilitar o passo de seleção, você pode usar o seguinte comando para obter programaticamente o hash mais recente da página do Composer e armazená-lo em uma variável do shell:

HASH=`curl -sS https://composer.github.io/installer.sig`
Se você quiser verificar o valor realizado, execute:

echo $HASH
Output
e0012edf3e80b6978849f5eff0d4b4e4c79ff1609dd1e613307e16318854d24ae64f26d17af3ef0bf7cfb710ca74755a
Agora o código PHP a seguir, execute conforme a página de download do Composer, para verificar se o script de instalação está seguro para ser executado:

php -r "if (hash_file('SHA384', 'composer-setup.php') === '$HASH') { echo 'Installer verified'; } else { echo 'Installer corrupt'; unlink('composer-setup.php'); } echo PHP_EOL;"
Você verá o seguinte resultado:

Resultado
Installer verified
Se Installer corruptvocê estiver usando o hash correto, verifique se você está usando o hash correto. Em seguida, repita o processo de verificação. Quando você tiver um instalador selecionado, você pode continuar.

Para instalar o composerglobalmente, use o seguinte comando que baixará e instalará o Composer como um comando disponível em todo o sistema chamado composer, sob /usr/local/bin:

sudo php composer-setup.php --install-dir=/usr/local/bin --filename=composer
Você verá um resultado semelhante com este:

Output
All settings correct for using Composer
Downloading...

Composer (version 1.10.5) successfully installed to: /usr/local/bin/composer
Use it: php /usr/local/bin/composer
Para testar sua instalação, execute:

composer
Output
   ______
  / ____/___  ____ ___  ____  ____  ________  _____
 / /   / __ \/ __ `__ \/ __ \/ __ \/ ___/ _ \/ ___/
/ /___/ /_/ / / / / / / /_/ / /_/ (__  )  __/ /
\____/\____/_/ /_/ /_/ .___/\____/____/\___/_/
                    /_/
Composer version 1.10.5 2020-04-10 11:44:22

Usage:
  command [options] [arguments]

Options:
  -h, --help                     Display this help message
  -q, --quiet                    Do not output any message
  -V, --version                  Display this application version
      --ansi                     Force ANSI output
      --no-ansi                  Disable ANSI output
  -n, --no-interaction           Do not ask any interactive question
      --profile                  Display timing and memory usage information
      --no-plugins               Whether to disable plugins.
  -d, --working-dir=WORKING-DIR  If specified, use the given directory as working directory.
      --no-cache                 Prevent use of the cache
  -v|vv|vvv, --verbose           Increase the verbosity of messages: 1 for normal output, 2 for more verbose output and 3 for debug
...
Isso verifica que o Composer foi instalado com sucesso em seu sistema e está disponível em todo o sistema.

Nota: se você preferirá ter-lhe-ão separados separados do Composer para projeto hospedado neste servidor, você pode instalar localmente, em uma base por projeto. Este método também é útil quando o usuário do sistema não possui permissão para instalar o software disponível em todo o sistema.

Para fazer isso, use o comando php composer-setup.php. Isso irá gerar um arquivo composer.pharem seu diretório atual, que pode ser executado com o seu atual php composer.phar.

Agora podemos dar uma dependência em como usar o Compose como gerenciar.

Passo 3 — Usando o Compositor em um Projeto PHP
Os projetos PHP geralmente dependentes de bibliotecas externas, e o gerenciamento de dependências e suas versões podem ser complicados. O Composer resolve esse problema de manter um controle de projeto de extensões e dependências, também facilita o processo de descoberta, instalação e atualização de pacotes que são definidos por enquanto.

Para usar o seu projeto, você pode compor um arquivo composer.json. O arquivo composer.jsonComposer quais dependências precisa para baixar seu projeto quais serão as versões de cada pacote tem permissão para instalações e instalações. Isso é muito importante para manter seu projeto consistente e evitar a instalação de versões instáveis ​​que podem causar problemas de compatibilidade retroativa.

Você não precisa criar este arquivo manualmente - é comum ocorrer erros de sintaxe quando fizer isso. O Composer oferece uma maneira de criar um novo arquivo composer.jsoncom base na entrada do usuário, o que é uma boa escolha se você planeja compartilhar seu projeto mais tarde como um pacote público no Packagist . O Composer gera automaticamente um arquivo básico composer.jsonquando você executa um comando composer requirepara incluir uma dependência em um projeto recém-criado.

O processo de uso do Composer para instalar um pacote como uma dependência em um projeto envolve os passos a seguir:

Identifique o tipo de biblioteca que o aplicativo precisa.
uma biblioteca de código aberto adequada no agist.org , o responsável oficial de pacotes para o Compose.
Escolha o pacote de dependência.
Execute composer requirepara incluir a dependência no arquivo composer.jsone instalar o pacote.
Vamos testar isso com uma aplicação de demonstração.

O objetivo desta aplicação é transformar uma determinação determinada em uma string de URL amigável - um slug . Isso é comumente usado para converter os títulos de página para caminhos de URL (Assim como a parte final da URL para este tutorial).

Vamos começar a criar um diretório para o nosso projeto. Vamos chamá-lo de slugify :

cd ~
mkdir slugify
cd slugify
Embora não seja necessário, você pode executar agora um comando composer init para criar um arquivo composer.json detalhado para seu projeto. Como o único objetivo do nosso projeto é demonstrar como instalar dependências com o Composer, usaremos um arquivo composer.json mais simples que será gerado automaticamente quando exigirmos nosso primeiro pacote.

Agora é hora de procurar no Packagist.org por um pacote que pode nos ajudar a gerar slugs. Se você procurar pelo termo “slug” no Packagist, receberá um resultado parecido com este:

Resultados da Pesquisa do Packagist para o termo "slug"

Você verá dois números no lado direito de cada pacote na lista. O número no topo representa quantas vezes o pacote foi instalado através do Composer, e o número em baixo mostra quantas vezes um pacote foi estrelado no GitHub. De um modo geral, os pacotes com mais instalações e mais estrelas tendem a ser mais estáveis, pois mais pessoas os utilizam. Também é importante verificar a descrição do pacote para relevância para garantir que ele é o que você precisa.

Precisamos de um conversor string-to-slug A partir dos resultados da pesquisa, o pacote cocur/slugify, que aparece como o primeiro resultado naquela página, parece ser um bom candidato, com uma quantidade razoável de instalações e estrelas.

Os pacotes no Packagist têm um nome de vendor e um nome de package. Cada pacote tem um identificador único (um namespace) no mesmo formato que o GitHub utiliza para seus repositórios: vendor/package. A biblioteca que queremos instalar utiliza o namespace cocur/slugify. Você precisa de um namespace do pacote para exigi-lo em seu projeto.

Agora que você sabe exatamente qual pacote deseja instalar, você pode executar o composer require para incluí-lo como uma dependência e gerar também o arquivo composer.json para seu projeto. Uma coisa importante é observar a exigência de pacotes. O Composer rastreia as dependências no nível da aplicação e do sistema. As dependências no nível do sistema são importantes para indicar de quais módulos PHP um pacote depende. No caso do pacote cocur/slugify, ele exige um módulo PHP que ainda não instalamos.

Quando um pacote necessário depende de uma biblioteca de sistema que não está atualmente instalada em seu servidor, você receberá um erro informando qual requisito está faltando:

composer require cocur/slugify
Output
Using version ^4.0 for cocur/slugify
./composer.json has been updated
Loading composer repositories with package information
Updating dependencies (including require-dev)
Your requirements could not be resolved to an installable set of packages.

  Problem 1
    - Installation request for cocur/slugify ^4.0 -> satisfiable by cocur/slugify[v4.0.0].
    - cocur/slugify v4.0.0 requires ext-mbstring * -> the requested PHP extension mbstring is missing from your system.
...
Para resolver o problema de dependência do sistema, podemos procurar pelo pacote que falta usando o apt search:

apt search mbstring
Output
Sorting... Done
Full Text Search... Done
php-mbstring/focal 2:7.4+75 all
  MBSTRING module for PHP [default]

php-patchwork-utf8/focal 1.3.1-1 all
  UTF-8 strings handling for PHP

php7.4-mbstring/focal 7.4.3-4ubuntu1 amd64
  MBSTRING module for PHP
Após localizar o nome do pacote correto, você pode utilizar o apt novamente para instalar a dependência de sistema:

sudo apt install php-mbstring
Assim que a instalação terminar, você pode executar novamente o comando composer require:

composer require cocur/slugify
Output
Using version ^4.0 for cocur/slugify
./composer.json has been created
Loading composer repositories with package information
Updating dependencies (including require-dev)
Package operations: 1 install, 0 updates, 0 removals
  - Installing cocur/slugify (v4.0.0): Downloading (100%)         
Writing lock file
Generating autoload files
Como você pode ver na saída, o Composer decidiu automaticamente qual versão do pacote utilizar. Se você verificar o diretório do seu projeto agora, ele irá conter dois arquivos novos: composer.json e composer.lock, e um diretório vendor:

ls -l
Output
total 12
-rw-rw-r-- 1 sammy sammy   59 May  4 13:56 composer.json
-rw-rw-r-- 1 sammy sammy 3229 May  4 13:56 composer.lock
drwxrwxr-x 4 sammy sammy 4096 May  4 13:56 vendor
O arquivo composer.lock é usado para armazenar informações sobre quais versões de cada pacote estão instaladas, e garantir que as mesmas versões sejam usadas se outra pessoa clonar seu projeto e instalar suas dependências. O diretório vendor é onde as dependências do projeto estão localizadas. Você não deve fazer commit da pasta vendor no controle de versão - você precisa apenas incluir os arquivos composer.json e composer.lock.

Ao instalar um projeto que já contém um arquivo composer.json, execute o composer install para baixar as dependências do projeto.

Vamos dar uma olhada rápida em restrições de versão. Se você verificar o conteúdo do seu arquivo composer.json, verá algo parecido com isto:

cat composer.json
Output
{
    "require": {
        "cocur/slugify": "^4.0"
    }
}
Note que há o caractere especial ^ antes do número da versão no composer.json. O Composer suporta várias restrições diferentes e formatos para definir a versão necessária do pacote, para fornecer flexibilidade enquanto também mantém seu projeto estável. O operador circunflexo (^) utilizado pelo arquivo composer.json criado automaticamente é o operador recomendado para a interoperabilidade máxima, seguindo o versionamento semântico. Neste caso, ele define 4.0 como a versão mínima compatível e permite atualizações para qualquer versão futura abaixo de 5.0.

De um modo geral, você não precisará alterar as restrições de versão em seu arquivo composer.json. No entanto, algumas situações podem exigir que você edite manualmente as restrições – por exemplo, quando uma nova versão principal da sua biblioteca requerida é liberada e você deseja atualizar, ou quando a biblioteca que você deseja usar não segue o versionamento semântico.

Aqui estão alguns exemplos para lhe dar um melhor entendimento sobre como as restrições de versão do Composer funcionam:

Restrição	Significado	Exemplo de Versões Permitidas
^1.0	>= 1.0 < 2.0	1.0, 1.2.3, 1.9.9
^1.1.0	>= 1.1.0 < 2.0	1.1.0, 1.5.6, 1.9.9
~1.0	>= 1.0 < 2.0.0	1.0, 1.4.1, 1.9.9
~1.0.0	>= 1.0.0 < 1.1	1.0.0, 1.0.4, 1.0.9
1.2.1	1.2.1	1.2.1
1.*	>= 1.0 < 2.0	1.0.0, 1.4.5, 1.9.9
1.2. *	>= 1.2 < 1.3	1.2.0, 1.2.3, 1.2.9
Para uma visualização mais detalhada das restrições de versão do Composer, consulte a documentação oficial.

A seguir, vamos ver como carregar dependências automaticamente com o Composer.

Passo 4 — Incluindo o Script Autoload
Como o PHP por si só não carrega classes automaticamente, o Composer fornece um script autoload que você pode incluir em seu projeto para obter o carregamento automático para ele. Este arquivo é gerado automaticamente pelo Composer quando você adiciona sua primeira dependência.

A única coisa que você precisa fazer é incluir o arquivo vendor/autoload.php em seus scripts PHP antes de qualquer instância de classe.

Vamos testar isso em nossa aplicação de demonstração. Abra um novo arquivo chamado test.php em seu editor de texto:

nano test.php
Adicione o código a seguir que vem no arquivo vendor/autoload.php, carrega a dependência cocur/slugify, e o utiliza para criar um slug:

test.php
<?php
require __DIR__ . '/vendor/autoload.php';

use Cocur\Slugify\Slugify;

$slugify = new Slugify();

echo $slugify->slugify('Hello World, this is a long sentence and I need to make a slug from it!');
Salve o arquivo e saia do seu editor.

Agora, execute o script.

php test.php
Isso produz a saída hello-world-this-is-a-long-sentence-and-i-need-to-make-a-slug-from-it.

As dependências precisam de atualizações quando novas versões são liberadas. Dessa forma, vamos ver como lidar com isso.

Passo 5 — Atualizando as Dependências do Projeto
Sempre que você quiser atualizar suas dependências do projeto para versões mais recentes, execute o comando update:

composer update
Isso irá verificar por versões mais recentes das bibliotecas que você requer em seu projeto. Se uma versão mais recente for encontrada e ela for compatível com a restrição de versão definida no arquivo composer.json, o Composer substituirá a versão anterior instalada. O arquivo composer.lock será atualizado para refletir essas alterações.

Você também pode atualizar uma ou mais bibliotecas específicas, especificando-as desta forma:

composer update vendor/package vendor2/package2
Certifique-se de verificar em seus arquivos composer.json e composer.lock dentro do seu sistema de controle de versão após atualizar suas dependências de modo que outros também possam instalar essas versões mais recentes.

Conclusão





***********
Algoritmo "CalculoMedia2"
// Disciplina: Lógica de programação
// Professor : Antonio Carlos Nicolodi
// Descrição : calculo da média aritimética
// Autor     : Professor Antonio
// Data atual: 01/04/2015
var
// Seção de Declarações
   v1, v2, total: Real
   sinal : Caracter
Inicio
// Seção dos Comandos
   Escreva ("Digite o primeiro valor: ")
   Leia (v1)
   Escreva ("Digite a operação + - * / : ")
   Leia (sinal)
   Escreva ("Digite o segundo valor: ")
   Leia (v2)

   Se sinal = "+" entao
   total <- v1 + v2
   Escreva("O Resultado é: ", total)
   Senao
   Se sinal = "-" entao
   total <- v1 - v2
   Escreva("O Resultado é: ", total)
   Senao
   Se sinal = "*" entao
   total <- v1 * v2
   Escreva("O Resultado é: ", total)


   Senao
     Escreva("OPERAÇÃO INVÁLIDA! ")



      Escreval("total")
   fimse
Fimalgoritmo

****
COMANDOS DOCKER
root@DELLAGS:~# curl -s "https://laravel.build/laravel-9-course?with=mysql,redis,mailhog" | bash

root@DELLAGS:~/example-app# ./vendor/bin/sail  artisan migrate --seed -> criar o banco de dados e copular dados;

Dockerfile

root@DELLAGS:~/example-app# docker exec -it example-app-mysql-1 bash


FROM wyveo/nginx-php-fpm:latest
WORKDIR /usr/share/nginx
RUN rm -rf /usr/share/nginx/html
COPY . /usr/share/nginx
RUN chmod -R 755 /usr/share/nginx/storage/*
RUN ln -s public html

.env (do composer)

DB_CONNECTION=mysql
DB_HOST=mysql-app (serviço do mysql no docker-compose.yaml)
DB_PORT=3306
DB_DATABASE=laraveldockerdb
DB_USERNAME=root
DB_PASSWORD=123456



docker-compose.yaml

version: '3'

services:
  laraveldocker-app:
    build: .
    ports:
      - "3003:80"
    volumes:
      - ./:/usr/share/nginx
      - .docker/nginx:/etc/nginx/conf.d/
    networks:
      - app-network
  mysql-app:
    image: mysql:5.7.22
    ports:
      - "3306:3306"
    volumes:
      - .docker/dbdata:/var/lib/mysql
    environment:
      MYSQL_DATABASE: laraveldocker
      MYSQL_ROOT_PASSWORD: 123456
    networks:
      - app-network
networks:
  app-network:
    driver: bridge
    



/*************************************************
#criando um serviço com um nome qualquer
version: '3'

services:
  laravel-app:                    #criando um serviço com um nome qualquer
    build: . ou image: wyveo/nginx-php-fpm:latest -> neste caso sem Dockerfile.                    # endereço da imagem ou local do Dockerfile (neste caso o ponto siginifica a raiz do projeto)
    ports:
      - "8080:80"                 # 8080 porta do meu host: 80 é a porta do docker nginx
    volumes:                      # docker-compose up -d -> sobe a imagem e libera o terminal  
      - ./:/usr/share/nginx       # TUDO QUE ESTIVE NA RAIZ (na rais tem o meu projeto laravel) './' IRÁ SER REFLETIDO NA PASTA /usr/share/nginx (pasta de acesso da página html)
                                  # C:\Laravel-docker\laravel-docker>docker compose up -d --build atualiza a minha imagem

  mysql-app:
      image: mysql:5.7
      ports:
        - "3306:3306"
      volumes:
        - .docker/dbdata:/var/lib/mysql          # qualqer nome (para persistir -guardar os dados do banco de dados)


      environment:
        MYSQL_DATABASE: laravel
        MYSQL_ROOT_PASSWORD: laravel
    
      

      /***************************///


  
C:\Laravel-docker\laravel-docker>docker compose up -d --build

                                
                               

    

/******************************** Dockerfile
FROM wyveo/nginx-php-fpm:latest

/***************************///
  COMANDOS

docker compose down -> para todos os containers
C:\Laravel-docker\laravel-docker>docker exec -it laravel-docker-laravel-app-1 bash 
root@612ea0ea3340:/# cd /usr/share/nginx/
root@612ea0ea3340:/usr/share/nginx# php artisan migrate
root@612ea0ea3340:/usr/share/nginx# php artisan serve

		
/***********/
PS C:\Users\alber> docker run -e MYSQL_ROOT_PASSWORD=root --name meu-mysql -d mysql:5.7

docker inspect meu-mysql ou | grep IPAddress

PS C:\Users\alber> docker run -e MYSQL_ROOT_PASSWORD=root --name meu-mysql -d -p 3306:3306 mysql:5.7

docker ps
docker ps -l
docker ps -a
docker rm -f nome


/*** LARAVEL */
### CRIANDO UM PROJETO NO LARAVEL 
laravel new projeto_laravel_via_installer (ESTA É UM AOPÇÃO)
composer create-project --prefer-dist laravel/laravel app_controle_tarefas "8.5.9"
cd app_controle_tarefas
cd public
php -S localhost:8000

ou 
da raiz do projeto:
php artisan serve 
ou
php artisan serve --port=3000

### PARA ABRIR PORTA EM OUTRO SERVIDOR
php artisan serve --host test.com --port 8080

 **********************************************************************
cd app_controle_tarefas
cd public
php artisan serve
- acessa o navegador http://localhost:8000

### DENTRO DO PROJETO CRIADO INSTALAR O LARAVEL/UI:^3.2 - versão 3.2
composer require laravel/ui:^3.2

### SE OCORRER ERRO AUMENTAR A MEMÓRIA DISPONIVEL PARA O php

-php --ini -> localiza o arquivo de configuração do php
LOCALIZA memory_limit = 1000 e altera para 
         memory_limit  = -1 e Salva

### LISTA A RELAÇÃO DE COMANDOS 
php artisan list 

DEVERA SURGIR AS OPÇÕES ABAIXO:

 ui
  ui:auth               Scaffold basic login and registration views and routes
  ui:controllers        Scaffold the authentication controllers
 vendor

### ENTENDENDO O PACOTE UI E INICIANDO A AUTENTICAÇÃO WEB NATIVA DO LARAVEL

COMANDO PARA LISTAR ROUTES: 
php artisan route:list

### php artisan ui bootstrap --auth (bootstrap ou react ou vue)
aplicando o bootstrap incluindo os recursos de autenticação;
poderia ser aplicado o bootstrap sem os recursos de autenticação;

### php artisan route:list -> mostra as rotas - ver que aumentaram as rotas

### APÓS ESSE PROCESSO O SISTEMA PEDE PARA RODAR
npm install -> instala as dependências do package.json (inclusive o bootstrap)
npm run dev -> gera os assets da aplicação de acordo com a tecnologia selecionada (bootstrap, react ou vue) -> Geralmente roda mais de uma vez para compilar tudo.

### CRIA O BANCO DE DADOS NORMALMENTE

### EXECUTA AS MIGRATIONS PADRÕES CRIADAS PARA O SISTEMA DE login
php artisan migrate -> CRIA AS TABELAS NO BANCO DE DADOS


************************************** 
INSTALANDO O COMPOSER NO UBUNTU
**************************************
sudo apt update
sudo apt install php-cli unzip

cd ~

curl -sS https://getcomposer.org/installer -o composer-setup.php

HASH=`curl -sS https://composer.github.io/installer.sig`

echo $HASH ->saída: Output
e0012edf3e80b6978849f5eff0d4b4e4c79ff1609dd1e613307e16318854d24ae64f26d17af3ef0bf7cfb710ca74



php -r "if (hash_file('SHA384', 'composer-setup.php') === '$HASH') { echo 'Installer verified'; } else { echo 'Installer corrupt'; unlink('composer-setup.php'); } echo PHP_EOL;"

sudo php composer-setup.php --install-dir=/usr/local/bin --filename=composer





***********************

DigitalOcean Kubernetes: novo plano de controle é mais rápido e gratuito, habilita HA para SLA de 99,95% de tempo de atividade
Produtos
Preços

Documentos
divisa suspensa

Entrar
divisa suspensa

// Tutorial //
Como Instalar e Utilizar o Composer no Ubuntu 20.04
Publicado em 21 de maio de 2020
Ubuntu
PHP
Ubuntu 20.04
Avatar padrão
Por Erika Heidi
Advogado Desenvolvedor
Português
Como Instalar e Utilizar o Composer no Ubuntu 20.04
Introdução
O Composer é uma ferramenta popular de gerenciamento de dependências para o PHP, criado para facilitar a instalação e a atualização das dependências principalmente do projeto. Ele controla quais outros pacotes de projeto específico dependem e são instalados para você, usando as opções apropriadas de acordo com os requisitos do projeto. O Composer também é comumente utilizado para inicializar novos projetos em frameworks PHP populares, como o Symfon e o Laravel .

Neste tutorial, você instalará e começará a usar o Composer em um sistema Ubuntu 20.04.

Pré-requisitos
Para seguir este guia, você pode acessar um servidor como usuário Ubuntu20.04 como usuário sudonão-root um firewall habilitado em seu servidor Para configurar isto, siga nosso guia Configuração do servidor inicial para o Ubuntu 20.04

Passo 1 — Instalando o PHP e as Dependências Adicionais
Além das dependências que já devem estar incluídas em seu sistema Ubuntu 20.04, como o , o Composer exige ou gitexecuta scripts PHP na linha de comando e para extrair arquivos zipados. Vamos instalar essas dependências agora.curlphp-cliunzip

primeiro, atual, gerenciador de pacotes de soluções: o cache do gerenciador de pacotes

sudo apt update
Em seguida, o seguinte comando para instalar os pacotes, execute:

sudo apt install php-cli unzip
Você será solicitado a confirmar a instalação digitando Ye, depois, ENTER.

Assim que os pré-requisitos para instalação do Composer forem instalados, você poderá seguir.

Passo 2 — Baixando e Instalando o Compositor
O Composer fornece um instalador de script escrito em PHP. Vamos baixá-lo, verificar se ele não está danificado e, em seguida, o usaremos para instalar o Composer.

Certifique-se de estar em sua pasta home. Em seguida, baixe o instalador usando o curl:

cd ~
curl -sS https://getcomposer.org/installer -o composer-setup.php
Em seguida, vamos verificar se o instalador baixado corresponde ao hash SHA-384 para o instalador mais recente encontrado na página Composer Public Keys / Signatures . Para facilitar o passo de seleção, você pode usar o seguinte comando para obter programaticamente o hash mais recente da página do Composer e armazená-lo em uma variável do shell:

HASH=`curl -sS https://composer.github.io/installer.sig`
Se você quiser verificar o valor realizado, execute:

echo $HASH
Output
e0012edf3e80b6978849f5eff0d4b4e4c79ff1609dd1e613307e16318854d24ae64f26d17af3ef0bf7cfb710ca74755a
Agora o código PHP a seguir, execute conforme a página de download do Composer, para verificar se o script de instalação está seguro para ser executado:

php -r "if (hash_file('SHA384', 'composer-setup.php') === '$HASH') { echo 'Installer verified'; } else { echo 'Installer corrupt'; unlink('composer-setup.php'); } echo PHP_EOL;"
Você verá o seguinte resultado:

Resultado
Installer verified
Se Installer corruptvocê estiver usando o hash correto, verifique se você está usando o hash correto. Em seguida, repita o processo de verificação. Quando você tiver um instalador selecionado, você pode continuar.

Para instalar o composerglobalmente, use o seguinte comando que baixará e instalará o Composer como um comando disponível em todo o sistema chamado composer, sob /usr/local/bin:

sudo php composer-setup.php --install-dir=/usr/local/bin --filename=composer
Você verá um resultado semelhante com este:

Output
All settings correct for using Composer
Downloading...

Composer (version 1.10.5) successfully installed to: /usr/local/bin/composer
Use it: php /usr/local/bin/composer
Para testar sua instalação, execute:

composer
Output
   ______
  / ____/___  ____ ___  ____  ____  ________  _____
 / /   / __ \/ __ `__ \/ __ \/ __ \/ ___/ _ \/ ___/
/ /___/ /_/ / / / / / / /_/ / /_/ (__  )  __/ /
\____/\____/_/ /_/ /_/ .___/\____/____/\___/_/
                    /_/
Composer version 1.10.5 2020-04-10 11:44:22

Usage:
  command [options] [arguments]

Options:
  -h, --help                     Display this help message
  -q, --quiet                    Do not output any message
  -V, --version                  Display this application version
      --ansi                     Force ANSI output
      --no-ansi                  Disable ANSI output
  -n, --no-interaction           Do not ask any interactive question
      --profile                  Display timing and memory usage information
      --no-plugins               Whether to disable plugins.
  -d, --working-dir=WORKING-DIR  If specified, use the given directory as working directory.
      --no-cache                 Prevent use of the cache
  -v|vv|vvv, --verbose           Increase the verbosity of messages: 1 for normal output, 2 for more verbose output and 3 for debug
...
Isso verifica que o Composer foi instalado com sucesso em seu sistema e está disponível em todo o sistema.

Nota: se você preferirá ter-lhe-ão separados separados do Composer para projeto hospedado neste servidor, você pode instalar localmente, em uma base por projeto. Este método também é útil quando o usuário do sistema não possui permissão para instalar o software disponível em todo o sistema.

Para fazer isso, use o comando php composer-setup.php. Isso irá gerar um arquivo composer.pharem seu diretório atual, que pode ser executado com o seu atual php composer.phar.

Agora podemos dar uma dependência em como usar o Compose como gerenciar.

Passo 3 — Usando o Compositor em um Projeto PHP
Os projetos PHP geralmente dependentes de bibliotecas externas, e o gerenciamento de dependências e suas versões podem ser complicados. O Composer resolve esse problema de manter um controle de projeto de extensões e dependências, também facilita o processo de descoberta, instalação e atualização de pacotes que são definidos por enquanto.

Para usar o seu projeto, você pode compor um arquivo composer.json. O arquivo composer.jsonComposer quais dependências precisa para baixar seu projeto quais serão as versões de cada pacote tem permissão para instalações e instalações. Isso é muito importante para manter seu projeto consistente e evitar a instalação de versões instáveis ​​que podem causar problemas de compatibilidade retroativa.

Você não precisa criar este arquivo manualmente - é comum ocorrer erros de sintaxe quando fizer isso. O Composer oferece uma maneira de criar um novo arquivo composer.jsoncom base na entrada do usuário, o que é uma boa escolha se você planeja compartilhar seu projeto mais tarde como um pacote público no Packagist . O Composer gera automaticamente um arquivo básico composer.jsonquando você executa um comando composer requirepara incluir uma dependência em um projeto recém-criado.

O processo de uso do Composer para instalar um pacote como uma dependência em um projeto envolve os passos a seguir:

Identifique o tipo de biblioteca que o aplicativo precisa.
uma biblioteca de código aberto adequada no agist.org , o responsável oficial de pacotes para o Compose.
Escolha o pacote de dependência.
Execute composer requirepara incluir a dependência no arquivo composer.jsone instalar o pacote.
Vamos testar isso com uma aplicação de demonstração.

O objetivo desta aplicação é transformar uma determinação determinada em uma string de URL amigável - um slug . Isso é comumente usado para converter os títulos de página para caminhos de URL (Assim como a parte final da URL para este tutorial).

Vamos começar a criar um diretório para o nosso projeto. Vamos chamá-lo de slugify :

cd ~
mkdir slugify
cd slugify
Embora não seja necessário, você pode executar agora um comando composer init para criar um arquivo composer.json detalhado para seu projeto. Como o único objetivo do nosso projeto é demonstrar como instalar dependências com o Composer, usaremos um arquivo composer.json mais simples que será gerado automaticamente quando exigirmos nosso primeiro pacote.

Agora é hora de procurar no Packagist.org por um pacote que pode nos ajudar a gerar slugs. Se você procurar pelo termo “slug” no Packagist, receberá um resultado parecido com este:

Resultados da Pesquisa do Packagist para o termo "slug"

Você verá dois números no lado direito de cada pacote na lista. O número no topo representa quantas vezes o pacote foi instalado através do Composer, e o número em baixo mostra quantas vezes um pacote foi estrelado no GitHub. De um modo geral, os pacotes com mais instalações e mais estrelas tendem a ser mais estáveis, pois mais pessoas os utilizam. Também é importante verificar a descrição do pacote para relevância para garantir que ele é o que você precisa.

Precisamos de um conversor string-to-slug A partir dos resultados da pesquisa, o pacote cocur/slugify, que aparece como o primeiro resultado naquela página, parece ser um bom candidato, com uma quantidade razoável de instalações e estrelas.

Os pacotes no Packagist têm um nome de vendor e um nome de package. Cada pacote tem um identificador único (um namespace) no mesmo formato que o GitHub utiliza para seus repositórios: vendor/package. A biblioteca que queremos instalar utiliza o namespace cocur/slugify. Você precisa de um namespace do pacote para exigi-lo em seu projeto.

Agora que você sabe exatamente qual pacote deseja instalar, você pode executar o composer require para incluí-lo como uma dependência e gerar também o arquivo composer.json para seu projeto. Uma coisa importante é observar a exigência de pacotes. O Composer rastreia as dependências no nível da aplicação e do sistema. As dependências no nível do sistema são importantes para indicar de quais módulos PHP um pacote depende. No caso do pacote cocur/slugify, ele exige um módulo PHP que ainda não instalamos.

Quando um pacote necessário depende de uma biblioteca de sistema que não está atualmente instalada em seu servidor, você receberá um erro informando qual requisito está faltando:

composer require cocur/slugify
Output
Using version ^4.0 for cocur/slugify
./composer.json has been updated
Loading composer repositories with package information
Updating dependencies (including require-dev)
Your requirements could not be resolved to an installable set of packages.

  Problem 1
    - Installation request for cocur/slugify ^4.0 -> satisfiable by cocur/slugify[v4.0.0].
    - cocur/slugify v4.0.0 requires ext-mbstring * -> the requested PHP extension mbstring is missing from your system.
...
Para resolver o problema de dependência do sistema, podemos procurar pelo pacote que falta usando o apt search:

apt search mbstring
Output
Sorting... Done
Full Text Search... Done
php-mbstring/focal 2:7.4+75 all
  MBSTRING module for PHP [default]

php-patchwork-utf8/focal 1.3.1-1 all
  UTF-8 strings handling for PHP

php7.4-mbstring/focal 7.4.3-4ubuntu1 amd64
  MBSTRING module for PHP
Após localizar o nome do pacote correto, você pode utilizar o apt novamente para instalar a dependência de sistema:

sudo apt install php-mbstring
Assim que a instalação terminar, você pode executar novamente o comando composer require:

composer require cocur/slugify
Output
Using version ^4.0 for cocur/slugify
./composer.json has been created
Loading composer repositories with package information
Updating dependencies (including require-dev)
Package operations: 1 install, 0 updates, 0 removals
  - Installing cocur/slugify (v4.0.0): Downloading (100%)         
Writing lock file
Generating autoload files
Como você pode ver na saída, o Composer decidiu automaticamente qual versão do pacote utilizar. Se você verificar o diretório do seu projeto agora, ele irá conter dois arquivos novos: composer.json e composer.lock, e um diretório vendor:

ls -l
Output
total 12
-rw-rw-r-- 1 sammy sammy   59 May  4 13:56 composer.json
-rw-rw-r-- 1 sammy sammy 3229 May  4 13:56 composer.lock
drwxrwxr-x 4 sammy sammy 4096 May  4 13:56 vendor
O arquivo composer.lock é usado para armazenar informações sobre quais versões de cada pacote estão instaladas, e garantir que as mesmas versões sejam usadas se outra pessoa clonar seu projeto e instalar suas dependências. O diretório vendor é onde as dependências do projeto estão localizadas. Você não deve fazer commit da pasta vendor no controle de versão - você precisa apenas incluir os arquivos composer.json e composer.lock.

Ao instalar um projeto que já contém um arquivo composer.json, execute o composer install para baixar as dependências do projeto.

Vamos dar uma olhada rápida em restrições de versão. Se você verificar o conteúdo do seu arquivo composer.json, verá algo parecido com isto:

cat composer.json
Output
{
    "require": {
        "cocur/slugify": "^4.0"
    }
}
Note que há o caractere especial ^ antes do número da versão no composer.json. O Composer suporta várias restrições diferentes e formatos para definir a versão necessária do pacote, para fornecer flexibilidade enquanto também mantém seu projeto estável. O operador circunflexo (^) utilizado pelo arquivo composer.json criado automaticamente é o operador recomendado para a interoperabilidade máxima, seguindo o versionamento semântico. Neste caso, ele define 4.0 como a versão mínima compatível e permite atualizações para qualquer versão futura abaixo de 5.0.

De um modo geral, você não precisará alterar as restrições de versão em seu arquivo composer.json. No entanto, algumas situações podem exigir que você edite manualmente as restrições – por exemplo, quando uma nova versão principal da sua biblioteca requerida é liberada e você deseja atualizar, ou quando a biblioteca que você deseja usar não segue o versionamento semântico.

Aqui estão alguns exemplos para lhe dar um melhor entendimento sobre como as restrições de versão do Composer funcionam:

Restrição	Significado	Exemplo de Versões Permitidas
^1.0	>= 1.0 < 2.0	1.0, 1.2.3, 1.9.9
^1.1.0	>= 1.1.0 < 2.0	1.1.0, 1.5.6, 1.9.9
~1.0	>= 1.0 < 2.0.0	1.0, 1.4.1, 1.9.9
~1.0.0	>= 1.0.0 < 1.1	1.0.0, 1.0.4, 1.0.9
1.2.1	1.2.1	1.2.1
1.*	>= 1.0 < 2.0	1.0.0, 1.4.5, 1.9.9
1.2. *	>= 1.2 < 1.3	1.2.0, 1.2.3, 1.2.9
Para uma visualização mais detalhada das restrições de versão do Composer, consulte a documentação oficial.

A seguir, vamos ver como carregar dependências automaticamente com o Composer.

Passo 4 — Incluindo o Script Autoload
Como o PHP por si só não carrega classes automaticamente, o Composer fornece um script autoload que você pode incluir em seu projeto para obter o carregamento automático para ele. Este arquivo é gerado automaticamente pelo Composer quando você adiciona sua primeira dependência.

A única coisa que você precisa fazer é incluir o arquivo vendor/autoload.php em seus scripts PHP antes de qualquer instância de classe.

Vamos testar isso em nossa aplicação de demonstração. Abra um novo arquivo chamado test.php em seu editor de texto:

nano test.php
Adicione o código a seguir que vem no arquivo vendor/autoload.php, carrega a dependência cocur/slugify, e o utiliza para criar um slug:

test.php
<?php
require __DIR__ . '/vendor/autoload.php';

use Cocur\Slugify\Slugify;

$slugify = new Slugify();

echo $slugify->slugify('Hello World, this is a long sentence and I need to make a slug from it!');
Salve o arquivo e saia do seu editor.

Agora, execute o script.

php test.php
Isso produz a saída hello-world-this-is-a-long-sentence-and-i-need-to-make-a-slug-from-it.

As dependências precisam de atualizações quando novas versões são liberadas. Dessa forma, vamos ver como lidar com isso.

Passo 5 — Atualizando as Dependências do Projeto
Sempre que você quiser atualizar suas dependências do projeto para versões mais recentes, execute o comando update:

composer update
Isso irá verificar por versões mais recentes das bibliotecas que você requer em seu projeto. Se uma versão mais recente for encontrada e ela for compatível com a restrição de versão definida no arquivo composer.json, o Composer substituirá a versão anterior instalada. O arquivo composer.lock será atualizado para refletir essas alterações.

Você também pode atualizar uma ou mais bibliotecas específicas, especificando-as desta forma:

composer update vendor/package vendor2/package2
Certifique-se de verificar em seus arquivos composer.json e composer.lock dentro do seu sistema de controle de versão após atualizar suas dependências de modo que outros também possam instalar essas versões mais recentes.








INÍCIO:

1 instalar o docker

2 abrir wsl2/Windows ou linux
 curl -s "https://laravel.build/olw?with=mysql,redis,mailhog,minio" | bash

3 cd olw
./vendor/bin/sail up -d
	ou
4 cd olw && ./vendor/bin/sail up -d

5 ATRIBUINDO PERMISSÃO PARA A PASTA
cd .. -> sai da pasta
sudo chmod 777 olw/ -R ou sem o 'sudo' chmod 777 olw/ -R

6 CRIANDO ALIAS PARA O COMANDO ANTERIOR
alias sail='[ -f sail ] && sh sail || sh vendor/bin/sail'
passa a usar assim: sail ps

7 CONFIGURAR PORTAS PARA A APLICAÇÃO NO NAVEGADOR E MYSQL
.env
APP_PORT=8000

*porta do myql
FORWARD_DB_PORT=3307

8 INSTALANDO DEPENDÊNCIA AO PROJETO
./vendor/bin/sail composer require laravel/breeze --dev

9 DEIXAR TELA DE AUTENTICAÇÃO PRONTA, ROTA AUTENTICADA, TAWINDCSS INSTALADO E INERTIA INSTALADO
./vendor/bin/sail artisan breeze:install vue 
ou
./vendor/bin/sail art breeze:install vue


10 RODAR AS MIGRATES PADRÕES DO PROJETO AI JÁ PODE CADASTRAR USUÁRIOS PARA LOGIN:
./vendor/bin/sail art migrate

11 


/*******************************************/
2a AULA:

O PROJETO CONSISTE EM RECEBER DADOS DE UMA API (punkapi.com) DE INFORMAÇÕES SOBRE CERVEJAS, VAMOS CONSTRUIR AS ROTAS PARA CONSUMIR A API E CRIAR A ESTRUTURA PARA O RELATÓRIO QUE IREMOS GERAR EM EXCEL E ENVIAR PARA O STORAGE...
1 CRIAR ROTAS:
code .
olw/routes/web.php


sail up -d -> SOBE O CONTAINER localhost:8000 (nesse projeto)

Route::get('/beers', fn()=> 'Olw - testando a rota /beers');

**************************************************
obs:
- laravel.com/api -> acesso a documentação do código;
- in line paramets for vscode -> extensão para vscode para exibir o nome dos métodos na hora que codificar;
- fira code -> extensão para fonte no vscode

Copilot vs Tabnine, qual preferem? (pesquisar sobre)
Link para extensões vscode:
https://github.com/icarojobs/vscode-useful-extensions
*************************************************


Route::get('/beers', fn()=> 'Olw - testando a rota /beers')
                             ->middleware(['auth']);

* FLUXO PADRÃO DO MVC-LARAVEL: 
life cicle: sai do usuário pelo navegador, insomnia ou postman -> passa pelo index.php(pasta public) -> passa pelos arquivos do bootstrap retornando uma instância da aplicação -> passa pelo kernel do http (carrega mais instâncias) -> Service provider -> despacha a requisição pro Router -> Cai no arquivo Web.php -> Middleware (se tiver, geralmente tem os globais) -> Controller (faz as regras de negócio e pode chamar outras classes como Serviços por exemplo)
-> Retorna uma view ou um json (No caso estamos usando inértia, ele não vai reinderizar a 'view.blade' padrão, ele vai reinderizar componente vue.js através do inértia.).


* EM VEZ DE USAR A FUNÇÃO AQUI NA ROTA CRIAMOS UM CONTROLLER:
obs.: ​dica: php artisan make:controller -r cria o Resource também.

sail artisan make:controller BeerController
ou 
sail art make:controller BeerController -> CRIA O ARQUIVO BeerController.php na pasta app/Http/Controllers
->
<?php

namespace App\Http\Controllers;

use Illuminate\Http\Request;

class BeerController extends Controller
{
    public function index()
    {
    return 'Virgu & Beer & Code'
    }
}

* NO ARQUIVO DE ROTAS Web.php CHAMA O BeersController:

importante importar o Controller <nomeDoController>+<CTRL=ENTER:
use App\Http\Controllers\BeerController;

Route::get('/beers', [BeerController::class, 'index'])
                        ->middleware(['auth']);


* PRECISAMOS CRIAR UM MÉTODO PARA PEGAR A LISTA, LISTAR OS DADOS DA API (listar as bebidas de https://api.punkapi.com/v2 ->
VAMOS CRIAR UMA NOVA CLASSE de serviços em app/Sevices/PunkapiService.php

* O LARAVEL POSSUI UM RECURSO CHAMADO HTTPClient que abstrai o uso de uma ferramenta chama guzeo, esse guzeo é o client http mais comum para php, com ele fazemos requisições pra diversos serviços web dentro do php para outras url, ele é robusto, então o laravel simplifica importando o recurso que faz tudo por 'detrás dos panos':

PunkapiService.php

<?php

namespace App\Services;

use Illuminate\Support\Facades\Http;

class PunkapiService
{
    public function getBeers()
    {
        return Http::get('https://api.punkapi.com/v2/beers');
    }
}

E NO BeerController.php fica:
<?php

namespace App\Http\Controllers;

use App\Services\PunkapiService;
use Illuminate\Http\Request;

class BeerController extends Controller
{
    public function index()
    {
    //return 'Virgu & Beer & Code';
    $service = new PunkapiService;

    return $service->getBeers();
    }
}

* TRATE É CARACTERÍSTICA QUE A CLASSE ADQUIRE (pode ter mesmos métodos e atributos substituindo o recurso de um classe extender várias classes que não tem no php, a trate é uma forma de fazer isso. O service  é uma outra camada na maioria das vezes abstrair seviços que vc vai consumir, por exemplo API.

Estando logado, os dados da api já serão exibidos em localhost:8000/beers, se usar um aplicativo cliente tipo insomnia pode apresentar os dados também, melhor comentar a linha de de autenticação da rota:
Route::get('/beers', [BeerController::class, 'index']);
linha de autenticação da rota // ->middleware(['auth']);

* ESSA API PERMITE FAZER FILTROS VIA PARÂMETROS NA PRÓPRIA ROTA. PRIMEIRO VAMOS REFATORAR O CÓDIO, A CLASSE PunkapiService.php:

USO DE CONFIG E MACRO


Vamos alterar a url, primeiro acessando a pasta config da raiz do projeto e criar o arquivo punkapi.php. O que acontece é que o config(pasta config da raiz) carrega todos os arquivos da pasta e permite que sejam acessados via funções simples(HELPERS), isso é muito legal porque podemos acessar esses arquivos de configurações de qualquer lugar do projeto: 

<?php

return [
    'url' => env('PUNK_BASE_URL', 'https://api.punkapi.com/v2')
];

Usando o helper env significa dizer que, se não houver a constante PUNK_BASE_URL setada no arquivo .env do projeto, seu valor será o segundo parâmetro: http://api.punkapi.com/v2 e no arquivo PunkapiService.php da pasta app/Services fica:

<?php

namespace App\Services;

use Illuminate\Support\Facades\Http;

class PunkapiService
{
    public function getBeers()
    {
        return Http::get('/beers');
    }
}

MACRO é uma forma de criar funções customizadas:
 em app\Providers vamos acessar o arquivo AppServiceProvider.php que é uma classe que tem dois métodos register e boot. No método boot vamos chamar o método Http do laravel e chamar o método macro, no primeiro parâmetro será um nome atribuído à função e e o segundo uma clausure (uma função).
Neste arquivo é passado o arquivo de configuração da url (em 'config/punkapi.php') além de tokens, headers,...
 

use Illuminate\Support\Facades\Http; -> deve ser importado
E a função boot fica:

  public function boot()
    {
        Http::macro('punkapi', function(){
            return Http::acceptJson()
            ->baseUrl(config('punkapi.url'));
        });
    }

Então criamos uma macro(uma função customizada) chamada punkapi que já retorna o client com accept/Json no Header e com o baseUrl configurado lá do arquivo /config/punkapi.php e se estiver setado no .env pegará de lá.

/app/Services/PunkapiService.php fica:

<?php

namespace App\Services;

use Illuminate\Support\Facades\Http;

class PunkapiService
{
    public function getBeers()
    {
        return Http::punkapi()->get('/beers');
    }
}

*obs.: a baseUrl poderia ser setada no construtor, que pode setar token também.(uma outra abordagem para versão sem macros);

->Testamos o retorno Json em localhost:8000/beers.

Refatorando o arquivo PunkapiService.php: O client Http não lança exceção e podemos forçar o retorno em modo Json:
<?php

namespace App\Services;

use Illuminate\Support\Facades\Http;

class PunkapiService
{
    public function getBeers()
    {
       // return Http::punkapi()->get('/beers');
       return Http::punkapi()
            ->get('/beers')
            ->throw()  // Exceção em caso de erro
            ->json();   // Força o retorno em formato Json
    }
}

Podemos testar forçando um erro alterando a constante PUNKAPI_BASE_URL criada em /config/punkapi.php, vamos atribuir um valor diferente no arquivo .env:

PUNKAPI_BASE_URL="adfjklj878"

Podemos usar a função retry tem dois parâmetros, o número de tentativas pra buscar a requisição e o intervalo entre elas. Refatorando o código fica:
<?php

namespace App\Services;

use Illuminate\Support\Facades\Http;

class PunkapiService
{
    public function getBeers()
    {
       // return Http::punkapi()->get('/beers');
       return Http::punkapi()
            ->get('/beers')
            ->throw()  // Exceção em caso de erro
            ->json();   // Força o retorno em formato Json
    }
}

- Quando sai a exceção nao deveriamos retornar o erro em json por ser um api neste caso estamos usamos um app web e não uma api. E usaríamos o Route Api.

Refatorando o método boot de /app/Providers/AppServiceProvider.php, inserindo o retry():

     */
    public function boot()
    {
        Http::macro('punkapi', function(){
            return Http::acceptJson()
            ->baseUrl(config('punkapi.url'))
            ->retry(3,100);
        });
    }
}

comando de help

* sail composer dump-autoload
* Verificar Nome do arquivo se bate com o nome das rotas(Classes criadas e importar o nome errado);
* inteliphense

Refatorando BeerController.php
<?php

namespace App\Http\Controllers;

use App\Services\PunkapiService;

class BeerController extends Controller
{
    public function index()
    {

    $service = new PunkapiService();

    return $service->getBeers();
    }
}

Em vez de instanciar o método PunkapiService() dentro de index, vamos passar por parâmetro de index() declarando seu Próprio nome (PunkapiService) como tipo. Fica assim:

<?php

namespace App\Http\Controllers;

use App\Services\PunkapiService;

class BeerController extends Controller
{
    public function index(PunkapiService $service)
    {
    return $service->getBeers();
    }
}

Assim usamos feactures do php(injeção de dependências) e ao mesmo tempo feactures do laravel. Em vez de criar uma instância dentro do método index, vamos injetar a classe como parâmetro para o método index(), ficando index($service) e a instância de dentro da função passa como parâmetro de 'tipo da variável'. Isso quebra a cadeia de dependência entre as classes.
Assim, o método index ganha independência não mais dependendo da instância de new PunkapiService e passamos a olhar a função index em si.
Assim, o Laravel tenta fazer um binding, um match, o laravel tenta encontrar alguma classe PunkapiService e cria uma instância dessa classe e usa ali como parâmetro. Se não fizer assim, lá em Rotas teria que ser passado como parâmetro o que fica desnecessário.
Não poderia ser feito se na classe PunkapiService existisse o construtor para atribuir valores automaticamente à classe. Assim podemos usar porque não precisamos passar nenhum valor.

ADICIONAR OS FILTROS:
Vamos filtrar o retorno api com os seguintes itens: beer_name, food, ibu_gt, malte:

var_dump($v)
die();
dd($variável)
benchmarck -> ?

/*****REFATORA PARA TESTE alterando BeerController.php e PunkapiService.php
BeerController.php
<?php

namespace App\Http\Controllers;

use App\Services\PunkapiService;

class BeerController extends Controller
{
    public function index(PunkapiService $service)
    {
    return $service->getBeers(
        'heineken',
        'cheese',
        'corn',
        45
    );
    }
}

PunkapiService.php
<?php

namespace App\Services;

use Illuminate\Support\Facades\Http;

class PunkapiService
{
    public function getBeers(
        string $beer_name,
        string $food,
        string $malt,
        string $ibu_gt
    )
    {
        $params = get_defined_vars();

        dd($params);

        return Http::punkapi()
            ->get('/beers', $params)
            ->throw()  // Exceção em caso de erro
            ->json();   // Força o retorno em formato Json
    }
}

Resultado do debug no insomnia ou no navegador:
array:4 [▼ // app/Services/PunkapiService.php:18
  "beer_name" => "heineken"
  "food" => "cheese"
  "malt" => "corn"
  "ibu_gt" => "45"
]
//* fim teste

Refatorando:

class PunkapiService
{
    public function getBeers(
        string $beer_name = null,
        string $food = null,
        string $malt = null,
        string $ibu_gt = null
    )
    {
        $params = get_defined_vars();

        dd($params);

        return Http::punkapi()
            ->get('/beers', $params)
            ->throw()  // Exceção em caso de erro
            ->json();   // Força o retorno em formato Json
    }
}

Assim quando não passar o valor para a chave ele exibirá a chave e o valor Null, vamos refatorar para não exibir nem a chave englobando get_defined_vers() com array_filter no arquivo PunkapiService.php:

$params = array_filter(get_defined_vars());

<?php

namespace App\Http\Controllers;

use App\Services\PunkapiService;

class BeerController extends Controller
{
    public function index(PunkapiService $service)
    {
    return $service->getBeers(
        'heineken',
        'cheese',
        'corn',
       // 45 -> Esse não é passado
    );
    }
}


array:3 [▼ // app/Services/PunkapiService.php:18
  "beer_name" => "heineken"
  "food" => "cheese"
  "malt" => "corn"
	Aqui não exibiu o valor 45
]


USANDO A FUNÇÃO NAMED_ARGS passamos só os parâmetros que precisamos retornar da api e o php com essa função saberá qual a posição dela no array de argumentos passados como parâmetro sem a necessidade de seguir a mesma sequência dos argumentos:
class BeerController extends Controller
{
    public function index(PunkapiService $service)
    {
    return $service->getBeers(food: 'cheese');
    }
}

REFATORANDO:
BeerController.php
<?php

namespace App\Http\Controllers;

use App\Services\PunkapiService;
use Illuminate\Http\Request;

class BeerController extends Controller
{
    public function index( Request $request, PunkapiService $service)
    {
    return $service->getBeers(...$request->all());
    }
}

PunkapiService.php
<?php

namespace App\Services;

use Illuminate\Support\Facades\Http;

class PunkapiService
{
    public function getBeers(
        string $beer_name = null,
        string $food = null,
        string $malt = null,
        string $ibu_gt = null
    )
    {
        $params = array_filter(get_defined_vars());

     //   dd($params);

        return Http::punkapi()
            ->get('/beers', $params)
            ->throw()  // Exceção em caso de erro
            ->json();   // Força o retorno em formato Json
    }
}

CRIANDO UMA REQUEST
sail artisan make:request BeerRequest
/app/Http/Requests/BeerRequest.php

* clouser é uma função passada como parâmetro


AGRUPANDO AS ROTAS 2:01MINUTO 
open laravel week | MVC, rotas , services, api, filas, redis laravel Excel e S3 | Mosturação










 
































/**************************************/

sail share

sail artisan sail:publish ->coloca em uma pasta na raiz chamada docker

sail --help

sail artisan optimizer:clear

sail ps

sail build --no-cache -> faz o bild da aplicação. (dá um sail down  por precaução antes.)










/*********************************

root@DELLAGS:~# curl -s "https://laravel.build/laravel-9-course?with=mysql,redis,mailhog" | bash

Dockerfile

root@DELLAGS:~/example-app# docker exec -it example-app-mysql-1 bash


FROM wyveo/nginx-php-fpm:latest
WORKDIR /usr/share/nginx
RUN rm -rf /usr/share/nginx/html
COPY . /usr/share/nginx
RUN chmod -R 755 /usr/share/nginx/storage/*
RUN ln -s public html

.env (do composer)

DB_CONNECTION=mysql
DB_HOST=mysql-app (serviço do mysql no docker-compose.yaml)
DB_PORT=3306
DB_DATABASE=laraveldockerdb
DB_USERNAME=root
DB_PASSWORD=123456



docker-compose.yaml

version: '3'

services:
  laraveldocker-app:
    build: .
    ports:
      - "3003:80"
    volumes:
      - ./:/usr/share/nginx
      - .docker/nginx:/etc/nginx/conf.d/
    networks:
      - app-network
  mysql-app:
    image: mysql:5.7.22
    ports:
      - "3306:3306"
    volumes:
      - .docker/dbdata:/var/lib/mysql
    environment:
      MYSQL_DATABASE: laraveldocker
      MYSQL_ROOT_PASSWORD: 123456
    networks:
      - app-network
networks:
  app-network:
    driver: bridge
    



/*************************************************
#criando um serviço com um nome qualquer
version: '3'

services:
  laravel-app:                    #criando um serviço com um nome qualquer
    build: . ou image: wyveo/nginx-php-fpm:latest -> neste caso sem Dockerfile.                    # endereço da imagem ou local do Dockerfile (neste caso o ponto siginifica a raiz do projeto)
    ports:
      - "8080:80"                 # 8080 porta do meu host: 80 é a porta do docker nginx
    volumes:                      # docker-compose up -d -> sobe a imagem e libera o terminal  
      - ./:/usr/share/nginx       # TUDO QUE ESTIVE NA RAIZ (na rais tem o meu projeto laravel) './' IRÁ SER REFLETIDO NA PASTA /usr/share/nginx (pasta de acesso da página html)
                                  # C:\Laravel-docker\laravel-docker>docker compose up -d --build atualiza a minha imagem

  mysql-app:
      image: mysql:5.7
      ports:
        - "3306:3306"
      volumes:
        - .docker/dbdata:/var/lib/mysql          # qualqer nome (para persistir -guardar os dados do banco de dados)


      environment:
        MYSQL_DATABASE: laravel
        MYSQL_ROOT_PASSWORD: laravel
    
      

      /***************************///


  
C:\Laravel-docker\laravel-docker>docker compose up -d --build

                                
                               

    

/******************************** Dockerfile
FROM wyveo/nginx-php-fpm:latest

/***************************///
  COMANDOS

docker compose down -> para todos os containers
C:\Laravel-docker\laravel-docker>docker exec -it laravel-docker-laravel-app-1 bash 
root@612ea0ea3340:/# cd /usr/share/nginx/
root@612ea0ea3340:/usr/share/nginx# php artisan migrate
root@612ea0ea3340:/usr/share/nginx# php artisan serve

		
/***********/
PS C:\Users\alber> docker run -e MYSQL_ROOT_PASSWORD=root --name meu-mysql -d mysql:5.7

docker inspect meu-mysql ou | grep IPAddress

PS C:\Users\alber> docker run -e MYSQL_ROOT_PASSWORD=root --name meu-mysql -d -p 3306:3306 mysql:5.7

docker ps
docker ps -l
docker ps -a
docker rm -f nome


/*** LARAVEL */
### CRIANDO UM PROJETO NO LARAVEL 
laravel new projeto_laravel_via_installer (ESTA É UM AOPÇÃO)
composer create-project --prefer-dist laravel/laravel app_controle_tarefas "8.5.9"
cd app_controle_tarefas
cd public
php -S localhost:8000

ou 
da raiz do projeto:
php artisan serve 
ou
php artisan serve --port=3000

### PARA ABRIR PORTA EM OUTRO SERVIDOR
php artisan serve --host test.com --port 8080

 **********************************************************************
cd app_controle_tarefas
cd public
php artisan serve
- acessa o navegador http://localhost:8000

### DENTRO DO PROJETO CRIADO INSTALAR O LARAVEL/UI:^3.2 - versão 3.2
composer require laravel/ui:^3.2

### SE OCORRER ERRO AUMENTAR A MEMÓRIA DISPONIVEL PARA O php

-php --ini -> localiza o arquivo de configuração do php
LOCALIZA memory_limit = 1000 e altera para 
         memory_limit  = -1 e Salva

### LISTA A RELAÇÃO DE COMANDOS 
php artisan list 

DEVERA SURGIR AS OPÇÕES ABAIXO:

 ui
  ui:auth               Scaffold basic login and registration views and routes
  ui:controllers        Scaffold the authentication controllers
 vendor

### ENTENDENDO O PACOTE UI E INICIANDO A AUTENTICAÇÃO WEB NATIVA DO LARAVEL

COMANDO PARA LISTAR ROUTES: 
php artisan route:list

### php artisan ui bootstrap --auth (bootstrap ou react ou vue)
aplicando o bootstrap incluindo os recursos de autenticação;
poderia ser aplicado o bootstrap sem os recursos de autenticação;

### php artisan route:list -> mostra as rotas - ver que aumentaram as rotas

### APÓS ESSE PROCESSO O SISTEMA PEDE PARA RODAR
npm install -> instala as dependências do package.json (inclusive o bootstrap)
npm run dev -> gera os assets da aplicação de acordo com a tecnologia selecionada (bootstrap, react ou vue) -> Geralmente roda mais de uma vez para compilar tudo.

### CRIA O BANCO DE DADOS NORMALMENTE

### EXECUTA AS MIGRATIONS PADRÕES CRIADAS PARA O SISTEMA DE login
php artisan migrate -> CRIA AS TABELAS NO BANCO DE DADOS


************************************** 
INSTALANDO O COMPOSER NO UBUNTU
**************************************
sudo apt update
sudo apt install php-cli unzip

cd ~

curl -sS https://getcomposer.org/installer -o composer-setup.php

HASH=`curl -sS https://composer.github.io/installer.sig`

echo $HASH ->saída: Output
e0012edf3e80b6978849f5eff0d4b4e4c79ff1609dd1e613307e16318854d24ae64f26d17af3ef0bf7cfb710ca74



php -r "if (hash_file('SHA384', 'composer-setup.php') === '$HASH') { echo 'Installer verified'; } else { echo 'Installer corrupt'; unlink('composer-setup.php'); } echo PHP_EOL;"

sudo php composer-setup.php --install-dir=/usr/local/bin --filename=composer





***********************

DigitalOcean Kubernetes: novo plano de controle é mais rápido e gratuito, habilita HA para SLA de 99,95% de tempo de atividade
Produtos
Preços

Documentos
divisa suspensa

Entrar
divisa suspensa

// Tutorial //
Como Instalar e Utilizar o Composer no Ubuntu 20.04
Publicado em 21 de maio de 2020
Ubuntu
PHP
Ubuntu 20.04
Avatar padrão
Por Erika Heidi
Advogado Desenvolvedor
Português
Como Instalar e Utilizar o Composer no Ubuntu 20.04
Introdução
O Composer é uma ferramenta popular de gerenciamento de dependências para o PHP, criado para facilitar a instalação e a atualização das dependências principalmente do projeto. Ele controla quais outros pacotes de projeto específico dependem e são instalados para você, usando as opções apropriadas de acordo com os requisitos do projeto. O Composer também é comumente utilizado para inicializar novos projetos em frameworks PHP populares, como o Symfon e o Laravel .

Neste tutorial, você instalará e começará a usar o Composer em um sistema Ubuntu 20.04.

Pré-requisitos
Para seguir este guia, você pode acessar um servidor como usuário Ubuntu20.04 como usuário sudonão-root um firewall habilitado em seu servidor Para configurar isto, siga nosso guia Configuração do servidor inicial para o Ubuntu 20.04

Passo 1 — Instalando o PHP e as Dependências Adicionais
Além das dependências que já devem estar incluídas em seu sistema Ubuntu 20.04, como o , o Composer exige ou gitexecuta scripts PHP na linha de comando e para extrair arquivos zipados. Vamos instalar essas dependências agora.curlphp-cliunzip

primeiro, atual, gerenciador de pacotes de soluções: o cache do gerenciador de pacotes

sudo apt update
Em seguida, o seguinte comando para instalar os pacotes, execute:

sudo apt install php-cli unzip
Você será solicitado a confirmar a instalação digitando Ye, depois, ENTER.

Assim que os pré-requisitos para instalação do Composer forem instalados, você poderá seguir.

Passo 2 — Baixando e Instalando o Compositor
O Composer fornece um instalador de script escrito em PHP. Vamos baixá-lo, verificar se ele não está danificado e, em seguida, o usaremos para instalar o Composer.

Certifique-se de estar em sua pasta home. Em seguida, baixe o instalador usando o curl:

cd ~
curl -sS https://getcomposer.org/installer -o composer-setup.php
Em seguida, vamos verificar se o instalador baixado corresponde ao hash SHA-384 para o instalador mais recente encontrado na página Composer Public Keys / Signatures . Para facilitar o passo de seleção, você pode usar o seguinte comando para obter programaticamente o hash mais recente da página do Composer e armazená-lo em uma variável do shell:

HASH=`curl -sS https://composer.github.io/installer.sig`
Se você quiser verificar o valor realizado, execute:

echo $HASH
Output
e0012edf3e80b6978849f5eff0d4b4e4c79ff1609dd1e613307e16318854d24ae64f26d17af3ef0bf7cfb710ca74755a
Agora o código PHP a seguir, execute conforme a página de download do Composer, para verificar se o script de instalação está seguro para ser executado:

php -r "if (hash_file('SHA384', 'composer-setup.php') === '$HASH') { echo 'Installer verified'; } else { echo 'Installer corrupt'; unlink('composer-setup.php'); } echo PHP_EOL;"
Você verá o seguinte resultado:

Resultado
Installer verified
Se Installer corruptvocê estiver usando o hash correto, verifique se você está usando o hash correto. Em seguida, repita o processo de verificação. Quando você tiver um instalador selecionado, você pode continuar.

Para instalar o composerglobalmente, use o seguinte comando que baixará e instalará o Composer como um comando disponível em todo o sistema chamado composer, sob /usr/local/bin:

sudo php composer-setup.php --install-dir=/usr/local/bin --filename=composer
Você verá um resultado semelhante com este:

Output
All settings correct for using Composer
Downloading...

Composer (version 1.10.5) successfully installed to: /usr/local/bin/composer
Use it: php /usr/local/bin/composer
Para testar sua instalação, execute:

composer
Output
   ______
  / ____/___  ____ ___  ____  ____  ________  _____
 / /   / __ \/ __ `__ \/ __ \/ __ \/ ___/ _ \/ ___/
/ /___/ /_/ / / / / / / /_/ / /_/ (__  )  __/ /
\____/\____/_/ /_/ /_/ .___/\____/____/\___/_/
                    /_/
Composer version 1.10.5 2020-04-10 11:44:22

Usage:
  command [options] [arguments]

Options:
  -h, --help                     Display this help message
  -q, --quiet                    Do not output any message
  -V, --version                  Display this application version
      --ansi                     Force ANSI output
      --no-ansi                  Disable ANSI output
  -n, --no-interaction           Do not ask any interactive question
      --profile                  Display timing and memory usage information
      --no-plugins               Whether to disable plugins.
  -d, --working-dir=WORKING-DIR  If specified, use the given directory as working directory.
      --no-cache                 Prevent use of the cache
  -v|vv|vvv, --verbose           Increase the verbosity of messages: 1 for normal output, 2 for more verbose output and 3 for debug
...
Isso verifica que o Composer foi instalado com sucesso em seu sistema e está disponível em todo o sistema.

Nota: se você preferirá ter-lhe-ão separados separados do Composer para projeto hospedado neste servidor, você pode instalar localmente, em uma base por projeto. Este método também é útil quando o usuário do sistema não possui permissão para instalar o software disponível em todo o sistema.

Para fazer isso, use o comando php composer-setup.php. Isso irá gerar um arquivo composer.pharem seu diretório atual, que pode ser executado com o seu atual php composer.phar.

Agora podemos dar uma dependência em como usar o Compose como gerenciar.

Passo 3 — Usando o Compositor em um Projeto PHP
Os projetos PHP geralmente dependentes de bibliotecas externas, e o gerenciamento de dependências e suas versões podem ser complicados. O Composer resolve esse problema de manter um controle de projeto de extensões e dependências, também facilita o processo de descoberta, instalação e atualização de pacotes que são definidos por enquanto.

Para usar o seu projeto, você pode compor um arquivo composer.json. O arquivo composer.jsonComposer quais dependências precisa para baixar seu projeto quais serão as versões de cada pacote tem permissão para instalações e instalações. Isso é muito importante para manter seu projeto consistente e evitar a instalação de versões instáveis ​​que podem causar problemas de compatibilidade retroativa.

Você não precisa criar este arquivo manualmente - é comum ocorrer erros de sintaxe quando fizer isso. O Composer oferece uma maneira de criar um novo arquivo composer.jsoncom base na entrada do usuário, o que é uma boa escolha se você planeja compartilhar seu projeto mais tarde como um pacote público no Packagist . O Composer gera automaticamente um arquivo básico composer.jsonquando você executa um comando composer requirepara incluir uma dependência em um projeto recém-criado.

O processo de uso do Composer para instalar um pacote como uma dependência em um projeto envolve os passos a seguir:

Identifique o tipo de biblioteca que o aplicativo precisa.
uma biblioteca de código aberto adequada no agist.org , o responsável oficial de pacotes para o Compose.
Escolha o pacote de dependência.
Execute composer requirepara incluir a dependência no arquivo composer.jsone instalar o pacote.
Vamos testar isso com uma aplicação de demonstração.

O objetivo desta aplicação é transformar uma determinação determinada em uma string de URL amigável - um slug . Isso é comumente usado para converter os títulos de página para caminhos de URL (Assim como a parte final da URL para este tutorial).

Vamos começar a criar um diretório para o nosso projeto. Vamos chamá-lo de slugify :

cd ~
mkdir slugify
cd slugify
Embora não seja necessário, você pode executar agora um comando composer init para criar um arquivo composer.json detalhado para seu projeto. Como o único objetivo do nosso projeto é demonstrar como instalar dependências com o Composer, usaremos um arquivo composer.json mais simples que será gerado automaticamente quando exigirmos nosso primeiro pacote.

Agora é hora de procurar no Packagist.org por um pacote que pode nos ajudar a gerar slugs. Se você procurar pelo termo “slug” no Packagist, receberá um resultado parecido com este:

Resultados da Pesquisa do Packagist para o termo "slug"

Você verá dois números no lado direito de cada pacote na lista. O número no topo representa quantas vezes o pacote foi instalado através do Composer, e o número em baixo mostra quantas vezes um pacote foi estrelado no GitHub. De um modo geral, os pacotes com mais instalações e mais estrelas tendem a ser mais estáveis, pois mais pessoas os utilizam. Também é importante verificar a descrição do pacote para relevância para garantir que ele é o que você precisa.

Precisamos de um conversor string-to-slug A partir dos resultados da pesquisa, o pacote cocur/slugify, que aparece como o primeiro resultado naquela página, parece ser um bom candidato, com uma quantidade razoável de instalações e estrelas.

Os pacotes no Packagist têm um nome de vendor e um nome de package. Cada pacote tem um identificador único (um namespace) no mesmo formato que o GitHub utiliza para seus repositórios: vendor/package. A biblioteca que queremos instalar utiliza o namespace cocur/slugify. Você precisa de um namespace do pacote para exigi-lo em seu projeto.

Agora que você sabe exatamente qual pacote deseja instalar, você pode executar o composer require para incluí-lo como uma dependência e gerar também o arquivo composer.json para seu projeto. Uma coisa importante é observar a exigência de pacotes. O Composer rastreia as dependências no nível da aplicação e do sistema. As dependências no nível do sistema são importantes para indicar de quais módulos PHP um pacote depende. No caso do pacote cocur/slugify, ele exige um módulo PHP que ainda não instalamos.

Quando um pacote necessário depende de uma biblioteca de sistema que não está atualmente instalada em seu servidor, você receberá um erro informando qual requisito está faltando:

composer require cocur/slugify
Output
Using version ^4.0 for cocur/slugify
./composer.json has been updated
Loading composer repositories with package information
Updating dependencies (including require-dev)
Your requirements could not be resolved to an installable set of packages.

  Problem 1
    - Installation request for cocur/slugify ^4.0 -> satisfiable by cocur/slugify[v4.0.0].
    - cocur/slugify v4.0.0 requires ext-mbstring * -> the requested PHP extension mbstring is missing from your system.
...
Para resolver o problema de dependência do sistema, podemos procurar pelo pacote que falta usando o apt search:

apt search mbstring
Output
Sorting... Done
Full Text Search... Done
php-mbstring/focal 2:7.4+75 all
  MBSTRING module for PHP [default]

php-patchwork-utf8/focal 1.3.1-1 all
  UTF-8 strings handling for PHP

php7.4-mbstring/focal 7.4.3-4ubuntu1 amd64
  MBSTRING module for PHP
Após localizar o nome do pacote correto, você pode utilizar o apt novamente para instalar a dependência de sistema:

sudo apt install php-mbstring
Assim que a instalação terminar, você pode executar novamente o comando composer require:

composer require cocur/slugify
Output
Using version ^4.0 for cocur/slugify
./composer.json has been created
Loading composer repositories with package information
Updating dependencies (including require-dev)
Package operations: 1 install, 0 updates, 0 removals
  - Installing cocur/slugify (v4.0.0): Downloading (100%)         
Writing lock file
Generating autoload files
Como você pode ver na saída, o Composer decidiu automaticamente qual versão do pacote utilizar. Se você verificar o diretório do seu projeto agora, ele irá conter dois arquivos novos: composer.json e composer.lock, e um diretório vendor:

ls -l
Output
total 12
-rw-rw-r-- 1 sammy sammy   59 May  4 13:56 composer.json
-rw-rw-r-- 1 sammy sammy 3229 May  4 13:56 composer.lock
drwxrwxr-x 4 sammy sammy 4096 May  4 13:56 vendor
O arquivo composer.lock é usado para armazenar informações sobre quais versões de cada pacote estão instaladas, e garantir que as mesmas versões sejam usadas se outra pessoa clonar seu projeto e instalar suas dependências. O diretório vendor é onde as dependências do projeto estão localizadas. Você não deve fazer commit da pasta vendor no controle de versão - você precisa apenas incluir os arquivos composer.json e composer.lock.

Ao instalar um projeto que já contém um arquivo composer.json, execute o composer install para baixar as dependências do projeto.

Vamos dar uma olhada rápida em restrições de versão. Se você verificar o conteúdo do seu arquivo composer.json, verá algo parecido com isto:

cat composer.json
Output
{
    "require": {
        "cocur/slugify": "^4.0"
    }
}
Note que há o caractere especial ^ antes do número da versão no composer.json. O Composer suporta várias restrições diferentes e formatos para definir a versão necessária do pacote, para fornecer flexibilidade enquanto também mantém seu projeto estável. O operador circunflexo (^) utilizado pelo arquivo composer.json criado automaticamente é o operador recomendado para a interoperabilidade máxima, seguindo o versionamento semântico. Neste caso, ele define 4.0 como a versão mínima compatível e permite atualizações para qualquer versão futura abaixo de 5.0.

De um modo geral, você não precisará alterar as restrições de versão em seu arquivo composer.json. No entanto, algumas situações podem exigir que você edite manualmente as restrições – por exemplo, quando uma nova versão principal da sua biblioteca requerida é liberada e você deseja atualizar, ou quando a biblioteca que você deseja usar não segue o versionamento semântico.

Aqui estão alguns exemplos para lhe dar um melhor entendimento sobre como as restrições de versão do Composer funcionam:

Restrição	Significado	Exemplo de Versões Permitidas
^1.0	>= 1.0 < 2.0	1.0, 1.2.3, 1.9.9
^1.1.0	>= 1.1.0 < 2.0	1.1.0, 1.5.6, 1.9.9
~1.0	>= 1.0 < 2.0.0	1.0, 1.4.1, 1.9.9
~1.0.0	>= 1.0.0 < 1.1	1.0.0, 1.0.4, 1.0.9
1.2.1	1.2.1	1.2.1
1.*	>= 1.0 < 2.0	1.0.0, 1.4.5, 1.9.9
1.2. *	>= 1.2 < 1.3	1.2.0, 1.2.3, 1.2.9
Para uma visualização mais detalhada das restrições de versão do Composer, consulte a documentação oficial.

A seguir, vamos ver como carregar dependências automaticamente com o Composer.

Passo 4 — Incluindo o Script Autoload
Como o PHP por si só não carrega classes automaticamente, o Composer fornece um script autoload que você pode incluir em seu projeto para obter o carregamento automático para ele. Este arquivo é gerado automaticamente pelo Composer quando você adiciona sua primeira dependência.

A única coisa que você precisa fazer é incluir o arquivo vendor/autoload.php em seus scripts PHP antes de qualquer instância de classe.

Vamos testar isso em nossa aplicação de demonstração. Abra um novo arquivo chamado test.php em seu editor de texto:

nano test.php
Adicione o código a seguir que vem no arquivo vendor/autoload.php, carrega a dependência cocur/slugify, e o utiliza para criar um slug:

test.php
<?php
require __DIR__ . '/vendor/autoload.php';

use Cocur\Slugify\Slugify;

$slugify = new Slugify();

echo $slugify->slugify('Hello World, this is a long sentence and I need to make a slug from it!');
Salve o arquivo e saia do seu editor.

Agora, execute o script.

php test.php
Isso produz a saída hello-world-this-is-a-long-sentence-and-i-need-to-make-a-slug-from-it.

As dependências precisam de atualizações quando novas versões são liberadas. Dessa forma, vamos ver como lidar com isso.

Passo 5 — Atualizando as Dependências do Projeto
Sempre que você quiser atualizar suas dependências do projeto para versões mais recentes, execute o comando update:

composer update
Isso irá verificar por versões mais recentes das bibliotecas que você requer em seu projeto. Se uma versão mais recente for encontrada e ela for compatível com a restrição de versão definida no arquivo composer.json, o Composer substituirá a versão anterior instalada. O arquivo composer.lock será atualizado para refletir essas alterações.

Você também pode atualizar uma ou mais bibliotecas específicas, especificando-as desta forma:

composer update vendor/package vendor2/package2
Certifique-se de verificar em seus arquivos composer.json e composer.lock dentro do seu sistema de controle de versão após atualizar suas dependências de modo que outros também possam instalar essas versões mais recentes.

Conclusão





***********
Algoritmo "CalculoMedia2"
// Disciplina: Lógica de programação
// Professor : Antonio Carlos Nicolodi
// Descrição : calculo da média aritimética
// Autor     : Professor Antonio
// Data atual: 01/04/2015
var
// Seção de Declarações
   v1, v2, total: Real
   sinal : Caracter
Inicio
// Seção dos Comandos
   Escreva ("Digite o primeiro valor: ")
   Leia (v1)
   Escreva ("Digite a operação + - * / : ")
   Leia (sinal)
   Escreva ("Digite o segundo valor: ")
   Leia (v2)

   Se sinal = "+" entao
   total <- v1 + v2
   Escreva("O Resultado é: ", total)
   Senao
   Se sinal = "-" entao
   total <- v1 - v2
   Escreva("O Resultado é: ", total)
   Senao
   Se sinal = "*" entao
   total <- v1 * v2
   Escreva("O Resultado é: ", total)


   Senao
     Escreva("OPERAÇÃO INVÁLIDA! ")



      Escreval("total")
   fimse
Fimalgoritmo

****
COMANDOS DOCKER
root@DELLAGS:~# curl -s "https://laravel.build/laravel-9-course?with=mysql,redis,mailhog" | bash

root@DELLAGS:~/example-app# ./vendor/bin/sail  artisan migrate --seed -> criar o banco de dados e copular dados;

Dockerfile

root@DELLAGS:~/example-app# docker exec -it example-app-mysql-1 bash


FROM wyveo/nginx-php-fpm:latest
WORKDIR /usr/share/nginx
RUN rm -rf /usr/share/nginx/html
COPY . /usr/share/nginx
RUN chmod -R 755 /usr/share/nginx/storage/*
RUN ln -s public html

.env (do composer)

DB_CONNECTION=mysql
DB_HOST=mysql-app (serviço do mysql no docker-compose.yaml)
DB_PORT=3306
DB_DATABASE=laraveldockerdb
DB_USERNAME=root
DB_PASSWORD=123456



docker-compose.yaml

version: '3'

services:
  laraveldocker-app:
    build: .
    ports:
      - "3003:80"
    volumes:
      - ./:/usr/share/nginx
      - .docker/nginx:/etc/nginx/conf.d/
    networks:
      - app-network
  mysql-app:
    image: mysql:5.7.22
    ports:
      - "3306:3306"
    volumes:
      - .docker/dbdata:/var/lib/mysql
    environment:
      MYSQL_DATABASE: laraveldocker
      MYSQL_ROOT_PASSWORD: 123456
    networks:
      - app-network
networks:
  app-network:
    driver: bridge
    



/*************************************************
#criando um serviço com um nome qualquer
version: '3'

services:
  laravel-app:                    #criando um serviço com um nome qualquer
    build: . ou image: wyveo/nginx-php-fpm:latest -> neste caso sem Dockerfile.                    # endereço da imagem ou local do Dockerfile (neste caso o ponto siginifica a raiz do projeto)
    ports:
      - "8080:80"                 # 8080 porta do meu host: 80 é a porta do docker nginx
    volumes:                      # docker-compose up -d -> sobe a imagem e libera o terminal  
      - ./:/usr/share/nginx       # TUDO QUE ESTIVE NA RAIZ (na rais tem o meu projeto laravel) './' IRÁ SER REFLETIDO NA PASTA /usr/share/nginx (pasta de acesso da página html)
                                  # C:\Laravel-docker\laravel-docker>docker compose up -d --build atualiza a minha imagem

  mysql-app:
      image: mysql:5.7
      ports:
        - "3306:3306"
      volumes:
        - .docker/dbdata:/var/lib/mysql          # qualqer nome (para persistir -guardar os dados do banco de dados)


      environment:
        MYSQL_DATABASE: laravel
        MYSQL_ROOT_PASSWORD: laravel
    
      

      /***************************///


  
C:\Laravel-docker\laravel-docker>docker compose up -d --build

                                
                               

    

/******************************** Dockerfile
FROM wyveo/nginx-php-fpm:latest

/***************************///
  COMANDOS

docker compose down -> para todos os containers
C:\Laravel-docker\laravel-docker>docker exec -it laravel-docker-laravel-app-1 bash 
root@612ea0ea3340:/# cd /usr/share/nginx/
root@612ea0ea3340:/usr/share/nginx# php artisan migrate
root@612ea0ea3340:/usr/share/nginx# php artisan serve

		
/***********/
PS C:\Users\alber> docker run -e MYSQL_ROOT_PASSWORD=root --name meu-mysql -d mysql:5.7

docker inspect meu-mysql ou | grep IPAddress

PS C:\Users\alber> docker run -e MYSQL_ROOT_PASSWORD=root --name meu-mysql -d -p 3306:3306 mysql:5.7

docker ps
docker ps -l
docker ps -a
docker rm -f nome


/*** LARAVEL */
### CRIANDO UM PROJETO NO LARAVEL 
laravel new projeto_laravel_via_installer (ESTA É UM AOPÇÃO)
composer create-project --prefer-dist laravel/laravel app_controle_tarefas "8.5.9"
cd app_controle_tarefas
cd public
php -S localhost:8000

ou 
da raiz do projeto:
php artisan serve 
ou
php artisan serve --port=3000

### PARA ABRIR PORTA EM OUTRO SERVIDOR
php artisan serve --host test.com --port 8080

 **********************************************************************
cd app_controle_tarefas
cd public
php artisan serve
- acessa o navegador http://localhost:8000

### DENTRO DO PROJETO CRIADO INSTALAR O LARAVEL/UI:^3.2 - versão 3.2
composer require laravel/ui:^3.2

### SE OCORRER ERRO AUMENTAR A MEMÓRIA DISPONIVEL PARA O php

-php --ini -> localiza o arquivo de configuração do php
LOCALIZA memory_limit = 1000 e altera para 
         memory_limit  = -1 e Salva

### LISTA A RELAÇÃO DE COMANDOS 
php artisan list 

DEVERA SURGIR AS OPÇÕES ABAIXO:

 ui
  ui:auth               Scaffold basic login and registration views and routes
  ui:controllers        Scaffold the authentication controllers
 vendor

### ENTENDENDO O PACOTE UI E INICIANDO A AUTENTICAÇÃO WEB NATIVA DO LARAVEL

COMANDO PARA LISTAR ROUTES: 
php artisan route:list

### php artisan ui bootstrap --auth (bootstrap ou react ou vue)
aplicando o bootstrap incluindo os recursos de autenticação;
poderia ser aplicado o bootstrap sem os recursos de autenticação;

### php artisan route:list -> mostra as rotas - ver que aumentaram as rotas

### APÓS ESSE PROCESSO O SISTEMA PEDE PARA RODAR
npm install -> instala as dependências do package.json (inclusive o bootstrap)
npm run dev -> gera os assets da aplicação de acordo com a tecnologia selecionada (bootstrap, react ou vue) -> Geralmente roda mais de uma vez para compilar tudo.

### CRIA O BANCO DE DADOS NORMALMENTE

### EXECUTA AS MIGRATIONS PADRÕES CRIADAS PARA O SISTEMA DE login
php artisan migrate -> CRIA AS TABELAS NO BANCO DE DADOS


************************************** 
INSTALANDO O COMPOSER NO UBUNTU
**************************************
sudo apt update
sudo apt install php-cli unzip

cd ~

curl -sS https://getcomposer.org/installer -o composer-setup.php

HASH=`curl -sS https://composer.github.io/installer.sig`

echo $HASH ->saída: Output
e0012edf3e80b6978849f5eff0d4b4e4c79ff1609dd1e613307e16318854d24ae64f26d17af3ef0bf7cfb710ca74



php -r "if (hash_file('SHA384', 'composer-setup.php') === '$HASH') { echo 'Installer verified'; } else { echo 'Installer corrupt'; unlink('composer-setup.php'); } echo PHP_EOL;"

sudo php composer-setup.php --install-dir=/usr/local/bin --filename=composer





***********************

DigitalOcean Kubernetes: novo plano de controle é mais rápido e gratuito, habilita HA para SLA de 99,95% de tempo de atividade
Produtos
Preços

Documentos
divisa suspensa

Entrar
divisa suspensa

// Tutorial //
Como Instalar e Utilizar o Composer no Ubuntu 20.04
Publicado em 21 de maio de 2020
Ubuntu
PHP
Ubuntu 20.04
Avatar padrão
Por Erika Heidi
Advogado Desenvolvedor
Português
Como Instalar e Utilizar o Composer no Ubuntu 20.04
Introdução
O Composer é uma ferramenta popular de gerenciamento de dependências para o PHP, criado para facilitar a instalação e a atualização das dependências principalmente do projeto. Ele controla quais outros pacotes de projeto específico dependem e são instalados para você, usando as opções apropriadas de acordo com os requisitos do projeto. O Composer também é comumente utilizado para inicializar novos projetos em frameworks PHP populares, como o Symfon e o Laravel .

Neste tutorial, você instalará e começará a usar o Composer em um sistema Ubuntu 20.04.

Pré-requisitos
Para seguir este guia, você pode acessar um servidor como usuário Ubuntu20.04 como usuário sudonão-root um firewall habilitado em seu servidor Para configurar isto, siga nosso guia Configuração do servidor inicial para o Ubuntu 20.04

Passo 1 — Instalando o PHP e as Dependências Adicionais
Além das dependências que já devem estar incluídas em seu sistema Ubuntu 20.04, como o , o Composer exige ou gitexecuta scripts PHP na linha de comando e para extrair arquivos zipados. Vamos instalar essas dependências agora.curlphp-cliunzip

primeiro, atual, gerenciador de pacotes de soluções: o cache do gerenciador de pacotes

sudo apt update
Em seguida, o seguinte comando para instalar os pacotes, execute:

sudo apt install php-cli unzip
Você será solicitado a confirmar a instalação digitando Ye, depois, ENTER.

Assim que os pré-requisitos para instalação do Composer forem instalados, você poderá seguir.

Passo 2 — Baixando e Instalando o Compositor
O Composer fornece um instalador de script escrito em PHP. Vamos baixá-lo, verificar se ele não está danificado e, em seguida, o usaremos para instalar o Composer.

Certifique-se de estar em sua pasta home. Em seguida, baixe o instalador usando o curl:

cd ~
curl -sS https://getcomposer.org/installer -o composer-setup.php
Em seguida, vamos verificar se o instalador baixado corresponde ao hash SHA-384 para o instalador mais recente encontrado na página Composer Public Keys / Signatures . Para facilitar o passo de seleção, você pode usar o seguinte comando para obter programaticamente o hash mais recente da página do Composer e armazená-lo em uma variável do shell:

HASH=`curl -sS https://composer.github.io/installer.sig`
Se você quiser verificar o valor realizado, execute:

echo $HASH
Output
e0012edf3e80b6978849f5eff0d4b4e4c79ff1609dd1e613307e16318854d24ae64f26d17af3ef0bf7cfb710ca74755a
Agora o código PHP a seguir, execute conforme a página de download do Composer, para verificar se o script de instalação está seguro para ser executado:

php -r "if (hash_file('SHA384', 'composer-setup.php') === '$HASH') { echo 'Installer verified'; } else { echo 'Installer corrupt'; unlink('composer-setup.php'); } echo PHP_EOL;"
Você verá o seguinte resultado:

Resultado
Installer verified
Se Installer corruptvocê estiver usando o hash correto, verifique se você está usando o hash correto. Em seguida, repita o processo de verificação. Quando você tiver um instalador selecionado, você pode continuar.

Para instalar o composerglobalmente, use o seguinte comando que baixará e instalará o Composer como um comando disponível em todo o sistema chamado composer, sob /usr/local/bin:

sudo php composer-setup.php --install-dir=/usr/local/bin --filename=composer
Você verá um resultado semelhante com este:

Output
All settings correct for using Composer
Downloading...

Composer (version 1.10.5) successfully installed to: /usr/local/bin/composer
Use it: php /usr/local/bin/composer
Para testar sua instalação, execute:

composer
Output
   ______
  / ____/___  ____ ___  ____  ____  ________  _____
 / /   / __ \/ __ `__ \/ __ \/ __ \/ ___/ _ \/ ___/
/ /___/ /_/ / / / / / / /_/ / /_/ (__  )  __/ /
\____/\____/_/ /_/ /_/ .___/\____/____/\___/_/
                    /_/
Composer version 1.10.5 2020-04-10 11:44:22

Usage:
  command [options] [arguments]

Options:
  -h, --help                     Display this help message
  -q, --quiet                    Do not output any message
  -V, --version                  Display this application version
      --ansi                     Force ANSI output
      --no-ansi                  Disable ANSI output
  -n, --no-interaction           Do not ask any interactive question
      --profile                  Display timing and memory usage information
      --no-plugins               Whether to disable plugins.
  -d, --working-dir=WORKING-DIR  If specified, use the given directory as working directory.
      --no-cache                 Prevent use of the cache
  -v|vv|vvv, --verbose           Increase the verbosity of messages: 1 for normal output, 2 for more verbose output and 3 for debug
...
Isso verifica que o Composer foi instalado com sucesso em seu sistema e está disponível em todo o sistema.

Nota: se você preferirá ter-lhe-ão separados separados do Composer para projeto hospedado neste servidor, você pode instalar localmente, em uma base por projeto. Este método também é útil quando o usuário do sistema não possui permissão para instalar o software disponível em todo o sistema.

Para fazer isso, use o comando php composer-setup.php. Isso irá gerar um arquivo composer.pharem seu diretório atual, que pode ser executado com o seu atual php composer.phar.

Agora podemos dar uma dependência em como usar o Compose como gerenciar.

Passo 3 — Usando o Compositor em um Projeto PHP
Os projetos PHP geralmente dependentes de bibliotecas externas, e o gerenciamento de dependências e suas versões podem ser complicados. O Composer resolve esse problema de manter um controle de projeto de extensões e dependências, também facilita o processo de descoberta, instalação e atualização de pacotes que são definidos por enquanto.

Para usar o seu projeto, você pode compor um arquivo composer.json. O arquivo composer.jsonComposer quais dependências precisa para baixar seu projeto quais serão as versões de cada pacote tem permissão para instalações e instalações. Isso é muito importante para manter seu projeto consistente e evitar a instalação de versões instáveis ​​que podem causar problemas de compatibilidade retroativa.

Você não precisa criar este arquivo manualmente - é comum ocorrer erros de sintaxe quando fizer isso. O Composer oferece uma maneira de criar um novo arquivo composer.jsoncom base na entrada do usuário, o que é uma boa escolha se você planeja compartilhar seu projeto mais tarde como um pacote público no Packagist . O Composer gera automaticamente um arquivo básico composer.jsonquando você executa um comando composer requirepara incluir uma dependência em um projeto recém-criado.

O processo de uso do Composer para instalar um pacote como uma dependência em um projeto envolve os passos a seguir:

Identifique o tipo de biblioteca que o aplicativo precisa.
uma biblioteca de código aberto adequada no agist.org , o responsável oficial de pacotes para o Compose.
Escolha o pacote de dependência.
Execute composer requirepara incluir a dependência no arquivo composer.jsone instalar o pacote.
Vamos testar isso com uma aplicação de demonstração.

O objetivo desta aplicação é transformar uma determinação determinada em uma string de URL amigável - um slug . Isso é comumente usado para converter os títulos de página para caminhos de URL (Assim como a parte final da URL para este tutorial).

Vamos começar a criar um diretório para o nosso projeto. Vamos chamá-lo de slugify :

cd ~
mkdir slugify
cd slugify
Embora não seja necessário, você pode executar agora um comando composer init para criar um arquivo composer.json detalhado para seu projeto. Como o único objetivo do nosso projeto é demonstrar como instalar dependências com o Composer, usaremos um arquivo composer.json mais simples que será gerado automaticamente quando exigirmos nosso primeiro pacote.

Agora é hora de procurar no Packagist.org por um pacote que pode nos ajudar a gerar slugs. Se você procurar pelo termo “slug” no Packagist, receberá um resultado parecido com este:

Resultados da Pesquisa do Packagist para o termo "slug"

Você verá dois números no lado direito de cada pacote na lista. O número no topo representa quantas vezes o pacote foi instalado através do Composer, e o número em baixo mostra quantas vezes um pacote foi estrelado no GitHub. De um modo geral, os pacotes com mais instalações e mais estrelas tendem a ser mais estáveis, pois mais pessoas os utilizam. Também é importante verificar a descrição do pacote para relevância para garantir que ele é o que você precisa.

Precisamos de um conversor string-to-slug A partir dos resultados da pesquisa, o pacote cocur/slugify, que aparece como o primeiro resultado naquela página, parece ser um bom candidato, com uma quantidade razoável de instalações e estrelas.

Os pacotes no Packagist têm um nome de vendor e um nome de package. Cada pacote tem um identificador único (um namespace) no mesmo formato que o GitHub utiliza para seus repositórios: vendor/package. A biblioteca que queremos instalar utiliza o namespace cocur/slugify. Você precisa de um namespace do pacote para exigi-lo em seu projeto.

Agora que você sabe exatamente qual pacote deseja instalar, você pode executar o composer require para incluí-lo como uma dependência e gerar também o arquivo composer.json para seu projeto. Uma coisa importante é observar a exigência de pacotes. O Composer rastreia as dependências no nível da aplicação e do sistema. As dependências no nível do sistema são importantes para indicar de quais módulos PHP um pacote depende. No caso do pacote cocur/slugify, ele exige um módulo PHP que ainda não instalamos.

Quando um pacote necessário depende de uma biblioteca de sistema que não está atualmente instalada em seu servidor, você receberá um erro informando qual requisito está faltando:

composer require cocur/slugify
Output
Using version ^4.0 for cocur/slugify
./composer.json has been updated
Loading composer repositories with package information
Updating dependencies (including require-dev)
Your requirements could not be resolved to an installable set of packages.

  Problem 1
    - Installation request for cocur/slugify ^4.0 -> satisfiable by cocur/slugify[v4.0.0].
    - cocur/slugify v4.0.0 requires ext-mbstring * -> the requested PHP extension mbstring is missing from your system.
...
Para resolver o problema de dependência do sistema, podemos procurar pelo pacote que falta usando o apt search:

apt search mbstring
Output
Sorting... Done
Full Text Search... Done
php-mbstring/focal 2:7.4+75 all
  MBSTRING module for PHP [default]

php-patchwork-utf8/focal 1.3.1-1 all
  UTF-8 strings handling for PHP

php7.4-mbstring/focal 7.4.3-4ubuntu1 amd64
  MBSTRING module for PHP
Após localizar o nome do pacote correto, você pode utilizar o apt novamente para instalar a dependência de sistema:

sudo apt install php-mbstring
Assim que a instalação terminar, você pode executar novamente o comando composer require:

composer require cocur/slugify
Output
Using version ^4.0 for cocur/slugify
./composer.json has been created
Loading composer repositories with package information
Updating dependencies (including require-dev)
Package operations: 1 install, 0 updates, 0 removals
  - Installing cocur/slugify (v4.0.0): Downloading (100%)         
Writing lock file
Generating autoload files
Como você pode ver na saída, o Composer decidiu automaticamente qual versão do pacote utilizar. Se você verificar o diretório do seu projeto agora, ele irá conter dois arquivos novos: composer.json e composer.lock, e um diretório vendor:

ls -l
Output
total 12
-rw-rw-r-- 1 sammy sammy   59 May  4 13:56 composer.json
-rw-rw-r-- 1 sammy sammy 3229 May  4 13:56 composer.lock
drwxrwxr-x 4 sammy sammy 4096 May  4 13:56 vendor
O arquivo composer.lock é usado para armazenar informações sobre quais versões de cada pacote estão instaladas, e garantir que as mesmas versões sejam usadas se outra pessoa clonar seu projeto e instalar suas dependências. O diretório vendor é onde as dependências do projeto estão localizadas. Você não deve fazer commit da pasta vendor no controle de versão - você precisa apenas incluir os arquivos composer.json e composer.lock.

Ao instalar um projeto que já contém um arquivo composer.json, execute o composer install para baixar as dependências do projeto.

Vamos dar uma olhada rápida em restrições de versão. Se você verificar o conteúdo do seu arquivo composer.json, verá algo parecido com isto:

cat composer.json
Output
{
    "require": {
        "cocur/slugify": "^4.0"
    }
}
Note que há o caractere especial ^ antes do número da versão no composer.json. O Composer suporta várias restrições diferentes e formatos para definir a versão necessária do pacote, para fornecer flexibilidade enquanto também mantém seu projeto estável. O operador circunflexo (^) utilizado pelo arquivo composer.json criado automaticamente é o operador recomendado para a interoperabilidade máxima, seguindo o versionamento semântico. Neste caso, ele define 4.0 como a versão mínima compatível e permite atualizações para qualquer versão futura abaixo de 5.0.

De um modo geral, você não precisará alterar as restrições de versão em seu arquivo composer.json. No entanto, algumas situações podem exigir que você edite manualmente as restrições – por exemplo, quando uma nova versão principal da sua biblioteca requerida é liberada e você deseja atualizar, ou quando a biblioteca que você deseja usar não segue o versionamento semântico.

Aqui estão alguns exemplos para lhe dar um melhor entendimento sobre como as restrições de versão do Composer funcionam:

Restrição	Significado	Exemplo de Versões Permitidas
^1.0	>= 1.0 < 2.0	1.0, 1.2.3, 1.9.9
^1.1.0	>= 1.1.0 < 2.0	1.1.0, 1.5.6, 1.9.9
~1.0	>= 1.0 < 2.0.0	1.0, 1.4.1, 1.9.9
~1.0.0	>= 1.0.0 < 1.1	1.0.0, 1.0.4, 1.0.9
1.2.1	1.2.1	1.2.1
1.*	>= 1.0 < 2.0	1.0.0, 1.4.5, 1.9.9
1.2. *	>= 1.2 < 1.3	1.2.0, 1.2.3, 1.2.9
Para uma visualização mais detalhada das restrições de versão do Composer, consulte a documentação oficial.

A seguir, vamos ver como carregar dependências automaticamente com o Composer.

Passo 4 — Incluindo o Script Autoload
Como o PHP por si só não carrega classes automaticamente, o Composer fornece um script autoload que você pode incluir em seu projeto para obter o carregamento automático para ele. Este arquivo é gerado automaticamente pelo Composer quando você adiciona sua primeira dependência.

A única coisa que você precisa fazer é incluir o arquivo vendor/autoload.php em seus scripts PHP antes de qualquer instância de classe.

Vamos testar isso em nossa aplicação de demonstração. Abra um novo arquivo chamado test.php em seu editor de texto:

nano test.php
Adicione o código a seguir que vem no arquivo vendor/autoload.php, carrega a dependência cocur/slugify, e o utiliza para criar um slug:

test.php
<?php
require __DIR__ . '/vendor/autoload.php';

use Cocur\Slugify\Slugify;

$slugify = new Slugify();

echo $slugify->slugify('Hello World, this is a long sentence and I need to make a slug from it!');
Salve o arquivo e saia do seu editor.

Agora, execute o script.

php test.php
Isso produz a saída hello-world-this-is-a-long-sentence-and-i-need-to-make-a-slug-from-it.

As dependências precisam de atualizações quando novas versões são liberadas. Dessa forma, vamos ver como lidar com isso.

Passo 5 — Atualizando as Dependências do Projeto
Sempre que você quiser atualizar suas dependências do projeto para versões mais recentes, execute o comando update:

composer update
Isso irá verificar por versões mais recentes das bibliotecas que você requer em seu projeto. Se uma versão mais recente for encontrada e ela for compatível com a restrição de versão definida no arquivo composer.json, o Composer substituirá a versão anterior instalada. O arquivo composer.lock será atualizado para refletir essas alterações.

Você também pode atualizar uma ou mais bibliotecas específicas, especificando-as desta forma:

composer update vendor/package vendor2/package2
Certifique-se de verificar em seus arquivos composer.json e composer.lock dentro do seu sistema de controle de versão após atualizar suas dependências de modo que outros também possam instalar essas versões mais recentes.
 -->
exit
pwd
exit
curl
curl -s "https://laravel.build/example-app?with=mysql,redis" |bash
docker
curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -
docker
apt-cache policy docker-ce
docker
curl
curl --help
apt install docker
systemctl status docker
docker
exit
docker
ver
sudo apt-get update
sudo apt-get install ./docker-desktop-<version>-<arch>.deb
sudo apt-get install     ca-certificates     curl     gnupg     lsb-release
sudo mkdir -p /etc/apt/keyrings
curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg
echo   "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu \
  $(lsb_release -cs) stable" | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null
sudo apt-get update
sudo apt-get install docker-ce docker-ce-cli containerd.io docker-compose-plugin
sudo service docker start
sudo docker run hello-world
docker
exit
pwd
ls
cd Desktop
ls
mkdir ProjetosDocker
ls
cd ProjetosDocker/
ls
curl
curl -s "https://laravel.build/example-app?with=mysql,redir" | bash
docker
docker run
systemctl status docker
sudo systemctl status docker
wget -qO- https://get.docker.com/ | sh
curl -L https://github.com/docker/compose/releases/download/1.6.2/docker-compose-`uname -s`-`uname -m` > /usr/local/bin/docker-compose
chmod +x /usr/local/bin/docker-compose
docker-compose version
docker-machine version
docker
curl -s "https://laravel.build/example-app?with=mysql,redir" | bash
docker ls
docker --help
docker start
docker start --help
docker start -i
docker image list
cd ..
cd var
cd /var
cd run
ls
docker
docker run
docker run *
cd /
ls
pwd
cd rn
cd run
ls
docker
docker run
exit
docker
sytemctl status
sudo systemctl
cmd
docker
docker run
curl
curl --help
curl -V
docker -v
code .
cls
clear
docker
clear
docker ps
sudo sevice docker start
sudo service docker start
docker ps
sudo service docker start
docker ps
apt get install docker
apt install docker
docker ps
sudo service docker start
docker ps
sudo service docker start
sudo service docker-start
curl -s "https://laravel.build/example-app?wit..." | bash
docker
docker ps
exit
docker start
docker ps
docker start
docker ps
docker
docker ps
docker --version
docker run hello-world
docker image ls
Enable WSL 2 Windows features
Set-ExecutionPolicy -ExecutionPolicy RemoteSigned
lsb_release -a
dotnet --version
sudo wget https://packages.microsoft.com/config/ubuntu/20.04/packages-microsoft-prod.deb -O packages-microsoft-prod.deb
sudo dpkg -i packages-microsoft-prod.deb
sudo apt-get update
sudo apt-get install apt-transport-https
sudo apt-get update
sudo apt-get install dotnet-sdk-3.1
dotnet --version
code .
docker
sudo apt install gnome-terminal
docker
docker ps
docker start
sudo apt remove docker-desktop
sudo apt-get install ./docker-desktop-<version>-<arch>.deb
sudo apt-get update
sudo apt-get install ./docker-desktop-<version>-<arch>.deb
systemctl --user enable docker-desktop
systemctl --user stop docker-desktop
wsl.exe -l -v
wsl
apt install wsl
code .
curl -s https://laravel.build/example-app | bash
docker
apt get install docker
sudo su
clear
docker ps
y
pwd
ls
cd ProjetosDocker/
pwd
php -v
cls
clear
curl -s "https://laravel.build/example-app?with=mysql,redis,pgsql" |bash
sudo apt-get curl
curl
curl --manual
clear
docker ps
curl -s "https://laravel.build/example-app?with=mysql,redis,pgsql" |bash
docker ps
docker
docker ps
exit
ls
./vendor/bin/sail up
./vendor/bin/sail up -D
./vendor/bin/sail up -d
./vendor/bin/sail ps
./vendor/bin/sail composer require/breeze --dev
./vendor/bin/sail compose require/breeze --dev
./vendor/bin/sail composer require laravel/breeze --dev
sudo su
./vendor/bin/sail composer require laravel/breese --dev
docker ps
docker stop
docker ps
./vendor/bin/sail stop
./vendor/bin/sail composer require laravel/breese --dev
docker start
docker ps
./vendor/bin/sail up
./vendor/bin/sail up -d
docker ps
docker stop
./vendor/bin/sail stop
docker ps
docker ls
docker -ls
docker -l
docker ls
docker --help
docker rmi
docker rm
docker rm --help
docker rm -f
docker ls
list
docker ps
docker start
docker run
docker ps
curl -s "https://laravel.build/example-app?with=mysql,redis" | bash
docker ps
docker ls
ls
cd ProjetosDocker/
cd ..
cd example-app/
code .
docker run -d -p 80:80 docker/getting-started
docker up -d
clear
docker run -d -p 80:80 docker/getting-started
docker up 0094
docker run 7b0aed04f7c251a872242ec415f2d99551385af0c8ceb8409af2ffa9c3fedf6a -d
docker
docker ps
code .
docker
clear
clear ps
docker ps
sudo apt install curl 
exit
pwd
./vendor/bin/sail up -d
cls
clear

./vendor/bin/sail up -d
docker ps
clear
docker ps
./vendor/bin/sail up -d
docker kill
docker stop
doker ps
docker
exit
curl -s "https://laravel.build/laravel-curso?with=mysql,redis,mailhog" |bash
cd laravel-curso/
./vendeor/bin/sail up -d
./vendor/bin/sail up -d
docker ps
code .
./vendor/bin/sail up -d
curl "http://localhost/tutorial/"    -X GET    -H 'host: localhost'    -H 'connection: keep-alive'    -H 'sec-ch-ua: "Chromium";v="106", "Google Chrome";v="106", "Not;A=Brand";v="99"'    -H 'sec-ch-ua-mobile: ?0'    -H 'sec-ch-ua-platform: "Windows"'    -H 'upgrade-insecure-requests: 1'    -H 'user-agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/106.0.0.0 Safari/537.36'    -H 'accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9'    -H 'sec-fetch-site: same-origin'    -H 'sec-fetch-mode: navigate'    -H 'sec-fetch-dest: document'    -H 'referer: http://localhost/'    -H 'accept-encoding: gzip, deflate, br'    -H 'accept-language: pt-BR,pt;q=0.9,en-US;q=0.8,en;q=0.7,es;q=0.6'    -H 'cookie: _ga=GA1.1.171439518.1657383921; _ga_E7H41BFJ0Q=GS1.1.1657462355.2.1.1657462635.0; pma_lang=pt';
clear
./vendor/bin/sail up -d
pwd
ls
cd ProjetosDocker/
ls
cd example-app
ls
cd ..
cd example-app
ls
cd ..
rm -rf example-app
ls
rm-rf laravel-curso/
ls
rm -rf laravel-curso/
clear
ls
cd ProjetosDocker/
ls
curl -s "https://laravel.build/laravel-curso?with=mysql,redis,mailhog" |bash
cd laravel-curso && ./vendor/bin/sail up -d
code .
pwd
ls
cd ProjetosDocker/
ls
rm -rf laravel-curso/
ls
clear
curl -s "https://laravel.build/laravel-curso?with=mysql" |bash
pwd
ls
cd ProjetosDocker/
ls
rm -rf laravel-curso/
ls
cd ..
cd laravel-curso/
ls
exit
php -S localhost:8080
apt install php-cli
php -S localhost:8080
docker run -d -p 80:80 docker/getting-started
curl -s "https://laravel.build/laravel-curso?with=mysql" |bash
docker ps
docker ls
docker -l
docker l
docker ps
docker exec
docker exec -it docker/getting-started bash
docker ps
docker exec -it 6ec4e45db98a bash
docker exec -it 6ec4e45db98a 
docker exec --help
docker exec -it 6ec4e45db98a bash
clear
docker ps
code .
ls
cd laravel-curso/
ls
docker ps
cd ..
ls
pwd
cd socket/
ls
cd ..
cd ProjetosDocker/
ls
cd ..
rm -rf laravel-curso/
ls
cd ..
ls
clear
docker ps
docker exec -it docker/getting-started: bash
docker exec -it docker/getting-started bash
docker exec -it getting-started bash
docker exec -it 6ec4e45db98a bash
docker exec -it 6ec4e45db98a 
ls
cd socket/
ls
cd ..
cd snap
ls
cd ..
cd \
cd /
ls
cd var
ls
cd lib
ls
cd docker
ls
cd containers
ls
cd ..
cd image
ls
cd ..
sudo service docker status
status docker
sudo status docker
sudo service status docker
sudo service docker
sudo service docker status
docker start
cd ..
pwd
ls
cd usr
ls
ls -l
cd ..
docker ps
docker
docker ps
apt-get docker
apt-get install docker 
docker ps
apt-get uninstall docker 
pwd
ls
cd ..
ls
cd usr
ls
cd bin
ls
cd ..
cd lig
cd lib
ls
clear
ls
cd ..
ls
cd usr
ls
ls docker
cld
cd ..
ls
cd ProjetosDocker/
ls
sudo apt update
sudo apt install apt-transport-https ca-certificates curl software-properties-common
curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -
sudo add-apt-repository "deb [arch=amd64] https://download.docker.com/linux/ubuntu focal stable"
sudo apt update
apt-cache policy docker-ce
sudo apt install docker-ce
sudo systemctl status docker
wsl --set-version Ubuntu 2
sudo apt update
sudo apt install apt-transport-https ca-certificates curl software-properties-common
sudo apt install build-essential
curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add
sudo add-apt-repository "deb [arch=amd64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable"
sudo apt update
sudo apt install docker-ce
sudo docker run hello-world
início do docker de serviço sudo
sudo service docker start
sudo docker run hello-world
docker ps
sudo etc
cd etc
ls
cd ..
ls
cd etc
ls
vi init.d
cd ..
ls
sudo apt install docker-ce
sudo service docker status
sudo service docker start
docker ps
ls
cd var/run
ls
vi docker.sock
docker.sock
cd user
ls
cd ..
ls
cd run
ls
cd docker
ls
cd ..
sudo service docker start
docker ps
curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add
sudo add-apt-repository "deb [arch=amd64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable"
sudo docker run hello-world
docker ps
sudo service docker start
sudo service status
sudo service docker start
sudo curl -L "https://github.com/docker/compose/releases/download/1.24.0/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
sudo chmod +x /usr/local/bin/docker-compose
docker-compose --version
ls
cd ProjetosDocker/
code .
curl -s "https://laravel.build/laravel-9-course?with=mysql,redis,mailhog" | bash
docker start
docker ps
sudo apt install docker-ce
docker start
sudo service docker start
curl -s "https://laravel.build/laravel-9-course?with=mysql,redis,mailhog" | bash
docker ps
exit
docker ps
ls
docker ps
clear
docker ps
curl -s "https://laravel.build/laravel-9-course?with=mysql,redis,mailhog" | bash
cd laravel-9-course && ./vendor/bin/sail up -d
docker ps
clear
docker ps
docker ps -l
./vendor/bin/sail up -d
php artisan about
./vendor/bin/sail up -d
docker ps
docker-compose up -d
./vendor/bin/sail up -d
pwd
ls
cd laravel-9-course/
./vendor/bin/sail up -d
docker exec -it b6870e2dd73e bash
clear
ls
cd ..
clear
ls
cd laravel-9-course/
ls
php artisan serve
php artisan
clear
ls
code .
docker ps
docker ps -l
docker exec -it laravel-9-course-laravel.test-1 bash
ls
php artisan serve
vi
vi docker-compose.yml
code .
exit
php artisan serve
exit
php -v
mysql -v
mysql -u root
mysql -u root -p
docker ps
docker ps -l
exit
ls
rm -rf laravel-9-course/
ls
cd example-app/
ls
php -v
mysql -u root -p
apt install mysql-client-core-8.0
mysql -u root -p
jdflkjadsl
curl -s https://laravel.build/example-app | bash
cd example-app && ./vendor/bin/sail up -d
ls
php -S localhost:8000
php artisan serve
ls
cd public/
php -S localhost:8000
php artisan serve
clear
./vendor/bin/sail up -d
php artisan cache:clear
./vendor/bin/sail php artisan cache:clear
./vendor/bin/sail up -d
./vendor/bin/sail php artisan route:clear
./vendor/bin/sail down
./vendor/bin/sail php artisan route:clear
dir
cd public/
php -S localhost:80
cd ..
./vendor/bin/sail up -d
./vendor/bin/sail down
curl -s "https://laravel.build/olw?with=mysql,redis,mailhog,minio" | bash
LS
ls
cd ProjetosDocker/
ls
cd olw
ls
cd ..
cd olw
ls
sail artisan serve
sail php artisan serve
cls
clear
ls
code .
docker ps
clear
docker ps
alias sail='[ -f sail ] && sh sail || sh vendor/bin/sail'
sail up -d
code .
sail down
ls
cd ..
ls
version
ls
cd ..
ls
cd var
ls
cls
ls
cd www
cd /
ls
cd var
ls
cd www
cd ..
ls
cd home
ls
cd alber
ls
cd ..
laravel -v
laravel -V
composer -V
./vendor/bin/sail up -d
./vendor/bin/sail down
./vendor/bin/sail up -d
sail ps
sail down
clear
./vendor/bin/sail ps
./vendor/bin/sail down
./vendor/bin/sail up -d
php artisan --version
./vendor/bin/sail down
./vendor/bin/sail ps
docker up -d
docker run -d
docker ps
./vendor/bin/sail ps
./vendor/bin/sail up -d
docke ps
docker ps
docker exec -it ffc7fa4e28ed bash
docker ps
sail up -d
cd ..
./vendor/bin/sail up -d
docker ps
./vendor/bin/sail up -d
ls
cd home
ls
cd alber/
ls
cd ..
ls
cd ..
ls
cd home
ls
cd var
ls
cd ..
cd var
ls
cd ..
ls
docker ps
exit
wsl --set-version <Distro> 2, – wsl --set-default-version 2
wsl --importe visando WSL 2wsl --export
cls
clear
wsl
wsl2
wsl.exe -l -v
wsl.exe --set-default-version 2
docker ps
./vendor/bin/sail up -d
docker run
docker run olw-laravel.test-1
start-container
docker start-container
docker up start-container
docker run start-container
docker down
clear
docker ps
ls
cd olw
./vendor/bin/sail down
./vendor/bin/sail up -d
./vendor/bin/sail down
ls
cd ..
ls
rm -rf olw
ls
rm -rf ProjetosDocker/
rm -rf example-app/
ls
exit
curl.exe -L -o ubuntu-2004.appx https://aka.ms/wslubuntu2004
wsl --set-default-version 2
Error: 0x1bc
For information on key differences with WSL 2 please visit https://aka.ms/wsl2
[    0.363323] 9p: Installing v9fs 9p2000 file system support
[    0.363336] FS-Cache: Netfs '9p' registered for caching
[    0.398989] 9pnet: Installing 9P2000 support
wsl --update
apt-get upgrade
Get-WindowsOptionalFeature -Online -FeatureName Microsoft-Windows-Subsystem-Linux
sudo service ssh status
debug1: sshd version OpenSSH_7.2, OpenSSL 1.0.2g  1 Mar 2016
debug1: key_load_private: incorrect passphrase supplied to decrypt private key
debug1: key_load_public: No such file or directory
Could not load host key: /etc/ssh/ssh_host_rsa_key
debug1: key_load_private: No such file or directory
debug1: key_load_public: No such file or directory
Could not load host key: /etc/ssh/ssh_host_dsa_key
debug1: key_load_private: No such file or directory
debug1: key_load_public: No such file or directory
Could not load host key: /etc/ssh/ssh_host_ecdsa_key
debug1: key_load_private: No such file or directory
debug1: key_load_public: No such file or directory
Could not load host key: /etc/ssh/ssh_host_ed25519_key
sudo apt-get purge openssh-server
sudo apt-get install openssh-server
wsl --install
wsl --update
wsl --shutdown
exit
sudo apt update
sudo apt install gedit -y
sudo apt-get install     ca-certificates     curl     gnupg     lsb-release
sudo mkdir -p /etc/apt/keyrings
curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg
echo   "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu \
  $(lsb_release -cs) stable" | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null
sudo apt-get update
sudo apt-get install docker-ce docker-ce-cli containerd.io docker-compose-plugin
sudo service docker start
sudo docker run hello-world
sudo su docker run hello-world
docker ps
ps aux | grep docker
sudo service docker status
systemctl start docker
gpasswd -a $USER docker
systemctl start docker
sudo service docker start
docke ps
docker ps
sudo service docker start
sudo service --status-all
sudo service docker start
systemctl enable docker
systemctl restart docker
systemctl enable docker
sudo service docker start
/var/run/docker.sock
sudo nohup docker daemon -H tcp://0.0.0.0:2375 -H unix:///var/run/docker.sock
sudo usermod -aG docker $USER
reboot
docker ps
sudo /var/run/docker.sock
cd  /var/run/docker.sock
cd  /var/run/
ls
cd WSL
ls
cd ..
ls
cd ..
ls
curl -s "https://laravel.build/olw?with=mysql,redis,mailhog,minio" | bash
docker ps
docker start
service docker start
sudo service docker status
sudo service docker start
sudo service docker status
sudo service docker start
sudo service docker status
& $Env:ProgramFiles\Docker\Docker\DockerCli.exe -SwitchDaemon .
docker pull mcr.microsoft.com/windows/nanoserver:ltsc2022
dockerd --debug
docker -H tcp://0.0.0.0:2375 ps
sudo dockerd -H unix:///var/run/docker.sock -H tcp://192.168.59.106 -H tcp://10.10.10.2sudo dockerd -H unix:///var/run/docker.sock -H tcp://192.168.59.106 -H tcp://10.10.10.2
docker --tlsverify ps
docker ps
docker -H :5555 pull ubuntu
docker -H tcp://127.0.0.1:2375 pull ubuntu
docker 
docker ps
docker version
docker ps
systemclt start docker 
systemctl start docker 
docker 
docker -H
docker -H --host list
docker -H --host
docker -H --help
docker ps
curl -s "https://laravel.build/olw?with=mysql,redis,mailhog,minio" | bash
cd olw && ./vendor/bin/sail up
cd olw && ./vendor/bin/sail up -d
cd ..
cd olw
./vendor/bin/sail up -d
./vendor/bin/sail down
./vendor/bin/sail tinker
cls
clear
sail php --version
sail share
sudo chmod 777 storage/ -R
sudo chmod 0777 storage/ -R
./vendor/bin/sail up -d
./vendor/bin/sail down
ls
cd olw
./vendor/bin/sail up -d
sudo chmod 777 storage/ -R
./vendor/bin/sail up -d
code .
./vendor/bin/sail down
curl -s "https://laravel.build/example-app | bash
cd ..
curl -s "https://laravel.build/example-app | bash
ls
curl -s https://laravel.build/example-app | bash
cd example-app/
./vendor/bin/sail up -d
sudo chmod 777 storage/ -R
./vendor/bin/sail up -d
sail share
./vendor/bin/sail share
mysql 
myqsl -u root -p
alias sail='[ -f sail ] && sh sail || sh vendor/bin/sail'
ls
sail ps
./vendor/bin/sail ps
docker ps
cd example-app/
sail ps
sail down
composer global require beyondcode/expose
expose default-server sa-1
expose token 89e90595-06a7-4245-99c9-03536b633447
composer global require beyondcode/expose
ls
php artisan serve
cd public/
php -S localhost:8080
clear
cd..
cd ..
cd example-app/
clear
sail up -d
code .
ls
code .
sail down
cd ..
docker ps
clear
./vendor/bin/sail up -d
cd example-app/
./vendor/bin/sail up -d
code .
./vendor/bin/sail down
php artisan route:list
sail artisan route:list
sail
cls
clear
./vendor/bin/sail list
./vendor/bin/sail down
./vendor/bin/sail up -d
./vendor/bin/sail down
./vendor/bin/sail up -d
/ls
mysql -u root -p
mysql -u sail -p
mysql
docker ps
ls
cd example-app/
./vendor/bin/sail up -d
code .
cd ..
mysql
mysql --version
mysql -u sail -p
cd ..
ls
cd example-app/
clear
mysql -u root -p
cd..
ls
cd ..
sail down
./vendor/bin/sail down
docker ps
cd example-app/
sail down
./vendor/bin/sail down
ls
cd ..
ls
sail up -d
./vendor/bin/sail up -d
cd example-app/
./vendor/bin/sail up -d
docker ps
./vendor/bin/sail up -d
mysql -u root -p
mysql -u sail -p
exit
mysql -u sail -p
./vendor/bin/sail up -d
mysql -u sail -p
clear
./vendor/bin/sail down
mysql -u sail -p
exit
docker ps
docker ps -l
docker ps -a
clear
ls
cd ex
cd example-app/
ls
./vendor/bin/sail up -d
code .
mysql --version
mysql -u sail -p
mysql -u root -p
mysql -u sail -p
mysql --version
myql -u root -p
mysql -u root -p
ls
sudo
sudo chmod 777 storage/ -R
ls
cd ..
ls
cd ..
ls
sudo chmod 777 var/ -R
mysql -u root -p
ls
docker ps
cd example-app/
sail down
./vendor/bin/sail down
./vendor/bin/sail up -d
code .
ls
cd ..
ls
cd ..
ls
cd ..
ls
cd home
ls
cd ..
cd root
ls
cd example-app/
ls
cd ..
docker ps
docker exec -it example-app-mysql-1 bash
ls
cd example-app/
ping localhost:3306
ping 0.0.0.0:3306
clear
./vendor/bin/sail down
sail ps
./vendor/bin/sail ps
ls
cd ..
pwd
ls
cd olw
ls
cd ..
cd example-app/
sail ps
./vendor/bin/sail up -d
sail artisan migrate --seed
p
./vendor/bin/sail  artisan migrate --seed
./vendor/bin/sail artisan make:controller UserController
php artisan make:controller UserController
./vendor/bin/sail artisan make:controller UserController
php artisan make:controller UserController
clear
docker ps
./vendor/bin/sail  up -d
php -v
docker ps
docker run hello-world
exit
./vendor/bin/sail artisan serve
docker ps
clear
./vendor/bin/sail  up -d
mysql --v
mysql -v
mysql -u root -p
cd ..
mysql -u root -p
clear
mysql --version;
composer
clear
docker ps -l
docker ps
docker run hello-world
clear
docker ps -l
ls
cd example-app/
./vendor/bin/sail up -d
code .
./vendor/bin/sail down
./vendor/bin/sail up -d
./vendor/bin/sail down
./vendor/bin/sail up -d
./vendor/bin/sail down
./vendor/bin/sail up -d
./vendor/bin/sail down
./vendor/bin/sail up -d
code .
./vendor/bin/sail down
./vendor/bin/sail up -d
ping
ping 127.0.0.1:3307
ping 127.0.0.1:3306
ping 127.0.0.1
ping 127.0.0.1:80
ping 127.0.0.1:6379
ping 127.0.0.1:3306
ping 127.0.0.1:3307
./vendor/bin/sail down
./vendor/bin/sail up -d
code .
./vendor/bin/sail down
./vendor/bin/sail up -d
code .
./vendor/bin/sail down
./vendor/bin/sail up -d
code .
./vendor/bin/sail up -d
./vendor/bin/sail down
./vendor/bin/sail up -d
code .
./vendor/bin/sail up -d
./vendor/bin/sail down
./vendor/bin/sail up -d
code .
./vendor/bin/sail up -d
./vendor/bin/sail down
./vendor/bin/sail up -d
./vendor/bin/sail down
./vendor/bin/sail up -d
./vendor/bin/sail down
./vendor/bin/sail up -d
./vendor/bin/sail down
./vendor/bin/sail up -d
./vendor/bin/sail down
./vendor/bin/sail up -d
./vendor/bin/sail down
./vendor/bin/sail up -d
./vendor/bin/sail down
./vendor/bin/sail up -d
./vendor/bin/sail down
./vendor/bin/sail up -d
./vendor/bin/sail down
./vendor/bin/sail up -d
code .
./vendor/bin/sail up -d
./vendor/bin/sail down
./vendor/bin/sail up -d
./vendor/bin/sail down
./vendor/bin/sail up -d
clear
docker ps
docker exec -it example-app-mysql-1
docker exec -it example-app-mysql-1 bash
./vendor/bin/sail up -d
./vendor/bin/sail down
./vendor/bin/sail up -d
ls
cd example-app/
docker ps
ls
php artisan serve
clear
ls
cd vendor
cd bin
ls
vi sail
clear
code .
ls
cd sail
cd ..
cd vendor
cd bin
sail up -d
cd ..
./vendor/bin/sail up -d
ls
code .
./vendor/bin/sail ps
clear

./vendor/bin/sail down
docker ps -l
docker  -l
ls
cd olw
./vendor/bin/sail up -d
code .
docker ps
./vendor/bin/sail up -d
clear
./vendor/bin/sail up -d
./vendor/bin/sail composer require laravel/breeze --dev
./vendor/bin/sail up -d
./vendor/bin/sail composer require laravel/breeze --dev
cd ..
sudo chmod 777 olw/ -R
./vendor/bin/sail composer require laravel/breeze --dev
cd olw
./vendor/bin/sail composer require laravel/breeze --dev
./vendor/bin/sail art breeze:install vue
./vendor/bin/sail art migrate
CLEAR
clear
alias sail='bash vendor/bin/sail'
sail ps
git init
git add .
git commit -m "comit inicial"
git add .
git remote add origin https://github.com/albertogomesdasilva/laravel- sail-olw.git
git remote add origin -m https://github.com/albertogomesdasilva/laravel- sail-olw.git
git push
git push --set-upstream origin master
git remote add origin https://github.com/albertogomesdasilva/laravel-sail-olw.git
git push -u origin main
git remote add origin https://github.com/albertogomesdasilva/laravel-sail-olw.git
git push -u origin main
git login
git user.name albertogomesdasilva
echo "# laravel-sail-olw" >> README.md 
git init 
git add README.md 
git commit -m "first commit" 
git branch -M main 
git remote add origin https://github.com/albertogomesdasilva/laravel- sail-olw.git
echo "# laravel-sail-olw" >> README.md 
git init 
git add README.md 
git commit -m "first commit" 
git branch -M main 
git remote add origin https://github.com/albertogomesdasilva/laravel- sail-olw.git
echo "# laravel-sail-olw" >> README.md 
git init
git add README.md
git commit -m "first commit"
git config  user.name "Albertogomesdasilva"
git config  user.email "albertogomesdasilva@hotmail.com"
git branch -M main
git remote add origin https://github.com/albertogomesdasilva/laravel-sail-olw.git
git push -u origin main
ping www.google.com
clear
git remote add origin https://github.com/albertogomesdasilva/laravel-sail-olw.git
git push -u origin main
git remote add origin https://github.com/albertogomesdasilva/laravel-sail-olw
echo "# laravel-sail-olw" >> README.md
git init
git add README.md
git commit -m "first commit"
git branch -M main
git remote add origin https://github.com/albertogomesdasilva/laravel-sail-olw.git2
git push -u origin main
git remote add origin https://github.com/albertogomesdasilva/laravel-sail-olw.git
git remote add origin https://github.com/albertogomesdasilva/laravel-sail-olw.git2
git remote add origin https://github.com/albertogomesdasilva/laravel-sail-olw.git
clear
git remote add origin https://github.com/albertogomesdasilva/laravel-sail-olw
git config --global user.email  "albertogomesdasilva@hotmail.com"
git status
touch .gitignore
git add .
git commit -a -m "commit inicial"
git remote add origin https://github.com/albertogomesdasilva/laravel- sail-olw.git
git branch -M main 
git remote add origin https://github.com/albertogomesdasilva/laravel- sail-olw.git
clear
git status
git push --set-upstream origin master
git branch
git status
git init
git status
git add.
git add .
git status
git commit -a -m "commit inicial"
git status
git remote add origin https://github.com/albertogomesdasilva/laravel-sail-olw.git
git push
cd ..
git remote add origin https://github.com/albertogomesdasilva/laravel-sail-olw.git
cd owl
ls
cd olw
git remote add origin https://github.com/albertogomesdasilva/laravel-sail-olw
git push -u origin main
git init
clear
git reset
git status
git logout
git --help
git exit
clear
git add ANOTAÇÕES.md
git log
git commit "anotações"
clear
sail ps
clear
alias sail='bash vendor/bin/sail'
alias s='bash vendor/bin/sail'
s ps
clear
sail ps
s ps
clear
s down
s up -d
clear
s art make:controller BeerController
alias sail='bash vendor/bin/sail'
sail art migrate
sail npm run dev
npm run dev
sail npm run dev
npm run dev
sail npm run dev
sail art migrate
./vendor/bin/sail art migrate
./vendor/bin/sail artisan migrate
npm i
composer install
php --ini
php ini
php -i
ls
composer update
composer install
docker ps
ls
cd olw
s up -d
./vendor/bin/sail up -d
ls
cd public
ls
cd build
ls
cd assets/
ls
cd ..
ls
cd resources/
ls
cd views
ls
cd..
cd ..
code .
./vendor/bin/sail up -d
./vendor/bin/sail down
./vendor/bin/sail up -d
sail art migrate
./vendor/bin/sail up -d
./vendor/bin/sail donw
./vendor/bin/sail down
./vendor/bin/sail up -d
./vendor/bin/sail down
composer install
--ignore-platform-req=ext-simplexml --ignore-platform-req=ext-dom --ignore-platform-req=ext-xml --ignore-platform-req=ext-curl
composer install --ignore-platform-req=ext-simplexml --ignore-platform-req=ext-dom --ignore-platform-req=ext-xml --ignore-platform-req=ext-curl
sudo su composer update
sudo composer update
sudo su
sudo composer update
composer i
apt install composer
composer update
composer update --with-all-dependencies
php composer.phar install --no-plugins --no-scripts
cd olw
php composer.phar install --no-plugins --no-scripts
ls
cd olw
ls
apt update
composer update
./vendor/bin/sail up -d
./vendor/bin/sail down
./vendor/bin/sail up -d
composer update
composer update --with-all
ls
sudo su albert
sudo su alber
cd ow
cd olw
./vendor/bin/sail up -d
code .
./vendor/bin/sail up -d
php composer.phar update --no-plugins --no-scripts
ls
composer install
code .
php composer.phar install --no-plugins --no-scripts
cls
clear
./vendor/bin/sail up -d
./vendor/bin/sail down
php composer.phar install --no-plugins --no-scripts
composer update
cd ..
ls
cd ..
ls
chmod 777 usr/ -R
php --ini
php -ini
composer install
cd olw
pwd
ls
cd home
ls
cd ..
ls
cd root
ls
cd olw
composer install
npm i
cd public/
ls
cd buido
cd buid
cd build
ls
cd asstes
cd assets
ls
ls
chmod 777 olw/ -R
cd olw
sail up -d
./vendor/bin/sail up -d
./vendor/bin/sail composer dumpautoload
./vendor/bin/sail composer autoload
./vendor/bin/sail composer dump-autoload
composer install
composer --ignore-platform-req=ext-simplexml --ignore-platform-req=ext-dom --ignore-platform-req=ext-dom --ignore-platform-req=ext-xml --ignore-platform-req=ext-dom --ignore-platform-req=ext-dom --ignore-platform-req=ext-dom --ignore-platform-req=ext-curl --ignore-platform-req=ext-dom --ignore-platform-req=ext-simplexml
composer dumautoload --ignore-platform-req=ext-simplexml --ignore-platform-req=ext-dom --ignore-platform-req=ext-dom --ignore-platform-req=ext-xml --ignore-platform-req=ext-dom --ignore-platform-req=ext-dom --ignore-platform-req=ext-dom --ignore-platform-req=ext-curl --ignore-platform-req=ext-dom --ignore-platform-req=ext-simplexml
composer dumpautoload --ignore-platform-req=ext-simplexml --ignore-platform-req=ext-dom --ignore-platform-req=ext-dom --ignore-platform-req=ext-xml --ignore-platform-req=ext-dom --ignore-platform-req=ext-dom --ignore-platform-req=ext-dom --ignore-platform-req=ext-curl --ignore-platform-req=ext-dom --ignore-platform-req=ext-simplexml
./vendor/bin/sail up -d
code .
./vendor/bin/sail up -d
cd ..
ls
./vendor/bin/down
./vendor/bin/sail down
cd root
cd olw
./vendor/bin/sail down
cd olw
./vendor/bin/sail up -d
cd ..
rm -rf olw
ls
exit
docker ps
docker ps -la
docker ps -l
exit
nmp run dev
ls
cd example-app/
ls
sail 
./vendor/bin/sail up -d
code .
./vendor/bin/sail stop
cd ..
docker
docker ps
clear
cd ..
sudo chmod 777 olw/ -R
composer require laravel/breeze --dev
php -ini
php --ini
clear
./vendor/bin/sail composer require laravel/breeze --dev
cd olw
./vendor/bin/sail composer require laravel/breeze --dev
./vendor/bin/sail artisan breeze:install vue
./vendor/bin/sail art migrate
alias sail='[ -f sail ] && sh sail || sh vendor/bin/sail'
sail art make:controller BeerController
sail ps
sail artisan make:controller BeerController
sail artisan make:request BeerRequest
sail composer require psr/simple-cache:^2.0 maatwebsite/excel
./vendor/bin/sail composer require psr/simple-cache:^2.0 maatwebsite/excel
./vendor/bin/sail composer dump-autoload
./vendor/bin/sail artisan make:export BeerExport
./vendor/bin/sail art config:cache
./vendor/bin/sail art optimize:clear
./vendor/bin/sail composer require psr/simple-cache:^2.0 maatwebsite/excel
./vendor/bin/sail composer require -W league/flysystem-aws-s3-v3 "^3.0"
curl -s "https://laravel.build/olw?with=mysql,redis,mailhog,minio" | bash
ls
rm -rf example-app/
ls
rm -rf olw
clear
curl -s "https://laravel.build/olw?with=mysql,redis,mailhog,minio" | bash
docker scan
cd olw && ./vendor/bin/sail up -d
code .
cd olw && ./vendor/bin/sail up -d
./vendor/bin/sail up -d
code .
./vendor/bin/sail down
./vendor/bin/sail up -d
sail down
./vendor/bin/sail down
./vendor/bin/sail up -d
code .
./vendor/bin/sail up -d
code .
./vendor/bin/sail up -d
sail down
./vendor/bin/sail down
ls
cd olw
./vendor/bin/sail up -d
docker ps
ls
cd olx
ls
cd olw
./vendor/bin/sail up -d
docker ps
clear
code .
ls
cd ..
ls
docker ps
docker exec -it 51288723f17a bash
ls
./vendor/bin/sail up -d
cd olw
./vendor/bin/sail up -d
./vendor/bin/sail down
./vendor/bin/sail up -d
./vendor/bin/sail art migrate
php artisan migrate
clear
composer update
npm i
npm
composer install
php --ini
alias sail='[ -f sail ] && sh sail || sh vendor/bin/sail'
sail ps
s ps
sh ps
clear
sail art make:migration create_history_table
sail art make:model Export -mr
sail art make: Export -mr
sail art make:model Export -mr
sail art make:model Meal -mr
sail art make:factory MealFactory
sail art make:seed MealSeeder
sail composer require jzonta/faker-restaurant
sail composer dump-autoload
./vendor/bin/sail composer dump-autoload
clear
alias sail='[ -f sail ]
alias sail='[ -f sail ] && sh sail || sh vendor/bin/sail'
sail art migrate:fresh --seed
clear
sail art migrate:fresh --seed
sail art make:mail ExportEmail
sail up -d
sail down
sail up -d
docker ps
ols
olw
ls
cd olw
ls
sail ps
clear
./vendor/bin/sail up -d
code .
./vendor/bin/sail up -d
./vendor/bin/sail art server
./vendor/bin/sail art serve
sail art migrate:fresh --seed
alias sail='[ -f sail ] && sh sail || sh vendor/bin/sail'
sail composer dump-autoload
sail up -d
sail composer require jzonta/faker-restaurant
sail ps
sail composer install
composer install
php --ini
composer install
php -S localhost:8000
cd ..
chmod 777 olw/ -R
sail ps
./vendor/bin/sail up -d
cd olw
./vendor/bin/sail up -d
docker ps
./vendor/bin/sail up -d -->
"# notas" 

### FAKER
Falso#
Downloads do empacotador Status do fluxo de trabalho do GitHub

Faker é uma biblioteca PHP que gera dados falsos para você. Se você precisa inicializar seu banco de dados, criar documentos XML de boa aparência, preencher sua persistência para testá-lo ou anonimizar dados obtidos de um serviço de produção, o Faker é para você.

É fortemente inspirado por Perl's Data::Faker , e por Ruby's Faker .

Instalação#
Faker requer PHP >= 7.1.


composer require fakerphp/faker
Uso básico#
Carregamento automático#
Faker suporta tanto PSR-0como PSR-4autoloaders.


// when installed via composer
require_once 'vendor/autoload.php';
Você também pode carregar o autoloader FakersenviadoPSR-0


// load Faker autoloader
require_once '/path/to/Faker/src/autoload.php';
alternativamente, você pode usar qualquer outro autoloader compatível com PSR-4

Crie dados falsos#
Use Faker\Factory::create()para criar e inicializar um gerador faker, que pode gerar dados chamando métodos com o nome do tipo de dados desejado.


require_once 'vendor/autoload.php';

// use the factory to create a Faker\Generator instance
$faker = Faker\Factory::create();
// generate data by calling methods
echo $faker->name();
// 'Vince Sporer'
echo $faker->email();
// 'walter.sophia@hotmail.com'
echo $faker->text();
// 'Numquam ut mollitia at consequuntur inventore dolorem.'
Cada chamada para $faker->name()produz um resultado diferente (aleatório). Isso ocorre porque o Faker usa __call()magia e encaminha Faker\Generator->$method()chamadas para Faker\Generator->format($method, $attributes).


for ($i = 0; $i < 3; $i++) {
    echo $faker->name() . "\n";
}

// 'Cyrus Boyle'
// 'Alena Cummerata'
// 'Orlo Bergstrom'
Modificadores#
Faker fornece três provedores especiais, unique(), optional(), e valid(), para serem chamados antes de qualquer provedor.


// unique() forces providers to return unique values
$values = [];
for ($i = 0; $i < 10; $i++) {
    // get a random digit, but always a new one, to avoid duplicates
    $values []= $faker->unique()->randomDigit();
}
print_r($values); // [4, 1, 8, 5, 0, 2, 6, 9, 7, 3]

// providers with a limited range will throw an exception when no new unique value can be generated
$values = [];
try {
    for ($i = 0; $i < 10; $i++) {
        $values []= $faker->unique()->randomDigitNotNull();
    }
} catch (\OverflowException $e) {
    echo "There are only 9 unique digits not null, Faker can't generate 10 of them!";
}

// you can reset the unique modifier for all providers by passing true as first argument
$faker->unique($reset = true)->randomDigitNotNull(); // will not throw OverflowException since unique() was reset
// tip: unique() keeps one array of values per provider

// optional() sometimes bypasses the provider to return a default value instead (which defaults to NULL)
$values = [];
for ($i = 0; $i < 10; $i++) {
    // get a random digit, but also null sometimes
    $values []= $faker->optional()->randomDigit();
}
print_r($values); // [1, 4, null, 9, 5, null, null, 4, 6, null]

// optional() accepts a weight argument to specify the probability of receiving the default value.
// 0 will always return the default value; 1.0 will always return the provider. Default weight is 0.5 (50% chance).
// Please note that the weight can be provided as float (0 / 1.0) or int (0 / 100)

// As float
$faker->optional($weight = 0.1)->randomDigit(); // 90% chance of NULL
$faker->optional($weight = 0.9)->randomDigit(); // 10% chance of NULL

// As int
$faker->optional($weight = 10)->randomDigit; // 90% chance of NULL
$faker->optional($weight = 100)->randomDigit; // 0% chance of NULL

// optional() accepts a default argument to specify the default value to return.
// Defaults to NULL.
$faker->optional($weight = 0.5, $default = false)->randomDigit(); // 50% chance of FALSE
$faker->optional($weight = 0.9, $default = 'abc')->word(); // 10% chance of 'abc'

// valid() only accepts valid values according to the passed validator functions
$values = [];
$evenValidator = function($digit) {
    return $digit % 2 === 0;
};
for ($i = 0; $i < 10; $i++) {
    $values []= $faker->valid($evenValidator)->randomDigit();
}
print_r($values); // [0, 4, 8, 4, 2, 6, 0, 8, 8, 6]

// just like unique(), valid() throws an overflow exception when it can't generate a valid value
$values = [];
try {
    $faker->valid($evenValidator)->randomElement([1, 3, 5, 7, 9]);
} catch (\OverflowException $e) {
    echo "Can't pick an even number in that set!";
}
Se você quiser usar um modificador com um valor não gerado pelo Faker, use o passthrough()método. passthrough() simplesmente retorna qualquer valor que foi dado.


$faker->optional()->passthrough(mt_rand(5, 15));
Localização#
Faker\Factorypode receber uma localidade como argumento, para retornar dados localizados. Se nenhum provedor localizado for encontrado, a fábrica retornará à localidade padrão (en_US).


// create a French faker
$faker = Faker\Factory::create('fr_FR');
for ($i = 0; $i < 3; $i++) {
    echo $faker->name() . "\n";
}

// Luce du Coulon
// Auguste Dupont
// Roger Le Voisin
Você pode verificar as localidades do Faker disponíveis no código-fonte, no Providerdiretório . A localização do Faker é um processo contínuo, para o qual precisamos da sua ajuda. Não hesite em criar provedores localizados para sua própria localidade e enviar um PR!

Semeando o Gerador#
Você pode querer sempre obter os mesmos dados gerados - por exemplo, ao usar o Faker para fins de teste de unidade. O gerador oferece um seed()método que propaga o gerador de números aleatórios. Chamar o mesmo script duas vezes com a mesma semente produz os mesmos resultados.


$faker = Faker\Factory::create();
$faker->seed(1234);

echo $faker->name(); // 'Jess Mraz I';
Dica
Os formatadores DateTime não reproduzirão os mesmos dados falsos se você não corrigir o $maxvalor:


// even when seeded, this line will return different results because $max varies
$faker->dateTime(); // equivalent to $faker->dateTime($max = 'now')
// make sure you fix the $max parameter
$faker->dateTime('2014-02-25 08:37:17'); // will return always the same date when seeded
Dica
Os formatadores não reproduzirão os mesmos dados falsos se você usar a rand()função php. Use $fakerou mt_rand()em vez disso:


// bad
$faker->realText(rand(10, 20));
// good
$faker->realText($faker->numberBetween(10, 20));
Faker Internals: Entendendo os Provedores#
Um Faker\Generatorsozinho não pode fazer muita geração. Ele precisa Faker\Providerde objetos para delegar a geração de dados a eles. Faker\Factory::create()realmente cria um Faker\Generatorpacote com os provedores padrão. Aqui está o que acontece sob o capô:


$faker = new Faker\Generator();
$faker->addProvider(new Faker\Provider\en_US\Person($faker));
$faker->addProvider(new Faker\Provider\en_US\Address($faker));
$faker->addProvider(new Faker\Provider\en_US\PhoneNumber($faker));
$faker->addProvider(new Faker\Provider\en_US\Company($faker));
$faker->addProvider(new Faker\Provider\Lorem($faker));
$faker->addProvider(new Faker\Provider\Internet($faker));
Sempre que você tenta acessar uma propriedade do $fakerobjeto, o gerador procura um método com o mesmo nome em todos os provedores anexados a ele. Por exemplo, chamar $faker->nameaciona uma chamada para Faker\Provider\Person::name(). E como o Faker começa com o último provedor, você pode facilmente substituir os formatadores existentes: basta adicionar um provedor contendo métodos nomeados de acordo com os formatadores que você deseja substituir.

Isso significa que você pode adicionar facilmente seus próprios provedores a uma Faker\Generatorinstância. Um provedor geralmente é uma classe que estende o \Faker\Provider\Base. Essa classe pai permite que você use métodos como lexify()ou randomNumber(); também lhe dá acesso a formatadores de outros provedores, através da $generatorpropriedade protegida. Os novos formatadores são os métodos públicos da classe do provedor.

Aqui está um exemplo de provedor para preencher dados de livros:


namespace Faker\Provider;

class Book extends \Faker\Provider\Base
{
  public function title($nbWords = 5)
  {
    $sentence = $this->generator->sentence($nbWords);
    return substr($sentence, 0, strlen($sentence) - 1);
  }

  public function ISBN()
  {
    return $this->generator->ean13();
  }
}
Para registrar este provedor, basta adicionar uma nova instância de \Faker\Provider\Booka um gerador existente:


$faker->addProvider(new \Faker\Provider\Book($faker));
Agora você pode usar os dois novos formatadores como qualquer outro formatador Faker:


$book = new Book();
$book->setTitle($faker->title());
$book->setISBN($faker->ISBN());
$book->setSummary($faker->text());
$book->setPrice($faker->randomNumber(2));
Dica
Um provedor também pode ser um Plain Old PHP Object. Nesse caso, todos os métodos públicos do provedor ficam disponíveis para o gerador.

Formatadores específicos de idioma#
As localidades suportadas podem ser encontradas no cabeçalho "Locales" à esquerda.

Localidades com nomes errados#
Nome atual	Nome correto
at_AT	de_AT
zh_CN	zh_Hans_CN
zh_TW	zh_Hant_TW
Fonte: https://www.localeplanet.com/icu/

Licença#
Faker é lançado sob a licença MIT. Consulte o arquivo LICENSE incluído para obter detalhes.


Guia rápido do WSL2 + Docker
O que é o WSL2
Em 2016, a Microsoft anunciou a possibilidade de rodar o Linux dentro do Windows 10 como um subsistema e o nome a ser dado de WSL ou Windows Subsystem for Linux .

O acesso ao sistema de arquivos no Windows 10 pelo Linux era simples e rápido, porém não tínhamos uma execução completa do kernel do Linux, além de outros recursos nativos e isto impossibilitava a execução de várias tarefas no Linux, uma delas é o Docker.

Em 2019, a Microsoft anunciou o WSL 2 , com uma dinâmica aprimorada em relação a 1ª versão:

Execução do kernel completo do Linux.
Melhor desempenho para acesso aos arquivos dentro do Linux.
Compatibilidade completa de chamada do sistema.
O WSL 2 foi lançado oficialmente no dia 28 de maio de 2020.

Com o WSL 2 é possível executar o Docker no Linux usando o Windows 10/11.

Compare como versões: https://docs.microsoft.com/pt-br/windows/wsl/compare-versions

O que é Docker
Docker é uma plataforma de código aberto que possibilita o pacote de uma aplicação dentro do container. Uma aplicação consegue se adequar e rodar em qualquer máquina que tenha essa tecnologia instalada.

Porque usar WSL 2 + Docker para desenvolvimento
Configuração semper e complexo, foi de algumas ferramentas que não são totalmente de desenvolvimento, mas também de algumas ferramentas que não são totalmente desenvolvidas.

Com o nascimento do Docker este cenário melhorou bastante, pois podemos montar o ambiente de desenvolvimento baseado em Unix, de forma independente e rápida, e ainda unificada com outros sistemas operacionais.

Veja nossa live sobre WSL 2 + Docker no canal Full Cycle : https://www.youtube.com/watch?v=usF0rYCcj-E .

Modos de uso Docker no Windows
Caixa de ferramentas do Docker .
Docker Desktop com Hyper-V .
Docker Desktop com WSL2 .
Docker Engine (Docker Nativo) instalado diretamente no WSL2 .
Caixa de ferramentas do Docker
Roda em cima do programa de virtualização de sistemas da Oracle, chamado de VirtualBox . O desempenho do Docker Toolbox para muitas aplicações/ferramentas pode ser muito ruim, inviabilizando seu uso.

Docker Desktop com Hyper-V
Roda em cima do Hyper-V da Microsoft em vez de usar o VirtualBox usando o Docker Toolbox. O Docker Desktop com Hyper-V necessita da versão PRO do Windows 10/11, portanto é necessário comprar-la se você não a tem.

O Hyper-V requer muitos recursos da máquina e, apesar de funcionar melhor que o Docker Toolbox, a máquina pode ficar lenta para usar outras coisas no Windows.

A Docker já anunciou que vai remover o suporte ao Hyper-V futuramente.

Docker Desktop com WSL2
Roda em cima do Virtual Machine Platform em vez de usar o VirtualBox ou Hyper-V. Se integra com o WSL2 permitindo rodar o Docker dentro do ambiente do Linux. Não é necessário adquirir licença PRO para o Windows 10/11, tem um grande desempenho e consome menos recursos quando comparado ao Docker Toolbox ou Docker Desktop com Hyper-V.

Temos uma grande vantagem de trabalhar totalmente dentro do Linux para desenvolvimento, portanto, usar WSL2 + Docker é a melhor maneira de desenvolver aplicações no Windows.

Vantagens
Simplifica a configuração do Docker tanto no Windows quanto no WSL 2.
Permite rodar o Docker fora do WSL 2. É possível usar qualquer shell como PowerShell ou DOS.
Suporta containers no modo Windows (Imagens que contém o Windows por debaixo dos panos ao invés do Linux).
Criar um ambiente centralizado para armazenamento de imagens, volumes e outras configurações do Docker. Pode-se ter várias distribuições do WSL 2 rodando o mesmo Docker.
Interface visual para gerenciar o Docker.
Desvantagens
Uso de memória inicial sem rodar nenhum container Docker pode chegar a 3GB.
Adiciona infraestrutura complexa para executar o Docker, quando for necessário apenas rodar os containers Docker dentro de um WSL 2 apenas.
Docker Engine (Docker Nativo) instalado diretamente no WSL2.
O Docker Engine nativo que roda totalmente no ambiente Linux e suportado para o Docker 2 é instalado a funcionar como uma configuração do Linux para sua distribuição como sendo totalmente disponibilizados no site do Docker .

Vantagens
Consuma o mínimo de memória necessário para rodar o Docker Daemon (servidor do Docker).
É mais rápido ainda que com o Docker Desktop, porque roda diretamente dentro da própria instância do WSL2 e não em uma instância separada do WSL2.
Desvantagens
Necessário executar o comando sudo service docker startsempre que o WSL 2 foi reiniciado. Isto não é planejado para ser implementado, mas é bom para ser iniciado e futuramente com a inclusão do arquivo /etc/wsl.
Se for necessário executar o Docker em outra instância do WSL 2, é necessário instalar novamente o Docker nesta instância ou configurar o acesso ao soquete do Docker desejado para compartilhar o Docker entre as instâncias.
Não suporta contêineres no modo Windows.
Requisitos
Windows 10 Home ou Professional

Versão 1903 ou superior para sistemas x64, com Build 18362 ou superior.
Versão 2004 ou superior para sistemas ARM64, com Build 19041 ou superior.
Windows 11 Home ou Professional

Versão 22000 ou superior.
Seu Windows está confirmado, mas já está confirmado o menu de notificações perto do relógio > Todas as configurações > Sistema > Sobre. Caso não esteja, use o Assistente do Windows Update para atualizar sua versão do Windows.

Uma máquina com virtualização (verifique a disponibilidade de acordo com a marca do seu processador. Se sua máquina for mais antiga pode ser necessária habilita-la na BIOS).
Pelo menos 4GB de memória RAM.
Instalação do WSL 2
Windows 10
Habilitar o Virtual Machine Platform
Execute os seguintes comandos no PowerShell em modo administrador:

dism.exe /online /enable-feature /featurename:Microsoft-Windows-Subsystem-Linux /all /norestart
dism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart
Abra o PowerShell e digite o comando wsl, se não funcionar reinicie sua máquina.

Instalar o executável do WSL
Baixe o Kernel do WSL 2 neste link: https://docs.microsoft.com/pt-br/windows/wsl/wsl2-kernel e instale o pacote.

Atribuir a versão default da WSL para a versão 2
A versão 1 do WSL é o padrão no momento, atribua a versão default para a versão 2, assim como todas as distribuições Linux instaladas já serão por default da versão 2. Execute o comando com o PowerShell:

wsl --set-default-version 2
(Opcional) Alterar a versão do WSL 1 de uma distribuição para a versão 2
Se você já tiver o WSL 1 na máquina e acabou de instalar a versão 2, pode-se converter sua distribuição Linux WSL 1 para WSL 2, execute o comando com o PowerShell:

wsl --set-version <distribution name> 2
Windows 11
Execute o comando:

wsl --install
Este comando irá instalar todas as dependências do WSL instalando Ubuntucomo o Linux padrão.

Se você quiser instalar uma versão diferente do Ubuntu, execute o comando wsl -l -o, será listado todas as versões do Linux disponíveis. Instale a versão escolhida com o comando wsl --install -d nome-da-distribuicao.

sugerimos o Ubuntu (sem versão) por ser uma distribuição popular e que já vem com várias ferramentas instaladas por padrão.

Escolha sua distribuição Linux na Windows Store
Também é possível instalar distribuições Linux pela Windows Store. Escolha sua distribuição Linux preferida no aplicativo Windows Store, sugerindo o Ubuntu (sem versão) por ser uma distribuição popular e que já vem com várias instaladas por padrão.

Distribuições Linux na Windows Store

Ao iniciar o Linux instalado, você deverá criar um nome de usuário que poderá ser o mesmo da sua máquina e uma senha , este será o usuário root da sua instância WSL .

Parabéns, seu WSL2 já está funcionando:

Exemplo de WSL2 funcionando

(Opcional) Usar o Windows Terminal como terminal padrão de desenvolvimento para Windows
Uma deficiência que o Windows sempre provou ser um terminal adequado para desenvolvimento. Agora temos o Windows Terminal construído pela própria Microsoft que permite rodar terminais em abas, alterar núcleos e temas, configurar atalhos e muito mais.

Instale-o pela Windows Store e use estas configurações de padrões para habilitar WSL 2, Git Bash e o tema drácula e alguns atalhos.

Para sobrescrever as configurações a seta para baixo do lado das abas e em configurações , abrir as configurações do Windows Terminal, apenas cole o conteúdo do arquivo JSON e salve, após isso clique Ubuntuna seção Perfis, clique sobre Diretório iniciale altere o caminho para: (\\wsl$\Ubuntu\home\SEU_USUÁRIO_UBUNTU).

O que o WSL 2 pode usar os recursos de sua máquina
Podemos dizer que o WSL 2 tem acesso quase total aos recursos de sua máquina. Ele tem acesso por padrão:

Todo disco rígido.
A usar completamente os recursos de processamento.
A usar 80% da memória RAM disponível.
A usar 25% da memória disponível para SWAP.
Isto pode não ser interessante, uma vez que o WSL 2 pode usar todas as máquinas de sua máquina, mas pode configurar limites.

Crie um arquivo chamado .wslconfigna raiz da sua pasta de usuário (C:\Users\<seu_usuario>)e defina estas configurações:

[wsl2]
memory=8GB
processors=4
swap=2GB
Estes são limites de exemplo e as configurações mais básicas a serem utilizadas, configure-os às suas disponibilidades. Para mais detalhes veja esta documentação da Microsoft: https://docs.microsoft.com/pt-br/windows/wsl/wsl-config#wsl-2-settings .

Para estas configurações é necessário reiniciar como distribuições Linux, sugerimos então executar no PowerShell o comando wsl --shutdown:

Integrar Docker com WSL 2
No início deste tutorial observei 4 modos de usar o Docker no Windows , mas somente 2 que recomendamos:

Docker Engine (Docker Nativo) instalado diretamente no WSL2 .
Docker Desktop com WSL2 .
Recomendamos que escolha a 1ª opção de seus benefícios, já que a maioria das pessoas poderá usar o WSL 2 como ferramenta central para desenvolvimento. Mas, neste tutorial vamos mostrar como duas formas de instalação.

1 - Instalar o Docker com Docker Engine (Docker Nativo)
A instalação do Docker no WSL 2 é instalada em sua distribuição do Docker Linux, portanto você tem o Ubuntu é igual ao Ubuntu, se é Fedora é igual ao Fedora. A documentação de instalação do Ubuntu no Docker no Linux por distribuição está aqui , vamos como instalar no Ubuntu

Quem está migrando de Docker Desktop para Docker Engine, temos duas opções

Desinstale o Docker Desktop.
Desativar o Docker Desktop Service nos serviços do Windows. Esta opção permite que você utilize o Docker Desktop, se necessário, para a maioria dos usuários a desinstalação do Docker Desktop é o mais recomendado. Se você escolheu a 2ª opção, excluir o arquivo ~/.docker/config.json e realizar a autenticação com Docker novamente através do comando "docker login"
Se necessitar integrar o Docker com outras IDEs que não sejam o VSCode

O VSCode já se integra com o Docker no WSL desta forma através da extensão Remote WSL ou Remote Container.

É necessário habilitar a conexão ao servidor do Docker via TCP. Vamos aos passos:

Crie o arquivo /etc/docker/daemon.json:sudo echo '{"hosts": ["tcp://0.0.0.0:2375", "unix:///var/run/docker.sock"]}' > /etc/docker/daemon.json
Reinicie o Docker:sudo service docker restart
Após este procedimento, vá na sua IDE e para conectar ao Docker escolha a opção TCP Socket e coloque um URL http://IP-DO-WSL:2375. Seu IP do WSL pode ser encontrado com o comando cat /etc/resolv.conf.

Se não funcionar, reinicie o WSL com o comando wsl --shutdowne inicie o serviço do Docker novamente.

Instale os pré-requisitos:

sudo apt update && sudo apt upgrade
sudo apt remove docker docker-engine docker.io containerd runc
sudo apt-get install \
    apt-transport-https \
    ca-certificates \
    curl \
    gnupg \
    lsb-release
responsabilidade de fontes do Docker na lista do Ubuntu:

curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg
echo \
  "deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu \
  $(lsb_release -cs) stable" | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null
Instale o Docker Engine

sudo apt-get update
sudo apt-get install docker-ce docker-ce-cli containerd.io docker-compose-plugin
Dê permissão para rodar o Docker seu usuário atual:

sudo usermod -aG docker $USER
inicie o serviço do Docker:

sudo service docker start
Este comando acima terá que ser cumprido toda vez que Linux for reinicia. Se o Docker não estiver disponível ao serviço, use esta mensagem de erro ao rodar o comando docker:

Cannot connect to the Docker daemon at unix:///var/run/docker.sock. Is the docker daemon running?
O Docker Compose instalado agora estará na versão 2, para executá-lo em vez de docker-composeusar docker compose.

Erro ao iniciar o Docker no Ubuntu 22.04
Se mesmo ao iniciar o serviço do Docker ocorrer o seguinte erro ou similar:

Cannot connect to the Docker daemon at unix:///var/run/docker.sock. Is the docker daemon running? Rode o comando sudo update-alternatives --config iptablese escolha a opção 1iptables-legacy

Rode novamente o sudo service docker start. Rode algum comando Docker como docker pspara verificar se está funcionando corretamente. Se não mostrar o erro acima, está ok.

Dica para Windows 11
No Windows 11 é possível especificar um comando padrão para ser executado sempre que o WSL for iniciado, isto permite que já coloquemos o serviço do docker para iniciar automaticamente. Edite o arquivo /etc/wsl.conf:

Rode o comando para editar:

sudo vim /etc/wsl.conf

Aperte a letra ie cole o conteúdo:

[boot]
command="service docker start" 
Aperte a tecla :, digite wqpara salvar/sair e aperte enter. Pronto, para ativar o WSL com o comando wsl --shutdownno DOS ou PowerShell para testar. Após abrir o WSL novamente, digite o comando docker pspara avaliar o comando não retornar a mensagem acima:Cannot connect to the Docker daemon at unix:///var/run/docker.sock. Is the docker daemon running?

2 - Instalando o Docker com Docker Desktop
Baixe neste link: https://hub.docker.com/editions/community/docker-ce-desktop-windows e instale o Docker Desktop.

Clique não ícone do Docker perto do relógio -> Settings -> Settings no topo -> Resources -> WSL Integration.

Habilite Enable integration with my default WSL distroe habilite sua versão Linux.

Docker funcionando dentro do WSL 2

Dicas e truques básicos com WSL 2
A performance do WSL 2 está em executar tudo dentro do Linux, por isso evite executar seus projetos com ou sem Docker do caminho /mnt/c, pois você perderá performance.
Para abrir o terminal do WSL basta digitar o nome da distribuição no menu Iniciar ou executar C:\Windows\System32\wsl.exe.
O sistema de arquivos do Windows 10/11 é acessível em /mnt. Monte nenhum WSL2
É possível acessar o sistema de arquivos do Linux pela rede do Windows, \\wsl$não digite o Windows Explorer. Acessando WSL2 no Windows Explorer
É possível acessar uma pasta no Windows Explorer digitando o comando explorer.exe ..
É possível abrir uma pasta ou arquivo com o Visual Studio Code digitando o comando code . ou code meu_arquivo.ext.
Incrivelmente é acessível executáveis ​​do Windows no terminal do Linux possível-os com o .exe corretamente (não que funcionem corretamente). Executando executáveis ​​do Windows no WSL2
É possível executar algumas aplicações gráficas do Linux com WSL 2. Leia este tutorial: https://medium.com/@dianaarnos/aplica%C3%A7%C3%B5es-gr%C3%A1ficas-no-wsl2-e0a481e9768c .
Execute o comando wsl -l -vcom o PowerShell para ver como versões do Linux instaladas e seu status atual(parado ou rodando). Verificando distribuições instaladas do Linux no WSL 2
Execute o comando executar o comando wsl --shutdowndesativar todas as distribuições no momento da distribuição do PowerShell (Executar o comando, as que o Docker também iniciará as partidas e o Docker Desktop mostrará com o PowerShell uma notificação ao lado distribuições do relógio) se você não aceitará que iniciar o Docker novamente com o ícone perto do relógio do Windows).
Execute com o PowerShell o comando wsl --t <distribution name>para ativar somente uma distribuição Linux específica.
Se verificar que o WSL 2 está consumindo muitos recursos da máquina, execute os comandos dentro do terminal WSL 2 para a memória RAM a seguir:
echo 1 | sudo tee /proc/sys/vm/drop_caches
Acrescente export DOCKER_BUILDKIT=1no final do arquivo .profile do seu usuário do Linux para ganhar mais desempenho ao realizar builds com Docker. Execute o comando source ~/.profilepara carregar esta variável de ambiente no ambiente do seu WSL 2.
A inicialização do Caso do(podese-se), descrita na seção de início de serviços automatizados, permite também a utilização do docker serviços, enquanto não é inculcada no wsl, você pode configurar uma tarefa para executar comandos no wsl. veja o tutorial a seguir, WSL 2: Run Ubuntu Services on Windows 10 Startup , substituindo o conteúdo do arquivo /etc/init-wsl, por um dos exemplos abaixo:
Exemplo de inicialização do serviço do docker

  #!/bin/sh
  #Mensagem de Inicialização dos seviços
  echo initializing services
  #Inicializa o serviço do docker
  service docker start
Exemplo gerando um log na Área de trabalho

  #!/bin/sh
  #Grava a data/hora de início da execução no log
  date +%d/%m/%Y%t%H:%M:%S >> /mnt/c/Users/seu-usuario-do-windows/Desktop/wsl_start.log
  #Grava mensagem de Inicialização dos seviços no log
  echo initializing services >> /mnt/c/Users/seu-usuario-do-windows/Desktop/wsl_start.log
  #Inicializa o serviço do docker e grava o resultado do comando no log
  service docker start >> /mnt/c/Users/seu-usuario-do-windows/Desktop/wsl_start.log
  #Verifica o status do serviço do docker e grava o resultado do comando no log
  service docker status >> /mnt/c/Users/seu-usuario-do-windows/Desktop/wsl_start.log
manualmente, caso reinicie o WSL, será necessário reiniciar os serviços manualmente, ou executar o init-wsl manualmente.
No Windows 11 é possível iniciar o Docker automaticamente, veja a seção: Dica para Windows 11
Dúvidas
O WSL 2 funciona junto com outras máquinas virtuais como VirtualBox ou VMWare ? Siga a referência



######### LARAVEL COM JETSTREAM E FILAMENT


composer create-project laravel/laravel example-app

cd example-app

composer require laravel/jetstream

php artisan jetstream:install livewire



npm install

npm run dev

<!-- npm run buil -->

php artisan migrate


php artisan serve

cria usuário e senha

loga 

php artisan vendor:publish --tag=jeststream-view


### PARA CADASTRAR USUÁRIOS NO BANCO AO EXECUTAR php artisan migrate:fresh --seed BASTA INFORMAR OS DADOS DO USUÁRIO NO DatabaseSeeder.php
DatabaseSeeder.php

<?php

namespace Database\Seeders;

use App\Models\User;
use Illuminate\Database\Seeder;

class DatabaseSeeder extends Seeder
{
    /**
     * Seed the application's database.
     *
     * @return void
     */
    public function run()
    {

        User::factory()->create([
            'name' => 'Alberto Gomes da Silva',
            'email' => 'albertogomesdasilva@gmail.com',
            'password' => bcrypt('12345678')
        ]);
        
        User::factory(10)->create();   // CRIA 10 EMAILS PARA LOGIN DE USUÁRIOS ALEATORIAMENTE COM A SENHA 'password'
    }
}


<?php

namespace Database\Seeders;

// use Illuminate\Database\Console\Seeds\WithoutModelEvents;
use App\Models\User;                                ============> NÃO ESQUECER DE IMPORTAR A CLASSE User
use Illuminate\Database\Seeder;

class DatabaseSeeder extends Seeder
{
    /**
     * Seed the application's database.
     */
    public function run(): void
    {
        
        User::factory()->create([
            'name' => 'Alberto Gomes da Silva',
            'email' => 'albertogomesdasilva@gmail.com',
            'password' => bcrypt('12345678')
        ]);
        
        \App\Models\User::factory(10)->create();
    }
}



 
 # UserFactory.php
<?php

namespace Database\Factories;

use App\Models\Team;
use App\Models\User;
use Illuminate\Database\Eloquent\Factories\Factory;
use Illuminate\Support\Str;
use Laravel\Jetstream\Features;

class UserFactory extends Factory
{
    /**
     * The name of the factory's corresponding model.
     *
     * @var string
     */
    protected $model = User::class;

    /**
     * Define the model's default state.
     *
     * @return array<string, mixed>
     */
    public function definition(): array
    {
        return [
            'name' => $this->faker->name(),
            'email' => $this->faker->unique()->safeEmail(),
            'email_verified_at' => now(),
            'password' => '$2y$10$92IXUNpkjO0rOQ5byMi.Ye4oKoEa3Ro9llC/.og/at2.uheWG/igi', // password
            'two_factor_secret' => null,
            'two_factor_recovery_codes' => null,
            'remember_token' => Str::random(10),
            'profile_photo_path' => null,
            'current_team_id' => null,
        ];
    }

    /**
     * Indicate that the model's email address should be unverified.
     */
    public function unverified(): static
    {
        return $this->state(function (array $attributes) {
            return [
                'email_verified_at' => null,
            ];
        });
    }

    /**
     * Indicate that the user should have a personal team.
     */
    public function withPersonalTeam(callable $callback = null): static
    {
        if (! Features::hasTeamFeatures()) {
            return $this->state([]);
        }

        return $this->has(
            Team::factory()
                ->state(fn (array $attributes, User $user) => [
                    'name' => $user->name.'\'s Team',
                    'user_id' => $user->id,
                    'personal_team' => true,
                ])
                ->when(is_callable($callback), $callback),
            'ownedTeams'
        );
    }
}

### FILAMENT.COM
composer require filament/filament:"^2.0"


# composer.json linha 43

"post-update-cmd": [
    // ...
    "@php artisan filament:upgrade"
],

# Publicando o config/filament.php
php artisan vendor:publish --tag=filament-config

# filament.php
linha 172: 'dark_mode': true,

209: is_collapsible_on_desktop: => true,

213: 'width' => 'full',

# substituimos a página inicial welcome.blade.php e a pasta de assets dentro da pasta public

# EXIBINDO AS PÁGINAS DO FILAMENT ADMIN
php artisan vendor:publish

Tag: filament-translations .............................. 28  
  Tag: filament-views ..................................... 29  
  Tag: flare-config ....................................... 30  
  Tag: forms-config ....................................... 31  
  Tag: forms-stubs ........................................ 32  
  Tag: forms-translations ................................. 33  
  Tag: forms-views ........................................ 34  
  Tag: fortify-config ..................................... 35  
  Tag: fortify-migrations ................................. 36  
  Tag: fortify-support .................................... 37  
  Tag: ignition-config .................................... 38  
  Tag: jetstream-config ................................... 39  
  Tag: jetstream-inertia-auth-pages ....................... 40  
  Tag: jetstream-migrations ............................... 41  
  Tag: jetstream-routes ................................... 42  
  Tag: jetstream-team-migrations .......................... 43  
  Tag: laravel-errors ..................................... 44  
  Tag: laravel-mail ....................................... 45  
  Tag: laravel-notifications .............................. 46  
  Tag: laravel-pagination ................................. 47  
  Tag: livewire ........................................... 48  
  Tag: sail ............................................... 56  
  Tag: sail-bin ........................................... 57  
  Tag: sail-docker ........................................ 58  
  Tag: sanctum-config ..................................... 59  
  Tag: sanctum-migrations ................................. 60  
  Tag: tables-config ...................................... 61  
  Tag: tables-stubs ....................................... 62  
  Tag: tables-translations ................................ 63  
  Tag: tables-views ....................................... 64  
❯ 29 ===========> filament.views 

# insere a logo do Dashboard
resources\views\vendor\filament\components\header\index.blade.php 
@props([
    'actions' => null,
    'heading',
    'subheading' => null
])

<header {{ $attributes->class(['filament-header space-y-2 items-start justify-between sm:flex sm:space-y-0 sm:space-x-4  sm:rtl:space-x-reverse sm:py-4']) }}>
    <div>
        <x-filament::header.heading>
            <div class="flex items-center">
                <div>  <img class="w-20 mr-2" src="assets/img/real-invest-logo.png" alt="logo"> </div>
                 <div>
                     {{ $heading }}
                 </div>   
                </div>
                
            </div>
        </x-filament::header.heading>

        @if ($subheading)
            <x-filament::header.subheading class="mt-1">
                {{ $subheading }}
            </x-filament::header.subheading>
        @endif
    </div>


    <x-filament::pages.actions :actions="$actions" class="shrink-0" />
</header>

# https://tailwindcss.com/docs/width


### aparência e themes filament para mudar a aparência do filament
https://filament.com/docs    -> Building themes

npm install tailwindcss @tailwindcss/forms @tailwindcss/typography autoprefixer tippy.js --save-dev

# tailwind.config.js  -> fica assim
import defaultTheme from 'tailwindcss/defaultTheme';
import forms from '@tailwindcss/forms';
import typography from '@tailwindcss/typography';

const colors = require('tailwindcss/colors')     // INSERIDA ESTA LINHA 

/** @type {import('tailwindcss').Config} */
export default {
    content: [
        './vendor/laravel/framework/src/Illuminate/Pagination/resources/views/*.blade.php',
        './vendor/laravel/jetstream/**/*.blade.php',
        './storage/framework/views/*.php',
        './resources/views/**/*.blade.php',

        './vendor/filament/**/*.blade.php',   //INSERIDA ESTA LINHA 


    ],

    theme: {
        extend: {
            fontFamily: {
                sans: ['Figtree', ...defaultTheme.fontFamily.sans],
            },
//  INSERIDAS ESTAS LINHAS
            colors: { 
                danger: colors.rose,
                primary: colors.blue,
                success: colors.green,
                warning: colors.yellow,
            }, 
// FIM
        },
    },

    plugins: [forms, typography],
};

# vite.config.js -> fica assim

import { defineConfig } from 'vite';
import laravel, { refreshPaths } from 'laravel-vite-plugin';

export default defineConfig({
    plugins: [
        laravel({
            input: [
                'resources/css/app.css',

                'resources/css/filament.css',     // INSERIDA ESTA LINHA AQUI
                
                'resources/js/app.js',
            ],
            refresh: [
                ...refreshPaths,
                'app/Http/Livewire/**',
            ],
        }),
    ],
});

# CRIA UM ARQUIVO NA PASTA resource/css/filament.css
# filament.css

@import '../../vendor/filament/filament/resources/css/app.css';   // Somente essa linha no filament.css

 
# App/Providers/AppServiceProvider.php
<?php

namespace App\Providers;

use Illuminate\Support\ServiceProvider;

use Filament\Facades\Filament;      // inserida aqui
use Illuminate\Foundation\Vite;    //e inserido aqui 

class AppServiceProvider extends ServiceProvider
{
    /**
     * Register any application services.
     */
    public function register(): void
    {
        //
    }

    /**
     * Bootstrap any application services.
     */
    public function boot(): void
    {
         
Filament::serving(function () {
    // Using Vite
    Filament::registerViteTheme('resources/css/filament.css');
});
    }
}

#### O DARK MODE DEIXA DE FUNCIONAR

* *ailwind.config.js

import defaultTheme from 'tailwindcss/defaultTheme';
import forms from '@tailwindcss/forms';
import typography from '@tailwindcss/typography';

const colors = require('tailwindcss/colors')     // INSERIDA ESTA LINHA 

/** @type {import('tailwindcss').Config} */
export default {
    darkMode: 'class',              ========> INSERE SOMENTE ESSA LINHA AQUI QUE O DARK MODE VOLTA A FUNCIONAR
    content: [


### AJUSTAR AS CORES AZUIS COMO O AZUL DA LOGO
 
 tailwind.config.css
 import defaultTheme from 'tailwindcss/defaultTheme';
import forms from '@tailwindcss/forms';
import typography from '@tailwindcss/typography';

const colors = require('tailwindcss/colors')     // INSERIDA ESTA LINHA 

/** @type {import('tailwindcss').Config} */
export default {
    darkMode: 'class',
    content: [
        './vendor/laravel/framework/src/Illuminate/Pagination/resources/views/*.blade.php',
        './vendor/laravel/jetstream/**/*.blade.php',
        './storage/framework/views/*.php',
        './resources/views/**/*.blade.php',

        './vendor/filament/**/*.blade.php',   //INSERIDA ESTA LINHA 


    ],

    theme: {
        extend: {
            fontFamily: {
                sans: ['Figtree', ...defaultTheme.fontFamily.sans],
            },
//  INSERIDAS ESTAS LINHAS
            colors: { 
                danger: colors.rose,
                // primary: colors.blue,
                //INICIO DA CUSTOMIZAÇÃO
                primary: {
                    50: '#eff6ff',
                    100: '#dbeafe',
                    200: '#bfdbfe',
                    300: '#93c5fd',
                    400: '#60a5fa',
                    500: '#1e40af', // same as blue-800
                    600: '#2563eb',
                    700: '#1d4ed8',
                    800: '#1e40af',
                    900: '#1e3a8a',
                    
                        },

                //FIM
                success: colors.green,
                warning: colors.yellow,
            }, 
// FIM
        },
    },

    plugins: [forms, typography],
};


### MODEL / MIGRATION

php artisan make:model Property -mfc


php artisan make:model Property -mfc (CRIA A MODEL, A FACTORY E CONTROLLER)

# CONFIGURANDO PRIMEIRO A MODEL com SoftDeletes que será usada também da migration:
Property.php
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\SoftDeletes;
use Illuminate\Database\Eloquent\Factories\HasFactory;

class Property extends Model
{
    use HasFactory, SoftDeletes;

    protected $guarded = ['id'];
}


# CONFIGURANDO A MIGRATION
2023_06_05_212921_create_properties_table.php

<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create('properties', function (Blueprint $table) {
            $table->id();

            $table->string('title');
            $table->text('description');
            $table->string('country');
            $table->string('city');
            $table->string('address');
            $table->unsignedInteger('price');
            $table->unsignedInteger('sqm');
            $table->unsignedSmallInteger('bedrooms')->nullable();
            $table->unsignedSmallInteger('bathrooms')->nullable();
            $table->unsignedSmallInteger('garages')->nullable();
            $table->boolean('slider')->default(false);
            $table->boolean('visible')->default(true);
            $table->date('start_date')->default('2022-01-01');
            $table->date('end_date')->default('2023-01-01');

            $table->softDeletes();


            $table->timestamps();
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists('properties');
    }
};

# php artisan migrate

# CRIANDO O FILAMENT RESOURCE
* preencher a factory
database\factories\PropertyFactory.php

<?php

namespace Database\Factories;

use Illuminate\Database\Eloquent\Factories\Factory;

/**
 * @extends \Illuminate\Database\Eloquent\Factories\Factory<\App\Models\Property>
 */
class PropertyFactory extends Factory
{
    /**
     * Define the model's default state.
     *
     * @return array<string, mixed>
     */
    public function definition(): array
    {
        return [
            'title' => $this->faker->realTextBetween(25,45),
            'description' => $this->faker->realTextBetween(100,150),
            'country' => $this->faker->country(),
            'city' => $this->faker->city(),
            'address' => $this->faker->address(),
            'price' => rand(500, 5000)*1000,
            'sqm' => rand(150, 1500),
            'bedrooms' => rand(3, 10),
            'bathrooms' => rand(3, 6),
            'garages' => rand(1, 5),
        ];
    }
}

* preenchendo a database\seeders\DatabaseSeeder.php
<?php

namespace Database\Seeders;

// use Illuminate\Database\Console\Seeds\WithoutModelEvents;
use App\Models\User;
use App\Models\Property;
use Illuminate\Database\Seeder;

class DatabaseSeeder extends Seeder
{
    /**
     * Seed the application's database.
     */
    public function run(): void
    {
        
        User::factory()->create([
            'name' => 'Alberto Gomes da Silva',
            'email' => 'albertogomesdasilva@gmail.com',
            'password' => bcrypt('12345678')
        ]);
        
        \App\Models\User::factory(10)->create();
        
        Property::factory(50)->create();
    }
}

### REFAZENDO O BANCO DE DADOS, GERA O USUÁRIO albertogomesdasilva@gmail.com e Preenche 50 registros na tabela property

* importante alterar 'locale' e 'faker_locale' => 'pt_BR', para gerar registros faker em português. config\app.php

php artisan migrate:fresh --seed

### INSTALANDO O PACOTE DBAL PARA CRIAR  RESOURCES DO FILAMENT AUTOMATICAMENTE
composer require doctrine/dbal

### criando os resources com softdeletes que usamos na migration e na model:
php artisan make:filament-resource Property --generate --soft-deletes --view

* MODEL Despesa.php
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\SoftDeletes;
use Illuminate\Database\Eloquent\Factories\HasFactory;

class Despesa extends Model
{
    use HasFactory, SoftDeletes;

    protected $guarded = ['id'];
}

* MIGRATION 2023_06_05_223326_create_despesas_table.php
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create('despesas', function (Blueprint $table) {
            $table->id();

            $table->string('despesas');
            $table->float('valor')->nullable();
            $table->date('vencimento')->nullable();
            $table->boolean('status')->nullable();
            $table->date('pagamento')->nullable();
            $table->string('obs')->nullable();

            $table->softDeletes();

            
            $table->timestamps();
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists('despesas');
    }
};

* DespesaFactory.php
<?php

namespace Database\Factories;

use Illuminate\Database\Eloquent\Factories\Factory;

/**
 * @extends \Illuminate\Database\Eloquent\Factories\Factory<\App\Models\Despesa>
 */
class DespesaFactory extends Factory
{
    /**
     * Define the model's default state.
     *
     * @return array<string, mixed>
     */
    public function definition(): array
    {
        return [
            'despesas' => $this->faker->realTextBetween(25,45),
            'valor' => fake()->randomfloat(2, 10, 1000),
            'vencimento' => fake()->date(),
            'status' => fake()->boolean(),
            'pagamento' => fake()->date(),
            'obs' => fake()->sentence(5),
        ];
    }
}


* DatabaseSeeder.php

<?php

namespace Database\Seeders;

// use Illuminate\Database\Console\Seeds\WithoutModelEvents;
use App\Models\User;
use App\Models\Despesa;
use App\Models\Property;
use Illuminate\Database\Seeder;

class DatabaseSeeder extends Seeder
{
    /**
     * Seed the application's database.
     */
    public function run(): void
    {
        
        User::factory()->create([
            'name' => 'Alberto Gomes da Silva',
            'email' => 'albertogomesdasilva@gmail.com',
            'password' => bcrypt('12345678')
        ]);
        
        \App\Models\User::factory(10)->create();
        
        Despesa::factory(10)->create();
        
        Property::factory(50)->create();
    }
}


### php artisan migrate:fresh --seed 

### $ php artisan make:filament-resource Despesa --generate --soft-deletes --view

localhost:8000/admin

#### CONTROLE DE ACESSO #####
### laravel new projeto

### composer require filament/filament:"^2.0"

### adicionar as linhas abaixo ao composer.json

"post-update-cmd": [
    // ...
    "@php artisan filament:upgrade" // somente esta linha
], 

### roda na linha de comando para publicação
php artisan vendor:publish --tag=filament-config

### Configura o .env

### Roda as migrate

### php artisan make:filament-user 

### campo adicionado à migrate create_user_....

  $table->boolean('is_admin')->default(0);   // este campo foi acrescentado

### adicionar o campo is_admin também na Model User
 protected $fillable = [
        'name',
        'email',
        'password',
        'is_admin'
    ];

### UserFactory:
  public function definition(): array
    {
        return [
            'name' => fake()->name(),
            'email' => fake()->unique()->safeEmail(),
            'email_verified_at' => now(),
            'password' => '$2y$10$92IXUNpkjO0rOQ5byMi.Ye4oKoEa3Ro9llC/.og/at2.uheWG/igi', // password
            'remember_token' => Str::random(10),
            'is_admin' => fake()->boolean(), // ACRESCENTA AQUI TAMBÉM
        ];
    }

### DatabaseSeeder.php

    public function run(): void
    {
         \App\Models\User::factory(10)->create();    // Desmarca essa opção

        // \App\Models\User::factory()->create([
        //     'name' => 'Test User',
        //     'email' => 'test@example.com',
        // ]);
    }

### php artisan migrate --seed

### php artisan serve

### Para gerar formulários e tabelas automaticamente baseado nos campos da tabela
composer require doctrine/dbal --dev

php artisan make:filament-resource User --generate --simple // Criar o crud numa pagina só - para estrutura pequena


### Criando um usuário para o filament: 
php artisan make:filament-user

### Criando vários usuários
php artisan tinker
User::factory()->count(10)->create()

### Filters
 //importa em App\filament\UserResource ou no Resource específico  nessas linhas do arquivo 72, 73, 74 mais ou menos
 use Filament\Tables\Filters\TernaryFilter; 
   ->filters([
                TernaryFilter::make('is_admin'),
            ])


###### Criando uma nova tabela

php artisan make:model Despesas -m -f  // -m migrate   -f factory

migration:

 public function up(): void
    {
        Schema::create('despesas', function (Blueprint $table) {
            $table->id();
            $table->string('despesa');
            $table->float('valor');
            $table->date('vencimento');
            $table->boolean('is_pg');
            $table->date('pagamento');
            $table->timestamps();
        });
    }


despesasfactory:
 public function definition(): array
    {
        return [
            'despesa' => fake()->sentense(2),
            'valor'   => fake()->float(3, 2),
            'vencimento'=> fake()->date('d/m/Y'),
            'is_pg' => fake()->boolean(),
            'pagamento'=> fake()->date('d/m/Y'),
            

        ];

DatabaseSeeder.php -- 

    public function run(): void
    {
       //  \App\Models\User::factory(50)->create();    // Marca essa opção que já foi usada
         Despesas::factory(5)->create();   

        // \App\Models\User::factory()->create([
        //     'name' => 'Test User',
        //     'email' => 'test@example.com',
        // ]);
    }
}

### Executa as migrations com Facker()
 php artisan migrate --seed 
 php artisan make:filament-resource Despesas --generate --simple

#### CONTROLE DE ACESSO ##################
1- create laravel project
# composer create-project laravel/laravel --prefer-dist l9-bootstrap
    or
    - laravel new l9-bootstrap

    Get inside l9-bootstrap.

    cd l9-bootstrap
  
2-Install Laravel/UI
    Laravel UI is an official library that offers selective or predefined UI components. 
    The laravel/ui package comes with the login and registration scaffolding for 
    React, Vue, jQuery, and Bootstrap layouts.

    Run the command to install Laravel/UI.
    
# composer require laravel/ui

3- Install Bootstrap in Laravel
    We have successfully installed a laravel/ui package using Composer, now in this step, 
    we will understand how to easily install the Bootstrap lastest CSS Framework using the following command.

    Run command to install Bootstrap in Laravel project

# php artisan ui bootstrap

4- Install Bootstrap Auth Scaffolding
    Execute the following command to Install the auth scaffoldings with Bootstrap
    
#  php artisan ui bootstrap --auth

    We have successfully installed the bootstrap, and you can make sure by going to resource/js/bootstrap.js. 
    You will see that popper.js and jQuery have been added to the bootstrap’s JavaScript file.
    
5- Install Bootstrap Packages
    Before you install Bootstrap Package, you need to check have installed Node js or not.
    - Run this command in command prompt to check
      # for node
      node -v
      # for npm
      npm -v
    - Install the bootstrap package
#     npm install
 6- Compile Assets
    As we can see, resources/sass folder _variables.scss and app.scss files have added along 
    with sass variables and fonts.
  
    @import url('https://fonts.googleapis.com/css?family=Nunito');
    // Variables
    @import 'variables';
    // Bootstrap
    @import '~bootstrap/scss/bootstrap';
 
 Now, we have to run the below command for asset compilation.
 
    # for development
    npm run dev

    # for production
    npm run production
 
    The above command compiles CSS and JavaScript files from resources/js and resources/sass folder to the public folder.


    - Automate SASS and JS Changes

    If you are lazy and don’t want to run the npm run dev command every time you make changes in SASS and JS file,
    you should use the following command.

       npm run watch


    It keeps an eye on your files and compiles the code automatically if detects any change made in SASS and JS files.


 
 7- Using Bootstrap in Laravel Blade Template

Now, sass files are complied to single CSS file inside the public folder, and we can define the js and 
CSS path and use the Bootstrap js and CSS in the Laravel blade template.
 <head> 
      <script src="{{ asset('js/app.js') }}" defer></script>
      <link href="{{ asset('css/app.css') }}" rel="stylesheet">
 </head>
 <body>
 <div class="card">
        <div class="card-body">

            <div class="mb-3">
                <label for="exampleFormControlInput1" class="form-label">Email address</label>
                <input type="email" class="form-control" id="exampleFormControlInput1" placeholder="name@example.com">
            </div>
            <div class="mb-3">
                <label for="exampleFormControlTextarea1" class="form-label">Example textarea</label>
                <textarea class="form-control" id="exampleFormControlTextarea1" rows="3"></textarea>
            </div>
        </div>
    </div>
 </body>


 <!-- /****  FILAMENT ************************ */ -->

 ### laravel new projeto

### composer require filament/filament:"^2.0"

### adicionar as linhas abaixo ao composer.json

"post-update-cmd": [
    // ...
    "@php artisan filament:upgrade" // somente esta linha
], 

### roda na linha de comando para publicação
php artisan vendor:publish --tag=filament-config

### Configura o .env

### Roda as migrate

Criar um usuário se não houver:
### php artisan make:filament-user

### campo adicionado à migrate create_user_....

  $table->boolean('is_admin')->default(0);   // este campo foi acrescentado

### adicionar o campo is_admin também na Model User
 protected $fillable = [
        'name',
        'email',
        'password',
        'is_admin'
    ];

### UserFactory:
  public function definition(): array
    {
        return [
            'name' => fake()->name(),
            'email' => fake()->unique()->safeEmail(),
            'email_verified_at' => now(),
            'password' => '$2y$10$92IXUNpkjO0rOQ5byMi.Ye4oKoEa3Ro9llC/.og/at2.uheWG/igi', // password
            'remember_token' => Str::random(10),
            'is_admin' => fake()->boolean(), // ACRESCENTA AQUI TAMBÉM
        ];
    }

### DatabaseSeeder.php

    public function run(): void
    {
         \App\Models\User::factory(10)->create();    // Desmarca essa opção

        // \App\Models\User::factory()->create([
        //     'name' => 'Test User',
        //     'email' => 'test@example.com',
        // ]);
    }

### php artisan migrate --seed

### php artisan serve

### Para gerar formulários e tabelas automaticamente baseado nos campos da tabela
composer require doctrine/dbal --dev

php artisan make:filament-resource User -- generate --simple  // Criar o crud numa pagina só - para estrutura pequena

php artisan make:filament-resource User --generate


### Criando um usuário para o filament: 

php artisan make:filament-user
php artisan make:filament-user
### Criando vários usuários
php artisan tinker
User::factory()->count(10)->create()

* (obs...): Quando o filament não faz o hash da senha de um novo usuário no banco de dados:
no arquivo...
app\Filament\Resources\UserResource\Pages\CreateUser.php
insere esta função:


<?php

namespace App\Filament\Resources\UserResource\Pages;

use App\Filament\Resources\UserResource;
use Filament\Pages\Actions;
use Filament\Resources\Pages\CreateRecord;

class CreateUser extends CreateRecord
{
    protected static string $resource = UserResource::class;

    protected function mutateFormDataBeforeCreate(array $data): array
{
    $data['user_id'] = auth()->id();
 
    return $data;
}
    
}

* OBS: SE FOR EM MODAL

use Filament\Pages\Actions\CreateAction;
 
CreateAction::make()
    ->mutateFormDataUsing(function (array $data): array {
        <!-- dd($data); -->

        <!-- $data['user_id'] = auth()->id(); -->

        $data['password'] = Hash::make($data['password']);

        <!-- dd($data); -->
 
        return $data;
    })

* OBS2: EM CASO DE PROBLEMAS NA CRIAÇÃO DE HASH NA CRIAÇÃO DE USUÁRIO E EDIÇÃO:
o campo de senha somente será obrigatório no create:

ALTERA O FORM DE UserResource.php: https://filamentphp.com/tricks/password-form-fields (último bloco no fim da página)

use Filament\Forms\Components\TextInput;
use Filament\Pages\Page;
use Illuminate\Support\Facades\Hash;

  Forms\Components\TextInput::make('password')
        ->label('Senha')
        ->password()
        ->dehydrateStateUsing(fn ($state) => Hash::make($state))
        ->dehydrated(fn ($state) => filled($state))
        ->required(fn (string $context): bool => $context === 'create')


### REGRAS DE PERMISSÕES com laravel permission https://spatie.be/docs/laravel-permission/v5/introduction

composer require spatie/laravel-permission

# publicando:
php artisan vendor:publish --provider="Spatie\Permission\PermissionServiceProvider"

 php artisan optimize:clear

# Rodar o php artisan migrate para criar novas tabelas de permissões: Model_has_permissions, model_has_holes, permissions, role_has_permissions e roles
 php artisan migrate

# Cria um model chamado Role para acesso a tabela criada:
 php artisan make:model Role

 # NA MODEL Role extender a model de ModelsRole (do laravel permission):
 <?php

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;

<!-- (ESSA LINHA NÃO IMPORTA AUTOMATICAMENTE AS VEZES) -->
use Spatie\Permission\Models\Role as ModelsRole; 

class Role extends ModelsRole     // ALTERA ESSA LINHA
{
    use HasFactory;
}


# agora cria os formulários e tabelas: (NESTE CASO VAMOS USAR O SISTEMA DE MODAL --simple)

php artisan make:filament-resource Role --generate --simple

 # Criando o Resource de Role:
 php artisan make:filament-resource Role --generate

## VAMOS ELIMINAR O CAMPO GUARD DO FORM E TABLE em RoleResource.php

  // Forms\Components\TextInput::make('guard_name')
                //     ->required()
                //     ->maxLength(255),

# em table remove guard_name e updated_at
    // Tables\Columns\TextColumn::make('guard_name'),

      // Tables\Columns\TextColumn::make('updated_at')
                    // ->dateTime(),


### FAZER MODEL Permission.php - extender de ModelsPermission e criar o resource:
php artisan make:model Permission

* ALTERAR NA MODEL: Permission.php  
use Spatie\Permission\Models\Permission as ModelsPermission; 


class Permission extends ModelsPermission

* CRIAR O RESOUCE
php artisan make:filament-resource Permission --generate --simple


### FAZENDO O RELACINAMENTO ENTRE USUÁRIOS E PERMISSÕES
https://filamentphp.com/docs/2.x/admin/resources/getting-started#belongsto

* UseResource.php

use Filament\Forms\Components\Select;
 
               Forms\Components\TextInput::make('password')
                    ->label('Senha')
                    ->password()
                    ->dehydrateStateUsing(fn ($state) => Hash::make($state))
                    ->dehydrated(fn ($state) => filled($state))
                    ->required(fn (string $context): bool => $context === 'create'),
 
## ACRESCENTA ESSE:
                Forms\Components\Select::make('roles')
                    ->multiple()
                    ->relationship('roles', 'name')
            ]);
    }

### obs -> PARA USAR ADICIONA HasRoles na Model User.php

use HasApiTokens, HasFactory, Notifiable, HasRoles;

fica assim: 

<?php

namespace App\Models;

// use Illuminate\Contracts\Auth\MustVerifyEmail;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Foundation\Auth\User as Authenticatable;
use Illuminate\Notifications\Notifiable;
use Laravel\Sanctum\HasApiTokens;

use Spatie\Permission\Traits\HasRoles;


class User extends Authenticatable
{
    use HasApiTokens, HasFactory, Notifiable, HasRoles;

    /**
     * The attributes that are mass assignable.
     *
     * @var array<int, string>
     */
    protected $fillable = [
        'name',
        'email',
        'password',
    ];

    /**
     * The attributes that should be hidden for serialization.
     *
     * @var array<int, string>
     */


    protected $hidden = [
        'password',
        'remember_token',
    ];

    /**
     * The attributes that should be cast.
     *
     * @var array<string, string>
     */
    protected $casts = [
        'email_verified_at' => 'datetime',
        'password' => 'hashed',
    ];
}

 * até aqui exibe as roles no momento de cadastro de usuário mais tem que relacionar:
 Na Model: User.php 
acrescenta na classe: implements FilamentUser

 na linha 13 fica assim:
<?php

namespace App\Models;

// use Illuminate\Contracts\Auth\MustVerifyEmail;
use Laravel\Sanctum\HasApiTokens;
use Spatie\Permission\Traits\HasRoles;
use Illuminate\Notifications\Notifiable;
use Filament\Models\Contracts\FilamentUser;    // ---> AQUI IMPORTA A CLASSE FILAMENT USER
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Foundation\Auth\User as Authenticatable;


class User extends Authenticatable implements FilamentUser    //---> FICA ASSIM
{
    use HasApiTokens, HasFactory, Notifiable, HasRoles;

E NO FINAL Da Model User.php que verifica se o meu usuário tem uma Role chamada Admin.

        public function canAccessFilament(): bool
        {
            return $this->hasRole('Admin');
        }
}


### ########################
em PermissionResource.php

   Forms\Components\Select::make('roles')
                    ->multiple()
                    ->relationship('roles', 'name')
                    ->preload()


e em RoleResource.php
   ## ACRESCENTA ESSE:
                 Forms\Components\Select::make('permissions')
                 ->multiple()
                 ->relationship('permissions', 'name')
                 ->preload() 



# Na documentação pede em Best Pratics:

usuários possuem regras e regras possuem permissões, o app sempre tem que checar permissions e não regras.
para testar em Permissions criamos uma nova permissão: access_admin que pertence a admin e manager. 

# AGORA NO FINAL DO ARQUIVO DE MODEL User.php alteramos...

 {
        // return $this->hasRole('Admin');
        // return $this->hasRole( ['Admin', 'Manage']);
        return $this->hasPermissionTo('access_admin');
    }

* VAMOS TESTAR COM UM USUÁRIO gerente que tem Roles Manage cadastrada e tudo ok... se acessar com usuario@gmail.com que não tem regras ou permissão não loga. (403 FORBIDDEN) -> só loga no Laravel normal.

### Para alterar os nomes de colunas e formulários adiciona: ->label('nome')...

### CRIE AS PERMISSIONS (user_read, user_create, user_....)

### Polices
Criando as Polices
php artisan make:policy UserPolicy --model=User

\App\Pocies

# Registrando as policies
Abra App\Providers\AuthServiceProvider.php

<?php

namespace App\Providers;

// use Illuminate\Support\Facades\Gate;
use App\Policies\UserPolicy;  ======> aqui importa a classe
use Illuminate\Foundation\Support\Providers\AuthServiceProvider as ServiceProvider;

class AuthServiceProvider extends ServiceProvider
{
    /**
     * The model to policy mappings for the application.
     *
     * @var array<class-string, class-string>
     */
    protected $policies = [
        User::class => UserPolicy::class,
    ];

    /**
         * Register any authentication / authorization services.
     */
    public function boot(): void
    {
        //
    }
}

Em App\Policies\UserPolicy.php

<?php

namespace App\Policies;

use App\Models\User;
use Illuminate\Auth\Access\Response;

class UserPolicy
{
    /**
     * Determine whether the user can view any models.
     */
    public function viewAny(User $user): bool
    {
        return $user->hasPermissionTo('user_read');
    }

    /**
     * Determine whether the user can view the model.
     */
    public function view(User $user, User $model): bool
    {
        return $user->hasPermissionTo('user_read');
    }

    /**
     * Determine whether the user can create models.
     */
    public function create(User $user): bool
    {
        return $user->hasPermissionTo('user_create');
    }

    /**
     * Determine whether the user can update the model.
     */
    public function update(User $user, User $model): bool
    {
        return $user->hasPermissionTo('user_update');
    }

    /**
     * Determine whether the user can delete the model.
     */
    public function delete(User $user, User $model): bool
    {
        return $user->hasPermissionTo('user_delete');
    }

    /**
     * Determine whether the user can restore the model.
     */
    public function restore(User $user, User $model): bool
    {
        //
    }

    /**
     * Determine whether the user can permanently delete the model.
     */
    public function forceDelete(User $user, User $model): bool
    {
        //
    }
}

# CRIAMOS A ROLE USER COM ACESSO APENAS AO "admin", com isso o usuario@gmail.com que acessa o painel mais não tem acesso aos item de usuários do menu.

### CRIAREMOS OS POLICIES DE ROLE E PERMISSIONS AGORA
php artisan make:policy PermissionPolicy --model=Permission 
php artisan make:policy RolePolicy --model=Role 


Teremos em \App\Policies\PermissionPolicy.php RolePolicy.php e UserPolicy.php que foi criado antes...
PermissionPolicy.php
<?php

namespace App\Policies;

use App\Models\Permission;
use App\Models\User;
use Illuminate\Auth\Access\Response;

class PermissionPolicy
{
    /**
     * Determine whether the user can view any models.
     */
    public function viewAny(User $user): bool
    {
        return $user->hasPermissionTo('permission_read');
    }

    /**
     * Determine whether the user can view the model.
     */
    public function view(User $user, Permission $permission): bool
    {
        return $user->hasPermissionTo('permission_read');
    }

    /**
     * Determine whether the user can create models.
     */
    public function create(User $user): bool
    {
        return $user->hasPermissionTo('permission_create');
    }

    /**
     * Determine whether the user can update the model.
     */
    public function update(User $user, Permission $permission): bool
    {
        return $user->hasPermissionTo('permission_update');
    }

    /**
     * Determine whether the user can delete the model.
     */
    public function delete(User $user, Permission $permission): bool
    {
        return $user->hasPermissionTo('permission_delete');
    }

    /**
     * Determine whether the user can restore the model.
     */
    public function restore(User $user, Permission $permission): bool
    {
        //
    }

    /**
     * Determine whether the user can permanently delete the model.
     */
    public function forceDelete(User $user, Permission $permission): bool
    {
        //
    }
}

RolePolicy.php
<?php

namespace App\Policies;

use App\Models\Role;
use App\Models\User;
use Illuminate\Auth\Access\Response;

class RolePolicy
{
    /**
     * Determine whether the user can view any models.
     */
    public function viewAny(User $user): bool
    {
        return $user->hasPermissionTo('role_read');
    }

    /**
     * Determine whether the user can view the model.
     */
    public function view(User $user, Role $role): bool
    {
        return $user->hasPermissionTo('role_read');
    }

    /**
     * Determine whether the user can create models.
     */
    public function create(User $user): bool
    {
        return $user->hasPermissionTo('role_create');
    }

    /**
     * Determine whether the user can update the model.
     */
    public function update(User $user, Role $role): bool
    {
        return $user->hasPermissionTo('role_update');
    }

    /**
     * Determine whether the user can delete the model.
     */
    public function delete(User $user, Role $role): bool
    {
        return $user->hasPermissionTo('role_delete');
    }

    /**
     * Determine whether the user can restore the model.
     */
    public function restore(User $user, Role $role): bool
    {
        //
    }

    /**
     * Determine whether the user can permanently delete the model.
     */
    public function forceDelete(User $user, Role $role): bool
    {
        //
    }
}

## E NO PAINEL CRIAREMOS TODAS AS PERMISSÕES QUE SERÃO USADAS

### AJUSTES PARA EVITAR QUE O GERENTE SE COLOQUE COMO ADMINISTRADOR E OU DELETE USUARIOS DE NIVEL ACIMA DELE
1. EVITAR QUE GERENTE NÃO CRIE ADMINISTRADOR, CRIE APENAS OUTROS GERENTES E USUÁRIOS:

\App\filament\Resource\UserResource.php

Acrescenta uma função de verificação em ->relationship:
## ACRESCENTA ESSE:
                Forms\Components\Select::make('roles')
                    ->multiple()
                    ->relationship('roles', 'name', fn(Builder $query ) => 
                        auth()->user()->hasRole('Admin') ? null : $query->where('name', '!=', 'Admin' )
                    )
                    ->preload()   // esta linha já estava.
            ]);
    }


## PARA EVITAR QUE O GERENTE APAGUE O ADMINISTRADOR OU MUDE O ADMINISTRADOR PARA USUÁRIO:
Na exibição de usuarios com perfil de admin não aparecerá na listagem:

UserResource.php

no finalzinho do arquivo:

  // FUNÇÃO PARA EVITAR QUE O GERENTE VEJA NA LISTAGEM OS ADMINISTRADORES
    public static function getEloquentQuery(): Builder
    {
        return auth()->user()-hasRole('Admin') 
            ? parent::getEloquentQuery() 
            : parent::getEloquentQuery()->whereHas(
                'roles',
                fn(Builder $query) => $query->where('name', '!=', 'Admin')
            );
    }
}






### Filters
 //importa em App\filament\UserResource ou no Resource específico  nessas linhas do arquivo 72, 73, 74 mais ou menos
 use Filament\Tables\Filters\TernaryFilter; 
   ->filters([
                TernaryFilter::make('is_admin'),
            ])


###### Criando uma nova tabela

php artisan make:model Despesas -m -f  // -m migrate   -f factory

migration:

 public function up(): void
    {
        Schema::create('despesas', function (Blueprint $table) {
            $table->id();
            $table->string('despesa');
            $table->float('valor');
            $table->date('vencimento');
            $table->boolean('is_pg');
            $table->date('pagamento');
            $table->timestamps();
        });
    }


despesasfactory:
 public function definition(): array
    {
        return [
            'despesa' => fake()->sentense(2),
            'valor'   => fake()->float(3, 2),
            'vencimento'=> fake()->date('d/m/Y'),
            'is_pg' => fake()->boolean(),
            'pagamento'=> fake()->date('d/m/Y'),
            

        ];

DatabaseSeeder.php -- 

    public function run(): void
    {
       //  \App\Models\User::factory(50)->create();    // Marca essa opção que já foi usada
         Despesas::factory(5)->create();   

        // \App\Models\User::factory()->create([
        //     'name' => 'Test User',
        //     'email' => 'test@example.com',
        // ]);
    }
}

### Executa as migrations com Facker()
 php artisan migrate --seed 
 php artisan make:filament-resource Despesas --generate --simple


laravel new painel



php artisan migrate

composer require filament/filament:"^2.0"

atualizar o composer.json linha: 42:
"post-update-cmd: [
	// ...
	"@php artisan filament:upgrade"


fazer a publicação do config do filament:
php artisan vendor:publish --tag=filament-config

publicar as traduções:
php artisan vendor:publish --tag=translations
configurar o .env

php artisan make:migrate

PACOTE DE PERMISSÕES SPAITE.BE
composer require spatie/laravel-permission

php artisan vendor:publish --provider="Spatie\Permission\PermissionServiceProvider


/****
php artisan optimize:clear

or

php artisan confg:clear


php artisan make:migration add_is_admin_to_users_table





php artisan migrate
























/*****************************************************/

APP_PORT=8091

PUBLICAR:
./vendor/bin/sail bash


// criando usuarios
/home



 problema view grande RESOLVER viteconfig.js

export default defineConfig( {
server: {
	hmr {
		host: "localhost"
       }	
},

curl -s "https://laravel.build/olw?with=pgsql" | bash

[root@server www] chown -R sail:sail olw/
[root@server www] chown -R apache:apache pingcrm/
chown -R apache:apache olw/

chown root:root /var/www/html/storage/logs/laravel.log

php artisan config:cache

php artisan optimize:clear

php artisan about



find * -type d -exec chmod 755 {} \;
find * -type f -exec chmod 644 {} \;


php artisan tinker
User::factory()->count(10)->create()

O erro "Permission denied" ocorre quando você não tem permissão para executar o arquivo "./vendor/bin/sail". Existem algumas possíveis soluções para esse problema:

Verifique as permissões do arquivo: Use o comando ls -l ./vendor/bin/sail para verificar as permissões atuais do arquivo. Certifique-se de que você tenha permissão de execução para o arquivo. Se as permissões estiverem incorretas, você pode usar o comando chmod para corrigi-las. Por exemplo, você pode executar o seguinte comando para dar permissão de execução ao arquivo:

shell
Copy code
chmod +x ./vendor/bin/sail
Em seguida, tente executar o comando novamente.

Execute o comando com privilégios de superusuário: Se o arquivo tiver permissões adequadas, mas você ainda receber o erro de permissão negada, pode ser necessário executar o comando com privilégios de superusuário (root). Use o comando sudo antes do comando para executá-lo com privilégios elevados. Por exemplo:

shell
Copy code
sudo ./vendor/bin/sail up -d
Insira a senha de superusuário quando solicitado e o comando será executado com as permissões adequadas.

Certifique-se de que você está executando o comando corretamente e que o arquivo "./vendor/bin/sail" existe no diretório atual. Se o problema persistir, verifique se o arquivo não está corrompido ou se existe algum problema com as permissões do diretório que contém o arquivo.





User
fiz: [root@a5738s olw]# chmod +x ./vendor/bin/sail
[root@a5738s olw]# ./vendor/bin/sail up -d
./vendor/bin/sail: line 37: /root/olw/vendor/laravel/sail/bin/sail: Permission denied

ChatGPT
O erro "Permission denied" indica que você não tem permissão para executar o arquivo "/root/olw/vendor/laravel/sail/bin/sail". Isso pode acontecer se as permissões do arquivo ou diretórios relacionados estiverem configuradas de forma inadequada.

Aqui estão algumas possíveis soluções para resolver esse problema:

Verifique as permissões do arquivo: Use o comando ls -l /root/olw/vendor/laravel/sail/bin/sail para verificar as permissões atuais do arquivo. Certifique-se de que você tenha permissão de execução para o arquivo. Se as permissões estiverem incorretas, você pode usar o comando chmod para corrigi-las. Por exemplo, execute o seguinte comando para dar permissão de execução ao arquivo:

shell
Copy code
chmod +x /root/olw/vendor/laravel/sail/bin/sail
Em seguida, tente executar o comando novamente.

Verifique as permissões dos diretórios relacionados: Além das permissões do arquivo em si, verifique também as permissões dos diretórios pai. Certifique-se de que o diretório "/root/olw/vendor/laravel/sail/" e seus diretórios pai tenham permissões adequadas para a execução de arquivos. Use o comando ls -ld para verificar as permissões dos diretórios relevantes e, se necessário, ajuste-as com o comando chmod.

Execute o comando com privilégios de superusuário: Se as permissões estiverem corretas, mas você ainda estiver enfrentando o erro, pode ser necessário executar o comando com privilégios de superusuário (root). Use o comando sudo antes do comando para executá-lo com privilégios elevados. Por exemplo:

shell
Copy code
sudo ./vendor/bin/sail up -d

/****************
https://github.com/inertiajs/pingcrm

https://dashboard.kiwify.com.br/course/65fe7cb0-9e36-4a29-9e11-b455e9b09d10?lesson=d599f3e0-c447-4ecd-9064-1f281d0e58fe

carregando telas no navegador

Instalação
Clone o repositório localmente:

* git clone https://github.com/inertiajs/pingcrm.git pingcrm
cd pingcrm
Instale as dependências do PHP:

* composer install
Instale as dependências do NPM:

* npm ci
Construir ativos:

* npm run dev
Configuração de instalação:

* cp .env.example .env
Gerar chave de aplicativo:

* php artisan key:generate
Crie um banco de dados SQLite. Você também pode usar outro banco de dados (MySQL, Postgres), basta atualizar sua configuração de acordo.

* touch database/database.sqlite
Execute migrações de banco de dados:

* php artisan migrate
Execute o seeder do banco de dados:

* php artisan db:seed
Execute o servidor dev (a saída fornecerá o endereço):

### php artisan serve
Você está pronto para ir! Visite o Ping CRM em seu navegador e faça o login com:

Nome de usuário: johndoe@example.com
Senha: secreta

Executando testes
### Para executar os testes Ping CRM, execute:

* phpunit

/***
>composer create-project laravel/laravel projeto-inertia-vue

>>configurar o arquivo .env e criar o banco de dados

>php artisan migrate

>composer require laravel/breeze --dev

>php artisan breeze:install vue --ssr

>php artisan make:model Carro -m (Cria a Model - no singular - e a Migration - no plural)-> Neste caso não precisa colocar protected $table = 'carros'

>php artisan make:migration create_testando_table

 */create_testando_table.php

    public function up()
    {
        Schema::create('testando', function (Blueprint $table) {
            $table->id();
            $table->string('string');
            $table->integer('integer');
            $table->decimal('decimal');
            $table->boolean('boolean');
            $table->enum('enum', ['opcao_1', 'opcao_2', 'opcao_3']);
            $table->timestamps();
        });
    }

>php artisan migrate

>php artisan make:model Testando

>Testando.php
class Testando extends Model
{
    use HasFactory;

    protected $table = 'testando';

    protected $fillable = [
        'string', 'integer', 'decima', 'boolean', 'enum'
    ];
}

>php artisan tinker

> use App\Models\Testando;                                                              
> Testando::all();                                                                      
= Illuminate\Database\Eloquent\Collection {#3747
    all: [
      App\Models\Testando {#3749
        id: 1,
        string: "isso é uma string",
        integer: 52,
        decimal: "2.50",
        boolean: 1,
        enum: "opcao_1",
        created_at: "2022-12-15 14:33:59",
        updated_at: null,
      },
    ],
  }

> Testando::create(['string' => 'Criando através da Model', 'integer'=> 25, 'decimal'=>5,5, 'b
oolean' => 1, 'enum' => 'opcao_3']);                

    
> $variavel = Testando::find(1);

> $variavel -> update(['string'=>'Atualizado']); 

>> $variavel                                                                                   
= App\Models\Testando {#3745
    id: 1,
    string: "Estou Atualizado",
    integer: 52,
    decimal: "2.50",
    boolean: 1,
    enum: "opcao_1",
    created_at: "2022-12-15 14:33:59",
    updated_at: "2022-12-15 18:04:10",
  }
  >> $variavel->delete();                                                                        
= true

/**** */
// RELACIONAMENTOS

>php artisan make:migration create_relacionamento_table


 public function up()
    {
        Schema::create('relacionamento', function (Blueprint $table) {
            $table->id();
            $table->string('nome');
            $table->unsignedBigInteger('id_testando');
            $table->timestamps();

            $table->foreign('id_testando')->references('id')->on('testando');
        });
    }

>php artisan migrate

>php artisan make:mode Relacionamento

>Relacionamento.php:
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;

class Relacionamento extends Model
{
    use HasFactory;

    protected $table = 'relacionamento';

    protected $fillable = [
        'nome', 'id_testando'
    ];
}

>php artisan tinker
use App\Models\Relacionamento
Relacionamento::create(['nome' => 'Testando relacionamento', 'id_testando' => 2]);









/****************************************************** */

https://github.com/inertiajs/pingcrm

https://dashboard.kiwify.com.br/course/65fe7cb0-9e36-4a29-9e11-b455e9b09d10?lesson=d599f3e0-c447-4ecd-9064-1f281d0e58fe

carregando telas no navegador

Instalação
Clone o repositório localmente:

* git clone https://github.com/inertiajs/pingcrm.git pingcrm
cd pingcrm
Instale as dependências do PHP:

* composer install
Instale as dependências do NPM:

* npm ci
Construir ativos:

* npm run dev
Configuração de instalação:

* cp .env.example .env
Gerar chave de aplicativo:

* php artisan key:generate
Crie um banco de dados SQLite. Você também pode usar outro banco de dados (MySQL, Postgres), basta atualizar sua configuração de acordo.

* touch database/database.sqlite
Execute migrações de banco de dados:

* php artisan migrate
Execute o seeder do banco de dados:

* php artisan db:seed
Execute o servidor dev (a saída fornecerá o endereço):

### php artisan serve
Você está pronto para ir! Visite o Ping CRM em seu navegador e faça o login com:

Nome de usuário: johndoe@example.com
Senha: secreta

Executando testes
### Para executar os testes Ping CRM, execute:

* phpunit

/******************************************* */


https://github.com/inertiajs/pingcrm

https://dashboard.kiwify.com.br/course/65fe7cb0-9e36-4a29-9e11-b455e9b09d10?lesson=d599f3e0-c447-4ecd-9064-1f281d0e58fe

carregando telas no navegador

Instalação
Clone o repositório localmente:

* git clone https://github.com/inertiajs/pingcrm.git pingcrm
cd pingcrm
Instale as dependências do PHP:

* composer install
Instale as dependências do NPM:

* npm ci
Construir ativos:

* npm run dev
Configuração de instalação:

* cp .env.example .env
Gerar chave de aplicativo:

* php artisan key:generate
Crie um banco de dados SQLite. Você também pode usar outro banco de dados (MySQL, Postgres), basta atualizar sua configuração de acordo.

* touch database/database.sqlite
Execute migrações de banco de dados:

* php artisan migrate
Execute o seeder do banco de dados:

* php artisan db:seed
Execute o servidor dev (a saída fornecerá o endereço):

### php artisan serve
Você está pronto para ir! Visite o Ping CRM em seu navegador e faça o login com:

Nome de usuário: johndoe@example.com
Senha: secreta

Executando testes
### Para executar os testes Ping CRM, execute:

* phpunit

# Ping CRM

A demo application to illustrate how Inertia.js works.

![](https://raw.githubusercontent.com/inertiajs/pingcrm/master/screenshot.png)

## Installation

Clone the repo locally:

```sh
git clone https://github.com/inertiajs/pingcrm.git pingcrm
cd pingcrm
```

Install PHP dependencies:

```sh
composer install
```

Install NPM dependencies:

```sh
npm ci
```

Build assets:

```sh
npm run dev
```

Setup configuration:

```sh
cp .env.example .env
```

Generate application key:

```sh
php artisan key:generate
```

Create an SQLite database. You can also use another database (MySQL, Postgres), simply update your configuration accordingly.

```sh
touch database/database.sqlite
```

Run database migrations:

```sh
php artisan migrate
```

Run database seeder:

```sh
php artisan db:seed
```

Run the dev server (the output will give the address):

```sh
php artisan serve
```

You're ready to go! Visit Ping CRM in your browser, and login with:

- **Username:** johndoe@example.com
- **Password:** secret

## Running tests

To run the Ping CRM tests, run:

```
phpunit
```
/*********************************************************** */
PROJETO PINGCRM LARAVEL/INERTIA/VUE
>composer create-project laravel/laravel projeto-laravel-inertia-vue

>composer require laravel/breeze --dev

>php artisan breeze:install vue --ssr (--SSR -> Server Side Render: as páginas são construídas no servidor)

>php artisan migrate

>php artisan serve

https://github.com/inertiajs/pingcrm.git (PROJETO PRONTO)

composer install
npm ci
npm install
npm run dev || npm run watch
.env
php artisan key:generate


************************************************


wdev-vagas
https://youtu.be/BT5QY3VYSsk

https://youtu.be/8c7PEWcQi7U?list=PL_zkXQGHYosHgSJNqqT9RAc6IlBjCfcmm

https://youtu.be/bIAyp12FuQY?list=PL_zkXQGHYosHgSJNqqT9RAc6IlBjCfcmm

https://youtu.be/eO11iFgrdCA?list=PL_zkXQGHYosHgSJNqqT9RAc6IlBjCfcmm

https://youtu.be/6Es3i2eH5K4?list=PL_zkXQGHYosHgSJNqqT9RAc6IlBjCfcmm

https://youtu.be/m1MrI16KvCc?list=PL_zkXQGHYosHgSJNqqT9RAc6IlBjCfcmm

https://youtu.be/uYkkUgA5KgI?list=PL_zkXQGHYosHgSJNqqT9RAc6IlBjCfcmm

https://youtu.be/sjriQ_NsjdI?list=PL_zkXQGHYosHgSJNqqT9RAc6IlBjCfcmm

https://youtu.be/u0d0y1nWHRE?list=PL_zkXQGHYosHgSJNqqT9RAc6IlBjCfcmm

### CONFIGURAR USUARIO E SENHA MYSQL

sudo service mysql stop
# Criando o diretório do serviço
sudo mkdir /var/run/mysqld
# Dando permissão ao MySQL para escrever no diretório
sudo chown mysql: /var/run/mysqld
# Iniciar o MySQL manualmente, sem checagem de permissões
sudo mysqld_safe --skip-grant-tables --skip-networking &
# Login sem senha
mysql -u root mysql



use mysql;
#usar a tabela do MySQL

ALTER USER 'root'@'localhost' IDENTIFIED BY '123456';

#Mecanismo padrão de resolução de senha para usuário root
update user set plugin="mysql_native_password" where User='root';
flush privileges;
quit;



sudo /etc/init.d/mysql stop 
sudo /etc/init.d/mysql start
#Tente executar para fazer login com a nova senha
mysql -u root -p


CREATE USER 'root'@'%' IDENTIFIED BY '123456';
GRANT ALL PRIVILEGES ON *.* TO 'root'@'%' WITH GRANT OPTION;
FLUSH PRIVILEGES;

exit


/*********************************************************** */

C:\Users\alber\Desktop\PROGRAMAÇÃO\KIWIFY LARAVEL PROJETO ESCOLA\pingcrm>php artisan tinker
PHP Warning:  PHP Startup: gd: Unable to initialize module
Module compiled with module API=20190902
PHP    compiled with module API=20210902
These options need to match
 in Unknown on line 0

Warning: PHP Startup: gd: Unable to initialize module
Module compiled with module API=20190902
PHP    compiled with module API=20210902
These options need to match
 in Unknown on line 0
Psy Shell v0.11.9 (PHP 8.1.11 — cli) by Justin Hileman
> use App\Models\Relacionamento;                                               
> $rel = Relacionamento::find(1);                                              
= null

> quit                                                                         

   INFO  Goodbye.


C:\Users\alber\Desktop\PROGRAMAÇÃO\KIWIFY LARAVEL PROJETO ESCOLA\pingcrm>php artisan tinker
PHP Warning:  PHP Startup: gd: Unable to initialize module
Module compiled with module API=20190902
PHP    compiled with module API=20210902
These options need to match
 in Unknown on line 0

Warning: PHP Startup: gd: Unable to initialize module
Module compiled with module API=20190902
PHP    compiled with module API=20210902
These options need to match
 in Unknown on line 0
Psy Shell v0.11.9 (PHP 8.1.11 — cli) by Justin Hileman
> Relacionamento::all()                                                        

   ERROR  Class "Relacionamento" not found in C:\Users\alber\Desktop\PROGRAMAÇÃO\KIWIFY LARAVEL PROJETO ESCOLAeval()'d code.

> use App\Models;                                                              
> Relacionamento::all()                                                        

   ERROR  Class "Relacionamento" not found in C:\Users\alber\Desktop\PROGRAMAÇÃO\KIWIFY LARAVEL PROJETO ESCOLAeval()'d code.

> use App\Models\Relacionameto                                                 
> Relacionamento::all()                                                        

   ERROR  Class "Relacionamento" not found in C:\Users\alber\Desktop\PROGRAMAÇÃO\KIWIFY LARAVEL PROJETO ESCOLAeval()'d code.

> $res = Relacionamento::all()                                                 

   ERROR  Class "Relacionamento" not found in C:\Users\alber\Desktop\PROGRAMAÇÃO\KIWIFY LARAVEL PROJETO ESCOLAeval()'d code.

> $res->all()                                                                  

   WARNING  Undefined variable $res in C:\Users\alber\Desktop\PROGRAMAÇÃO\KIWIFY LARAVEL PROJETO ESCOLAeval()'d code.


   ERROR  Call to a member function all() on null in C:\Users\alber\Desktop\PROGRAMAÇÃO\KIWIFY LARAVEL PROJETO ESCOLAeval()'d code.

> $res->find(1)                                                                

   WARNING  Undefined variable $res in C:\Users\alber\Desktop\PROGRAMAÇÃO\KIWIFY LARAVEL PROJETO ESCOLAeval()'d code.


   ERROR  Call to a member function find() on null in C:\Users\alber\Desktop\PROGRAMAÇÃO\KIWIFY LARAVEL PROJETO ESCOLAeval()'d code.

> $res->find(1);                                                               

   WARNING  Undefined variable $res in C:\Users\alber\Desktop\PROGRAMAÇÃO\KIWIFY LARAVEL PROJETO ESCOLAeval()'d code.


   ERROR  Call to a member function find() on null in C:\Users\alber\Desktop\PROGRAMAÇÃO\KIWIFY LARAVEL PROJETO ESCOLAeval()'d code.

> $variavel = Relacionamento::find(1)                                          

   ERROR  Class "Relacionamento" not found in C:\Users\alber\Desktop\PROGRAMAÇÃO\KIWIFY LARAVEL PROJETO ESCOLAeval()'d code.

> $variavel = Testando::find(1)                                                

   ERROR  Class "Testando" not found in C:\Users\alber\Desktop\PROGRAMAÇÃO\KIWIFY LARAVEL PROJETO ESCOLAeval()'d code.

> use App\Models\Testando;                                                     
> $res = Testando::find(1)                                                     
= null

> $res->all()                                                                  

   ERROR  Call to a member function all() on null in C:\Users\alber\Desktop\PROGRAMAÇÃO\KIWIFY LARAVEL PROJETO ESCOLAeval()'d code.

> use App\Models\Testando;                                                     
> $rel = Testando(2)                                                           

   ERROR  Call to undefined function App\Models\Testando() in C:\Users\alber\Desktop\PROGRAMAÇÃO\KIWIFY LARAVEL PROJETO ESCOLAeval()'d code.

> $rel = Testando(2);                                                          

   ERROR  Call to undefined function App\Models\Testando() in C:\Users\alber\Desktop\PROGRAMAÇÃO\KIWIFY LARAVEL PROJETO ESCOLAeval()'d code.

> $rel = Testando::all();                                                      
= Illuminate\Database\Eloquent\Collection {#3600
    all: [
      App\Models\Testando {#3622
        id: 2,
        string: "String",
        integer: 25,
        decimal: "5.50",
        boolean: 0,
        enum: "opcao_2",
        created_at: "2022-11-24 09:06:12",
        updated_at: null,
      },
    ],
  }

> $variavel->testando;                                                         

   WARNING  Undefined variable $variavel in C:\Users\alber\Desktop\PROGRAMAÇÃO\KIWIFY LARAVEL PROJETO ESCOLAeval()'d code.


   WARNING  Attempt to read property "testando" on null in C:\Users\alber\Desktop\PROGRAMAÇÃO\KIWIFY LARAVEL PROJETO ESCOLAeval()'d code.

= null

> use App\Models\Relacionamento                                                
> $rel = Relacionamento::all();                                                
= Illuminate\Database\Eloquent\Collection {#3609
    all: [
      App\Models\Relacionamento {#3631
        id: 2,
        nome: "Relacionamento primeiro",
        id_testando: 2,
        created_at: "2022-11-24 09:09:57",
        updated_at: null,
      },
    ],
  }

> $rel->testando                                                               

   Exception  Property [testando] does not exist on this collection instance.  

> $rel->testando;                                                              

   Exception  Property [testando] does not exist on this collection instance.  

> use App\Models\Testando;                                                     
> $rel->testando;                                                              

   Exception  Property [testando] does not exist on this collection instance.  

> exit                                                                         

   INFO  Goodbye.


C:\Users\alber\Desktop\PROGRAMAÇÃO\KIWIFY LARAVEL PROJETO ESCOLA\pingcrm>php ar
tisan tinker
PHP Warning:  PHP Startup: gd: Unable to initialize module
Module compiled with module API=20190902
PHP    compiled with module API=20210902
These options need to match
 in Unknown on line 0

Warning: PHP Startup: gd: Unable to initialize module
Module compiled with module API=20190902
PHP    compiled with module API=20210902
These options need to match
 in Unknown on line 0
Psy Shell v0.11.9 (PHP 8.1.11 — cli) by Justin Hileman
> use Relacionamento                                                           
> $x = Relacionamento::find(1);                                                

   ERROR  Class "Relacionamento" not found in C:\Users\alber\Desktop\PROGRAMAÇÃO\KIWIFY LARAVEL PROJETO ESCOLAeval()'d code.

> use App\Models\Relacionamento;                                               
> $x = Relacionamento::find(1);                                                
= null

> $x = Relacionamento::find(2);                                                
= App\Models\Relacionamento {#3618
    id: 2,
    nome: "Relacionamento primeiro",
    id_testando: 2,
    created_at: "2022-11-24 09:09:57",
    updated_at: null,
  }

> $x = Relacionamento::find(3);                                                
= null

> $y = Testando::find(3);                                                      

   ERROR  Class "Testando" not found in C:\Users\alber\Desktop\PROGRAMAÇÃO\KIWIFY LARAVEL PROJETO ESCOLAeval()'d code.

> use App\Models\Testando::class;                                              

   PARSE ERROR  PHP Parse error: Syntax error, unexpected T_PAAMAYIM_NEKUDOTAYIM, expecting ';' in vendor\psy\psysh\src\Exception\ParseErrorException.php on line 40.

> use App\Models\Testando                                                      
> $y = Testando::find(1)                                                       
= null

> $y = Testando::find(2)                                                       
= App\Models\Testando {#3610
    id: 2,
    string: "String",
    integer: 25,
    decimal: "5.50",
    boolean: 1,
    enum: "opcao_1",
    created_at: "2022-11-24 09:06:06",
    updated_at: null,
  }

> $y = Testando::find(3)                                                       
= App\Models\Testando {#3612
    id: 3,
    string: "Nova String",
    integer: 52,
    decimal: "4.50",
    boolean: 0,
    enum: "opcao_2",
    created_at: "2022-11-24 09:06:12",
    updated_at: null,
  }

> $y = Testando::all()                                                         
= Illuminate\Database\Eloquent\Collection {#3602
    all: [
      App\Models\Testando {#3613
        id: 2,
        string: "String",
        integer: 25,
        decimal: "5.50",
        boolean: 1,
        enum: "opcao_1",
        created_at: "2022-11-24 09:06:06",
        updated_at: null,
      },
      App\Models\Testando {#3627
        id: 3,
        string: "Nova String",
        integer: 52,
        decimal: "4.50",
        boolean: 0,
        enum: "opcao_2",
        created_at: "2022-11-24 09:06:12",
        updated_at: null,
      },
    ],
  }

> $x = Relacionamento::find(2);                                                
= App\Models\Relacionamento {#3623
    id: 2,
    nome: "Relacionamento primeiro",
    id_testando: 2,
    created_at: "2022-11-24 09:09:57",
    updated_at: null,
  }

> $y = Testando::all()                                                         
= Illuminate\Database\Eloquent\Collection {#3633
    all: [
      App\Models\Testando {#3634
        id: 2,
        string: "String",
        integer: 25,
        decimal: "5.50",
        boolean: 1,
        enum: "opcao_1",
        created_at: "2022-11-24 09:06:06",
        updated_at: null,
      },
      App\Models\Testando {#3635
        id: 3,
        string: "Nova String",
        integer: 52,
        decimal: "4.50",
        boolean: 0,
        enum: "opcao_2",
        created_at: "2022-11-24 09:06:12",
        updated_at: null,
      },
    ],
  }

> $x->Testando                                                                 
= App\Models\Testando {#3622
    id: 2,
    string: "String",
    integer: 25,
    decimal: "5.50",
    boolean: 1,
    enum: "opcao_1",
    created_at: "2022-11-24 09:06:06",
    updated_at: null,
  }

> $x                                                                           
= App\Models\Relacionamento {#3623
    id: 2,
    nome: "Relacionamento primeiro",
    id_testando: 2,
    created_at: "2022-11-24 09:09:57",
    updated_at: null,
    Testando: App\Models\Testando {#3622
      id: 2,
      string: "String",
      integer: 25,
      decimal: "5.50",
      boolean: 1,
      enum: "opcao_1",
      created_at: "2022-11-24 09:06:06",
      updated_at: null,
    },
  }

> $y->Relacionamento                                                           

   Exception  Property [Relacionamento] does not exist on this collection instance.

> $x->Testando                                                                 
= App\Models\Testando {#3622
    id: 2,
    string: "String",
    integer: 25,
    decimal: "5.50",
    boolean: 1,
    enum: "opcao_1",
    created_at: "2022-11-24 09:06:06",
    updated_at: null,
  }

> $x->all()                                                                    
= Illuminate\Database\Eloquent\Collection {#3636
    all: [
      App\Models\Relacionamento {#3613
        id: 2,
      decimal: "5.50",
      boolean: 1,
      enum: "opcao_1",
      created_at: "2022-11-24 09:06:06",
      updated_at: null,
    },
    App\Models\Testando {#3635
      id: 3,
      string: "Nova String",
      integer: 52,
      decimal: "4.50",
      boolean: 0,
      enum: "opcao_2",
      created_at: "2022-11-24 09:06:12",
      updated_at: null,
    },
  ]

> $x->$y                                                                       
= null

> $y->$x                                                                       

   Exception  Property [{"id":2,"nome":"Relacionamento primeiro","id_testando":2,"created_at":"2022-11-24T09:09:57.000000Z","updated_at":null,"testando":{"id":2,"string":"String","integer":25,"decimal":"5.50","boolean":1,"enum":"opcao_1","created_at":"2022-11-24T09:06:06.000000Z","updated_at":null}}] does not exist on this collection instance.

> $x->Testando                                                                 
= App\Models\Testando {#3622
    id: 2,
    string: "String",
    integer: 25,
    decimal: "5.50",
    boolean: 1,
    enum: "opcao_1",
    created_at: "2022-11-24 09:06:06",
    updated_at: null,
  }

> $x::with('testando')->find(all)                                              

   ERROR  Undefined constant "all" in C:\Users\alber\Desktop\PROGRAMAÇÃO\KIWIFY LARAVEL PROJETO ESCOLAeval()'d code.

> Relacionamento::with('testando')->find(all)                                  

   ERROR  Undefined constant "all" in C:\Users\alber\Desktop\PROGRAMAÇÃO\KIWIFY LARAVEL PROJETO ESCOLAeval()'d code.

> Relacionamento::with('testando')->find(1)                                    
= null

>                                                                              
> Relacionamento::with('testando')->find(2)                                    
= App\Models\Relacionamento {#3651
    id: 2,
    nome: "Relacionamento primeiro",
    id_testando: 2,
    created_at: "2022-11-24 09:09:57",
    updated_at: null,
    testando: App\Models\Testando {#3660
      id: 2,
      string: "String",
      integer: 25,
      decimal: "5.50",
      boolean: 1,
      enum: "opcao_1",
      created_at: "2022-11-24 09:06:06",
      updated_at: null,
    },
  }

> Relacionamento::with('testando')->all()                                      

   BadMethodCallException  Call to undefined method Illuminate\Database\Eloquent\Builder::all().

> Relacionamento::with('testando')                                             
= Illuminate\Database\Eloquent\Builder {#3991}

> $z = Relacionamento::with('testando')                                        
= Illuminate\Database\Eloquent\Builder {#3645}

> $z->find(all)                                                                

   ERROR  Undefined constant "all" in C:\Users\alber\Desktop\PROGRAMAÇÃO\KIWIFY LARAVEL PROJETO ESCOLAeval()'d code.

> $z->all()                                                                    

   BadMethodCallException  Call to undefined method Illuminate\Database\Eloquent\Builder::all().

> $z                                                                           
= Illuminate\Database\Eloquent\Builder {#3645}

> $z::all()                                                                    

   BadMethodCallException  Call to undefined method Illuminate\Database\Eloquent\Builder::all().

> $x::all()
= Illuminate\Database\Eloquent\Collection {#3647
    all: [
      App\Models\Relacionamento {#3660
        id: 2,
        nome: "Relacionamento primeiro",
        id_testando: 2,
        created_at: "2022-11-24 09:09:57",
        updated_at: null,
      },
    ],
  }

> $y::all()

   ERROR  Non-static method Illuminate\Support\Collection::all() cannot be called statically in C:\Users\alber\Desktop\PROGRAMAÇÃO\KIWIFY LARAVEL PROJETO ESCOLAeval()'d code.

> $z::all()

   BadMethodCallException  Call to undefined method Illuminate\Database\Eloquent\Builder::all().


   ERROR  Non-static method Illuminate\Support\Collection::all() cannot be called statically in C:\Users\alber\Desktop\PROGRAMAÇÃO\KIWIFY LARAVEL PROJETO ESCOLAeval()'d code.

>                                                                              

>                                                                              
> use App\Models\Testando;                                                     
> $t = Testando::find(2)                                                       
= App\Models\Testando {#3602
    id: 2,
    string: "String",
    integer: 25,
    decimal: "5.50",
    boolean: 1,
    enum: "opcao_1",
    created_at: "2022-11-24 09:06:06",
    updated_at: null,
  }

> $t->relacionamento                                                           
= null

> $t->relacionamento                                                           
= null

> exit                                                                         

   INFO  Goodbye.


C:\Users\alber\Desktop\PROGRAMAÇÃO\KIWIFY LARAVEL PROJETO ESCOLA\pingcrm>php artisan tinker
PHP Warning:  PHP Startup: gd: Unable to initialize module
Module compiled with module API=20190902
PHP    compiled with module API=20210902
These options need to match
 in Unknown on line 0

Warning: PHP Startup: gd: Unable to initialize module
Module compiled with module API=20190902
PHP    compiled with module API=20210902
These options need to match
 in Unknown on line 0
Psy Shell v0.11.9 (PHP 8.1.11 — cli) by Justin Hileman
> $t = Testando::find(2)                                                       

   ERROR  Class "Testando" not found in C:\Users\alber\Desktop\PROGRAMAÇÃO\KIWIFY LARAVEL PROJETO ESCOLAeval()'d code.

> use App\Models\Testando;                                                     
> $t = Testando::find(2)                                                       
    nome: "Relacionamento primeiro",
    id_testando: 2,
    created_at: "2022-11-24 09:09:57",
    updated_at: null,
  }

> Testando::with('relacionamento')->find(2)                                    
= App\Models\Testando {#3624
    id: 2,
    string: "String",
    integer: 25,
    decimal: "5.50",
    boolean: 1,
    enum: "opcao_1",
    created_at: "2022-11-24 09:06:06",
    updated_at: null,
    relacionamento: App\Models\Relacionamento {#3631
      id: 2,
      nome: "Relacionamento primeiro",
      id_testando: 2,
      created_at: "2022-11-24 09:09:57",
      updated_at: null,
    },
  }

> $t->relacionamento                                                           
= App\Models\Relacionamento {#3625
    id: 2,
    nome: "Relacionamento primeiro",
    id_testando: 2,
    created_at: "2022-11-24 09:09:57",
    updated_at: null,
  }


<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;

class Testando extends Model
{
    use HasFactory;

    protected $table = 'testando';

    protected $fillable = [
        'string',
        'integer',
        'decimal',
        'boolean',
        'enum'
    ];

    public function relacionamento()
    {
        return $this->hasOne(Relacionamento::class, 'id_testando');
    }
}


<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;

class Relacionamento extends Model
{
    use HasFactory;

    protected $table = 'relacionamento';

    protected $fillable = [
        'nome',
        'id_testando'
    ];

    public function testando()
    {
        return $this->belongsTo(Testando::class, 'id_testando');
    }
}


** ** ** ****************** ** **livewire ** ************************/
https://github.com/Power-Components/livewire-powergrid

composer require power-components/livewire-powergrid

github.com/Power-Components/live

chmod -R /home/lucas/.cache

tempo 1:02:20





* laravel 8x
* livewire 2x
* composer 2x (composer self update)
* compativel com bootstrap 5
- usa o paginate do laravel


** ** ** * * * *   ***  ***   ***  

https://github.com/albertogomesdasilva/awesome-list/import

classes.vedovelli.com.br

https://www.youtube.com/vedovelli

https://javascript.tv.br/

 linkedin.com/in/vedovelli


Beer and Code
​https://www.youtube.com/c/FabioVedove...

Vitor Souza
​Eu falei, eu falei! hehehe acompanhem ele no twitter.

Beer and Code
​https://classes.vedovelli.com.br/courses

Beer and Code
​https://www.linkedin.com/in/vedovelli/


/*******************  QUERYS NECESSÁRIAS  ***************************************** */

use sg;

insert into site_contatos(nome, telefone, email, motivo_contato, mensagem)values('João', '(88) 91111-2222', 'joao@contato.com.br', 3, 'É muito difícil localizar a opção de listar todos os produtos');
insert into site_contatos(nome, telefone, email, motivo_contato, mensagem)values('Rosa', '(33) 92222-3333', 'rosa@contato.com.br', 1, 'Quando custa essa aplicação?');
insert into site_contatos(nome, telefone, email, motivo_contato, mensagem)values('Fernando', '(11) 94444-5555', 'fernando@contato.com.br', 1, 'Como consigo criar multiplos usuários para minha empresa?');
insert into site_contatos(nome, telefone, email, motivo_contato, mensagem)values('André', '(88) 95555-6666', 'andre@contato.com.br', 2, 'Parabéns pela ferramenta, estou obtendo ótimos resultados!');
insert into site_contatos(nome, telefone, email, motivo_contato, mensagem)values('Ana', '(33) 96666-7777', 'ana@contato.com.br', 3, 'Não gostei muito das cores, consigo mudar de tema?');
insert into site_contatos(nome, telefone, email, motivo_contato, mensagem)values('Helena', '(11) 97777-8888', 'helena@contato.com.br', 2, 'Consigo controlar toda a minha empresa de modo fácil e prático.');


/**************************   IMPORTANTES **************************************** */

https://github.com/albertogomesdasilva/awesome-list/import

classes.vedovelli.com.br

https://www.youtube.com/vedovelli

https://javascript.tv.br/

 linkedin.com/in/vedovelli


Beer and Code
​https://www.youtube.com/c/FabioVedove...

Vitor Souza
​Eu falei, eu falei! hehehe acompanhem ele no twitter.

Beer and Code
​https://classes.vedovelli.com.br/courses

Beer and Code
​https://www.linkedin.com/in/vedovelli/



https://github.com/albertogomesdasilva/awesome-list/import

classes.vedovelli.com.br

https://www.youtube.com/vedovelli

https://javascript.tv.br/

 linkedin.com/in/vedovelli


Beer and Code
​https://www.youtube.com/c/FabioVedove...

Vitor Souza
​Eu falei, eu falei! hehehe acompanhem ele no twitter.

Beer and Code
​https://classes.vedovelli.com.br/courses

Beer and Code
​https://www.linkedin.com/in/vedovelli/

/***************************************************************** */

VIDEO VEDOVELI Laravel, Inertia.js, Vue.js e TaiwlwindCSS
* composer create-project --prefer-dist laravel/laravel beer
* composer require laravel/breeze --dev


* criar app.blade.php na mesma pasta de welcome.blade.php

* app.blade.php (pasta views)
<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Beer and Code</title>
</head>
<body>
    
    <div>
        @yield('content')
    </div>
    
</body>
</html>

welcome.blade.php (pasta views)

@extends('app')


<h1> Welcome to Beer and Code </h1>

* INSTALAÇÕES:
- Do lado do servidor
* composer require inertiajs/inertia-laravel

* NOVO CONTEÚDO DO app.blade.php ( que está na documentação do Inertia js)

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0" />
    <link href="{{ mix('/css/app.css') }}" rel="stylesheet" />
    <script src="{{ mix('/js/app.js') }}" defer></script>
    @inertiaHead
  </head>
  <body>
  <div> 
    @inertia
  <div>
  </body>
</html>

- cria o middleware:
* php artisan inertia:middleware
Uma vez gerado, registre o HandleInertiaRequestsmiddleware em seu App\Http\Kernel, como o último item do seu webgrupo de middleware. (linha + - 40 do arquivo app/Http/Kernel.php)

'web' => [
    // ...
    \App\Http\Middleware\HandleInertiaRequests::class,
],


* npm install

* npm run dev
 
- DO LADO DO CLIENTE (CLIENT SIDE): no site do inertia no cliet side tem:

* >npm install @inertiajs/inertia @inertiajs/inertia-vue3 vue@next  

* CONTEÚDO DO ARQUIVO resources/ js / app.js : (consta na documentação client side)

 import { createApp, h } from 'vue'
import { createInertiaApp } from '@inertiajs/inertia-vue3'

createInertiaApp({
  resolve: name => require(`./Pages/${name}`),
  setup({ el, App, props, plugin }) {
    createApp({ render: () => h(App, props) })
      .use(plugin)
      .mount(el)
  },
})

* instala:
npm install @inertiajs/progress

PARA BUILD DA APLICAÇÃO INSTALAR O CODE SPLIT DA DOCUMENTAÇÃO client side

* webpack.mix.js
mix.js('resources/js/app.js', 'public/js')
    .postCss('resources/css/app.css', 'public/css', [
        //
    ])
    .vue({version: 3});     => acrescenta esta linha = observar o ;

* npm run dev
* npm install vue-loader@^16.2.0 --save-dev --legacy-peer-deps => ele diz pra intalar essa linha
* cria a pasta pages dentro de resources/js

/**********************************************************************

https://laravel-docs-pt-br.readthedocs.io/en/latest/cache/?q=breeze&check_keywords=yes&area=default

Taylor Otwel
curl -s "https://laravel.build/chirper" | bash


cd chirper
 
./vendor/bin/sail up

./vendor/bin/sail php --version
./vendor/bin/sail artisan --version
./vendor/bin/sail composer --version
./vendor/bin/sail npm --version


composer require laravel/breeze --dev
 
php artisan breeze:install vue

npm run dev
Por fim, abra outro terminal no chirperdiretório do seu projeto e execute as migrações iniciais do banco de dados para preencher o banco de dados com as tabelas padrão do Laravel e do Breeze:

php artisan migrate

## VUE BRASIL: https://www.youtube.com/watch?app=desktop&v=nksTeRRLAIY

# https://youtu.be/nksTeRRLAIY



# CRIANDO APP COM VUEJS:
https://www.google.com/search?q=fazer+app+android+a+partir+do+vue&oq=fazer+app+android+a+partir+do+vue&aqs=chrome..69i57.12946j0j4&sourceid=chrome&ie=UTF-8

# CRIANDO SISTEMA COM ELECTRON:
requisitos: nodejs, npm, vuejs

> vue create projetovueelectron
- preset default vue3
- cd projetovueelectron
- vue add electron-builder
. ^13.0.0 versão
- npm run serve (scripts em package.json)
# Exportar para aplicação desktop:
-  npm run electron:build

***********************************************
git --global --list

git --global user.name "nomedeusuário"

git --global user.email "cursovue@gmail.com"

git config --list (configurações locais do projeto - quando o git não tem usa as globais)

git config user.name "nomedousuário"

git config user.email "email@usuario.com"

git config --list   ->sobrepões as globais
git --global --list
git remote -v

*Get your local Git repository on Bitbucket
*Step 1: Switch to your repository's directory

cd /path/to/your/repo
Step 2: Connect your existing repository to Bitbucket

git remote add origin https://albertogomesdasilva@bitbucket.org/albertogomesdasilva/projetovujs.git
git push -u origin master

git remote add bitbucket https://albertogomesdasilva/projeto-vue-padrao.git  (bitbucket pode ser qualquer nome)

git remote set-url -> corrige o endereço da url: git remote set-url bitbucket https://albertogomesdasilva...

git remote -v -> exibe o link do git conectado.

git status -> exibe o que foi modificado no stage área

git reset -> 

git commit

git log



/************************************************************* */

#criando um serviço com um nome qualquer
#criando um serviço com um nome qualquer
version: '3'

services:
  laravel-app:                    #criando um serviço com um nome qualquer
    build: .                      # endereço da imagem ou local do Dockerfile (neste caso o ponto siginifica a raiz do projeto)
    ports:
      - "8080:80"                 # 8080 porta do meu host: 80 é a porta do docker nginx
    volumes:                      # docker-compose up -d -> sobe a imagem e libera o terminal  
      - ./:/usr/share/nginx       # TUDO QUE ESTIVE NA RAIZ (na rais tem o meu projeto laravel) './' IRÁ SER REFLETIDO NA PASTA /usr/share/nginx (pasta de acesso da página html)
                                  # C:\Laravel-docker\laravel-docker>docker compose up -d --build atualiza a minha imagem

  mysql-app:
      image: mysql:5.7
      ports:
        - "3306:3306"
      volumes:
        - .docker/dbdata:/var/lib/mysql          # qualqer nome (para persistir -guardar os dados do banco de dados)


      environment:
        MYSQL_DATABASE: laravel
        MYSQL_ROOT_PASSWORD: laravel
    
      

      


C:\Laravel-docker\laravel-docker>docker compose up -d --build
  

HostGator.com.br – Dados de acesso ao seu Plano P de Hospedagem de Sites
?
Tenha cuidado. Esta mensagem parece ser uma tentativa de phishing. Saiba mais sobre phishing | Mostrar conteúdo bloqueado
HostGator Brasil <vendas@hostgator.com.br>
Sáb, 31/10/2020 21:27
HostGator Brasil

 

 	
 
Dados de acesso à sua
hospedagem Plano P
 
 
 	
 
Olá, Alberto Gomes da Silva,

Você acaba de adquirir um Plano P e seu domínio principal é:
albertogomesdasilva.com.br

Seu plano já está ativo e neste e-mail estão todas as informações para acessar sua hospedagem e fazer as configurações necessárias para criar e publicar seu site.

Por favor, guarde este e-mail para futuras referências.

Os DNS do seu plano de hospedagem são:

Nameserver 1:
ns482.hostgator.com.br 216.172.172.210
Nameserver 2:
ns483.hostgator.com.br ()
Para configurar seu DNS, siga os guias abaixo:

Como alterar o DNS do seu domínio contratado com a HostGator
Como alterar o DNS no Registro BR
Como alterar o DNS em outros provedores
 
 
 	
Informações técnicas e acessos:
A seguir você encontra a informação técnica da sua hospedagem de sites e os acessos para aproveitar ao máximo o seu plano:

 
 	
Painel de controle cPanel

Use o Painel cPanel para facilitar a gestão de seus recursos como gerenciar seus domínios, criar contas de e-mail, transferência de arquivos, etc.

Usuário:
alber258
Senha:
057yVmuV1p
URL do Painel de Controle (cPanel):
http://216.172.172.210/cpanel
Quando as alterações de DNS se propagarem, você pode acessar seu cPanel usando a seguinte URL:
http://www.albertogomesdasilva.com.br/cpanel

 
Informações Técnicas

Para configurações mais avançadas do Outlook, acesso ao banco de dados e clientes FTP, entre outros, utilize as informações abaixo:

Nome do Servidor:
br482
IP do Servidor:
216.172.172.210
Nameserver 1:
ns482.hostgator.com.br 216.172.172.210
Nameserver 2:
ns483.hostgator.com.br ()
 
 	
 
 
 	
Subindo seu site via FTP

Já tem os arquivos do seu site em um ambiente local e precisa subi-los na hospedagem? Use o Gerenciador de arquivos do cPanel ou um cliente de FTP.

Hostname FTP:
216.172.172.210
Endereço temporário do seu site:
http://br482.teste.website/~alber258/
Depois da propagação, pode utilizar:
Hostname FTP:
albertogomesdasilva.com.br
URL do site:
http://www.albertogomesdasilva.com.br
Para saber como se conectar por FTP com o Filezilla, veja este vídeo.

 
Contas de e-mail

Criar uma conta de e-mail é rápido e fácil, basta clicar na opção de “Contas de E-mail” disponível no seu cPanel. Conheça o passo a passo.

Para acessar um serviço de e-mail como Outlook, Thunderbird, Gmail, Mac Mail, entre outros, use os seguintes dados:

POP3:
mail.albertogomesdasilva.com.br
SMTP:
mail.albertogomesdasilva.com.br
Usuário:
Conta de e-mail criada
Senha:
Senha configurada para esta conta de e-mail
 
 	
 
 
 	
Se tiver qualquer dúvida você pode acessar nosso tutorial “Como publicar meu site” ou entrar em contato conosco pelos nossos Canais de Atendimento.

Desejamos sucesso!

Atenciosamente,

Equipe HostGator Brasil

HostGator.com.br

 
 
 

Se você precisar de apoio, entre em contato pelos nossos Canais de ajuda.
Para acessar o Portal do Cliente, clique no link abaixo ou copie-o para a barra de endereços de seu navegador: https://financeiro.hostgator.com.br/
HostGator - Rua Lauro Linhares, 589, Ático, Trindade, Florianópolis - SC, CEP: 88036-001 - Brasil

                                
                               

    

/******************************** Dockerfile
FROM wyveo/nginx-php-fpm:latest

/***************************///
  COMANDOS

docker compose down -> para todos os containers
C:\Laravel-docker\laravel-docker>docker exec -it laravel-docker-laravel-app-1 bash 
root@612ea0ea3340:/# cd /usr/share/nginx/
root@612ea0ea3340:/usr/share/nginx# php artisan migrate
root@612ea0ea3340:/usr/share/nginx# php artisan serve

		

    

/******************************** Dockerfile
FROM wyveo/nginx-php-fpm:latest


		




MYSQL MUDAR SENHA ROOT
Toggle navigationViva o Linux
Home  Dicas  Banco de Dados MySQL Resetar senha de root perdida no MySQL no CentOS e Red Hat
Resetar senha de root perdida no MySQL no CentOS e Red Hat

Publicado por Clediomir Silva em 19/11/2014

[ Hits: 30.971 ]
 
 

 Denuncie    Favoritos    Indicar    Impressora
RESETAR SENHA DE ROOT PERDIDA NO MYSQL NO CENTOS E RED HAT


Essa dica tem por finalidade, demonstrar como alterar a senha do root do MySQL, caso você tenha esquecido ou caso tenha necessidade em servidores no qual não existem nenhuma documentação.

PROCEDIMENTOS PARA CONFIGURAR USUARIOS E SENHA DO MYSQL
Será necessário, em primeiro lugar, parar o serviço do MySQL e iniciá-lo em safe mod (modo seguro). Para isso, execute os seguintes comandos:

# service mysqld stop

Inicie o serviço no modo seguro executando o comando abaixo:

# mysqld_safe --skip-grant-tables &

Agora, acesse o MySQL com o usuário root que não irá solicitar a senha e altere a senha do mesmo conforme informado abaixo:

# mysql -u root

Escolha a base de dados do MySQL:

> use mysql;

Agora rode o comando que irá alterar a senha do usuário root:

update user set plugin="mysql_native_password" where User='root';

<!-- update user set password=PASSWORD("123456") where User='root'; -->

Execute o comando para validar as alterações:

> flush privileges;

E em seguida, digite:

> quit

E para finalizar, será necessário apenas reiniciar o serviço do MySQL com o comando:

# service mysqld restart

Feito isso, você pode testar as alterações acessando o servidor novamente, utilizando a senha que você adicionou no MySQL da seguinte forma:

# mysql -u root -p


Pronto!




sudo apt install php7.4-sqlite3 <- comando para instalar a extensão certa

////////////////////////////////////////////////////////////////////////////////////////////////
Dockfile

FROM wyveo/nginx-php-fpm:latest

/**///////////////////////// */

version: '3'
services:
  laravel-app:
    build: .
    ports:
      - "8080:80"
    volumes:
      - ./:/usr/share/nginx
    networks:
      - app-network
  

  mysql-app:
    image: mysql:5.7.22
    ports:
      - "3306:3306"
    volumes:
      - .docker/dbdata:/var/lib/mysql
    environment:
      MYSQL_HOST: mysql
      MYSQL_DATABASE: laravel
      MYSQL_ROOT_PASSWORD: laravel
    networks:
      - app-network
    
networks:
    app-network:
      driver: bridge
   
    
   
CONFIGURAÇÃO DO SERVIDOR PRIVADO COM LAMP
DOWNLOAD DO COMPOSER PARA FAZER A INSTALAÇÃO DO LARAVEL
[root@server www] wget https://getcomposer.org/installer
[root@server www] php installer
[root@server www] php composer.phar create-project --prefer-dist laravel/laravel laraveltips
FAZ O BACKUP DO default
[root@server www] mv default/ default_bkp
FAZ O APONTAMENTO DA PASTA PUBLIC DO PROJETO
[root@server www] ln -s laveltips/ public default
LISTA TUDO 
[root@server www] ls -la 

[root@server www] chown -R apache:apache laraveltips/


[root@alberto laraveltips]# find * -type d -exec chmod 755 {} \;
[root@alberto laraveltips]# find * -type f -exec chmod 644 {} \;



/**************************************************************

CRIANDO PROJETO 
instalando composer:
* [root@alberto www]# wget https://getcomposer.org/installer
* [root@alberto www]# php composer.phar create-project --prefer-dist laravel/laravel app_locadora_carros
* [root@alberto www]# ln -s app_locadora_carros default


1-
C:\Users\alber\Documents\COMPOSER>composer create-project --prefer-dist laravel/laravel blog "7.0"

2- 
COMANDO PARA PODER FUNCIONAR COM INSTALLER
C:\Users\alber\Documents\COMPOSER>composer global require laravel/installer

C:\Users\alber\Documents\COMPOSER>laravel new projeto_laravel_via_installer

LOCAL DE INSTALAÇÃO:
variáveis de ambiente
Path -> C:/Users/alber/AppData/Roaming/Composer
OU
C:\Users\alber\AppData\Roaming\Composer\vendor\bin

CD COMPOSER>
CD public>
php -S localhost:8000

/********************************************
ARQUIVO WEB.PHP
 ROTA LARAVEL 8X

Route::get('/', [\App\Http\Controllers\PrincipalController::class, 'principal']);


//////////////////////////

<?php

use Illuminate\Support\Facades\Route;

/*
|--------------------------------------------------------------------------
| Web Routes
|--------------------------------------------------------------------------
|
| Here is where you can register web routes for your application. These
| routes are loaded by the RouteServiceProvider within a group which
| contains the "web" middleware group. Now create something great!
|
*/

// Route::get('/', function () {
//     return view('welcome');
// });


// Route::get('/', function () {
//     return 'Olá, seja bem vindo ao curso!!!!!';
// });


Route::get('/', [\App\Http\Controllers\PrincipalController::class, 'principal']);

Route::get('/sobre-nos', function () {
    return 'Sobre Nós...';
});


Route::get('/contato', function () {
    return 'Contato.';
});


/*****************************************************************
SINTAXE ARQUIVO.BLADE

<h3>Fornecedor</h3>

{{-- TAG DE COMENTÁRIOS DO BLADE--}}
{{ 'Texto de teste'}}



<?= 'Texto de teste 2' ?>

@php
    // PARA COMENTÁRIOS DE UMA LINHA
    /*
        PARA COMENTÁRIOS DE MÚLTIPLAS LINHAS
    */
    echo 'Texto de teste 3';
@endphp

 ->  AULA 125

chmod 777 -R nomedapasta/

ls -la

chown apache:apache nomedapasta

## Laravel Sponsors


# composer 
# php artisan serve --port=9000  => Roda a aplicação na porta especificada
#  
### PROJETO EM LARAVEL
ROTA DE CONTINGÊNCIA (FALLBACK)

Route::fallback(function() {
    echo 'A Rota acessada não existe.  <a href=" ' .route('site.index').' "> clique aqui </a> para retornar';
  });

### PASSANDO VALORES DA ROTA PARA O CONTROLLER
<?php

use Illuminate\Support\Facades\Route;


Route::get('/', [\App\Http\Controllers\PrincipalController::class, 'index'])->name('site.index');

Route::get('/sobre-nos', [\App\Http\Controllers\SobrenosController::class, 'sobrenos'])->name('site.sobrenos');

Route::get('/contato', [\App\Http\Controllers\ContatoController::class, 'contato'])->name('site.contato');



Route::get('/login', function (){ return 'Login'; })->name('site.login');


Route::prefix('/app')->group(function(){

    Route::get('/clientes', function (){ return 'Clientes'; })->name('app.clientes');
    Route::get('/fornecedores', function (){ return 'Fornecedores'; })->name('app.fornecedores');
    Route::get('/produtos', function (){ return 'Produtos'; })->name('app.produtos');

});

Route::get('/teste/{param1?}/{param2?}', [\App\Http\Controllers\TesteController::class, 'teste'])->name('teste');

Route::fallback(function() {
    echo 'A Rota acessada não existe.  <a href=" ' .route('site.index').' "> clique aqui </a> para retornar';
  });




CONTROLLER
<?php

namespace App\Http\Controllers;

use Illuminate\Http\Request;

class TesteController extends Controller
{
    public function teste(int $p1, int $p2) {
        echo 'A soma dos valores é: ' . $p1 + $p2;
    }
}


<?php

use Illuminate\Support\Facades\Route;
use App\Http\Controllers\UserController; 

Route::get('/', function(){
    return view('welcome');
});


Route::get('user/{user?}', [UserController::class, 'show'])->name('user');

CONTROLLER
<?php

namespace App\Http\Controllers;

use App\Models\User;
use Illuminate\Http\Request;

class UserController extends Controller
{
    public function show(User $user){
        
        return view('user', [
            'name' => 'Paulo',
            'user' => $user
        
        ]);       
    }
}

### PASSANDO VALORES DA ROTA PARA O CONTROLLER DAÍ PARA A VIEW
ROTA PASSANDO VALORES:
Route::get('/teste/{param1?}/{param2?}', [\App\Http\Controllers\TesteController::class, 'teste'])->name('teste');

CONTROLLER RECEBENDO VALORES:
<?php

namespace App\Http\Controllers;

use Illuminate\Http\Request;

class TesteController extends Controller
{
    public function teste(int $p1, int $p2) {
       // echo 'A soma dos valores é: ' . $p1 + $p2;
       //return view('site.teste', ['x' => $p1 , 'y' => $p2 ] );   // MÉTODO ARRAY ASSOCIATIVO: ATRIBUI A VARIÁVEL RECEBIDA PARA UMA STRING QUALQUER 'x' => $p1, 'y' => $p2
       return view('site.teste', compact('p1', 'p2'));              // MÉTODO COMPACT: RECEBE A VARIÁVEL COMO UMA STRING 'p1', 'p2' E PASSA PARA A VIEW NOVAMENTE COMO VARIÁVEL $p1, $p2
      // return  view('site.teste')->with('a', $p1)->with('b', $p2);  // MÉTODO WITH: ATRIBUI O VALOR DA VARIÁVEL A UMA STRING QUALQUER 'a', 'b' E ESSA STRING SERÁ PASSADA PARA A VIEW COMO UMA VARÍÁVEL $a,$b

    }
}


VIEW RECEBENDO VALORES:
<h1>Teste </h1>

{{ $x }} <br>
{{  $y }}

{{ $a }}    // MÉTODO WITH FICARIA ASSIM
{{ $b }}


### COMENTÁRIOS E CODIFICAÇÃO PHP NO BLADE:
<h2>Fornecedor</h2>

{{ 'Texto ou variável aqui'}} <br>

<?= 'Teste' $x ?>

{{-- Comentário no Blade --}}

@php
    // Comentários dentro de uma tab php no blade
   
    /*
        Comentários de múltiplas
        linhas...
    */

@endphp

### @if @elseif @else @endif

FornecedorController.php
<?php

namespace App\Http\Controllers;

use Illuminate\Http\Request;

class FornecedorController extends Controller
{
    public function index(){
        $fornecedores = ['Fornecedor 1'];

        return view('app.fornecedor.index', compact('fornecedores'));
    }
}
abaixo a view que recebe os valores do controller
****************************
view.blade.php


<h2>Fornecedor</h2>

@if(count($fornecedores) > 0 && count($fornecedores) <= 10)
    <h3>Existem alguns fornecedores cadastrados.
@elseif(count($fornecedores) > 10)
    <h3>São vários os fornecedores cadastrados</h3>
@else 
    <h3> Ainda não existem fornecedores cadastrados.</h3> 
@endif

 <?php

namespace App\Http\Controllers;

use Illuminate\Http\Request;

class FornecedorController extends Controller
{
    public function index(){
        $fornecedores = [
            0 => [
                'nome' => 'Fornecedor 1',
            'status' => 'N',
            'cnpj' => '00.000.000/0001/00'
            ],
            1 => [
                'nome' => 'Fornecedor 2',
                'status' => 'S',
                ]
            ];

        return view('app.fornecedor.index', compact('fornecedores'));
    }
}

<h2>Fornecedor</h2>
<?php
    echo 'ALBERTO <br>';
    if(isset($fornecedores)){
        echo 'existe com php puro'. '<hr>';
    }
?>
@unless(isset($x))
    <h2>Bloco com h2 - Não existe a 'x'</h2><br>
@endunless

@php
    if(isset($fornecedores))
    echo 'Bloco php endphp' . '<br>'
@endphp
 {{-- //@dd($fornecedores) --}}

{{ 'Fornecedor: '  }} <br>

<?= 'Teste' ?>

{{-- Comentário no Blade --}}

@php
    // Comentários dentro de uma tab php no blade
   
    /*
        Comentários de múltiplas
        linhas...
    */
@endphp

@if(count($fornecedores) > 0 && count($fornecedores) <= 10)
    <h3>Existem alguns fornecedores cadastrados.
@elseif(count($fornecedores) > 10)
    <h3>São vários os fornecedores cadastrados</h3>
@else 
    <h3> Ainda não existem fornecedores cadastrados.</h3> 
@endif
<hr>
@isset ($fornecedores[1]['cnpj'])
    CNPJ: {{ $fornecedorES[1]['cnpj'] }}
@unless  ($fornecedores[1]['cnpj'])
    Este fornecedor não tem CNPJ
@endunless
   
@endisset

<h2>Fornecedor</h2>
<?php
    echo 'ALBERTO <br>';
    if(isset($fornecedores)){
        echo 'existe com php puro'. '<hr>';
    }
?>
@unless(isset($x))
    <h2>Bloco com h2 - Não existe a 'x'</h2><br>
@endunless

@php
    if(isset($fornecedores))
    echo 'Bloco php endphp' . '<br>'
@endphp
 {{-- //@dd($fornecedores) --}}

{{ 'Fornecedor: '  }} <br>

<?= 'Teste' ?>

{{-- Comentário no Blade --}}

@php
    // Comentários dentro de uma tab php no blade
   
    /*
        Comentários de múltiplas
        linhas...
    */
@endphp

@if(count($fornecedores) > 0 && count($fornecedores) <= 10)
    <h3>Existem alguns fornecedores cadastrados.
@elseif(count($fornecedores) > 10)
    <h3>São vários os fornecedores cadastrados</h3>
@else 
    <h3> Ainda não existem fornecedores cadastrados.</h3> 
@endif
<hr>
@isset ($fornecedores[1]['cnpj'])
    CNPJ: {{ $fornecedorES[1]['cnpj'] }}
@endisset

@empty ($fornecedores[1]['cnpj'])
    -VAZIO
@endempty
<hr>
Operador condicional ternário:
## VALOR DEFAULT
<hr>
CNPJ: {{ $fornecedores[0]['cnpj'] ?? 'Não existe CNPJ' }}  // valor default

### CASE:
<h2>Fornecedor</h2>
<?php
    echo 'ALBERTO <br>';
    if(isset($fornecedores)){
        echo 'existe com php puro'. '<hr>';
    }
?>
@unless(isset($x))
    <h2>Bloco com h2 - Não existe a 'x'</h2><br>
@endunless

@php
    if(isset($fornecedores))
    echo 'Bloco php endphp' . '<br>'
@endphp
 {{-- //@dd($fornecedores) --}}

{{ 'Fornecedor: '  }} <br>

<?= 'Teste' ?>

{{-- Comentário no Blade --}}

@php
    // Comentários dentro de uma tab php no blade
   
    /*
        Comentários de múltiplas
        linhas...
    */
@endphp

@if(count($fornecedores) > 0 && count($fornecedores) <= 10)
    <h3>Existem alguns fornecedores cadastrados.
@elseif(count($fornecedores) > 10)
    <h3>São vários os fornecedores cadastrados</h3>
@else 
    <h3> Ainda não existem fornecedores cadastrados.</h3> 
@endif
<hr>
@isset ($fornecedores[1]['cnpj'])
    CNPJ: {{ $fornecedorES[1]['cnpj'] }}
@endisset

@empty ($fornecedores[1]['cnpj'])
    -VAZIO
@endempty
<hr>
Operador condicional ternário:
<hr>
CNPJ: {{ $fornecedores[0]['cnpj'] ?? 'Não existe CNPJ' }} <hr>  {{-- valor default --}}

@switch($fornecedores[1]['ddd'])
    @case ('11')
        - DDD: {{ $fornecedores[1]['ddd'] }} São Paulo - SP
        @break
    @case('32')
        - DDD: {{ $fornecedores[1]['ddd'] }} Juiz de Fora -MG
        @break
    @default
        Estado não informado
@endswitch

@@@ @for

<h2>Fornecedor</h2>
<?php
    echo 'ALBERTO <br>';
    if(isset($fornecedores)){
        echo 'existe com php puro'. '<hr>';
    }
?>
@unless(isset($x))
    <h2>Bloco com h2 - Não existe a 'x'</h2><br>
@endunless

@php
    if(isset($fornecedores))
    echo 'Bloco php endphp' . '<br>'
@endphp
 {{-- //@dd($fornecedores) --}}

{{ 'Fornecedor: '  }} <br>

<?= 'Teste' ?>

{{-- Comentário no Blade --}}

@php
    // Comentários dentro de uma tab php no blade
   
    /*
        Comentários de múltiplas
        linhas...
    */
@endphp

@if(count($fornecedores) > 0 && count($fornecedores) <= 10)
    <h3>Existem alguns fornecedores cadastrados.
@elseif(count($fornecedores) > 10)
    <h3>São vários os fornecedores cadastrados</h3>
@else 
    <h3> Ainda não existem fornecedores cadastrados.</h3> 
@endif
<hr>
@isset ($fornecedores[1]['cnpj'])
    CNPJ: {{ $fornecedores[1]['cnpj'] }}
@endisset

@empty ($fornecedores[1]['cnpj'])
    -VAZIO
@endempty
<hr>
Operador condicional ternário:
<hr>
CNPJ: {{ $fornecedores[0]['cnpj'] ?? 'Não existe CNPJ' }} <hr>  {{-- valor default --}}

@switch($fornecedores[1]['ddd'])
    @case ('11')
        - DDD: {{ $fornecedores[1]['ddd'] }} São Paulo - SP
        @break
    @case('32')
        - DDD: {{ $fornecedores[1]['ddd'] }} Juiz de Fora -MG
        @break
    @default
        Estado não informado
@endswitch

<hr>FOR: <br>


 @for ($i = 0 ; isset($fornecedores[$i]); $i++)
    Fornecedor:  {{ $fornecedores[$i]['nome'] }}  <br>
    Status:     {{ $fornecedores[$i]['status']}}  <br>
    DDD:     {{ $fornecedores[$i]['ddd']}}  <br>
    telefone:     {{ $fornecedores[$i]['telefone']}}  <hr>

    @endfor

### @WHILE
<h2>Fornecedor</h2>
<?php
    echo 'ALBERTO <br>';
    if(isset($fornecedores)){
        echo 'existe com php puro'. '<hr>';
    }
?>
@unless(isset($x))
    <h2>Bloco com h2 - Não existe a 'x'</h2><br>
@endunless

@php
    if(isset($fornecedores))
    echo 'Bloco php endphp' . '<br>'
@endphp
 {{-- //@dd($fornecedores) --}}

{{ 'Fornecedor: '  }} <br>

<?= 'Teste' ?>

{{-- Comentário no Blade --}}

@php
    // Comentários dentro de uma tab php no blade
   
    /*
        Comentários de múltiplas
        linhas...
    */
@endphp

@if(count($fornecedores) > 0 && count($fornecedores) <= 10)
    <h3>Existem alguns fornecedores cadastrados.
@elseif(count($fornecedores) > 10)
    <h3>São vários os fornecedores cadastrados</h3>
@else 
    <h3> Ainda não existem fornecedores cadastrados.</h3> 
@endif
<hr>
@isset ($fornecedores[1]['cnpj'])
    CNPJ: {{ $fornecedores[1]['cnpj'] }}
@endisset

@empty ($fornecedores[1]['cnpj'])
    -VAZIO
@endempty
<hr>
Operador condicional ternário:
<hr>
CNPJ: {{ $fornecedores[0]['cnpj'] ?? 'Não existe CNPJ' }} <hr>  {{-- valor default --}}

@switch($fornecedores[1]['ddd'])
    @case ('11')
        - DDD: {{ $fornecedores[1]['ddd'] }} São Paulo - SP
        @break
    @case('32')
        - DDD: {{ $fornecedores[1]['ddd'] }} Juiz de Fora -MG
        @break
    @default
        Estado não informado
@endswitch

<hr>FOR: <br>

 @for ($i = 0 ; isset($fornecedores[$i]); $i++)
    Fornecedor:  {{ $fornecedores[$i]['nome'] }}  <br>
    Status:     {{ $fornecedores[$i]['status']}}  <br>
    DDD:     {{ $fornecedores[$i]['ddd']}}  <br>
    telefone:     {{ $fornecedores[$i]['telefone']}}  <hr>

 @endfor
<hr> WHILE <hr>

@php $i = 0 @endphp
    @while (isset($fornecedores[$i]))
        Fornecedor:  {{ $fornecedores[$i]['nome'] }}  <br>
        Status:     {{ $fornecedores[$i]['status']}}  <br>
        DDD:     {{ $fornecedores[$i]['ddd']}}  <br>
        telefone:     {{ $fornecedores[$i]['telefone']}}  <br>
        @php $i++ @endphp
    @endwhile
<hr>

<hr>
FOREACH

FOREACH - Gera uma cópia do valor original <br>

@foreach ($fornecedores as $indice => $fornecedor)
  Fornecedor: {{ $fornecedor['nome']}} <br>
  Status: {{ $fornecedor['status'] }} <br>
  CNPJ: {{ $fornecedor['cnpj'] ?? '' }} <br>
  Telefone: ({{ $fornecedor['dd'] ?? '' }})  {{ $fornecedor['telefone'] ?? '' }} <br> <hr>

@endforeach

### @forelse
### FornecedorController.php
$fornecedores =[];
### index.blade.php

@forelse ($fornecedores as $indice => $fornecedor)
  Fornecedor: {{ $fornecedor['nome']}} <br>
  Status: {{ $fornecedor['status'] }} <br>
  CNPJ: {{ $fornecedor['cnpj'] ?? '' }} <br>
  Telefone: ({{ $fornecedor['dd'] ?? '' }})  {{ $fornecedor['telefone'] ?? '' }} <br> <hr>
@empty
        Não existem Registros

@endforelse


### ESCAPANDO A FORMA DE IMPRESSÃO
  Fornecedor: @{{ $fornecedor['nome']}} <br>
  Status: @{{ $fornecedor['status'] }} <br>
  CNPJ: @{{ $fornecedor['cnpj'] ?? '' }} <br>

### OBJETO LOOP CRIADO AUTOMATICAMENTE QUANDO USAMOS FOREACH E FORELSE
<h2>Fornecedor</h2>
### OBJETO LOOP -> Existe em @foreach e @forelse
    
@endforeach
@forelse ($fornecedores as $indice => $fornecedor)
@dd($loop)
    @if($loop->first)
        => Aqui é a primeira iteração do loop  
    @endif
    Iteração Atual: -> {{ $loop->iteration }}<br>
    Fornecedor: {{ $fornecedor['nome']}} <br>
    Status: {{ $fornecedor['status'] }} <br>
    CNPJ: {{ $fornecedor['cnpj'] ?? '' }} <br>  
    @if($loop->last)
        => Aqui é a última iteração do loop <hr>
    @else 
        <hr>
    @endif
@empty
    Telefone: ({{ $fornecedor['dd'] ?? '' }})  {{ $fornecedor['telefone'] ?? '' }} <br>  <hr>
        Não existem Registros

@endforelse


### LIMPAR AS VIEWS COMPILADAS NO CACHE 

php artisan view:clear

### ASSETS => Tudo aquilo que complementa os arquivos html ou a página web a pasta de assets(arquivos js, css, imagens, sons, etc ficam em /public do projeto)

  <body>
        <div class="topo">

            <div class="logo">
                <img src="img/logo.png">
                <img src="{{ asset('img/logo.png') }}">
            </div>

### CSS externo
  <link rel="stylesheet" href="{{asset('css/estilo_basico.css')}}" >

### layout_principal.php
<!DOCTYPE html>
<html lang="pt-br">
    <head>
        <title>Super Gestão - Sobre Nós</title>
        <meta charset="utf-8">

      <link rel="stylesheet" href="{{asset('css/estilo_basico.css')}}" >
       
    </head>

    <body>
        @yield('conteudo')
    </body>
</html>

### principal.php  /  contato.php / outras_paginas.php
@extends('site.layouts.basico')

@section('conteudo')
        <div class="topo">

            <div class="logo">
                <img src="{{asset('img/logo.png')}}">
            </div>

            <div class="menu">
                <ul>
                    <li><a href="{{ route('site.index') }}">Principal</a></li>
                    <li><a href="{{ route('site.sobrenos') }}">Sobre Nós</a></li>
                    <li><a href="{{ route('site.contato') }}">Contato</a></li>
                </ul>
            </div>
        </div>
 @endsection  

 ### PASSANDO PARÂMETROS PARA O LAYOUT PRINCIPAL
layout_principal.php
 @extends('site.layouts.basico')

@section('titulo', 'Página Principal')
@section('conteudo')
        <div class="topo">

            <div class="logo">
                <img src="img/logo.png">
            </div>

            <div class="menu">
                <ul>
                    <li><a href="{{ route('site.index') }}">Principal</a></li>
                    <li><a href="{{ route('site.sobrenos') }}">Sobre Nós</a></li>
                    <li><a href="{{ route('site.contato') }}">Contato</a></li>
                </ul>
            </div>
        </div>
@endsection

contato.php
@extends('site.layouts.basico')

@section('titulo', 'Contato')
@section('conteudo')
        <div class="topo">

            <div class="logo">
                <img src="{{asset('img/logo.png')}}">
            </div>
@endsection

sobre-nos.php
@extends('site.layouts.basico')

@section('titulo', 'Sobre Nos')
@section('conteudo')
        <div class="topo">

            <div class="logo">
                <img src="{{asset('img/logo.png')}}">
            </div>

            <div class="menu">
                <ul>
                    <li><a href="{{ route('site.index') }}">Principal</a></li>
                    <li><a href="{{ route('site.sobrenos') }}">Sobre Nós</a></li>
                    <li><a href="{{ route('site.contato') }}">Contato</a></li>
                </ul>
            </div>
      </div>
@endsection

######## Se quiser receber parâmetros vindo da view
CotatoController.php
<?php
namespace App\Http\Controllers;
use Illuminate\Http\Request;
class ContatoController extends Controller
{
    public function contato() {
        return view('site.contato', ['titulo' => 'Contato - titulo vindo do controlador']);
    }
}

/*** */
View recebendo parâmetro vindo do controlador 
contato.blade.php
@extends('site.layouts.basico')

@section('titulo', $titulo)
@section('titulo', 'Contato')
@section('conteudo')
        <div class="topo">




### INCLUINDO PÁGINAS include (é literalmente uma inclusão)

 @include('site.layouts._partials.topo')

### ENVIANDO O FORMULÁRIO DE CONTATO
form.blade.php
<form action={{ route('site.contato') }} method="get" > 
        <input type="text" name="nome" placeholder="Nome" class="borda-preta">
        <br>
        <input type="text" name="telefone" placeholder="Telefone" class="borda-preta">
        <br>
        <input type="text" name="email" placeholder="E-mail" class="borda-preta">
        <br>
        <select class="borda-preta">
            <option value="">Qual o motivo do contato?</option>
            <option value="1">Dúvida</option>
            <option value="2">Elogio</option>
            <option value="3">Reclamação</option>
        </select>
        <br>
        <textarea name="mensagem" class="borda-preta">Preencha aqui a sua mensagem</textarea>
        <br>
        <button type="submit" class="borda-preta">ENVIAR</button>
    </form>

web.php

Route::get('/contato', [\App\Http\Controllers\ContatoController::class, 'contato'])->name('site.contato');                    

ContatoController.php
<?php

namespace App\Http\Controllers;

use Illuminate\Http\Request;

class ContatoController extends Controller
{
    public function contato() {

        var_dump($_GET);
        return view('site.contato', ['titulo' => 'Contato - titulo vindo do controlador'], ['teste' => 'Alberto Gomes']);
    }
}




/**************** */
BLADE.PHP
<h1>Passando variável direto: {{ $name }} </h1>
<hr>
<h1>Listando o Retorno da Model User</h1>
<h2>{{ $user }} </h2>
<p>Selecionando o nome fica: {{ $user->name }} </p>
<p>Selecionando o Email fica: {{ $user->email }} </p>

DATABASE SEED
class DatabaseSeeder extends Seeder
{
    /**
     * Seed the application's database.
     *
     * @return void
     */
    public function run()
    {
        \App\Models\User::factory(10)->create();

        //  \App\Models\User::factory()->create([
        //      'name' => 'Test User',
        //      'email' => 'test@example.com',
        //  ]);
    }
}

## REDIRECIONAMENTO DE ROTAS
web.php

Route::get('/rota1', function(){
    echo 'Rota 1';
})->name('site.rota1');
Route::get('/rota2', function(){
    //echo 'Rota 2';
    return redirect()->route('site.rota1');
})->name('site.rota2');

//Route::redirect('/rota2', 'rota1');


### MÉTODO POST -> Exige o csrf (CROSS-SITE REQUEST FORGERY ou falsificação de solicitação entre sites)

<form action={{ route('site.contato') }} method="post" > 
@csrf
    <input type="text" name="nome" placeholder="Nome" class="borda-preta">
    <br>
    <input type="text" name="telefone" placeholder="Telefone" class="borda-preta">
    <br>
    <input type="text" name="email" placeholder="E-mail" class="borda-preta">
    <br>
    <select class="borda-preta">
        <option value="">Qual o motivo do contato?</option>
        <option value="1">Dúvida</option>
        <option value="2">Elogio</option>
        <option value="3">Reclamação</option>
    </select>
    <br>
    <textarea name="mensagem" class="borda-preta">Preencha aqui a sua mensagem</textarea>
    <br>
    <button type="submit" class="borda-preta">ENVIAR</button>
</form>

ContatoController.php
<?php

namespace App\Http\Controllers;

use Illuminate\Http\Request;

class ContatoController extends Controller
{
    public function contato() {

    use    var_dump($_POST);
    ou     dd($_POST);
        return view('site.contato', ['titulo' => 'Contato - titulo vindo do controlador'], ['teste' => 'Alberto Gomes']);
    }
}

### incluindo views ou partials @components
 @component('site.layouts._components.form_contato')
@endcomponent

### passando parâmetros por @components

   @component('site.layouts._components.form_contato')
                        <p>A nossa equipe analisará a sua mensagem e retornaremos o mais brevemente possível.</p>
                        <p> Nosso tempo médio de resposta é de 48horas.</p>
@endcomponent

NO COMPONENTE ADICIONAMOS A TAG {{ slot }} :
{{ $slot }}
<form action={{ route('site.contato') }} method="post" > 
            @csrf
            <input type="text" name="nome" placeholder="Nome" class="borda-preta">
            <br>
            <input type="text" name="telefone" placeholder="Telefone" class="borda-preta">
            <br>
            <input type="text" name="email" placeholder="E-mail" class="borda-preta">
            <br>
            <select class="borda-preta">
                <option value="">Qual o motivo do contato?</option>
                <option value="1">Dúvida</option>
                <option value="2">Elogio</option>
                <option value="3">Reclamação</option>
            </select>
            <br>
            <textarea name="mensagem" class="borda-preta">Preencha aqui a sua mensagem</textarea>
    <br>
    <button type="submit" class="borda-preta">ENVIAR</button>
</form>

principal.blade.php

@extends('site.layouts.basico')


@section('titulo', 'Página Principal')
@section('conteudo')
      {{-- @include('site.layouts._partials.topo') --}}
 
        <div class="conteudo-destaque">
        
            <div class="esquerda">
                <div class="informacoes">
                    <h1>Sistema Super Gestão</h1>
                    <p>Software para gestão empresarial ideal para sua empresa.<p>
                    <div class="chamada">
                        <img src="{{asset('/img/check.png') }}">
                        <span class="texto-branco">Gestão completa e descomplicada</span>
                    </div>
                    <div class="chamada">
                        <img src="{{asset('img/check.png') }}">
                        <span class="texto-branco">Sua empresa na nuvem</span>
                    </div>
                </div>

                <div class="video">
                    <img src="{{asset('img/player_video.jpg') }} ">
                </div>
            </div>

            <div class="direita">
                <div class="contato">
                    <h1>Contato</h1>
                    <p>Caso tenha qualquer dúvida por favor entre em contato com nossa equipe pelo formulário abaixo.<p>
                     @component('site.layouts._components.form_contato')
                        <h3> Entraremos em contato: aguarde 48 hs. </h3>
                    @endcomponent
                </div>
            </div>
        </div>
  @endsection

  ### SEGUNDA FORMA DE ENVIAR PARÂMETROS POR COMPONENTES @component

  principal.blade.php

    <h1>Contato</h1>
                    <p>Caso tenha qualquer dúvida por favor entre em contato com nossa equipe pelo formulário abaixo.<p>
                     @component('site.layouts._components.form_contato', ['x' => 10])
                        <h3> Entraremos em contato: aguarde 48 hs. </h3>
@endcomponent

ou 

 <p>Caso tenha qualquer dúvida por favor entre em contato com nossa equipe pelo formulário abaixo.<p>
                     @component('site.layouts._components.form_contato', ['x' => 'Entraremos em contato: aguarde 48 hs.'])
                      
                    @endcomponent


form_contato.ph
    {{ $slot }}
    {{ $x }}


    /************ */

contato.blade.php

@component('site.layouts._components.form_contato', ['x' => '48 horas.'])
    <p>A nossa equipe analisará a sua mensagem e retornaremos o mais brevemente possível.</p>
    <p> Nosso tempo médio de resposta é de</p>
@endcomponent

form_contato.blade.php
{{ $slot }}

{{ $x }}
<form action={{ route('site.contato') }} method="post" > 
    @csrf
    <input type="text" name="nome" placeholder="Nome" class="borda-preta">
    <br>
    <input type="text" name="telefone" placeholder="Telefone" class="borda-preta">
    <br>
    <input type="text" name="email" placeholder="E-mail" class="borda-preta">
    <br>
    <select class="borda-preta">
        <option value="">Qual o motivo do contato?</option>
        <option value="1">Dúvida</option>
        <option value="2">Elogio</option>
        <option value="3">Reclamação</option>
    </select>
    <br>
    <textarea name="mensagem" class="borda-preta">Preencha aqui a sua mensagem</textarea>
<br>
<button type="submit" class="borda-preta">ENVIAR</button>
</form>



### CRIANDO UMA MODEL E SUA MIGRATION
>php artisan make:model SiteContato -m

Dica - Resolvendo problema do php artisan migrate
Dica importante para próxima aula enviada pelo João Vitor Moraski. A dica se aplica a você caso você esteja utilizando o sistema operacional Linux na distro Ubuntu 20.04:



Tive um problema onde sempre que tentava executar a migrate aparecia algo do tipo could not find drive (SQL: PRAGMA foreign_keys = on;).

Algumas pessoas conseguem resolver o erro tirando o ";" de trás da escrita 'extension:pdo_sqlite' no php.ini. O arquivo php ini pode ser localizado por meio do comando php -i | grep 'php.ini' ou pelo comando php --ini (os comandos devem ser executado na linha de comando do sistema operacional).

Porém, se o procedimento acima não funcionar, tente realizar a instalação da extensão em seu sistema operacional. No meu caso, na versão 20.04 do Ubuntu, ocorreu que a extensão não estava instalada por padrão. O comando utilizado na linha de comando do sistema operacional para instalar a extensão é:

sudo apt install php7.4-sqlite3 <- comando para instalar a extensão certa

### SQLITE -> IDEAL PARA PEQUENOS PROJETOS SEM SEGURANÇA. /config/database.php (classe das configurações) -> alterções são feitas em .ven 
linha9 DB_CONNECTION=sqlite

Se DB_DATABASE não estiver configurada ele adotará o padrão.. Bastando criar um arquivo /database/database.sqlit Dentro da pasta database do projeto.

### Testa se o PDO está carregado:
>php -r "var_dump(extension_loaded('pdo_mysql'));" 

bool(true)




### CRIANDO E EXCECUTANDO migrations
2022_10_29_124933_create_site_contatos_table.php

<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     *
     * @return void
     */
    public function up()
    {
        Schema::create('site_contatos', function (Blueprint $table) {
            $table->id();
            $table->string('nome', 50);
            $table->string('telefone', 20);
            $table->string('email', 80);
            $table->integer('motivo_contato');
            $table->text('mensagem');
            $table->timestamps();
        });
    }

    /**
     * Reverse the migrations.
     *
     * @return void
     */
    public function down()
    {
        Schema::dropIfExists('site_contatos');
    }
};
 > php artisan migrate

 ### Criando Model e Migration uma de cada vez
>php artisan make:model Fornecedor 

>php artisan make:migration create_fornecedores_table

<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     *
     * @return void
     */
    public function up()
    {
        Schema::create('fornecedores', function (Blueprint $table) {
            $table->id();
            $table->string('nome', 50);
            $table->timestamps();
        });
    }
>php artisan migrate
 ### MIGRATION: Adicionando campos a uma tabela já existente (MÉTODO UP) e DESFAZENDO AS ADIÇÕES (MÉTOD DOWN):
 ==> COMANDOS: 
 * Executar a criação das tabelas: php artisan migrate -> acontece da mais antiga para a mais atual
 * Reverter as migrações: php artisan migrate:rollback -> acontece da mais atual para a mais antiga
 * Podemos indicar quantos passos(sterps) podemos reverter ou quantas migrates queremos reverter: 
    > php artisan migrate:rollback  ou php artisan migrate:rollback --step=2
    > php artisan migrate -> Executa novamente todas as migrations recriando as tabelas e colunas.

 - php artisan make:migration alter_fornecedores_novas_colunas

2022_10_30_144326_alter_fornecedores_novas_colunas.php
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     *
     * @return void
     */
    public function up()
    {
        // CRIANDO NOVA COLUNAS NA TABELA
        Schema::table('fornecedores', function (Blueprint $table) {
            $table->string('uf', 2);
            $table->string('email', 150);
        });
    }

    /**
     * Reverse the migrations.
     *
     * @return void
     */
    public function down()
    {
        // PARA REMOVER AS COLUNAS CRIADA NO MÉTODO UP
        Schema::table('fornecedores', function (Blueprint $table) {
           // $table->$table->dropColumn('uf');
           // $table->dropColumn('email'); ou podemos usar apenas o comando abaixo passando um array de colunas
            $table->dropColumn(['uf', 'email']);
        });
    }
};

### CRIANDO A MIGRATION 2022_10_30_151416_create_produtos_table.php COM VALORES NULOS E DEFAULT (VALOR PADRÃO):
> php artisan make:migration create_produtos_table <ENTER>
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     *
     * @return void
     */
    public function up()
    {
        Schema::create('produtos', function (Blueprint $table) {
            $table->id();
            $table->string('nome', 100);
            $table->text('descricao')->nullable();
            $table->integer('peso')->nullable();
            $table->float('preco_venda', 8, 2)->default(0.01);
            $table->integer('estoque_minimo')->default(1);
            $table->integer('estoque_maximo')->default(1);
            $table->timestamps();
        });
    }

    /**
     * Reverse the migrations.
     *
     * @return void
     */
    public function down()
    {
        Schema::dropIfExists('produtos');
    }
};
### EXECUTANDO A MIGRATION CRIADA:
> php artisan migrate







### CRIANDO MIGRATIONS COM RELACIONAMENTOS DE TABELAS
> php artisan make:migration create_produto_detalhes_table
2022_10_30_152706_create_produtos_detalhes_table.php

 * Para fazer o relacionamento de um para um entre tabelas, a chave primária de uma das tabelas do relacionamento, viage para a 
   outra tabela e lá, essa chave primária que viajou, seja recebida como chave estrageira. Vale lembra que no relacionamento de um para um tanto faz qual a tabela que vai receber a chave estrageira, mais o ideal, por convenção, o indicado é que a chave 
   primária da tabela mais forte do relacionamento, ou seja, aquela tabela que tem mais impacto no negócio, viage como chave 
   estrangeira para a tabela mais fraca do relacionamento, ou seja, aquela que tem menos impacto do ponto de vista do negócio.
   Sendo assim a tabela produto_detalhes tem que ter uma nova coluna "produto_id" para receber a chave primária da tabela "produtos":

<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     *
     * @return void
     */
    public function up()
    {
        Schema::create('produto_detalhes', function (Blueprint $table) {
            // Colunas
            $table->id();

            $table->unsignedBigInteger('produto_id'); // Por convensão usamos o singular do nome da tabela que envia a chave e o nome da coluna

            $table-> float('comprimento', 8, 2);
            $table-> float('largura', 8, 2);
            $table-> float('altura', 8, 2);

            $table->timestamps();

            // Constraint de de integridade referencial
            $table->foreign('produto_id')->references('id')->on('produtos');
            // Constraint para garantir que não tenha valor repetido
            $table->unique('produto_id');
        });
    }

    /**
     * Reverse the migrations.
     *
     * @return void
     */
    public function down()
    {
        Schema::dropIfExists('produto_detalhes');
    }
};

>php artisan migrate

### Migration - Adicionando Chaves Estrangeiras (Relacionamento de um para muitos):
### MÉTODOS UP E MÉTODO DOWN
>php artisan make:migration create_unicades_table
2022_10_30_163254_create_unidades_table.php

<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     *
     * @return void
     */
    public function up()
    {
        Schema::create('unidades', function (Blueprint $table) {
            $table->id();
            $table->string('unidade', 5);
            $table->string('decricao', 30);
            $table->timestamps();

        
        });

            // adicionar o relacionamento com a tabela produtos
        Schema::table('produtos', function (Blueprint $table) {
            $table->unsignedBigInteger('unidade_id');
            $table->foreign('unidade_id')->references('id')->on('unidades');
        });
        
        // RELACIONAMENTOS NECESSÁRIOS (vamos usar a mesma migration)
        // adicionar o relacionamento com a tabela produtos_detalhes
        Schema::table('produto_detalhes', function (Blueprint $table) {
            $table->unsignedBigInteger('unidade_id');
            $table->foreign('unidade_id')->references('id')->on('unidades');
        });

       
    }

    /**
     * Reverse the migrations.
     *
     * @return void
     */
    public function down()
    {
        /* DESFAZENDO TUDO FEITO NO MÉTODO UP */
        // REMOVENDO AS CHAVES ESTRANGEIRAS
        // adicionar o relacionamento com a tabela produtos_detalhes
        Schema::table('produto_detalhes', function(Blueprint $table) {
            // remover a forekey(fk)
            $table->dropForeign('produto_detalhes_unidade_id_foreign');   // [table]_[coluna]_foreign ->verificar o nome criado na tablela
            
            // remover a coluna unidade_id
            $table->dropColumn('unidade_id');
            
        });
        
       
        // remover o relacionamento com a tabela produtos
        Schema::table('produtos', function(Blueprint $table) {
            // remover a forekey(fk)
            $table->dropForeign('produtos_unidade_id_foreign');   // [table]_[coluna]_foreign ->verificar o nome criado na tablela
            
            // remover a coluna unidade_id
            $table->dropColumn('unidade_id');
            
        });

        Schema::dropIfExists('unidades');
    }
};

### >php artisan migrate                -> EXECUTA TODOS OS MÉTODO UP CRIANDO AS TABELAS NO BANCO DE DADOS
### >php artisan migrate:rollback       -> DESFAZ TODOS OS MÉTODOS DOWN DESFAZENDO AS TABELAS DO BANCO DE DADOS

>php artisan migrate:rollback 

### ESTRUTURA DAS TABELAS PRODUTOS, UNIDADES E PRODUTO_DETALHES
Table: produtos
Columns:
id bigint(20) UN AI PK 
nome varchar(100) 
descricao text 
peso int(11) 
preco_venda double(8,2) 
estoque_minimo int(11) 
estoque_maximo int(11) 
created_at timestamp 
updated_at timestamp 
unidade_id bigint(20) UN

Table: unidades
Columns:
id bigint(20) UN AI PK 
unidade varchar(5) 
decricao varchar(30) 
created_at timestamp 
updated_at timestamp

Table: produto_detalhes
Columns:
id bigint(20) UN AI PK 
produto_id bigint(20) UN 
comprimento double(8,2) 
largura double(8,2) 
altura double(8,2) 
created_at timestamp 
updated_at timestamp 
unidade_id bigint(20) UN

Table: unidades
Columns:
id bigint(20) UN AI PK 
unidade varchar(5) 
decricao varchar(30) 
created_at timestamp 
updated_at timestamp

### ADICIONANDO CHAVE ESTRANGEIRAS - RELACIONAMENTO MUITOS PARA MUITOS -> Este tipo de relacionamento sempre envolve uma terceira tabela: vamos criar a tabela filiais e produto_filiais e estabelecer este relacionamento:
php artisan make:migration ajuste_produtos_filiais

2022_10_30_175104_ajuste_produtos_filiais.php

<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     *
     * @return void
     */
    public function up()
    {
        //Criando a tabela filiais
        Schema::create('filiais', function (Blueprint $table) {
            $table->id();
            $table->string('filial', 30);
            $table->timestamps();
        });
       
        //Criando a tabela produto_filiais
        Schema::create('produto_filiais', function (Blueprint $table) {
            $table->id();
            $table->unsignedBigInteger('filial_id');
            $table->unsignedBigInteger('produto_id');
            $table->decimal('preco_venda', 8, 2);
            $table->integer('estoque_minimo');
            $table->integer('estoque_maximo');
            $table->timestamps();

            //  Constraint de Relacionamentos - foreign key
            $table->foreign('filial_id')->references('id')->on('filiais');
            $table->foreign('produto_id')->references('id')->on('produtos');
        });

        // Removendo colunas da tabela produtos
        Schema::table('produtos', function (Blueprint $table) {
           $table->dropColumn(['preco_venda', 'estoque_minimo', 'estoque_maximo']);
        });
    }

    /**
     * Reverse the migrations.
     *
     * @return void
     */
    public function down()
    {
        // Recriando as colunas da tabela produtos
        Schema::table('produtos', function (Blueprint $table) {
            $table->decimal('preco_venda', 8, 2)->default(0.01);
            $table->integer('estoque_minimo')->default(1);
            $table->integer('estoque_maximo')->default(1);
         });

         Schema::dropIfExists('produto_filiais');

         Schema::dropIfExists('filiais');
    }
};
### TESTANDO AS MIGRATES
>php artisan migrate
>php artisan migrate:rollback

### MIGRATION -> MODIFICADOR After: Permite que novas colunas sejam inseridas em pontos específicos de uma coluna pre existente: após(after) uma coluna já existente: 'uf' e 'email' que foram colunas adicionadas na tabela 'fornecedores' ficaram no final, vamos criar então uma nova coluna 'site' na tabela 'fornecedores' e indicar a posição que será criada:
>php artisan make:migration nova_coluna_site_com_after

2022_10_30_182603_nova_coluna_site_com_after.php

<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     *
     * @return void
     */
    public function up()
    {
        //
        Schema::table('fornecedores', function (Blueprint $table) {
            $table->string('site', 150)->after('nome')->nullable()->default('https://www.albertogomesdasilva.com.br');
        });
    }

    /**
     * Reverse the migrations.
     *
     * @return void
     */
    public function down()
    {
        //
        Schema::table('fornecedores', function (Blueprint $table) {
            $table->dropColumn('site');
        });

    }
};

### COMANDOS MIGRATIONS: STATUS, RESET, REFRESH E FRESH
- >php artisan migrate:status -> Verifica se a migration já foi executada;
- >php artisan migrate:reset -> Executa todos os métodos down da mais atual para a mais antiga e retorna o status das migrations para pedente- apaga o banco de dados por completo;
- >php artisan migrate:refresh -> Reverte todas as migrations e na sequência executa todos os métodos up - apaga o banco de dados e na sequência recria;
- >php artisan migrate:fresh -> Dropa o banco de dados e executa todas as migrations - zera os id's das tabelas do banco de dados;

### ENTENDENDO O ELOQUENT ORM -> Object Relacional Maping nativo do Framework Laravel. O ORM (Mapeamento Objeto Relacional ) é uma técnica para aproximar o paradigma de desenvolvimento de aplicações orientadas a objetos com um banco de dados relacional ( Orientação a Objetos <==> Banco de Dados Relacional). As bibliotecas e frameworks definem como os dados serão mapeados entre os dois ambientes possibilitando o CRUD dimiundo significativamente o tempo de desenvolvimento de aplicações utilizando os recursos do ORM que independente de linguagem de programação. Atualmente dois padrões se destacam no mercado: Data Mapper e Active Record. O Framework Laravel o ORM Eloquente segue o padrão Active Record.

### TINKER -> É um a ferramenta nativa do framework Laravel, é um console interativo que possibilita o acesso as classes do projeto através do terminal. Através do Tinker podemos facilmente manipular as classes relativas aos Models do projeto, podemos instanciar as classes e executar os métodos dos objetos instanciados e os métodos estáticos também, podemos também testar o Mapeamento Objeto Relacional entre as classes relativas ao Models do projeto e o Banco de Dados. Sem o Tinker precisaremos usar uma interface previamente criada ou diretamente no banco de dados, ou através de um script para esse propósito. O Tinker é um atalho para testarmos os Models com o Eloquent ORM fazendo a persistência de dados no banco.
### INSERINDO REGISTROS NO BANCO
>php artisan tinker
Psy Shell v0.11.8 (PHP 8.1.11 — cli) by Justin Hileman
>>> $contato = new SiteContato                                                 
[!] Aliasing 'SiteContato' to 'App\Models\SiteContato' for this Tinker session.
=> App\Models\SiteContato {#3680}

>>> $contato->nome = 'Alberto'                                                 
=> "Alberto"

>>> $contato->telefone = '98981188434'                                         
=> "98981188434"

>>> $contato->email = 'albertoogmesdasilva@gmail.com'                          
=> "albertoogmesdasilva@gmail.com"

>>> $contato->motivo_contato = 1                                               
=> 1

>>> $contato->mensagem = 'Olá. Gostaria de maiores detalhes..'                 
=> "Olá. Gostaria de maiores detalhes.."    
>>> print_r($contato->getAttributes())                                         
Array
(
    [nome] => Alberto
    [telefone] => 98981188434
    [email] => albertoogmesdasilva@gmail.com
    [motivo_contato] => 1
    [mensagem] => Olá. Gostaria de maiores detalhes..
)
=> true

>>> $contato->save()                                                           
=> true
### INSERINDO NOVO REGISTRO COM TINKER
>>> $contato2 = new SiteContato();                                             
=> App\Models\SiteContato {#4017}

>>> $contato2->nome = 'Maria'                                                  
=> "Maria"

>>> $contato2->telefone = '98998887777'                                        
=> "98998887777"

>>> $contato2->email = 'maria@gmail.com'                                       
=> "maria@gmail.com"

>>> $contato2->mensagem = 'tudo ok..'                                          
=> "tudo ok.."

>>> $contato2->motivo_contato = 2                                              
=> 2

>>> print_r($contato2->getAttributes())                                        
Array
(
    [nome] => Maria
    [telefone] => 98998887777
    [email] => maria@gmail.com
    [mensagem] => tudo ok..
    [motivo_contato] => 2
)
=> true

>>> $contato2->save()                                                          
=> true

### AJUSTANDO O NOME DA TABELA NO MODEL PARA UM CORRETO ORM
* MODEL: SiteContato.php  ==> site_contato -> nome da tabela no banco de dados.
* MODEL: Fornecedor.php   ==> fornecedores -> nome da tabela no banco -> Neste caso vamos tentar salvar com o tinker na tabela fornecedores irá gerar um erro:
>>> $f->save()                                                                 
Illuminate\Database\QueryException with message 'SQLSTATE[42S02]: Base table or view not found: 1146 Table 'sg.fornecedors' doesn't exist (SQL: insert into `fornecedors` (`nome`, `site`, `uf`, `email`, `updated_at`, `created_at`) values (Fornecedor XYZ, http://fornecedorxyz.com.br, MA, fornecedorxyz@gmail.com.br, 2022-10-30 19:53:51, 2022-10-30 19:53:51))'

para corrigir isto no Model Fornecedor.php incluiremos a linha 
    protected $table = 'fornecedores';


<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;

class SiteContato extends Model   //site_contato -> nome da tabela no banco de dados.
{
    use HasFactory;
    protected $table = 'fornecedores';  // Ajustar quando o ORM não consegue salvar na tabela.

}


### SALVANDO NO BANCO DE DADOS USANDO O MÉTODO ESTÁTICO HERDADO DA CLASSE MODEL - CREATE (não depende da instância do objeto -> seu uso é mais comum - já usamos na criação das migrations.)
PARA ISSO ACRESCENTAMOS UMA LINHA DE PERMISSÃO PARA INSERÇÃO DE DADOS NO BANCO:   protected $fillable = ['nome', 'site', 'uf', 'email'];
Fornecedor.php
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;

class Fornecedor extends Model
{
    use HasFactory;
    protected $table = 'fornecedores';

    protected $fillable = ['nome', 'site', 'uf', 'email'];

}


>php artisan tinker

Psy Shell v0.11.8 (PHP 8.1.11 — cli) by Justin Hileman
>>> Fornecedor::create(['nome'=>'Fornecedro ABC', 'site'=>'fornecedor.com.br', 'uf'=>'SP', 'email'=>'contato@abc.com.br']) 

* OBS.: QUALQUER ERRO SAI DO TINKER COM 'quit' e retorna para que o tinker recarregue os Models.

### RECUPERANDO REGISTROS NO BANCO DE DADOS
* MÉTODO ESTÁTICO ALL -> Recupera todos os registros de uma tabela

>>> $fornecedores = Fornecedor::all()                                          
=> Illuminate\Database\Eloquent\Collection {#3695
     all: [
       App\Models\Fornecedor {#3692
         id: 1,
         nome: "Fornecedor XYZ",
         site: "https://www.albertogomesdasilva.com.br",
         created_at: "2022-10-30 20:01:42",
         updated_at: "2022-10-30 20:01:42",
         uf: "MA",
         email: "fornecedorxyz@gmail.com.br",
       },
       App\Models\Fornecedor {#3689
         id: 2,
         nome: "Brascopper-SLZ",
         site: "https://brascopper-slz.com.br",
         created_at: "2022-10-30 20:06:03",
         updated_at: "2022-10-30 20:06:03",
         updated_at: "2022-10-30 20:14:19",
         uf: "SP",
         email: "contato@abc.com.br",
       },
     ],
   }

>>>>>> $r=SiteContato::all()                                                      
[!] Aliasing 'SiteContato' to 'App\Models\SiteContato' for this Tinker session.
=> Illuminate\Database\Eloquent\Collection {#4022
     all: [
       App\Models\SiteContato {#4637
         id: 1,
         nome: "Alberto",
         telefone: "98981188434",
         email: "albertoogmesdasilva@gmail.com",
         motivo_contato: 1,
         mensagem: "Olá. Gostaria de maiores detalhes..",
         created_at: "2022-10-30 19:34:37",
         updated_at: "2022-10-30 19:34:37",
       },
       App\Models\SiteContato {#4638
         id: 2,
         nome: "Maria",
         telefone: "98998887777",
         email: "maria@gmail.com",
         motivo_contato: 2,
         mensagem: "tudo ok..",
         created_at: "2022-10-30 19:40:45",
         updated_at: "2022-10-30 19:40:45",
       },
     ],
   }

   - CLASSIFICANDO:
   >>> $registros->toArray()                                                            
=> [
     [
       "id" => 1,
       "nome" => "Fornecedor XYZ",
       "site" => "https://www.albertogomesdasilva.com.br",
       "created_at" => "2022-10-30T20:01:42.000000Z",
       "updated_at" => "2022-10-30T20:01:42.000000Z",
       "uf" => "MA",
       "email" => "fornecedorxyz@gmail.com.br",
     ],
     [
       "id" => 2,
       "nome" => "Brascopper-SLZ",
       "site" => "https://brascopper-slz.com.br",
       "created_at" => "2022-10-30T20:06:03.000000Z",
       "updated_at" => "2022-10-30T20:06:03.000000Z",
       "uf" => "MA",
       "email" => "brascopperslz@gmail.com.br",
     ],
       "email" => "contato@abc.com.br",
     ],
   ]

>>> foreach($registros as $r) { echo $r-nome; echo '-';}                             
                         
Fornecedor XYZ-Brascopper-SLZ-Fornecedro ABC-⏎
>>>                                                                                  


* MÉTODO ESTÁTICO FIND:
>>> $buscar = Fornecedor::find(2)                                                    
=> App\Models\Fornecedor {#5020
     id: 2,
     nome: "Brascopper-SLZ",
     site: "https://brascopper-slz.com.br",
     created_at: "2022-10-30 20:06:03",
     updated_at: "2022-10-30 20:06:03",
     uf: "MA",
     email: "brascopperslz@gmail.com.br",
   }

>>>echo $buscar->nome                                                               
Brascopper-SLZ⏎                  

ou ainda..
>>> $buscar = Fornecedor::find([1,2,3,4])                                            
=> Illuminate\Database\Eloquent\Collection {#5019
     all: [
       App\Models\Fornecedor {#5014
         id: 1,
         nome: "Fornecedor XYZ",
         site: "https://www.albertogomesdasilva.com.br",
         created_at: "2022-10-30 20:01:42",
         updated_at: "2022-10-30 20:01:42",
         uf: "MA",
         email: "fornecedorxyz@gmail.com.br",
       },
       App\Models\Fornecedor {#5021
         id: 2,
         nome: "Brascopper-SLZ",
         site: "https://brascopper-slz.com.br",
         created_at: "2022-10-30 20:06:03",
         updated_at: "2022-10-30 20:06:03",
         uf: "MA",
         email: "brascopperslz@gmail.com.br",
       },
       App\Models\Fornecedor {#4637
         id: 3,
         nome: "Fornecedro ABC",
         site: "fornecedor.com.br",
         created_at: "2022-10-30 20:14:19",
         updated_at: "2022-10-30 20:14:19",
         uf: "SP",
         email: "contato@abc.com.br",
       },
     ],
   }

* MÉTODO ESTÁTICO WHERE:          

>>> $contatos = SiteContato::where('id', '>=', 1)->get()                             
=> Illuminate\Database\Eloquent\Collection {#5012
     all: [
       App\Models\SiteContato {#3688
         id: 1,
         nome: "Alberto",
         telefone: "98981188434",
         email: "albertoogmesdasilva@gmail.com",
         motivo_contato: 1,
         mensagem: "Olá. Gostaria de maiores detalhes..",
         created_at: "2022-10-30 19:34:37",
         updated_at: "2022-10-30 19:34:37",
       },
       App\Models\SiteContato {#5011
         id: 2,
         nome: "Maria",
         telefone: "98998887777",
         email: "maria@gmail.com",
         motivo_contato: 2,
         mensagem: "tudo ok..",
         created_at: "2022-10-30 19:40:45",
         updated_at: "2022-10-30 19:40:45",
       },
     ],
   }

>>>>>> $contatos = SiteContato::where('nome', '=','Maria')->get()                       
=> Illuminate\Database\Eloquent\Collection {#5012
     all: [
       App\Models\SiteContato {#5020
         id: 2,
         nome: "Maria",
         telefone: "98998887777",
         email: "maria@gmail.com",
         motivo_contato: 2,
         mensagem: "tudo ok..",
         created_at: "2022-10-30 19:40:45",
         updated_at: "2022-10-30 19:40:45",
       },
     ],
   }

>>> $contatos = SiteContato::where('nome', '<>','Maria')->get()                      
=> Illuminate\Database\Eloquent\Collection {#5006
     all: [
       App\Models\SiteContato {#4645
         id: 1,
         nome: "Alberto",
         telefone: "98981188434",
         email: "albertoogmesdasilva@gmail.com",
         motivo_contato: 1,
         mensagem: "Olá. Gostaria de maiores detalhes..",
         created_at: "2022-10-30 19:34:37",
         updated_at: "2022-10-30 19:34:37",
       },
     ],
   }

* OBS.: QUANDO USAR IGUAL PODEMOS OMITIR O SEGUNDO PARÂMETRO, SIMPLIFICANDO A CONSULTA:
>>> $contatos = SiteContato::where('nome', 'Maria')->get()                           
=> Illuminate\Database\Eloquent\Collection {#4999
     all: [
       App\Models\SiteContato {#5001
         id: 2,
         nome: "Maria",
         telefone: "98998887777",
         email: "maria@gmail.com",
         motivo_contato: 2,
         mensagem: "tudo ok..",
         created_at: "2022-10-30 19:40:45",
         updated_at: "2022-10-30 19:40:45",
       },
     ],
   }
   >>> $contatos = SiteContato::where('email', 'like', '%gmail%')->get()                
=> Illuminate\Database\Eloquent\Collection {#4998
     all: [
       App\Models\SiteContato {#5009
         id: 1,
         nome: "Alberto",
         telefone: "98981188434",
         email: "albertoogmesdasilva@gmail.com",
         motivo_contato: 1,
         mensagem: "Olá. Gostaria de maiores detalhes..",
         created_at: "2022-10-30 19:34:37",
         updated_at: "2022-10-30 19:34:37",
       },
       App\Models\SiteContato {#5016
         id: 2,
         nome: "Maria",
         telefone: "98998887777",
         email: "maria@gmail.com",
         motivo_contato: 2,
         mensagem: "tudo ok..",
         created_at: "2022-10-30 19:40:45",
         updated_at: "2022-10-30 19:40:45",
       },
     ],
   }

### WHEREIN => É UMA COMPARAÇÃO POR IGUALDADE
>php artisan tinker
Psy Shell v0.11.8 (PHP 8.1.11 — cli) by Justin Hileman
>>> $contato = SiteContato::whereIn('motivo_contato', [1, 3])                                                                          
[!] Aliasing 'SiteContato' to 'App\Models\SiteContato' for this Tinker session.
=> Illuminate\Database\Eloquent\Builder {#3683}

>>> $contato = SiteContato::whereIn('motivo_contato', [1, 3])->get()

=> Illuminate\Database\Eloquent\Collection {#4633
     all: [
       App\Models\SiteContato {#4635
         id: 1,
         nome: "Alberto",
         telefone: "98981188434",
         email: "albertoogmesdasilva@gmail.com",
         motivo_contato: 1,
         mensagem: "Olá. Gostaria de maiores detalhes..",
         created_at: "2022-10-30 19:34:37",
         updated_at: "2022-10-30 19:34:37",
       },
       App\Models\SiteContato {#4636
         id: 3,
         nome: "João",
         telefone: "(88) 91111-2222",
         email: "joao@contato.com.br",
         motivo_contato: 3,
         mensagem: "É muito difícil localizar a opção de listar todos os produtos",
         created_at: null,
         updated_at: null,
       },
       App\Models\SiteContato {#4637
         id: 4,
         nome: "Rosa",
         telefone: "(33) 92222-3333",
         email: "rosa@contato.com.br",
         motivo_contato: 1,
         mensagem: "Quando custa essa aplicação?",
         created_at: null,
         updated_at: null,
       },
       App\Models\SiteContato {#3684
         id: 5,
         nome: "Fernando",
         telefone: "(11) 94444-5555",
         email: "fernando@contato.com.br",
         motivo_contato: 1,
         mensagem: "Como consigo criar multiplos usuários para minha empresa?",
         created_at: null,
         updated_at: null,
       },
       App\Models\SiteContato {#4640
         id: 7,
         nome: "Ana",
     ],
   }

### WHERE NOTIN => COMPARAÇÃO POR DIFERENÇA

* É possível passar quantos parâmetros forem necessários, basta separar os parâmetros por vírgula.
* O In e NotIn suportam comparações com valores numéricos, strings e datas.

>>> $contatos = SiteContato::whereNotIn('motivo_contato', [1,3])->get()                           
[!] Aliasing 'SiteContato' to 'App\Models\SiteContato' for this Tinker session.
=> Illuminate\Database\Eloquent\Collection {#4017
     all: [
       App\Models\SiteContato {#4633
         id: 2,
         nome: "Maria",
         telefone: "98998887777",
         email: "maria@gmail.com",
         motivo_contato: 2,
         mensagem: "tudo ok..",
         created_at: "2022-10-30 19:40:45",
         updated_at: "2022-10-30 19:40:45",
       },
       App\Models\SiteContato {#4634
         id: 6,
         nome: "André",
         telefone: "(88) 95555-6666",
         email: "andre@contato.com.br",
         motivo_contato: 2,
         mensagem: "Parabéns pela ferramenta, estou obtendo ótimos resultados!",
         created_at: null,
         updated_at: null,
       },
       App\Models\SiteContato {#4635
         id: 8,
         nome: "Helena",
         telefone: "(11) 97777-8888",
         email: "helena@contato.com.br",
         motivo_contato: 2,
         mensagem: "Consigo controlar toda a minha empresa de modo fácil e prático.",
         created_at: null,
         updated_at: null,
       },
     ],
   }

>>> $contatos = SiteContato::whereNotIn('created_at', ['2022-10-30 19:40:45','2022-10-30 19:40:45'
])->get()                                                                                         
=> Illuminate\Database\Eloquent\Collection {#3694
     all: [
       App\Models\SiteContato {#3685
         id: 1,
         nome: "Alberto",
         telefone: "98981188434",
         email: "albertoogmesdasilva@gmail.com",
         motivo_contato: 1,
         mensagem: "Olá. Gostaria de maiores detalhes..",
         created_at: "2022-10-30 19:34:37",
         updated_at: "2022-10-30 19:34:37",
       },
     ],
   }

### COMPARAÇÃO POR: ESTÁ ENTRE E INCLUSIVE:
* Pode ser usado tanto para números quanto para datas
- O EXEMPLO A SEGUIR RETORNARÁ OS ID's 3,4,5,6:
>>> $res = SiteContato::whereBetween('id', [3, 6])->get()                                         
=> Illuminate\Database\Eloquent\Collection {#4420
     all: [
       App\Models\SiteContato {#3684
         id: 3,
         nome: "João",
         telefone: "(88) 91111-2222",
         email: "joao@contato.com.br",
         motivo_contato: 3,
         mensagem: "É muito difícil localizar a opção de listar todos os produtos",
         created_at: null,
         updated_at: null,
       },
       App\Models\SiteContato {#3693
         id: 4,
         nome: "Rosa",
         telefone: "(33) 92222-3333",
         email: "rosa@contato.com.br",
         motivo_contato: 1,
         mensagem: "Quando custa essa aplicação?",
         created_at: null,
         updated_at: null,
       },
       App\Models\SiteContato {#4017
         id: 5,
         nome: "Fernando",
         telefone: "(11) 94444-5555",
         email: "fernando@contato.com.br",
         motivo_contato: 1,
         mensagem: "Como consigo criar multiplos usuários para minha empresa?",
         created_at: null,
         updated_at: null,
       },
       App\Models\SiteContato {#4633
         id: 6,
         nome: "André",
         telefone: "(88) 95555-6666",
         email: "andre@contato.com.br",
         motivo_contato: 2,
         mensagem: "Parabéns pela ferramenta, estou obtendo ótimos resultados!",
         created_at: null,
         updated_at: null,
       },
     ],
   }

### WHERENOTBETWIN: RETORNARÁ TUDO QUE NÃO ESTÁ ENTRE O RESCPECTIVO INTERVALO E INCLUSIVE:
* Pode ser usado tanto para números quanto para datas
- O EXEMPLO A SEGUIR RETORNARÁ OS ID's 1, 2, 7, 8  EXCLUINDO  3,4,5,6

>>> $res = SiteContato::whereNotBetween('id', [3, 6])->get()                                      
=> Illuminate\Database\Eloquent\Collection {#4640
     all: [
       App\Models\SiteContato {#4636
         id: 1,
         nome: "Alberto",
         telefone: "98981188434",
         email: "albertoogmesdasilva@gmail.com",
         motivo_contato: 1,
         mensagem: "Olá. Gostaria de maiores detalhes..",
         created_at: "2022-10-30 19:34:37",
         updated_at: "2022-10-30 19:34:37",
       },
       App\Models\SiteContato {#4635
         id: 2,
         nome: "Maria",
         telefone: "98998887777",
         email: "maria@gmail.com",
         motivo_contato: 2,
         mensagem: "tudo ok..",
         created_at: "2022-10-30 19:40:45",
         updated_at: "2022-10-30 19:40:45",
       },
       App\Models\SiteContato {#4641
         id: 7,
         nome: "Ana",
         telefone: "(33) 96666-7777",
         email: "ana@contato.com.br",
         motivo_contato: 3,
         mensagem: "Não gostei muito das cores, consigo mudar de tema?",
         created_at: null,
         updated_at: null,
       },
       App\Models\SiteContato {#4651
         id: 8,
         nome: "Helena",
         telefone: "(11) 97777-8888",
         email: "helena@contato.com.br",
         motivo_contato: 2,
         mensagem: "Consigo controlar toda a minha empresa de modo fácil e prático.",
         created_at: null,
         updated_at: null,
       },
     ],
   }

### SELECIONANDO REGISTROS COM DOIS OU MAIS WHERES - através do objeto query builder do ORM: 
SELECT * FROM site_contatos WHERE nome <> 'Fernando' and motivo_contato in (1,2) and creted_at between '2022-10-21 00:00:00' and '2022-10-31 23:59:59'; -> Esta consulta SQL retorna dois registros.
* Neste caso todas operações precisam ser verdadeiras para que o registro seja retornado.
>>>>>> $contatos = SiteContato::where('nome', '<>', 'Fernando')->whereIn('motivo_contato', [1,2])->w
hereBetween('created_at', ['2022-10-21 00:00:00', '2022-10-31 00:00:00'])->get()                  
[!] Aliasing 'SiteContato' to 'App\Models\SiteContato' for this Tinker session.
=> Illuminate\Database\Eloquent\Collection {#4017
     all: [
       App\Models\SiteContato {#4632
         id: 1,
         nome: "Alberto",
         telefone: "98981188434",
         email: "albertoogmesdasilva@gmail.com",
         motivo_contato: 1,
         mensagem: "Olá. Gostaria de maiores detalhes..",
         created_at: "2022-10-30 19:34:37",
         updated_at: "2022-10-30 19:34:37",
       },
       App\Models\SiteContato {#4633
         id: 2,
         nome: "Maria",
         telefone: "98998887777",
         email: "maria@gmail.com",
         motivo_contato: 2,
         mensagem: "tudo ok..",
         created_at: "2022-10-30 19:40:45",
         updated_at: "2022-10-30 19:40:45",
       },
     ],
   }

>>>                    

### SELECIONANDO REGISTROS COM DOIS OU MAIS ORWHERES - através do objeto query builder do ORM:    
SELECT * FROM site_contatos WHERE nome <> 'Fernando' or motivo_contato in (1,2) or creted_at between '2022-10-21 00:00:00' and '2022-10-31 23:59:59';
* Neste caso apenas uma das operações precisa ser verdadeira para que o registro seja retornado.
>>>  $contatos = SiteContato::where('nome', '<>', 'Fernando')->orwhereIn('motivo_contato', [1,2])-
>orwhereBetween('created_at', ['2022-10-21 00:00:00', '2022-10-31 00:00:00'])->get()              
=> Illuminate\Database\Eloquent\Collection {#4632
     all: [
       App\Models\SiteContato {#4421
         id: 1,
         nome: "Alberto",
         telefone: "98981188434",
         email: "albertoogmesdasilva@gmail.com",
         motivo_contato: 1,
         mensagem: "Olá. Gostaria de maiores detalhes..",
         created_at: "2022-10-30 19:34:37",
         updated_at: "2022-10-30 19:34:37",
       },
       App\Models\SiteContato {#3681
         id: 2,
         nome: "Maria",
         telefone: "98998887777",
         email: "maria@gmail.com",
         motivo_contato: 2,
         mensagem: "tudo ok..",
         created_at: "2022-10-30 19:40:45",
         updated_at: "2022-10-30 19:40:45",
       },
       App\Models\SiteContato {#4649
         id: 3,
         nome: "João",
         telefone: "(88) 91111-2222",
         email: "joao@contato.com.br",
         motivo_contato: 3,
         mensagem: "É muito difícil localizar a opção de listar todos os produtos",
         created_at: null,
         updated_at: null,
       },
       App\Models\SiteContato {#4650
         id: 4,
         nome: "Rosa",
         telefone: "(33) 92222-3333",
         email: "rosa@contato.com.br",
         motivo_contato: 1,
         mensagem: "Quando custa essa aplicação?",
         created_at: null,
         updated_at: null,
       },
       App\Models\SiteContato {#4651
         id: 5,
         nome: "Fernando",
         telefone: "(11) 94444-5555",
         email: "fernando@contato.com.br",
         motivo_contato: 1,
         mensagem: "Como consigo criar multiplos usuários para minha empresa?",
         created_at: null,
         updated_at: null,
       },
       App\Models\SiteContato {#4652
         id: 6,
         nome: "André",
         telefone: "(88) 95555-6666",
         email: "andre@contato.com.br",
         motivo_contato: 2,
         mensagem: "Parabéns pela ferramenta, estou obtendo ótimos resultados!",
         created_at: null,
         updated_at: null,
       },
       App\Models\SiteContato {#4653
         id: 7,
         nome: "Ana",
         telefone: "(33) 96666-7777",
         email: "ana@contato.com.br",
         motivo_contato: 3,
         mensagem: "Não gostei muito das cores, consigo mudar de tema?",
         created_at: null,
       },
     ],
   }

>>>Podemos ter:
* OBS.: orWhere, orWhereIn, orWhereNotIn, orWhereBetween ou orWhereNotBetween se não informarmos o 'or' o operador será o 'and' 
where->

### WHRENULL e WHERENOTNULL
SELECT * FROM site_contatos WHERE updated_at is null;  (null <> vazio)
SELECT * FROM site_contatos WHERE updated_at is not null;
SELECT * FROM site_contatos WHERE updated_at is null;

>>> $contatos = SiteContato::whereNull('updated_at')->get();                                      
=> Illuminate\Database\Eloquent\Collection {#4638
     all: [
       App\Models\SiteContato {#4640
         id: 3,
         nome: "João",
         telefone: "(88) 91111-2222",
         email: "joao@contato.com.br",
         motivo_contato: 3,
         mensagem: "É muito difícil localizar a opção de listar todos os produtos",
         created_at: null,
         updated_at: null,
       },
       App\Models\SiteContato {#4641
         id: 4,
         nome: "Rosa",
         telefone: "(33) 92222-3333",
         email: "rosa@contato.com.br",
         motivo_contato: 1,
         mensagem: "Quando custa essa aplicação?",
         created_at: null,
         updated_at: null,
       },
       App\Models\SiteContato {#4642
         id: 5,
         nome: "Fernando",
         telefone: "(11) 94444-5555",
         email: "fernando@contato.com.br",
         motivo_contato: 1,
         mensagem: "Como consigo criar multiplos usuários para minha empresa?",
         created_at: null,
         updated_at: null,
       },
       App\Models\SiteContato {#4643
         id: 6,
         nome: "André",
         telefone: "(88) 95555-6666",
         email: "andre@contato.com.br",
         motivo_contato: 2,
         mensagem: "Parabéns pela ferramenta, estou obtendo ótimos resultados!",
         created_at: null,
         updated_at: null,
       },
       App\Models\SiteContato {#4644
         id: 7,
         nome: "Ana",
         telefone: "(33) 96666-7777",
         email: "ana@contato.com.br",
         motivo_contato: 3,
         mensagem: "Não gostei muito das cores, consigo mudar de tema?",
         created_at: null,
         updated_at: null,
       },
       App\Models\SiteContato {#4645
         id: 8,
         nome: "Helena",
         telefone: "(11) 97777-8888",
         email: "helena@contato.com.br",
         motivo_contato: 2,
         mensagem: "Consigo controlar toda a minha empresa de modo fácil e prático.",
         created_at: null,
         updated_at: null,
       },
     ],
   }

### NOTNULL
>>> $contatos = SiteContato::whereNotNull('updated_at')->get();                                   
=> Illuminate\Database\Eloquent\Collection {#4646
     all: [
       App\Models\SiteContato {#4637
         id: 1,
         nome: "Alberto",
         telefone: "98981188434",
         email: "albertoogmesdasilva@gmail.com",
         motivo_contato: 1,
         mensagem: "Olá. Gostaria de maiores detalhes..",
         created_at: "2022-10-30 19:34:37",
         updated_at: "2022-10-30 19:34:37",
       },
       App\Models\SiteContato {#3682
         id: 2,
         nome: "Maria",
         telefone: "98998887777",
         email: "maria@gmail.com",
         motivo_contato: 2,
         mensagem: "tudo ok..",
         created_at: "2022-10-30 19:40:45",
         updated_at: "2022-10-30 19:40:45",
       },
     ],
   }

>>> $contatos = SiteContato::whereNotNull('updated_at')->orWhereNull('created_at')->get();        
=> Illuminate\Database\Eloquent\Collection {#4637
     all: [
       App\Models\SiteContato {#4641
         id: 1,
         nome: "Alberto",
         telefone: "98981188434",
         email: "albertoogmesdasilva@gmail.com",
         motivo_contato: 1,
         mensagem: "Olá. Gostaria de maiores detalhes..",
         created_at: "2022-10-30 19:34:37",
         updated_at: "2022-10-30 19:34:37",
       },
       App\Models\SiteContato {#4658
         id: 2,
         nome: "Maria",
         telefone: "98998887777",
         email: "maria@gmail.com",
         motivo_contato: 2,
         mensagem: "tudo ok..",
         created_at: "2022-10-30 19:40:45",
         updated_at: "2022-10-30 19:40:45",
       },
       App\Models\SiteContato {#4659
         id: 3,
         nome: "João",
         telefone: "(88) 91111-2222",
         email: "joao@contato.com.br",
         motivo_contato: 3,
         mensagem: "É muito difícil localizar a opção de listar todos os produtos",
         created_at: null,
         updated_at: null,
       },
       App\Models\SiteContato {#4660
         id: 4,
         nome: "Rosa",
         telefone: "(33) 92222-3333",
         email: "rosa@contato.com.br",
         motivo_contato: 1,
         mensagem: "Quando custa essa aplicação?",
         created_at: null,
         updated_at: null,
       },
       App\Models\SiteContato {#4661
         id: 5,
         nome: "Fernando",
         telefone: "(11) 94444-5555",
         email: "fernando@contato.com.br",
         motivo_contato: 1,
         mensagem: "Como consigo criar multiplos usuários para minha empresa?",
         created_at: null,
         updated_at: null,
       },
       App\Models\SiteContato {#4662
         id: 6,
         nome: "André",
         telefone: "(88) 95555-6666",
         email: "andre@contato.com.br",
         motivo_contato: 2,
         mensagem: "Parabéns pela ferramenta, estou obtendo ótimos resultados!",
         created_at: null,
         updated_at: null,
       },
       App\Models\SiteContato {#4663
         id: 7,
         nome: "Ana",
         telefone: "(33) 96666-7777",
         email: "ana@contato.com.br",
         motivo_contato: 3,
         mensagem: "Não gostei muito das cores, consigo mudar de tema?",
         created_at: null,
         updated_at: null,
       },
       App\Models\SiteContato {#4664
         id: 8,
         nome: "Helena",
         telefone: "(11) 97777-8888",
         email: "helena@contato.com.br",
         motivo_contato: 2,
         mensagem: "Consigo controlar toda a minha empresa de modo fácil e prático.",
         created_at: null,
         updated_at: null,
       },
     ],
   }

### SELECIONANDO REGISTROS COM BASE EM PARÂMETROS DO TIPO DATA E HORA
### WHEREDATE
o>php artisan tinker
Psy Shell v0.11.8 (PHP 8.1.11 — cli) by Justin Hileman
>>> $contatos = SiteContato::whereDate('created_at', '2022-10-30')->get()                         
[!] Aliasing 'SiteContato' to 'App\Models\SiteContato' for this Tinker session.
=> Illuminate\Database\Eloquent\Collection {#4418
     all: [
       App\Models\SiteContato {#4630
         id: 1,
         nome: "Alberto",
         telefone: "98981188434",
         email: "albertoogmesdasilva@gmail.com",
         motivo_contato: 1,
         mensagem: "Olá. Gostaria de maiores detalhes..",
         created_at: "2022-10-30 19:34:37",
         updated_at: "2022-10-30 19:34:37",
       },
       App\Models\SiteContato {#4631
         id: 2,
         nome: "Maria",
         telefone: "98998887777",
         email: "maria@gmail.com",
         motivo_contato: 2,
         mensagem: "tudo ok..",
         created_at: "2022-10-30 19:40:45",
         updated_at: "2022-10-30 19:40:45",
       },
     ],
   }

### WHEREDAY
>>> $contatos = SiteContato::whereDay('created_at', '30')->get()                                  
=> Illuminate\Database\Eloquent\Collection {#4639
     all: [
       App\Models\SiteContato {#4637
         id: 1,
         nome: "Alberto",
         telefone: "98981188434",
         email: "albertoogmesdasilva@gmail.com",
         motivo_contato: 1,
         mensagem: "Olá. Gostaria de maiores detalhes..",
         created_at: "2022-10-30 19:34:37",
         updated_at: "2022-10-30 19:34:37",
       },
       App\Models\SiteContato {#4636
         id: 2,
         nome: "Maria",
         telefone: "98998887777",
         email: "maria@gmail.com",
         motivo_contato: 2,
         mensagem: "tudo ok..",
         created_at: "2022-10-30 19:40:45",
         updated_at: "2022-10-30 19:40:45",
       },
     ],
   }

### WHEREMONTH
>>> $contatos = SiteContato::whereMonth('created_at', '10')->get()                                
=> Illuminate\Database\Eloquent\Collection {#4417
     all: [
       App\Models\SiteContato {#4484
         id: 1,
         nome: "Alberto",
         telefone: "98981188434",
         email: "albertoogmesdasilva@gmail.com",
         motivo_contato: 1,
         mensagem: "Olá. Gostaria de maiores detalhes..",
         created_at: "2022-10-30 19:34:37",
         updated_at: "2022-10-30 19:34:37",
       },
       App\Models\SiteContato {#3683
         id: 2,
         nome: "Maria",
         telefone: "98998887777",
         email: "maria@gmail.com",
         motivo_contato: 2,
         mensagem: "tudo ok..",
         created_at: "2022-10-30 19:40:45",
         updated_at: "2022-10-30 19:40:45",
       },
     ],
   }

### WHEREYEAR
>> $contatos = SiteContato::whereYear('created_at', '2022')->get()                               
=> Illuminate\Database\Eloquent\Collection {#4639
     all: [
       App\Models\SiteContato {#4640
         id: 1,
         nome: "Alberto",
         telefone: "98981188434",
         email: "albertoogmesdasilva@gmail.com",
         motivo_contato: 1,
         mensagem: "Olá. Gostaria de maiores detalhes..",
         created_at: "2022-10-30 19:34:37",
         updated_at: "2022-10-30 19:34:37",
       },
       App\Models\SiteContato {#4641
         id: 2,
         nome: "Maria",
         telefone: "98998887777",
         email: "maria@gmail.com",
         motivo_contato: 2,
         mensagem: "tudo ok..",
         created_at: "2022-10-30 19:40:45",
         updated_at: "2022-10-30 19:40:45",
       },
     ],
   }

>>> $contatos = SiteContato::whereTime('created_at', '19:40:45')->get()                           
=> Illuminate\Database\Eloquent\Collection {#3676
     all: [
       App\Models\SiteContato {#3687
         id: 2,
         nome: "Maria",
         telefone: "98998887777",
         email: "maria@gmail.com",
         motivo_contato: 2,
         mensagem: "tudo ok..",
         created_at: "2022-10-30 19:40:45",
         updated_at: "2022-10-30 19:40:45",
       },
     ],
   }

>>> $contatos = SiteContato::whereTime('created_at', '<>', '19:40:45')->get()                     
=> Illuminate\Database\Eloquent\Collection {#4639
     all: [
       App\Models\SiteContato {#3676
         id: 1,
         nome: "Alberto",
         telefone: "98981188434",
         email: "albertoogmesdasilva@gmail.com",
         motivo_contato: 1,
         mensagem: "Olá. Gostaria de maiores detalhes..",
         created_at: "2022-10-30 19:34:37",
         updated_at: "2022-10-30 19:34:37",
       },
     ],
   }

>>> $contatos = SiteContato::whereTime('created_at', '<>', '19:40:45')->get()                     
=> Illuminate\Database\Eloquent\Collection {#4639
     all: [
       App\Models\SiteContato {#3676
         id: 1,
         nome: "Alberto",
         telefone: "98981188434",
         email: "albertoogmesdasilva@gmail.com",
         motivo_contato: 1,
         mensagem: "Olá. Gostaria de maiores detalhes..",
         created_at: "2022-10-30 19:34:37",
         updated_at: "2022-10-30 19:34:37",
       },
     ],
   }

### ELOQUENT - SELECIONANDO REGISTROS COM WHERECOLUMN(): Filtra registros comparando valores de colunas do mesmo registro.
-> Trará registros onde 'created_at' e 'updated_at' com valores iguais
### passando apenas dois parâmetros significa ter subtendido o perador de igauldade:
>>> $contato = SiteContato::whereColumn('created_at', 'updated_at')->get();                       
[!] Aliasing 'SiteContato' to 'App\Models\SiteContato' for this Tinker session.
=> Illuminate\Database\Eloquent\Collection {#4383
     all: [
       App\Models\SiteContato {#4636
         id: 1,
         nome: "Alberto",
         telefone: "98981188434",
         email: "albertoogmesdasilva@gmail.com",
         motivo_contato: 1,
         mensagem: "Olá. Gostaria de maiores detalhes..",
         created_at: "2022-10-30 19:34:37",
         updated_at: "2022-10-30 19:34:37",
       },
       App\Models\SiteContato {#4637
         id: 2,
         nome: "Maria",
         telefone: "98998887777",
         email: "maria@gmail.com",
         motivo_contato: 2,
         mensagem: "tudo ok..",
         created_at: "2022-10-30 19:40:45",
         updated_at: "2022-10-30 19:40:45",
       },
     ],
   }

   >>> $contato = SiteContato::whereColumn('created_at', 'updated_at')->get();                       
[!] Aliasing 'SiteContato' to 'App\Models\SiteContato' for this Tinker session.
=> Illuminate\Database\Eloquent\Collection {#4383
     all: [
       App\Models\SiteContato {#4636
         id: 1,
         nome: "Alberto",
         telefone: "98981188434",
         email: "albertoogmesdasilva@gmail.com",
         motivo_contato: 1,
         mensagem: "Olá. Gostaria de maiores detalhes..",
         created_at: "2022-10-30 19:34:37",
         updated_at: "2022-10-30 19:34:37",
       },
       App\Models\SiteContato {#4637
         id: 2,
         nome: "Maria",
         telefone: "98998887777",
         email: "maria@gmail.com",
         motivo_contato: 2,
         mensagem: "tudo ok..",
         created_at: "2022-10-30 19:40:45",
         updated_at: "2022-10-30 19:40:45",
       },
     ],
   }

### ELOQUENT - SELECIONANDO REGISTROS COM WHERECOLUMN() -> Suporta 3 parâmetros, podemos usar o operador:
>>> $contact = SiteContato::whereColumn('created_at', '<>', 'updated_at')->get();                                                             
=> Illuminate\Database\Eloquent\Collection {#3676
     all: [
       App\Models\SiteContato {#3682
         id: 2,
         nome: "Maria",
         telefone: "98998887777",
         email: "maria@gmail.com",
         motivo_contato: 2,
         mensagem: "tudo ok..",
         created_at: "2022-10-31 19:40:45",
         updated_at: "2022-10-30 19:40:45",
       },
     ],
   }

   >>> $contact = SiteContato::where('id', '>', 1)->whereColumn('created_at', '>=', 'updated_at')->get();                                        
=> Illuminate\Database\Eloquent\Collection {#4647
     all: [
       App\Models\SiteContato {#4645
         id: 2,
         nome: "Maria",
         telefone: "98998887777",
         email: "maria@gmail.com",
         motivo_contato: 2,
         mensagem: "tudo ok..",
         created_at: "2022-10-31 19:40:45",
         updated_at: "2022-10-30 19:40:45",
       },
     ],
   }

### SELECIONANDO REGISTROS APLICANDO PRECEDÊNCIAS EM OPERAÇÕES LÓGICAS

SELECT * FROM site_contatos WHERE (nome = 'Jorge' OR nome = 'Ana') and (motivo_contato in (1, 2) or id between 4 and 7); ==> Resulta o registro de id=7 (Ana).



SELECT * FROM site_contatos WHERE nome = 'Jorge' OR nome 'Ana' and (motivo_contato in (1, 2) or id between 4 and 7;  ===> Resulta os registros 4, 5, 6 e 7 ( Rosa, Fernando, André e Ana).

>>> $contatos = SiteContato::where(function($query){ $query->where('nome', 'Jorge')->orWhere('nome', 'Ana'); })->where(function($query){ $query->whereIn('motivo_contato', [1, 2])->orWhereBeteen('id', [4, 7]); })->get();                                                           
BadMethodCallException with message 'Call to undefined method Illuminate\Database\Eloquent\Builder::orWhereBeteen()'
>>> $contatos = SiteContato::where(function($query){ $query->where('nome', 'Jorge')->orWhere('nome', 'Ana'); })->where(function($query){ $q
uery->whereIn('motivo_contato', [1, 2])->orWhereBetween('id', [4, 7]); })->get();                                                          
=> Illuminate\Database\Eloquent\Collection {#4652
     all: [
       App\Models\SiteContato {#4643
         id: 7,
         nome: "Ana",
         telefone: "(33) 96666-7777",
         email: "ana@contato.com.br",
         motivo_contato: 3,
         mensagem: "Não gostei muito das cores, consigo mudar de tema?",
         created_at: null,
         updated_at: null,
       },
     ],
   }
### ELOQUENT - ORDENANDO REGISTROS -> A ordenação pode ser feita com base em uma coluna podendo ser ascendente ou descendente, e é possível também combinar várias ordenações, ou seja, primeiro ordenamos com base em uma coluna e com base nesse resultado utilizamos uma segunda coluna para ordenação e assim consecutivamente de modo encadeado.

- $contatos = SiteContato::all();    -> o método all() exibe tudo;
- $contatos = SiteContato::orderBy('nome', 'asc')->get();  -> Ordena por nome (padrão é ascendente se não passar o segundo parâmetro 'asc');
- $contatos = SiteContato::orderBy('nome', 'desc')->get();
- $contatos = SiteContato::orderBy('motivo_contato')->orderBy('nome', 'asc')->get();

### FILTROS E ORDENAÇÃO:
>>> $contatos = SiteContato::whereBetween('id', [2,4])->orderBy('motivo_contato')->orderBy('nome','desc')->get();                          
=> Illuminate\Database\Eloquent\Collection {#4630
     all: [
       App\Models\SiteContato {#4638
         id: 4,
         nome: "Rosa",
         telefone: "(33) 92222-3333",
         email: "rosa@contato.com.br",
         motivo_contato: 1,
         mensagem: "Quando custa essa aplicação?",
         created_at: null,
         updated_at: null,
       },
       App\Models\SiteContato {#4642
         id: 2,
         nome: "Maria",
         telefone: "98998887777",
         email: "maria@gmail.com",
         motivo_contato: 2,
         mensagem: "tudo ok..",
         created_at: "2022-10-31 19:40:45",
         updated_at: "2022-10-30 19:40:45",
       },
       App\Models\SiteContato {#3685
         id: 3,
         nome: "João",
         telefone: "(88) 91111-2222",
         email: "joao@contato.com.br",
         motivo_contato: 3,
         mensagem: "É muito difícil localizar a opção de listar todos os produtos",
         created_at: null,
         updated_at: null,
       },
     ],
   }

### ELOQUENT ORM -> COLLECTIONS: (laravel.com/docs/8.x/collections) - Available Methods(Métodos disponíveis) -> Quando estamos construindo uma Query nós temos um objeto do tipo 'Builder', no instante em que executamos o método 'get' nós recuperamos com base na query que foi construída um objeto do tipo 'collection', a partir de um objeto do tipo collection podemo aplicar sobre esse objeto os métodos que são nativos dele:
>>> $resultado = SiteContato::where('id', '>', 5)       
=> Illuminate\Database\Eloquent\Builder {#4377}  ==> Objeto do tipo Builder
>>>                             
=> Illuminate\Database\Eloquent\Collection {#4654
     all: [
       App\Models\SiteContato {#4657
         id: 6,
         nome: "André",
         telefone: "(88) 95555-6666",
         email: "andre@contato.com.br",
         motivo_contato: 2,
         mensagem: "Parabéns pela ferramenta, estou obtendo ótimos resultados!",
         created_at: null,
         updated_at: null,
       },
       App\Models\SiteContato {#4653
         id: 7,
         nome: "Ana",
         telefone: "(33) 96666-7777",
         email: "ana@contato.com.br",
         motivo_contato: 3,
         mensagem: "Não gostei muito das cores, consigo mudar de tema?",
         created_at: null,
         updated_at: null,
       },
       App\Models\SiteContato {#4015
         id: 8,
         nome: "Helena",
         telefone: "(11) 97777-8888",
         email: "helena@contato.com.br",
         motivo_contato: 2,
         mensagem: "Consigo controlar toda a minha empresa de modo fácil e prático.",
         created_at: null,
         updated_at: null,
       },
     ],
   }

>>> $resultado->get()  ==> Obtenho uma coleção                                         
* first, last e reverse: 
>>> $resultador->first()  => Retorna o primeiro elemento
>>> $resultador->last()  => Retorna o último elemento
>>> $resultador->reverse() => Inverte a ordem na exibição

### ELOQUENT = COLLECTION TO ARRAY E TO JSON  => Convertem uma coleção de objetos para um array e para um json respectivamente:
$resultado = SiteContato::all()   -> Retorna uma collection
>>> $resultado = SiteContato::all()->toArray()  -> A Collection é convertida para um objeto do tipo Array. Quando é feita essa conversão os métodos estáticos de uma coleção, todos os métodos nativos nativos não se aplicam aqui.
=> [
     [
       "id" => 1,
       "nome" => "Alberto",
       "telefone" => "98981188434",
       "email" => "albertoogmesdasilva@gmail.com",
       "motivo_contato" => 1,
       "mensagem" => "Olá. Gostaria de maiores detalhes..",
       "created_at" => "2022-10-30T19:34:37.000000Z",
       "updated_at" => "2022-10-30T19:34:37.000000Z",
     ],
     [
       "id" => 2,
       "nome" => "Maria",
       "telefone" => "98998887777",
       "email" => "maria@gmail.com",
       "motivo_contato" => 2,
       "mensagem" => "tudo ok..",
       "created_at" => "2022-10-31T19:40:45.000000Z",
       "updated_at" => "2022-10-30T19:40:45.000000Z",
     ],
     [
       "id" => 3,
       "nome" => "João",
       "telefone" => "(88) 91111-2222",
       "email" => "joao@contato.com.br",
       "motivo_contato" => 3,
       "mensagem" => "É muito difícil localizar a opção de listar todos os produtos",
       "created_at" => null,
       "updated_at" => null,
     ],
     [
       "id" => 4,
       "nome" => "Rosa",
       "telefone" => "(33) 92222-3333",
       "email" => "rosa@contato.com.br",
       "motivo_contato" => 1,
       "mensagem" => "Quando custa essa aplicação?",
       "created_at" => null,
       "updated_at" => null,
     ],
     [
       "id" => 5,
       "nome" => "Fernando",
       "telefone" => "(11) 94444-5555",
       "email" => "fernando@contato.com.br",
       "motivo_contato" => 1,
       "mensagem" => "Como consigo criar multiplos usuários para minha empresa?",
       "created_at" => null,
       "updated_at" => null,
     ],
     [
       "id" => 6,
       "nome" => "André",
       "telefone" => "(88) 95555-6666",
       "email" => "andre@contato.com.br",
       "motivo_contato" => 2,
       "mensagem" => "Parabéns pela ferramenta, estou obtendo ótimos resultados!",
       "created_at" => null,
       "updated_at" => null,
     ],
     [
       "id" => 7,
       "nome" => "Ana",
       "telefone" => "(33) 96666-7777",
       "email" => "ana@contato.com.br",
       "motivo_contato" => 3,
       "mensagem" => "Não gostei muito das cores, consigo mudar de tema?",
       "created_at" => null,
       "updated_at" => null,
     ],
     [
       "id" => 8,
       "nome" => "Helena",
       "telefone" => "(11) 97777-8888",
       "email" => "helena@contato.com.br",
       "motivo_contato" => 2,
       "mensagem" => "Consigo controlar toda a minha empresa de modo fácil e prático.",
       "created_at" => null,
       "updated_at" => null,
     ],
   ]
### Convertendo a coleção para Json:
>>>>>> $resultado = SiteContato::all()->toJson()
=> "[{"id":1,"nome":"Alberto","telefone":"98981188434","email":"albertoogmesdasilva@gmail.com","motivo_contato":1,"mensagem":"Ol\u00e1. Gostaria de maiores detalhes..","created_at":"2022-10-30T19:34:37.000000Z","updated_at":"2022-10-30T19:34:37.000000Z"},{"id":2,"nome":"Maria","telefone":"98998887777","email":"maria@gmail.com","motivo_contato":2,"mensagem":"tudo ok..","created_at":"2022-10-31T19:40:45.000000Z","updated_at":"2022-10-30T19:40:45.000000Z"},{"id":3,"nome":"Jo\u00e3o","telefone":"(88) 91111-2222","email":"joao@contato.com.br","motivo_contato":3,"mensagem":"\u00c9 muito dif\u00edcil localizar a op\u00e7\u00e3o de listar todos os produtos","created_at":null,"updated_at":null},{"id":4,"nome":"Rosa","telefone":"(33) 92222-3333","email":"rosa@contato.com.br","motivo_contato":1,"mensagem":"Quando custa essa aplica\u00e7\u00e3o?","created_at":null,"updated_at":null},{"id":5,"nome":"Fernando","telefone":"(11) 94444-5555","email":"fernando@contato.com.br","motivo_contato":1,"mensagem":"Como consigo criar multiplos usu\u00e1rios para minha empresa?","created_at":null,"updated_at":null},{"id":6,"nome":"Andr\u00e9","telefone":"(88) 95555-6666","email":"andre@contato.com.br","motivo_contato":2,"mensagem":"Parab\u00e9ns pela ferramenta, estou obtendo \u00f3timos resultados!","created_at":null,"updated_at":null},{"id":7,"nome":"Ana","telefone":"(33) 96666-7777","email":"ana@contato.com.br","motivo_contato":3,"mensagem":"N\u00e3o gostei muito das cores, consigo mudar de tema?","created_at":null,"updated_at":null},{"id":8,"nome":"Helena","telefone":"(11) 97777-8888","email":"helena@contato.com.br","motivo_contato":2,"mensagem":"Consigo controlar toda a minha empresa de modo f\u00e1cil e pr\u00e1tico.","created_at":null,"updated_at":null}]"

### PLUCK -> Permite recuperar todos os valores de uma determinada chave. por exemplo: todos os emails, a partir daí combinar com outros métodos:
>>> SiteContato::all()->pluck('email')         
=> Illuminate\Support\Collection {#4657
     all: [
       "albertoogmesdasilva@gmail.com",
       "maria@gmail.com",
       "joao@contato.com.br",
       "rosa@contato.com.br",
       "fernando@contato.com.br",
       "andre@contato.com.br",
       "ana@contato.com.br",
       "helena@contato.com.br",
     ],
   }

>>> SiteContato::all()->pluck('email')->first() 
=> "albertoogmesdasilva@gmail.com"

* OBS.: APÓS CONVERTER EM ARRAY NÃO POSSO CHAMAR OUTROS MÉTODOS NATIVOS, SOMENTE ENQUANTO FOR UMA COLLECTION POSSO ENCADEAR MÉTODOS.

>>> SiteContato::all()->pluck('email')->toArray()->first()
PHP Error:  Call to a member function first() on array in C:\Users\alber\Desktop\PHP E LARAVEL-9eval()'d code on line 1

>>> SiteContato::all()->pluck('email')->reverse()->first()
=> "helena@contato.com.br"

### ATRIBUINDO UMA CHAVE PARA A CONSULTA
>>> SiteContato::all()->pluck('email', 'nome')
=> Illuminate\Support\Collection {#4663
     all: [
       "Alberto" => "albertoogmesdasilva@gmail.com",
       "Maria" => "maria@gmail.com",
       "João" => "joao@contato.com.br",
       "Rosa" => "rosa@contato.com.br",
       "Fernando" => "fernando@contato.com.br",
       "André" => "andre@contato.com.br",
       "Ana" => "ana@contato.com.br",
       "Helena" => "helena@contato.com.br",
     ],
   }                                                                                                                                        
### PARA CONHECER UM POUCO MAIS SOBRE OS MÉTODOS NATIVOS DOS OBJETOS COLLECTION
https://laravel.com/docs/8.x/collections

* ex.: >>> SiteContato::all()->pluck('id')                                                                                                        
=> Illuminate\Support\Collection {#5024
     all: [
       1,
       2,
       3,
       4,
       5,
       6,
       7,
       8,
     ],
   }

>>> SiteContato::all()->pluck('id')->sum() 
=> 36

### ATUALIZANDO REGISTROS - save()
>> $res = SiteContato::all()->first()                                                                                                     
=> App\Models\SiteContato {#4647
     id: 1,
     nome: "Alberto",
     telefone: "98981188434",
     email: "albertoogmesdasilva@gmail.com",
     motivo_contato: 1,
     mensagem: "Olá. Gostaria de maiores detalhes..",
     created_at: "2022-10-30 19:34:37",
     updated_at: "2022-10-30 19:34:37",
   }

>>>$res = SiteContato::all()->first()
=> App\Models\SiteContato {#4647
     id: 1,
     nome: "Alberto",
     telefone: "98981188434",
     email: "albertoogmesdasilva@gmail.com",
     motivo_contato: 1,
     mensagem: "Olá. Gostaria de maiores detalhes..",
     created_at: "2022-10-30 19:34:37",
     updated_at: "2022-10-30 19:34:37",
   }

>>> $res -> nome
=> "Alberto"

>>> $res -> nome = 'Adalberto'
=> "Adalberto"
>>> $res->save()
=> true

>>> dd($res)                                                                                                                               
App\Models\SiteContato^ {#4647 // vendor\psy\psysh\src\ExecutionLoopClosure.php(55) : eval()'d code:1
  #connection: "mysql"
  #table: "site_contatos"
  #primaryKey: "id"
  #keyType: "int"
  +incrementing: true
  #with: []
  #withCount: []
  +preventsLazyLoading: false
  #perPage: 15
  +exists: true
  +wasRecentlyCreated: false
  #escapeWhenCastingToString: false
  #attributes: array:8 [
    "id" => 1
    "nome" => "Adalberto"
    "telefone" => "98981188434"
    "email" => "adalberto@gmail.com"
    "motivo_contato" => 1
    "mensagem" => "Olá. Gostaria de maiores detalhes.."
    "created_at" => "2022-10-30 19:34:37"
    "updated_at" => "2022-10-31 20:53:29"
  ]
  #original: array:8 [
    "id" => 1
    "nome" => "Adalberto"
    "telefone" => "98981188434"
    "email" => "adalberto@gmail.com"
    "motivo_contato" => 1
    "mensagem" => "Olá. Gostaria de maiores detalhes.."
    "created_at" => "2022-10-30 19:34:37"
    "updated_at" => "2022-10-31 20:53:29"
  ]
  #changes: array:2 [
    "email" => "adalberto@gmail.com"
    "updated_at" => "2022-10-31 20:53:29"
  ]
  #casts: []
  #classCastCache: []
  #attributeCastCache: []
  #dates: []
  #dateFormat: null
  #appends: []
  #dispatchesEvents: []
  #observables: []
  #relations: []
  #touches: []
  +timestamps: true
  #hidden: []
  #visible: []
  #fillable: []
  #guarded: array:1 [
    0 => "*"
  ]
}

>>> print_r($res)                                                                                                                          
App\Models\SiteContato Object
(
    [connection:protected] => mysql
    [table:protected] => site_contatos
    [primaryKey:protected] => id
    [keyType:protected] => int
    [incrementing] => 1
    [with:protected] => Array
        (
        )

    [withCount:protected] => Array
        (
        )

    [preventsLazyLoading] =>
    [perPage:protected] => 15
    [exists] => 1
    [wasRecentlyCreated] =>
    [escapeWhenCastingToString:protected] =>
    [attributes:protected] => Array
        (
            [id] => 1
            [nome] => Adalberto
            [telefone] => 98981188434
            [email] => adalberto@gmail.com
            [motivo_contato] => 1
            [mensagem] => Olá. Gostaria de maiores detalhes..
            [created_at] => 2022-10-30 19:34:37
            [updated_at] => 2022-10-31 20:53:29
        )

    [original:protected] => Array
        (
            [id] => 1
            [nome] => Adalberto
            [telefone] => 98981188434
            [email] => adalberto@gmail.com
            [motivo_contato] => 1
            [mensagem] => Olá. Gostaria de maiores detalhes..
            [created_at] => 2022-10-30 19:34:37
            [updated_at] => 2022-10-31 20:53:29
        )

    [changes:protected] => Array
        (
        )

    [casts:protected] => Array
        (
        )

    [classCastCache:protected] => Array
        (
        )

    [attributeCastCache:protected] => Array
        (
        )

    [dates:protected] => Array
        (
        )

    [dateFormat:protected] =>
    [appends:protected] => Array
        (
        )

    [dispatchesEvents:protected] => Array
        (
        )

    [observables:protected] => Array
        (
        )

    [relations:protected] => Array
        (
        )

    [touches:protected] => Array
        (
        )

    [timestamps] => 1
    [hidden:protected] => Array
        (
        )

    [visible:protected] => Array
        (
        )

    [fillable:protected] => Array
        (
        )

    [guarded:protected] => Array
        (
            [0] => *
        )

)
=> true
>>> SiteContato::find(1)                                                                                                                   
=> App\Models\SiteContato {#4631
     id: 1,
     nome: "Adalberto",
     telefone: "98981188434",
     email: "adalberto@gmail.com",
     motivo_contato: 1,
     mensagem: "Olá. Gostaria de maiores detalhes..",
     created_at: "2022-10-30 19:34:37",
     updated_at: "2022-10-31 20:53:29",
   }

### ATUALIZANDO REGISTROS fill e save
>>> $res = Fornecedor::find(1)                                                                                                             
[!] Aliasing 'Fornecedor' to 'App\Models\Fornecedor' for this Tinker session.
=> App\Models\Fornecedor {#4646
     id: 1,
     nome: "Fornecedor XYZ",
     site: "https://www.albertogomesdasilva.com.br",
     created_at: "2022-10-30 20:01:42",
     updated_at: "2022-10-30 20:01:42",
     uf: "MA",
=> App\Models\Fornecedor {#4646
     id: 1,
     nome: "AGS - Fornecedores",
     site: "https://www.albertogomesdasilva.com.br",
     created_at: "2022-10-30 20:01:42",
     updated_at: "2022-10-30 20:01:42",
     uf: "MA",
     email: "fornecedorxyz@gmail.com.br",
   }

>>> $res->save()
=> true

### ATUALIZANDO REGISTROS WHERE E UPDATE
>>> Fornecedor::whereIn('id', [1, 2])                                                                                                      
=> Illuminate\Database\Eloquent\Builder {#4639}
>>> Fornecedor::whereIn('id', [1, 2])->get()                                                                                               
=> Illuminate\Database\Eloquent\Collection {#4635
     all: [
       App\Models\Fornecedor {#3681
         id: 1,
         nome: "AGS - Logística",
         site: "http://agslog.com.br",
         created_at: "2022-10-30 20:01:42",
         updated_at: "2022-10-31 21:15:09",
         uf: "MA",
         email: "agslog@gmail.com",
       },
       App\Models\Fornecedor {#4648
         id: 2,
         nome: "Brascopper-SLZ",
         site: "https://brascopper-slz.com.br",
         created_at: "2022-10-30 20:06:03",
         updated_at: "2022-10-30 20:06:03",
         uf: "MA",
         email: "brascopperslz@gmail.com.br",
       },
     ],
   }

>>> Fornecedor::whereIn('id', [1, 2])->update(['nome'=>'Nova Log', 'site'=>'http://nlog.com.br', 'email'=>'nlog@hotmail.com'])             
=> 2

>>> Fornecedor::whereIn('id', [1, 2])->get()                                                                                               
=> Illuminate\Database\Eloquent\Collection {#4418
     all: [
       App\Models\Fornecedor {#4631
         id: 1,
         nome: "Nova Log",
         site: "http://nlog.com.br",
         created_at: "2022-10-30 20:01:42",
         updated_at: "2022-10-31 21:21:31",
         uf: "MA",
         email: "nlog@hotmail.com",
       },
       App\Models\Fornecedor {#4641
         id: 2,
         nome: "Nova Log",
         site: "http://nlog.com.br",
         created_at: "2022-10-30 20:06:03",
         updated_at: "2022-10-31 21:21:31",
         uf: "MA",
         email: "nlog@hotmail.com",
       },
     ],
   }

   >>> Fornecedor::where('id', 1)->update(['nome' => 'AGS - Logística', 'site'=>'http://agslog.com.br', 'email'=>'agslog@gmail.com' ])        
=> 1

### DELETANDO REGISTROS - DELETE E DESTROY
>>> SiteContato::where('id', 1)->delete()
=> 1

>>> SiteContato::find(2)->delete('id', 2)
=> true

>>> $res = SiteContato::find(4)->delete()
=> true
>>> SiteContato::destroy(5)             
=> 1

>>> SiteContato::destroy(7, 8)   
=> 2
# php artisan make:seeder SiteContatoSeeder
# php artisan make:seeder Fornecedor
### SEEDERS (DatabaseSeeder) - (classes conhecidas como sementes) -> Inserindo poucos registros:
- Com o banco de dados completamente limpo vamos começar criando o nosso primeiro seed para popular a tabela 'fornecedores':

### php artisan make:seeder FornecedorSeeder  // Não existe convenção, mais o ideal é colocar no final do nome o nome seeder
# 3 FORMAS DIFERENTES:

FornecedorSeeder.php
<?php

namespace Database\Seeders;

use Illuminate\Database\Console\Seeds\WithoutModelEvents;
use Illuminate\Database\Seeder;

use App\Fornecedor;

class FornecedorSeeder extends Seeder
{
    /**
     * Run the database seeds.
     *
     * @return void
     */
    public function run()
    {
        // MÉTODO 1 DE FAZER -> Instanciando o objeto
        $fornecedor = new Fornecedor;

        $fornecedor->nome = 'Fornecedor 100';
        $fornecedor->site = 'https://fornecedor100.com.br';
        $fornecedor->uf = 'MA';
        $fornecedor->emal = 'fornecedor100@gmail.com';
        $fornecedor->save();

        // MÉTODO 2 DE FAZER => MÉTODO CREATE -> DESTA FORMA NO MODEL Fornecedor.php  DEVE INSERIR A LINHA:
        // protected $fillable = ['nome', 'site', 'uf', 'email'];
        Fornecedor::create([
            'nome'=>'Fornecedor200',
            'site' => 'https://forn200.com.br',
            'uf'=> 'RS',
            'email'=>'forn200@gmail.com'
        ]);

        // MÉTODO 3 -> USANDO O MÉTODO INSERT
        DB::table('fornecedores')->insert([
            'nome'=>'Fornecedor300',
            'site' => 'https://fornec300.com.br',
            'uf'=> 'SP',
            'email'=>'fornec300@hotmail.com'
        ]);
    }
}

# \App\Models\SiteContato::factory(100)->create(); -> esta instrução pode está no DatabaseSeeder.php ou no SiteContatoSeeder.php
# \App\Models\Fornecedor::factory(100)->create(); -> esta instrução pode está no DatabaseSeeder.php ou no FonnecedorSeeder.php;

->  $this->call(FornecedorSeeder::class);
->  $this->call(SiteContatoSeeder::class);
# CONFIGURAR O DatabaseSeeder.php

# para executar a seeder: php artisan db:seed   =>  $this->call(FornecedorSeeder::class);  
# php artisan db:seed -> Executa todas as seeders
# >php artisan db:seed --class=SiteContatoSeeder -> Executa uma seed específicada pelo nome

<?php

namespace Database\Seeders;

// use Illuminate\Database\Console\Seeds\WithoutModelEvents;
use Illuminate\Database\Seeder;

class DatabaseSeeder extends Seeder
{
    /**
     * Seed the application's database.
     *
     * @return void
     */
    public function run()
    {
         $this->call(FornecedorSeeder::class);  

        //   \App\Models\User::factory(10)->create();
        //   \App\Models\SiteContato::factory(100)->create();
        //   \App\Models\Fornecedor::factory(100)->create();
        //   \App\Models\FornecedorSeeder::class;

        // \App\Models\User::factory()->create([
        //     'name' => 'Test User',
        //     'email' => 'test@example.com',
        // ]);
    }
}

# FornecedorSeeder.php
<?php

namespace Database\Seeders;

use Illuminate\Database\Console\Seeds\WithoutModelEvents;
use Illuminate\Database\Seeder;

use App\Models\Fornecedor;

class FornecedorSeeder extends Seeder
{
    /**
     * Run the database seeds.
     *
     * @return void
     */
    public function run()
    {
        $fornecedor = new Fornecedor;

        $fornecedor->nome = 'Fornecedor 100';
        $fornecedor->site = 'https://fornecedor100.com.br';
        $fornecedor->uf = 'MA';
        $fornecedor->email = 'fornecedor100@gmail.com';
        $fornecedor->save();

        Fornecedor::create([
            'nome'=>'Fornecedor200',
            'site' => 'https://forn200.com.br',
            'uf'=> 'RS',
            'email'=>'forn200@gmail.com'
        ]);

    }
}

# SiteContatoSeeder.php
<?php

namespace Database\Seeders;

use Illuminate\Database\Console\Seeds\WithoutModelEvents;
use Illuminate\Database\Seeder;

use App\Models\SiteContato;

class SiteContatoSeeder extends Seeder
{
    /**
     * Run the database seeds.
     *
     * @return void
     */
    public function run()
    {
        $sitecontato = new SiteContato;

        $sitecontato->nome = 'Alberto Gomes';
        $sitecontato->telefone = '98981188434';
        $sitecontato->email = 'ags@silva.com.br';
        $sitecontato->motivo_contato = 2;
        $sitecontato->mensagem = 'Detalhes do produto';
        $sitecontato->save();

        SiteContato::create([
            'nome'=>'agsilva',
            'telefone' => '98988445577',
            'email'=> 'agsilva@gmail.com',
            'motivo_contato'=>1,
            'mensagem'=>'Mais informações.'
        ]);

    }
}

# DatabaseSeeder.php
<?php

namespace Database\Seeders;

// use Illuminate\Database\Console\Seeds\WithoutModelEvents;
use Illuminate\Database\Seeder;

class DatabaseSeeder extends Seeder
{
    /**
     * Seed the application's database.
     *
     * @return void
     */
    public function run()
    {
        // $this->call(FornecedorSeeder::class);
         $this->call(SiteContatoSeeder::class);

        //   \App\Models\User::factory(10)->create();
        //   \App\Models\SiteContato::factory(100)->create();
        //   \App\Models\Fornecedor::factory(100)->create();
        //   \App\Models\FornecedorSeeder::class;

        // \App\Models\User::factory()->create([
        //     'name' => 'Test User',
        //     'email' => 'test@example.com',
        // ]);
    }
}

>php artisan migrate:rollback
>php artisan migrate:fresh
>php artisan migrate --seed   

   INFO  Running migrations.

  2014_10_12_000000_create_users_table ..................................................... 71ms DONE
  2014_10_12_100000_create_password_resets_table ........................................... 59ms DONE
  2019_08_19_000000_create_failed_jobs_table ............................................... 58ms DONE
  2019_12_14_000001_create_personal_access_tokens_table .................................... 75ms DONE
  2022_10_29_124933_create_site_contatos_table ............................................. 27ms DONE
  2022_10_29_141119_create_fornecedores_table .............................................. 26ms DONE
  2022_10_30_144326_alter_fornecedores_novas_colunas ....................................... 50ms DONE
  2022_10_30_151416_create_produtos_table .................................................. 30ms DONE
  2022_10_30_152706_create_produtos_detalhes_table ........................................ 144ms DONE
  2022_10_30_163254_create_unidades_table ................................................. 291ms DONE
  2022_10_30_175104_ajuste_produtos_filiais ............................................... 269ms DONE
  2022_10_30_182603_nova_coluna_site_com_after ............................................. 51ms DONE
  2022_10_31_230638_alter_fornecedores_softdelete .......................................... 49ms DONE

   INFO  Seeding database.

  Database\Seeders\FornecedorSeeder .................................................... RUNNING  
  Database\Seeders\FornecedorSeeder .............................................. 11.04 ms DONE  

  Database\Seeders\SiteContatoSeeder ................................................... RUNNING  
  Database\Seeders\SiteContatoSeeder ............................................. 13.34 ms DONE  



### FACTORIES - FACTORY -> para popular o banco de dados criamos as factory

### https://github.com/fzaninotto/Faker/

# php artisan make:factory SiteContatoFactory --model SiteContato
# php artisan make:factory SiteContatoFactory --model SiteContato

>php artisan make:factory SiteContatoFactory --model SiteContato
<?php

namespace Database\Factories;

use Illuminate\Database\Eloquent\Factories\Factory;

/**
 * @extends \Illuminate\Database\Eloquent\Factories\Factory<\App\Models\SiteContato>
 */
class SiteContatoFactory extends Factory
{
    /**
     * Define the model's default state.
     *
     * @return array<string, mixed>
     */
    public function definition()
    {
        return [
            'nome' => fake()->name(),
            'telefone' => fake()->tollFreePhoneNumber(),
            'email' => fake()->email(),
            'motivo_contato' => fake()->numberBetween(1,3),
            'mensagem' => fake()->text(200)
        ];
    }
}


>php artisan make:factory FornecedorFactory --model Fornecedor

<?php

### https://github.com/fzaninotto/Faker/

namespace Database\Factories;

use Illuminate\Database\Eloquent\Factories\Factory;

/**
 * @extends \Illuminate\Database\Eloquent\Factories\Factory<\App\Models\Fornecedor>
 */
class FornecedorFactory extends Factory
{
    /**
     * Define the model's default state.
     *
     * @return array<string, mixed>
     */
    public function definition()
    {
        return [
            'nome' => fake()->name(),
            'site' => fake()->tollFreePhoneNumber(),
            'uf' => fake()->stateAbbr(),
            'email' => fake()->email(),
           
        ];
    }
}

### ALTERAMOS O ARQUIVO DatabaseSeeder.php para poder executar:
/database/seeders/DatabaseSeeder.php

<?php

namespace Database\Seeders;

// use Illuminate\Database\Console\Seeds\WithoutModelEvents;
use Illuminate\Database\Seeder;

class DatabaseSeeder extends Seeder
{
    /**
     * Seed the application's database.
     *
     * @return void
     */
    public function run()
    {
        // \App\Models\User::factory(10)->create();
         \App\Models\SiteContato::factory(100)->create();
         \App\Models\Fornecedor::factory(100)->create();

        // \App\Models\User::factory()->create([
        //     'name' => 'Test User',
        //     'email' => 'test@example.com',
        // ]);
    }
}

### EXECUTANDO A SEED E POPULANDO DADOS NO BANCO 

>php  artisan db:seed


### DELETANDO REGISTROS - SOFTDELETE -> Criamos uma coluna para marcamos um registro ao invés de excluir.
importamos com a linha:
 use Illuminate\Database\Eloquent\SoftDeletes; 
no Model Fornecedor.php

* Trait -> São pedaços de códigos que definem propriedades e métodos e que podem ser utilizados dentro de uma classe como um especie de include, de CTRL+C CTRL+V, com isso, a classe se expande incorporando as propriedades e métodos dessa respectiva trait. É parecida com extends, mas como não podemos ter herança múltiplas, as traits são utilizadas para poder contornar isso. Na O.O. temos essa restrição de herança multiplas. Implementa uma herança horizontal em vez da vertical de herança múltipla.

Fornecedor.php (Model)
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\SoftDeletes;

class Fornecedor extends Model
{
    use SoftDeletes;
    
    use HasFactory;
    protected $table = 'fornecedores';

    protected $fillable = ['nome', 'site', 'uf', 'email'];

}

O PRÓXIMO PASSO É AJUSTAR A MIGRATION DE CRIAÇÃO DA TABELA fornecedores:

$table->softDeletes();   //Cria a coluna deleted_at na tabela fornecedores

2022_10_29_141119_create_fornecedores_table.php

<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     *
     * @return void
     */
    public function up()
    {
        Schema::create('fornecedores', function (Blueprint $table) {
            $table->id();
            $table->string('nome', 50);
            $table->timestamps();
          //  $table->softDeletes();   //Cria a coluna deleted_at na tabela fornecedores
        });
    }

    /**
     * Reverse the migrations.
     *
     * @return void
     */
    public function down()
    {
        Schema::dropIfExists('fornecedores');
    }
};

Fazendo assim teremos que dá refresh no banco como um todo... 

### criando a migration para acrescentar a coluna deleted_at ao invés de acrescentar na migration de criação da tabela:

>php artisan make:migration alter_fornecedores_softdelete  


2022_10_31_230638_alter_fornecedores_softdelete.php

<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     *
     * @return void
     */
    public function up()
    {
        Schema::table('fornecedores', function(Blueprint $table) {
            $table->softDeletes();
        });
    }
    
    /**
     * Reverse the migrations.
     *
     * @return void
     */
    public function down()
    {
        Schema::table('fornecedores', function(Blueprint $table) {
            $table->dropSoftDeletes();
        });
        
    }
};


>php artisan migrate:status

Migration name ............................................................... Batch / Status  
  2014_10_12_000000_create_users_table ....................................... [1] Ran  
  2014_10_12_100000_create_password_resets_table ............................. [1] Ran  
  2019_08_19_000000_create_failed_jobs_table ................................. [1] Ran  
  2019_12_14_000001_create_personal_access_tokens_table ...................... [1] Ran  
  2022_10_29_124933_create_site_contatos_table ............................... [1] Ran  
  2022_10_29_141119_create_fornecedores_table ................................ [1] Ran  
  2022_10_30_144326_alter_fornecedores_novas_colunas ......................... [1] Ran  
  2022_10_30_151416_create_produtos_table .................................... [1] Ran  
  2022_10_30_152706_create_produtos_detalhes_table ........................... [1] Ran  
  2022_10_30_163254_create_unidades_table .................................... [1] Ran  
  2022_10_30_175104_ajuste_produtos_filiais .................................. [1] Ran  
  2022_10_30_182603_nova_coluna_site_com_after ................................ [1] Ran  
  2022_10_31_230638_alter_fornecedores_softdelete ............................. Pending  


> php artisan migrate

### DELETANDO E PREENCHENDO A COLUNA deleted_at
>>> $res = Fornecedor::find(1)                                                                                           
=> App\Models\Fornecedor {#3707
     id: 1,
     nome: "Santiago Wintheiser",
     site: "(888) 524-2135",
     created_at: "2022-10-31 22:40:51",
     updated_at: "2022-10-31 22:40:51",
     uf: "NC",
     email: "awalsh@yahoo.com",
     deleted_at: null,
   }

>>> $res->delete()                                                                                                       
=> true
ID   NOME          SITE      CREATED_AT UPDATED_AT  UF      EMAIL             DELETED_AT
1	Santiago Winth https.ww.com 22:40:51 23:13:33	    NC	awalsh@yahoo.com	2022-10-31 23:13:33

>>> Fornecedor::find(1)                                                                                                  
=> null

### RESTAURANDO OS REGISTROS REMOVIDOS DE MODO SUAVE (SOFTDELETE)
* Exibindo os deletados com softDelete
>>> Fornecedor::withTrashed()->get()                                                                                     
         updated_at: "2022-10-31 23:13:33",
         uf: "NC",
         email: "awalsh@yahoo.com",
         deleted_at: "2022-10-31 23:13:33",
       },
     ],
   }
* criando um novo registro:

>>> Fornecedor::create(['nome' => 'Fornec123', 'site'=>'fornec123.com.br', 'uf'=>'MA', 'email'=>'f123@gmail.com'])     
=> App\Models\Fornecedor {#4079
     nome: "Fornec123",
     site: "fornec123.com.br",
     uf: "MA",
     email: "f123@gmail.com",
     updated_at: "2022-10-31 23:30:02",
     created_at: "2022-10-31 23:30:02",
     id: 201,
   }                                                                                                     

* EXIBINDO SOMENTE OS DELETADOS COM SOFTDELETES
>>> Fornecedor::onlyTrashed()->get()                                                                                   
=> Illuminate\Database\Eloquent\Collection {#3706
     all: [
       App\Models\Fornecedor {#4097
         id: 1,
         nome: "Santiago Wintheiser",
         site: "(888) 524-2135",
         created_at: "2022-10-31 22:40:51",
         updated_at: "2022-10-31 23:13:33",
         uf: "NC",
         email: "awalsh@yahoo.com",
         deleted_at: "2022-10-31 23:13:33",   // QUANDO DELETA INSERI A DATA E HORA SOMENTE
       },
     ],
   }

### RESTAURANDO O REGISTRO DELETADO (SOFTDELETES)          
>>> $res = Fornecedor::withTrashed()->get()                                                                            
=> Illuminate\Database\Eloquent\Collection {#4077
     all: [
       App\Models\Fornecedor {#4100
         id: 1,
         nome: "Santiago Wintheiser",
         site: "(888) 524-2135",
         created_at: "2022-10-31 22:40:51",
         email: "f123@gmail.com",
         deleted_at: null,
       },
     ],
   }

>>> $res[0]->restore()
=> true

>>> SIMPLISMENTE DELETA O REGISTRO DA COLUNA deleted_at

### ENTENDENDO O OBJETO REQUEST
# ROTA -> web.php
Route::get('/contato', [\App\Http\Controllers\ContatoController::class, 'contato'])->name('site.contato');

# ContatoController.php
<?php

namespace App\Http\Controllers;

use Illuminate\Http\Request;

class ContatoController extends Controller
{
    public function contato(Request $request) {

      //  var_dump($_POST);
      // dd($_POST);
      echo '<pre>';
       print_r($request->all());
       echo '<hr>';
       print_r($_POST);
      echo '</pre>';
      echo $request->input('nome') . '<br>';
      echo $request->input('email') . '<hr>';
        return view('site.contato', ['titulo' => 'Contato - titulo vindo do controlador'], ['teste' => 'Alberto Gomes']);
    }
}

# view localhost:8000/contato (depois de preenchido e enviado) - Exibição na view contato;
Array
(
    [_token] => iseKKj7lQwd4Jm0tpCp4q1qAdjHj20ANtLLZtVo9
    [nome] => Alberto Gomes
    [telefone] => 9999999999
    [email] => albe@gmail.com
    [mensagem] => aestou com uma dúvida
)
Array
(
    [_token] => iseKKj7lQwd4Jm0tpCp4q1qAdjHj20ANtLLZtVo9
    [nome] => Alberto Gomes
    [telefone] => 9999999999
    [email] => albe@gmail.com
    [mensagem] => aestou com uma dúvida
)
Alberto Gomes
albe@gmail.com

### GRAVANDO OS DADOS DO FORMULÁRIO NO BANCO DE DADOS:
<?php

namespace App\Http\Controllers;

use Illuminate\Http\Request;

use App\Models\SiteContato;

class ContatoController extends Controller
{
    public function contato(Request $request) {

      // //  var_dump($_POST);
      // // dd($_POST);
      // echo '<pre>';
      //  print_r($request->all());
      //  echo '<hr>';
      //  print_r($_POST);
      // echo '</pre>';
      // echo $request->input('nome') . '<br>';
      // echo $request->input('email') . '<hr>';
       
      $contato = new SiteContato;
      // $contato->nome = $request->input('nome');
      // $contato->telefone = $request->input('telefone');
      // $contato->email = $request->input('email');
      // $contato->motivo_contato = $request->input('motivo_contato');
      // $contato->mensagem = $request->input('mensagem');

      $contato->fill($request->all());      // PRECISO DA LINHA '$contato->save();' PARA USAR ESTE MÉTODO, 
                                             //   USANDO ESSE   MÉTODO E O 'fill' NA MODEL SiteContato.php ADICIONAR 
                                              // O ATTRUBUTO $fillable
      $contato->create($request->all());    AQUI NÃO PRECISO DA LINHA: $contato->save();  //TAMBÉM PARA USAR ESTE MÉTODO 'create' NA MODEL SiteContato.php ADICIONAR O ATTRUBUTO $fillable
      
      $contato->save();  // ==> SALVA NO BANCO DE DADOS

     print_r($contato->getAttributes());
    //  print_r($_POST);

        return view('site.contato', ['titulo' => 'Contato (teste)']);   // PASSANDO O TÍTULO POR VARIÁVEL COMO PARÂMETRO 
    }
}

# MODEL SiteContato.php

<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;

class SiteContato extends Model
{
    use HasFactory;
    // protected $table = 'site_contatos';

     protected $fillable = ['nome', 'telefone','email', 'motivo_contato', 'mensagem']; // necessário para os métodos fill e create
}

### VAIDAÇÃO DE CAMPOS OBRIGATÓRIOS - required
laravel.com/docs/7.x/validation

#Available Validation Rules

-> Validação de dados do lado do backend da aplicação
ContatoController.php
<?php

namespace App\Http\Controllers;

use Illuminate\Http\Request;

use App\Models\SiteContato;

class ContatoController extends Controller

    public function salvar(Request $request) {

      // REALIZAR A VALIDAÇÃO DOS DADOS RECEBIDOS - A VARIÁVEL $erros DO lARAVEL ESTÁ DISPONIVEL PARA ISSO EM QUALQUER VIEW
        $request->validate([
          'nome' => 'required',
          'telefone' => 'required',
          'email' => 'required',
          'motivo_contato' => 'required',
          'mensagem' => 'required',
        ]);

### VALIDAÇÃO DE QUANTIDADES MÍNIMAS E MÁXIMSA DE CARACTERES (min e max)

laravel.com/docs/7.x/validation

#Available Validation Rules

   'nome' => 'required|min:3|max:40',  //Nomes de 3 a 40 caracteres permitido nesse campo

### REPOPULAR O FORMULÁRIO COM O CONTEÚDO ANTES DO ERRO
Recuperando os dados do formulário com o conteúdo que foi digitado ao ocorrer o erro.

* old()

for_contato.php
{{ $slot }}

{{ $x }}

<form action={{ route('site.contato') }} method="post" > 
            @csrf
            <input name="nome" value="{{ old('nome') }}"  type="text" placeholder="Nome" class="{{ $classe }}">
            <br>
            <input type="text" name="telefone" value="{{ old('telefone') }}" placeholder="Telefone" class="{{ $classe }}">
            <br>
            <input type="text" name="email" value="{{ old('email') }}" placeholder="E-mail" class="{{ $classe }}">
            <br>
            <select name="motivo_contato" class="{{ $classe }}">
                <option value="">Qual o motivo do contato?</option>
                <option value="1">Dúvida</option>
                <option value="2">Elogio</option>
                <option value="3">Reclamação</option>
            </select>
            <br>
            <textarea name="mensagem" value="{{ old('mensagem') }}" class="{{ $classe }}" placeholder="Preencha aqui a sua mensagem"> {{ (old('mensagem') != '') ?  old('mensagem')  :'' }} </textarea>
    <br>
    <button type="submit" class="btn btn-suces">ENVIAR</button>
</form>
<div style="position:absolute; top:0px; left:0px; width:100%; height: 150px; background: orange; color: red;">
{{ print_r($errors); }}
</div>














 
###********************-> FIM LARAVEL UDEMY  END <-******************###

<!--  DOCKER INÍCIO:

1 instalar o docker e docker-compose

2 abrir wsl2/Windows ou linux
 curl -s "https://laravel.build/projetosail?with=mysql,redis,mailhog,minio" | bash

3 cd olw
./vendor/bin/sail up -d
	ou
4 cd olw && ./vendor/bin/sail up -d

5 ATRIBUINDO PERMISSÃO PARA A PASTA
cd .. -> sai da pasta
sudo chmod 777 olw/ -R ou sem o 'sudo' chmod 777 olw/ -R

6 CRIANDO ALIAS PARA O COMANDO ANTERIOR
alias sail='[ -f sail ] && sh sail || sh vendor/bin/sail'
passa a usar assim: sail ps

7 CONFIGURAR PORTAS PARA A APLICAÇÃO NO NAVEGADOR E MYSQL
.env
APP_PORT=8000

*porta do myql
FORWARD_DB_PORT=3307

8 INSTALANDO DEPENDÊNCIA AO PROJETO
./vendor/bin/sail composer require laravel/breeze --dev 

e depois tem que 


9 DEIXAR TELA DE AUTENTICAÇÃO PRONTA, ROTA AUTENTICADA, TAWINDCSS INSTALADO E INERTIA INSTALADO
./vendor/bin/sail artisan breeze:install vue 
ou
./vendor/bin/sail art breeze:install vue




10 RODAR AS MIGRATES PADRÕES DO PROJETO AI JÁ PODE CADASTRAR USUÁRIOS PARA LOGIN:
./vendor/bin/sail art migrate

-->

 /***************************************** */
 Route::prefix('usuarios')->group(function() {
    Route::get('', function(){
        return 'usuarios';
    })->name('usuarios');
    
    Route::get('/{id}', function($id){
        return 'mostrar detalhes do usuário';
    })->name('usuario-detalhes');

    Route::get('/{id}/tags', function($id){
        return 'mostrar tags do usuário';
    })->name('usuario_tags');

});


/*******************************************/
2a AULA:

O PROJETO CONSISTE EM RECEBER DADOS DE UMA API (punkapi.com) DE INFORMAÇÕES SOBRE CERVEJAS, VAMOS CONSTRUIR AS ROTAS PARA CONSUMIR A API E CRIAR A ESTRUTURA PARA O RELATÓRIO QUE IREMOS GERAR EM EXCEL E ENVIAR PARA O STORAGE...
1 CRIAR ROTAS:
code .
olw/routes/web.php


sail up -d -> SOBE O CONTAINER localhost:8000 (nesse projeto)

Route::get('/beers', fn()=> 'Olw - testando a rota /beers');

**************************************************
obs:
- laravel.com/api -> acesso a documentação do código;
- in line paramets for vscode -> extensão para vscode para exibir o nome dos métodos na hora que codificar;
- fira code -> extensão para fonte no vscode

git Hub Copilot vs Tabnine -> (pesquisar sobre)
Link para extensões vscode:
https://github.com/icarojobs/vscode-useful-extensions
*************************************************


Route::get('/beers', fn()=> 'Olw - testando a rota /beers')
                             ->middleware(['auth']);

* FLUXO PADRÃO DO MVC-LARAVEL: 
life cicle: sai do usuário pelo navegador, insomnia ou postman -> passa pelo index.php(pasta public) -> passa pelos arquivos do bootstrap retornando uma instância da aplicação -> passa pelo kernel do http (carrega mais instâncias) -> Service provider -> despacha a requisição pro Router -> Cai no arquivo Web.php -> Middleware (se tiver, geralmente tem os globais) -> Controller (faz as regras de negócio e pode chamar outras classes como Serviços por exemplo)
-> Retorna uma view ou um json (No caso estamos usando inértia, ele não vai reinderizar a 'view.blade' padrão, ele vai reinderizar componente vue.js através do inértia.).


* EM VEZ DE USAR A FUNÇÃO AQUI NA ROTA CRIAMOS UM CONTROLLER:

* ROTAS:
Route::prefix('usuarios')->group(function() {
    Route::get('', function(){
        return 'usuário';
    })->name('usuarios');
    Route::get('/{id}', function($id){
        return $id;
    })->name('usuario_id');

});



Route::get('/users/{id?}', function ($id = null) {
    return $id;
});


obs.: ​dica: php artisan make:controller -r cria o Resource também.
dica: limpar o cache do container:
./vendor/bin/sail art config:cache 
./vendor/bin/sail art optimize:clear
ou
./vendor/bin/sail art config:cache && art optimize:clear

sail artisan make:controller BeerController
ou 
sail art make:controller BeerController -> CRIA O ARQUIVO BeerController.php na pasta app/Http/Controllers
->
<?php

namespace App\Http\Controllers;

use Illuminate\Http\Request;

class BeerController extends Controller
{
    public function index()
    {
    return 'Virgu & Beer & Code'
    }
}

* NO ARQUIVO DE ROTAS Web.php CHAMA O BeersController:

importante importar o Controller <nomeDoController>+<CTRL=ENTER:
use App\Http\Controllers\BeerController;

Route::get('/beers', [BeerController::class, 'index'])
                        ->middleware(['auth']);


* PRECISAMOS CRIAR UM MÉTODO PARA PEGAR A LISTA, LISTAR OS DADOS DA API (listar as bebidas de https://api.punkapi.com/v2 ->
VAMOS CRIAR UMA NOVA CLASSE de serviços em app/Sevices/PunkapiService.php

* O LARAVEL POSSUI UM RECURSO CHAMADO HTTPClient que abstrai o uso de uma ferramenta chama guzeo, esse guzeo é o client http mais comum para php, com ele fazemos requisições pra diversos serviços web dentro do php para outras url, ele é robusto, então o laravel simplifica importando o recurso que faz tudo por 'detrás dos panos':

PunkapiService.php

<?php

namespace App\Services;

use Illuminate\Support\Facades\Http;

class PunkapiService
{
    public function getBeers()
    {
        return Http::get('https://api.punkapi.com/v2/beers');
    }
}

E NO BeerController.php fica:
<?php

namespace App\Http\Controllers;

use App\Services\PunkapiService;
use Illuminate\Http\Request;

class BeerController extends Controller
{
    public function index()
    {
    //return 'Virgu & Beer & Code';
    $service = new PunkapiService;

    return $service->getBeers();
    }
}

* TRATE É CARACTERÍSTICA QUE A CLASSE ADQUIRE (pode ter mesmos métodos e atributos substituindo o recurso de um classe extender várias classes que não tem no php, a trate é uma forma de fazer isso. O service  é uma outra camada na maioria das vezes abstrair seviços que vc vai consumir, por exemplo API.

Estando logado, os dados da api já serão exibidos em localhost:8000/beers, se usar um aplicativo cliente tipo insomnia pode apresentar os dados também, melhor comentar a linha de de autenticação da rota:
Route::get('/beers', [BeerController::class, 'index']);
linha de autenticação da rota // ->middleware(['auth']);

* ESSA API PERMITE FAZER FILTROS VIA PARÂMETROS NA PRÓPRIA ROTA. PRIMEIRO VAMOS REFATORAR O CÓDIO, A CLASSE PunkapiService.php:

USO DE CONFIG E MACRO


Vamos alterar a url, primeiro acessando a pasta config da raiz do projeto e criar o arquivo punkapi.php. O que acontece é que o config(pasta config da raiz) carrega todos os arquivos da pasta e permite que sejam acessados via funções simples(HELPERS), isso é muito legal porque podemos acessar esses arquivos de configurações de qualquer lugar do projeto: 

<?php

return [
    'url' => env('PUNK_BASE_URL', 'https://api.punkapi.com/v2')
];

Usando o helper env significa dizer que, se não houver a constante PUNK_BASE_URL setada no arquivo .env do projeto, seu valor será o segundo parâmetro: http://api.punkapi.com/v2 e no arquivo PunkapiService.php da pasta app/Services fica:

<?php

namespace App\Services;

use Illuminate\Support\Facades\Http;

class PunkapiService
{
    public function getBeers()
    {
        return Http::get('/beers');
    }
}

MACRO é uma forma de criar funções customizadas:
 em app\Providers vamos acessar o arquivo AppServiceProvider.php que é uma classe que tem dois métodos register e boot. No método boot vamos chamar o método Http do laravel e chamar o método macro, no primeiro parâmetro será um nome atribuído à função e e o segundo uma clausure (uma função).
Neste arquivo é passado o arquivo de configuração da url (em 'config/punkapi.php') além de tokens, headers,...
 

use Illuminate\Support\Facades\Http; -> deve ser importado
E a função boot fica:

  public function boot()
    {
        Http::macro('punkapi', function(){
            return Http::acceptJson()
            ->baseUrl(config('punkapi.url'));
        });
    }

Então criamos uma macro(uma função customizada) chamada punkapi que já retorna o client com accept/Json no Header e com o baseUrl configurado lá do arquivo /config/punkapi.php e se estiver setado no .env pegará de lá.

/app/Services/PunkapiService.php fica:

<?php

namespace App\Services;

use Illuminate\Support\Facades\Http;

class PunkapiService
{
    public function getBeers()
    {
        return Http::punkapi()->get('/beers');
    }
}

*obs.: a baseUrl poderia ser setada no construtor, que pode setar token também.(uma outra abordagem para versão sem macros);

->Testamos o retorno Json em localhost:8000/beers.

Refatorando o arquivo PunkapiService.php: O client Http não lança exceção e podemos forçar o retorno em modo Json:
<?php

namespace App\Services;

use Illuminate\Support\Facades\Http;

class PunkapiService
{
    public function getBeers()
    {
       // return Http::punkapi()->get('/beers');
       return Http::punkapi()
            ->get('/beers')
            ->throw()  // Exceção em caso de erro
            ->json();   // Força o retorno em formato Json
    }
}

Podemos testar forçando um erro alterando a constante PUNKAPI_BASE_URL criada em /config/punkapi.php, vamos atribuir um valor diferente no arquivo .env:

PUNKAPI_BASE_URL="adfjklj878"

Podemos usar a função retry tem dois parâmetros, o número de tentativas pra buscar a requisição e o intervalo entre elas. Refatorando o código fica:
<?php

namespace App\Services;

use Illuminate\Support\Facades\Http;

class PunkapiService
{
    public function getBeers()
    {
       // return Http::punkapi()->get('/beers');
       return Http::punkapi()
            ->get('/beers')
            ->throw()  // Exceção em caso de erro
            ->json();   // Força o retorno em formato Json
    }
}

- Quando sai a exceção nao deveriamos retornar o erro em json por ser um api neste caso estamos usamos um app web e não uma api. E usaríamos o Route Api.

Refatorando o método boot de /app/Providers/AppServiceProvider.php, inserindo o retry():

     */
    public function boot()
    {
        Http::macro('punkapi', function(){
            return Http::acceptJson()
            ->baseUrl(config('punkapi.url'))
            ->retry(3,100);
        });
    }
}

comando de help

* ./vendor/bin/sail composer dump-autoload
* Verificar Nome do arquivo se bate com o nome das rotas(Classes criadas e importar o nome errado);
* inteliphense

Refatorando BeerController.php
<?php

namespace App\Http\Controllers;

use App\Services\PunkapiService;

class BeerController extends Controller
{
    public function index()
    {

    $service = new PunkapiService();

    return $service->getBeers();
    }
}

Em vez de instanciar o método PunkapiService() dentro de index, vamos passar por parâmetro de index() declarando seu Próprio nome (PunkapiService) como tipo. Fica assim:

<?php

namespace App\Http\Controllers;

use App\Services\PunkapiService;

class BeerController extends Controller
{
    public function index(PunkapiService $service)
    {
    return $service->getBeers();
    }
}

Assim usamos feactures do php(injeção de dependências) e ao mesmo tempo feactures do laravel. Em vez de criar uma instância dentro do método index, vamos injetar a classe como parâmetro para o método index(), ficando index($service) e a instância de dentro da função passa como parâmetro de 'tipo da variável'. Isso quebra a cadeia de dependência entre as classes.
Assim, o método index ganha independência não mais dependendo da instância de new PunkapiService e passamos a olhar a função index em si.
Assim, o Laravel tenta fazer um binding, um match, o laravel tenta encontrar alguma classe PunkapiService e cria uma instância dessa classe e usa ali como parâmetro. Se não fizer assim, lá em Rotas teria que ser passado como parâmetro o que fica desnecessário.
Não poderia ser feito se na classe PunkapiService existisse o construtor para atribuir valores automaticamente à classe. Assim podemos usar porque não precisamos passar nenhum valor.

ADICIONAR OS FILTROS:
Vamos filtrar o retorno api com os seguintes itens: beer_name, food, ibu_gt, malte:

var_dump($v)
die();
dd($variável)
benchmarck -> ?

/*****REFATORA PARA TESTE alterando BeerController.php e PunkapiService.php
BeerController.php
<?php

namespace App\Http\Controllers;

use App\Services\PunkapiService;

class BeerController extends Controller
{
    public function index(PunkapiService $service)
    {
    return $service->getBeers(
        'heineken',
        'cheese',
        'corn',
        45
    );
    }
}

PunkapiService.php
<?php

namespace App\Services;

use Illuminate\Support\Facades\Http;

class PunkapiService
{
    public function getBeers(
        string $beer_name,
        string $food,
        string $malt,
        string $ibu_gt
    )
    {
        $params = get_defined_vars();

        dd($params);

        return Http::punkapi()
            ->get('/beers', $params)
            ->throw()  // Exceção em caso de erro
            ->json();   // Força o retorno em formato Json
    }
}

Resultado do debug no insomnia ou no navegador:
array:4 [▼ // app/Services/PunkapiService.php:18
  "beer_name" => "heineken"
  "food" => "cheese"
  "malt" => "corn"
  "ibu_gt" => "45"
]
//* fim teste

Refatorando:

class PunkapiService
{
    public function getBeers(
        string $beer_name = null,
        string $food = null,
        string $malt = null,
        string $ibu_gt = null
    )
    {
        $params = get_defined_vars();

        dd($params);

        return Http::punkapi()
            ->get('/beers', $params)
            ->throw()  // Exceção em caso de erro
            ->json();   // Força o retorno em formato Json
    }
}

Assim quando não passar o valor para a chave ele exibirá a chave e o valor Null, vamos refatorar para não exibir nem a chave englobando get_defined_vers() com array_filter no arquivo PunkapiService.php:

$params = array_filter(get_defined_vars());

<?php

namespace App\Http\Controllers;

use App\Services\PunkapiService;

class BeerController extends Controller
{
    public function index(PunkapiService $service)
    {
    return $service->getBeers(
        'heineken',
        'cheese',
        'corn',
       // 45 -> Esse não é passado
    );
    }
}


array:3 [▼ // app/Services/PunkapiService.php:18
  "beer_name" => "heineken"
  "food" => "cheese"
  "malt" => "corn"
	Aqui não exibiu o valor 45
]


USANDO A FUNÇÃO NAMED_ARGS passamos só os parâmetros que precisamos retornar da api e o php com essa função saberá qual a posição dela no array de argumentos passados como parâmetro sem a necessidade de seguir a mesma sequência dos argumentos:
class BeerController extends Controller
{
    public function index(PunkapiService $service)
    {
    return $service->getBeers(food: 'cheese');
    }
}

REFATORANDO:
BeerController.php
<?php

namespace App\Http\Controllers;

use App\Services\PunkapiService;
use Illuminate\Http\Request;

class BeerController extends Controller
{
    public function index( Request $request, PunkapiService $service)
    {
    return $service->getBeers(...$request->all());
    }
}

PunkapiService.php
<?php

namespace App\Services;

use Illuminate\Support\Facades\Http;

class PunkapiService
{
    public function getBeers(
        string $beer_name = null,
        string $food = null,
        string $malt = null,
        string $ibu_gt = null
    )
    {
        $params = array_filter(get_defined_vars());

     //   dd($params);

        return Http::punkapi()
            ->get('/beers', $params)
            ->throw()  // Exceção em caso de erro
            ->json();   // Força o retorno em formato Json
    }
}

CRIANDO UMA REQUEST
sail artisan make:request BeerRequest
/app/Http/Requests/BeerRequest.php

* Funções anônimas, também conhecidas como closures , permitem a criação de funções que não tem o nome especificado. Elas são mais úteis como o valor de parâmetros callable, mas podem ter vários outros usos.. É uma função passada como parâmetro

CRIANDO NOVA ROTA PARA SALVAR COMO EXCEL
* https://docs.laravel-excel.com/3.1/getting-started/installation.html

Route::group([
    'prefix' => 'beers',
], function() {

    Route::get('/', [BeerController::class, 'index']); //-> Se houver necessidade de salvar dados por essa rota mudamos o método(verbo html) para post(os dados não serão expostos na url).
                          //  ->middleware(['auth']);
    Route::get('/export', [BeerController::class, 'export']);

});

Então passamos a ter duas rotas: localhost:8000/beers
localhost:8000/beers/export

No BeerController incluimos o método export():
class BeerController extends Controller
{
    public function index( BeerRequest $request, PunkapiService $service)
    {
    // return $service->getBeers(...$request->all());
    return $service->getBeers(...$request->validated());
    }

    public function export()
    {
        return 'Relatório criado.';
    }
}



INSTALANDO PACOTE LARAVEL-EXCEL PARA GERAR OS RELATÓRIO EM EXCEL FILTRADOS DA API:

* https://docs.laravel-excel.com/3.1/getting-started/installation.html

COMANDO PARA INSTALAR VIA COMPOSER:
./vendor/bin/sail composer require psr/simple-cache:^2.0 maatwebsite/excel

CRIAR A CLASSE DO EXCEL
./vendor/bin/sail artisan make:export BeerExport  --> Cria o arquivo em  /app/Exports/BeerExport.php

<?php

namespace App\Exports;

use Maatwebsite\Excel\Concerns\FromCollection;

class BeerExport implements FromCollection
{


    /**
    * @return \I¢lluminate\Support\Collection
    */
    public function collection()
    {
        //
    }
}

-> Dentro de colletion buscaremos as informações que serão salvas no arquivo do excel, um array de dados;

criamos um __construct() que vai ter uma propriedade privada do tipo array chamamos de $reportData.

O retorn será uma collection como informa o comentário:
 /**
    * @return \I¢lluminate\Support\Collection
    */

Na função colletion(), está recebendo um array return $this->reportData; 
Observe que não precisa mais declarar uma propriedade que vai se setada via construct(), basta defifinir o escopo junto do argumento e o php faz isso pra você. Como o retorno da função é um array usamos o helper collect para o $this->reportData:

BeerExport.php

<?php

namespace App\Exports;

use Maatwebsite\Excel\Concerns\FromCollection;

class BeerExport implements FromCollection
{

    public function __construct(
        private array $reportData
    ){}

    /**
    * @return \Illuminate\Support\Collection
    */
    public function collection()
    {
       return collect($this->reportData);
    }
}
 

Consultamos a documentação do Laravel-excel em 'Exporting collections':
em Excel Store passa o nome da classe e o nome do arquivo:

BeerController.php
<?php

namespace App\Http\Controllers;


use App\Exports\BeerExport;
use App\Http\Requests\BeerRequest;
use App\Services\PunkapiService;
use Maatwebsite\Excel\Facades\Excel;


class BeerController extends Controller
{
    public function index( BeerRequest $request, PunkapiService $service)
    {
    // return $service->getBeers(...$request->all());
    return $service->getBeers(...$request->validated());
    }

    public function export()
    {
      $params = [
        ['name' => 'Tom', 'age' => '30'],
        ['name' => 'Virgu', 'age' => '27']
       ];

       Excel::store(new BeerExport($params), 'olw-report.xlsx');
       return "Relatório criado";

    }


}

********************************************
* REFATORANDO E SALVANDO O ARQUIVO EXCEL EM /storage/app

BeerExport.php
<?php

namespace App\Exports;

use Maatwebsite\Excel\Concerns\FromCollection;

class BeerExport implements FromCollection
{

    public function __construct(
        private array $reportData
    ){}

    /**
    * @return \Illuminate\Support\Collection
    */
    public function collection()
    {
       return collect($this->reportData);
    }
}
*****************************

BeerController.php

<?php

namespace App\Http\Controllers;


use App\Exports\BeerExport;
use App\Http\Requests\BeerRequest;
use App\Services\PunkapiService;
use Maatwebsite\Excel\Facades\Excel;


class BeerController extends Controller
{
    public function index( BeerRequest $request, PunkapiService $service)
    {
        return $service->getBeers(...$request->all());

    }

    public function export(BeerRequest $request, PunkapiService $service)
    {
        $beers = $service->getBeers(...$request->validated());

        $filteredBeers = collect($beers)->map(function($value, $key){
        return collect($value)
                ->only(['name', 'tagline', 'first_brewed', 'description'])
                ->toArray();
    })->toArray();

    //dd($filteredBeers);

      $params = [
        ['name' => 'Tom', 'age' => '30'],
        ['name' => 'Virgu', 'age' => '27']
       ];

       Excel::store(new BeerExport($filteredBeers), 'olw-report.xlsx');

           return "Relatório criado";

    }


}

PARA SALVAR O ARQUIVO EXCEL EM UM STORAGE S3:
ALTERA BeerController.php

<?php

namespace App\Http\Controllers;


use App\Exports\BeerExport;
use App\Http\Requests\BeerRequest;
use App\Services\PunkapiService;
use Maatwebsite\Excel\Facades\Excel;


class BeerController extends Controller
{
    public function index( BeerRequest $request, PunkapiService $service)
    {
        return $service->getBeers(...$request->all());

    }

    public function export(BeerRequest $request, PunkapiService $service)
    {
        $beers = $service->getBeers(...$request->validated());

        $filteredBeers = collect($beers)->map(function($value, $key){
        return collect($value)
                ->only(['name', 'tagline', 'first_brewed', 'description'])
                ->toArray();
    })->toArray();


       Excel::store(
            new BeerExport($filteredBeers),
             'olw-report.xlsx',
             's3');

           return "Relatório criado";

    }


}

************
O REPOSITÓRIO DE ARQUIVOS minio:
NO DOCKER COMPOSER TEMOS O minio, um S3 que tem
MINIO_ROOT_USER: 'sail'
MINIO_ROOT_PASSWORD: 'password' e roda na porta 9000
localhost:9000
usuário: sail
senha: password

vamos criar um buncket(uma pasta)

e configurar o .env da raiz da aplicação:
originalmente é assim:
AWS_ACCESS_KEY_ID=
AWS_SECRET_ACCESS_KEY=
AWS_DEFAULT_REGION=us-east-1
AWS_BUCKET=
AWS_USE_PATH_STYLE_ENDPOINT=false

 e acrescentamos as informações para:


AWS_ACCESS_KEY_ID=sail
AWS_SECRET_ACCESS_KEY=password
AWS_DEFAULT_REGION=us-east-1
AWS_BUCKET=local
AWS_ENDPOINT=http://minio:9000
AWS_URL=http://minio:9000/local
AWS_USE_PATH_STYLE_ENDPOINT=true

altera tambem:

FILESYSTEM_DISK=local 
para:
FILESYSTEM_DISK=s3

INSTALAR UMA DEPENDÊNCIA (ADAPTER) PARA FAZER CORRESPONDÊNCIA COM A AWS:

Flysystem 3.x em laravel.com/docs/9.x/upgrade
./vendor/bin/sail composer require -W league/flysystem-aws-s3-v3 "^3.0"

em caso de erro:
 artisan vendor:publish --tag=laravel-assets --ansi --force

.env
APP_NAME=Laravel
APP_ENV=local
APP_KEY=base64:UbVvTP6Cu+LF5GamJdB4dsZZvW05ep4bZqcCEhmiDCg=
APP_DEBUG=true
APP_URL=http://localhost
APP_PORT=8000

# PUNKAPI_BASE_URL="httpadfjkljdsdfdfasf878"

LOG_CHANNEL=stack
LOG_DEPRECATIONS_CHANNEL=null
LOG_LEVEL=debug

DB_CONNECTION=mysql
FORWARD_DB_PORT=3307
DB_HOST=mysql
DB_PORT=3306
DB_DATABASE=olw
DB_USERNAME=sail
DB_PASSWORD=password

BROADCAST_DRIVER=log
CACHE_DRIVER=file
FILESYSTEM_DISK=s3
QUEUE_CONNECTION=sync
SESSION_DRIVER=file
SESSION_LIFETIME=120

MEMCACHED_HOST=memcached

REDIS_HOST=redis
REDIS_PASSWORD=null
REDIS_PORT=6379

MAIL_MAILER=smtp
MAIL_HOST=mailhog
MAIL_PORT=1025
MAIL_USERNAME=null
MAIL_PASSWORD=null
MAIL_ENCRYPTION=null
MAIL_FROM_ADDRESS="hello@example.com"
MAIL_FROM_NAME="${APP_NAME}"

AWS_ACCESS_KEY_ID=sail
AWS_SECRET_ACCESS_KEY=password
AWS_DEFAULT_REGION=us-east-1
AWS_BUCKET=local
AWS_ENDPOINT=http://minio:9000
AWS_URL=http://minio:9000/local
AWS_USE_PATH_STYLE_ENDPOINT=true

PUSHER_APP_ID=
PUSHER_APP_KEY=
PUSHER_APP_SECRET=
PUSHER_HOST=
PUSHER_PORT=443
PUSHER_SCHEME=https
PUSHER_APP_CLUSTER=mt1

VITE_PUSHER_APP_KEY="${PUSHER_APP_KEY}"
VITE_PUSHER_HOST="${PUSHER_HOST}"
VITE_PUSHER_PORT="${PUSHER_PORT}"
VITE_PUSHER_SCHEME="${PUSHER_SCHEME}"
VITE_PUSHER_APP_CLUSTER="${PUSHER_APP_CLUSTER}"

PRONTO. ENVIANDO PARA O MINIO.

/**** Criando as Migrations com Virgu e tabela de históricos

























 







/***********************************************************
QUINTA FEIRA: 20/10/22

Open Laravel Week | Deploy com Terraform, EC2 e RDS | Fermentação

****
https://portal.aws.amazon.com/billing/signup?nc2=h_ct&src=header_signup&redirect_url=https%3A%2F%2Faws.amazon.com%2Fregistration-confirmation&language=pt_br#/start/email

Com terraform pode mudar de infra e configurar no git.

PROGRMAR A CONFIGURAÇÃO DO SERVIDOR: É basicamente construir uma nova aplicação para fazer isso, mais fácil de entender.
Terraform serve para (linguagem HCL -> linguagem própria - linguagem descritiva, descreve o resultado e não como irá ser feito), ou seja, descrever o que queremos.
Terraspace é o framework pra terraform.
Quando criamos o Terraform, ele pode variar conforme a infra cloud (aws, azure, google cloud). sua estrutura é a mesma para todos. mas cada provider tem a sua forma de usar, não consegue usar o mesmo código para mais de uma cloud.
Vamos rodar Terraform via container:

1. clonar do git: git clone 
Criar uma pasta para a infraestrutura

sail   (script que vamos usar)
#!/usr/bin/env bash

docker run -rm -it
	-u $(id -u):$(id -g) \
	-v $PWD:/workspace \
	-w /workspace
	hashicorp/terraform:light "%@"


	<no terminal

Logar em: aws.amazon.com
busca: iam
iam dashboard -> mysecurity credencials (root user) -> Acces keys ->clicar em create access keys -> salva o access key e secret access key
e coloca no arquivo credencials na maquina local.. .aws/credencials
















///////////////////////////////////////////////////////////////////////////////////////////////////////
Como bootstrap um novo aplicativo Laravel com docker compose
Publicado em 17 de dezembro de 2020 · Atualizado em 29 de abril de 2022
Para começar, você precisará criar um ambiente contêiner capaz de executar PHP eComposer, a ferramenta de gerenciamento de dependência PHP. Em seguida, você poderá inicializado o novo aplicativo Laravel do zero, sem a necessidade de ter um ambiente PHP local instalado em sua máquina local ou servidor de desenvolvimento.

Neste guia, instruções simplificadas serão fornecidas sobre como configurar esse ambiente com base em nosso tutorial sobrecomo instalar o Laravel com o Docker Compose no Ubuntu 20.04. Consulte esse tutorial para obter instruções mais detalhadas sobre cada uma das opções usadas dentro do arquivo Docker Compose que será fornecido neste guia.

Crie um novo diretório para sua aplicação na pasta inicial:

mkdir ~/landing-laravel
cd ~/landing-laravel
Em seguida, você criará o arquivo que definirá o ambiente contêiner. Neste arquivo, você configurará um serviço chamado, que será baseado em uma imagem docker personalizada construída com um Arquivo Docker que você configurará mais tarde.docker-compose.ymlapp

Os argumentos de compilação, ambos definidos no arquivo e usados no Arquivo Docker na hora da compilação, devem ser alterados para refletir seu próprio nome de usuário e uid em sua máquina local ou servidor de desenvolvimento. Para descobrir o uid do usuário atual, digite:useruiddocker-compose.yml

echo $UID
Output
1000
As variações estarão disponíveis no tempo de compilação e serão usadas no Dockerfile para criar um novo usuário no serviço com o mesmo nome de usuário e uid que o usuário atual do sistema em sua máquina local ou servidor de desenvolvimento. Isso evitará problemas de permissão e propriedade ao trabalhar com arquivos de aplicativos tanto do contêiner quanto do host que executa o Docker.useruidapp

Crie um novo arquivo usando seu editor de texto de escolha. Aqui, é usado:docker-compose.ymlnano

nano docker-compose.yml
Copie o seguinte conteúdo para este arquivo e não se esqueça de substituir os valores destacados por valores apropriados, dependendo do seu próprio nome de usuário e uid no sistema que executa o Docker:

~/landing-laravel/docker-compor.yml
version: "3.7"
services:
  app:
    build:
      args:
        user: sammy
        uid: 1000
      context: ./
      dockerfile: Dockerfile
    image: landing-app
    restart: unless-stopped
    working_dir: /var/www/
    volumes:
      - ./:/var/www
    networks:
      - landing

networks:
  landing:
    driver: bridge
Salve e feche o arquivo quando terminar. Se você estiver usando, você pode fazer isso pressionando+, então, para confirmar.nanoCTRLXYENTER

Em seguida, você configurará o Arquivo Docker que é referenciado no arquivo, que configurará uma imagem personalizada para o serviço:docker-compose.ymlapp

nano Dockerfile
Este Arquivo Docker se estende da imagem padrãoDocker. Ele usa asandvariáveis para criar um novo usuário capaz de executar comandos de Artesão e Compositor. Ele também instala algumas dependências php que são exigidas por Laravel, e o Compositor executável.php:7.4-fpmuseruid

Copie o seguinte conteúdo para o seu Dockerfile:

~/minha-toda-lista/Dockerfile
FROM php:7.4-fpm

# Arguments defined in docker-compose.yml
ARG user
ARG uid

# Install system dependencies
RUN apt-get update && apt-get install -y \
    git \
    curl \
    libpng-dev \
    libonig-dev \
    libxml2-dev \
    zip \
    unzip

# Clear cache
RUN apt-get clean && rm -rf /var/lib/apt/lists/*

# Install PHP extensions
RUN docker-php-ext-install pdo_mysql mbstring exif pcntl bcmath gd

# Get latest Composer
COPY --from=composer:latest /usr/bin/composer /usr/bin/composer

# Create system user to run Composer and Artisan Commands
RUN useradd -G www-data,root -u $uid -d /home/$user $user
RUN mkdir -p /home/$user/.composer && \
    chown -R $user:$user /home/$user

# Set working directory
WORKDIR /var/www

USER $user
Salve e feche o arquivo quando terminar. Em seguida, você pode trazer o seu ambiente com:

docker-compose up -d
Este comando executará o Docker Compose nomodo destacado, o que significa que ele será executado em segundo plano. Na primeira vez que você traz um ambiente com uma imagem personalizada, o Docker Compose construirá automaticamente a imagem para você antes de criar os recipientes necessários. Isso pode levar alguns momentos para terminar. Você verá saída semelhante a esta:

Output
Creating network "landing-laravel_landing" with driver "bridge"
Building app
Step 1/11 : FROM php:7.4-fpm
 ---> fa37bd6db22a
...
Step 10/11 : WORKDIR /var/www
 ---> Using cache
 ---> 769afd5d44d8
Step 11/11 : USER $user
 ---> Using cache
 ---> 841eb5852b69

Successfully built 841eb5852b69
Successfully tagged landing-app:latest
WARNING: Image for service app was built because it did not already exist. To rebuild this image you must use `docker-compose build` or `docker-compose up --build`.
Creating landing-laravel_app_1 ... done

Você pode verificar se seu ambiente está funcionando com:

docker-compose ps
Output
        Name                       Command              State    Ports  
------------------------------------------------------------------------
landing-laravel_app_1   docker-php-entrypoint php-fpm   Up      9000/tcp
Uma vez que o serviço esteja em alta, você pode executar o Composer, a ferramenta de gerenciamento de dependência PHP, para inicialar um novo aplicativo Laravel. Para isso, você usará para executar comandos no serviço, onde o PHP está instalado.appdocker compose execapp

O seguinte comando usará o Docker Compose para executar, o que inicializárá uma nova instalação de Laravel com base no pacote:composer create-projectlaravel/laravel

docker-compose exec app composer create-project laravel/laravel --prefer-dist application
Creating a "laravel/laravel" project at "./application"
Installing laravel/laravel (v8.4.0)
  - Downloading laravel/laravel (v8.4.0)
  - Installing laravel/laravel (v8.4.0): Extracting archive
Created project in /var/www/application
> @php -r "file_exists('.env') || copy('.env.example', '.env');"
Loading composer repositories with package information
Updating dependencies
Lock file operations: 104 installs, 0 updates, 0 removals
…
Package manifest generated successfully.
71 packages you are using are looking for funding.
Use the `composer fund` command to find out more!
> @php artisan key:generate --ansi
Application key set successfully.
Esta instalação cria um novo arquivo baseado no arquivo padrão que vem com o Laravel. O arquivo contém credenciais de banco de dados e outras configurações sensíveis do aplicativo, e deve ser único por ambiente onde o aplicativo é executado. Você voltará para editar este arquivo depois de terminar de configurar o ambiente de desenvolvimento..env.env.example.env

Em seguida, copie os arquivos do aplicativo para o mesmo diretório que o arquivo, para que você possa compartilhar o arquivo de variáveis de ambiente da Laravel com o Docker Compose. Em seguida, você pode remover o diretor criado pelo Composer:docker-compose.ymlapplication

cp -rT application .
rm -rfv application
Seu aplicativo agora está em inicializado, mas você precisará incluir alguns serviços no arquivo Docker Compose para poder acessar o aplicativo a partir de um navegador. O Anservice servirá o aplicativo usando o servidor web Nginx, e o Aservice hospedará o banco de dados MySQL do aplicativo.nginxdb

Primeiro, derrubeseu ambiente com:

docker-compose down
Output
Stopping landing-laravel_app_1 ... done
Removing landing-laravel_app_1 ... done
Removing network landing-laravel_landing
Isso removerá todos os contêineres e redes associados a este ambiente. Antes de editar seu arquivo para adicionar os novos serviços, crie um novo diretório para compartilhar arquivos de configuração com contêineres. Você precisará disso para configurar corretamente o Nginx para lidar com o aplicativo Laravel PHP.docker-compose.yml

mkdir -p docker-compose/nginx
Em seguida, crie um novo arquivo contendo um bloco de servidor Nginx personalizado. Mais tarde, você configurará um volume para compartilhar este arquivo dentro do contêiner de serviço.landing-laravel.confnginx

Abra um novo arquivo de configuração Nginx com:

nano docker-compose/nginx/landing-laravel.conf
O seguinte bloco de servidor configura o Nginx para servir um aplicativo Laravel usando um serviço externo () para lidar com o código PHP. Copie este conteúdo para seu próprio arquivo de configuração Nginx:app

docker-compor/nginx/landing-laravel.conf
server {
    listen 80;
    index index.php index.html;
    error_log  /var/log/nginx/error.log;
    access_log /var/log/nginx/access.log;
    root /var/www/public;
    location ~ \.php$ {
        try_files $uri =404;
        fastcgi_split_path_info ^(.+\.php)(/.+)$;
        fastcgi_pass app:9000;
        fastcgi_index index.php;
        include fastcgi_params;
        fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
        fastcgi_param PATH_INFO $fastcgi_path_info;
    }
    location / {
        try_files $uri $uri/ /index.php?$query_string;
        gzip_static on;
    }
}
Salve e feche o arquivo quando terminar.

Em seguida, abra seu arquivo:docker-compose.yml

nano docker-compose.yml
Inclua a seguinte configuração para o serviço, no mesmo nível do serviço configurado anteriormente. Isso criará um novo serviço baseado na imagem, e todas as solicitações no portof do host onde o Docker está executando serão redirecionadas para portin o contêiner de serviço. Além dos arquivos do aplicativo, você também compartilhará um volume contendo o arquivo de configuração do Nginx para um aplicativo Laravel:nginxappnginx:alpine800080

  nginx:
    image: nginx:alpine
    restart: unless-stopped
    ports:
      - 8000:80
    volumes:
      - ./:/var/www
      - ./docker-compose/nginx:/etc/nginx/conf.d/
    networks:
      - landing

Em seguida, inclua o seguinte bloco de configuração para o serviço. Isso criará um serviço baseado na imagem padrão do MySQL 8 e puxará os valores definidos no arquivo de ambiente da Laravel para configurar o acesso ao banco de dados:db

  db:
    image: mysql:8
    restart: unless-stopped
    environment:
      MYSQL_DATABASE: ${DB_DATABASE}
      MYSQL_ROOT_PASSWORD: ${DB_PASSWORD}
      MYSQL_PASSWORD: ${DB_PASSWORD}
      MYSQL_USER: ${DB_USERNAME}
    networks:
      - landing
É assim que seu arquivo atualizado deve ser quando terminar:docker-compose.yml

~/landing-laravel/docker-compor.yml
version: "3.7"
services:
  app:
    build:
      args:
        user: sammy
        uid: 1000
      context: ./
      dockerfile: Dockerfile
    image: landing-app
    restart: unless-stopped
    working_dir: /var/www/
    volumes:
      - ./:/var/www
    networks:
      - landing

  nginx:
    image: nginx:alpine
    restart: unless-stopped
    ports:
      - 8000:80
    volumes:
      - ./:/var/www
      - ./docker-compose/nginx:/etc/nginx/conf.d/
    networks:
      - landing
  db:
    image: mysql:8
    restart: unless-stopped
    environment:
      MYSQL_DATABASE: ${DB_DATABASE}
      MYSQL_ROOT_PASSWORD: ${DB_PASSWORD}
      MYSQL_PASSWORD: ${DB_PASSWORD}
      MYSQL_USER: ${DB_USERNAME}
    networks:
      - landing

networks:
  landing:
    driver: bridge

Nota: para obter informações mais detalhadas sobre os ambientes Laravel de contêineres, incluindo explicações sobre volumes e redes compartilhadas, consulte nosso guia completo sobreComo Instalar o Laravel com o Docker Compose no Ubuntu 20.04.

Salve e feche o arquivo quando terminar de editar. Por fim, atualize seu arquivo Laravel dot env () para apontar a configuração do host do banco de dados MySQL para o host onde o serviço MySQL estará em execução, chamado:.envdb

nano .env
O arquivo que é gerado automaticamente pelo Composer após a instalação vem com alguns valores padrão que você pode querer alterar, como o e o. Avariável de banco de dados deve ser alterada para apontar para o serviço onde o MySQL estará em execução, e você pode referenciá-lo pelo nome de serviço, conforme definido no arquivo. Neste exemplo, você usou como nome para o serviço de banco de dados, então isso estará disponível na rede contêinerizada como um host nomeado..envAPP_NAMEAPP_URLDB_HOSTdocker-compose.ymldbdb

Altere-o de acordo com o exemplo a seguir como base. Os valores destacados foram atualizados aqui para refletir o estado da aplicação em desenvolvimento:.env

~/landing-laravel/.env
APP_NAME=LandingLaravel
APP_ENV=local
APP_KEY=base64:ffYPNP8kPeQDf8gE/qh3kWjk59p6gFY66kCKhhKUa2w=
APP_DEBUG=true
APP_URL=http://localhost:8000

LOG_CHANNEL=stack
LOG_LEVEL=debug

DB_CONNECTION=mysql
DB_HOST=db
DB_PORT=3306
DB_DATABASE=landing-db
DB_USERNAME=landing-user
DB_PASSWORD=dev-password

...
Você não precisa alterar nenhuma outra seção deste arquivo, mas sinta-se livre para ajustar ao seu caso de uso específico.

Salve e feche o arquivo quando terminar de editar seu conteúdo.

Agora você pode trazer o ambiente atualizado com:

docker-compose up -d
Output
Creating network "landing-laravel_landing" with driver "bridge"
Creating landing-laravel_app_1   ... done
Creating landing-laravel_db_1    ... done
Creating landing-laravel_nginx_1 ... done
Com o ambiente completo para cima, agora você pode apontar o seu navegador para ou o endereço IP do seu servidor remoto, na porta:localhost8000

http://localhost:8000

/****************************************************

AULA 

php composer.phar update
## Laravel Sponsors


# composer 
# php artisan serve --port=9000  => Roda a aplicação na porta especificada
#  
### PROJETO EM LARAVEL
ROTA DE CONTINGÊNCIA (FALLBACK)

Route::fallback(function() {
    echo 'A Rota acessada não existe.  <a href=" ' .route('site.index').' "> clique aqui </a> para retornar';
  });

### PASSANDO VALORES DA ROTA PARA O CONTROLLER
<?php

use Illuminate\Support\Facades\Route;


Route::get('/', [\App\Http\Controllers\PrincipalController::class, 'index'])->name('site.index');

Route::get('/sobre-nos', [\App\Http\Controllers\SobrenosController::class, 'sobrenos'])->name('site.sobrenos');

Route::get('/contato', [\App\Http\Controllers\ContatoController::class, 'contato'])->name('site.contato');



Route::get('/login', function (){ return 'Login'; })->name('site.login');


Route::prefix('/app')->group(function(){

    Route::get('/clientes', function (){ return 'Clientes'; })->name('app.clientes');
    Route::get('/fornecedores', function (){ return 'Fornecedores'; })->name('app.fornecedores');
    Route::get('/produtos', function (){ return 'Produtos'; })->name('app.produtos');

});

Route::get('/teste/{param1?}/{param2?}', [\App\Http\Controllers\TesteController::class, 'teste'])->name('teste');

Route::fallback(function() {
    echo 'A Rota acessada não existe.  <a href=" ' .route('site.index').' "> clique aqui </a> para retornar';
  });




CONTROLLER
<?php

namespace App\Http\Controllers;

use Illuminate\Http\Request;

class TesteController extends Controller
{
    public function teste(int $p1, int $p2) {
        echo 'A soma dos valores é: ' . $p1 + $p2;
    }
}


<?php

use Illuminate\Support\Facades\Route;
use App\Http\Controllers\UserController; 

Route::get('/', function(){
    return view('welcome');
});


Route::get('user/{user?}', [UserController::class, 'show'])->name('user');

CONTROLLER
<?php

namespace App\Http\Controllers;

use App\Models\User;
use Illuminate\Http\Request;

class UserController extends Controller
{
    public function show(User $user){
        
        return view('user', [
            'name' => 'Paulo',
            'user' => $user
        
        ]);       
    }
}

### PASSANDO VALORES DA ROTA PARA O CONTROLLER DAÍ PARA A VIEW
ROTA PASSANDO VALORES:
Route::get('/teste/{param1?}/{param2?}', [\App\Http\Controllers\TesteController::class, 'teste'])->name('teste');

CONTROLLER RECEBENDO VALORES:
<?php

namespace App\Http\Controllers;

use Illuminate\Http\Request;

class TesteController extends Controller
{
    public function teste(int $p1, int $p2) {
       // echo 'A soma dos valores é: ' . $p1 + $p2;
       //return view('site.teste', ['x' => $p1 , 'y' => $p2 ] );   // MÉTODO ARRAY ASSOCIATIVO: ATRIBUI A VARIÁVEL RECEBIDA PARA UMA STRING QUALQUER 'x' => $p1, 'y' => $p2
       return view('site.teste', compact('p1', 'p2'));              // MÉTODO COMPACT: RECEBE A VARIÁVEL COMO UMA STRING 'p1', 'p2' E PASSA PARA A VIEW NOVAMENTE COMO VARIÁVEL $p1, $p2
      // return  view('site.teste')->with('a', $p1)->with('b', $p2);  // MÉTODO WITH: ATRIBUI O VALOR DA VARIÁVEL A UMA STRING QUALQUER 'a', 'b' E ESSA STRING SERÁ PASSADA PARA A VIEW COMO UMA VARÍÁVEL $a,$b

    }
}


VIEW RECEBENDO VALORES:
<h1>Teste </h1>

{{ $x }} <br>
{{  $y }}

{{ $a }}    // MÉTODO WITH FICARIA ASSIM
{{ $b }}


### COMENTÁRIOS E CODIFICAÇÃO PHP NO BLADE:
<h2>Fornecedor</h2>

{{ 'Texto ou variável aqui'}} <br>

<?= 'Teste' $x ?>

{{-- Comentário no Blade --}}

@php
    // Comentários dentro de uma tab php no blade
   
    /*
        Comentários de múltiplas
        linhas...
    */

@endphp

### @if @elseif @else @endif

FornecedorController.php
<?php

namespace App\Http\Controllers;

use Illuminate\Http\Request;

class FornecedorController extends Controller
{
    public function index(){
        $fornecedores = ['Fornecedor 1'];

        return view('app.fornecedor.index', compact('fornecedores'));
    }
}
abaixo a view que recebe os valores do controller
****************************
view.blade.php


<h2>Fornecedor</h2>

@if(count($fornecedores) > 0 && count($fornecedores) <= 10)
    <h3>Existem alguns fornecedores cadastrados.
@elseif(count($fornecedores) > 10)
    <h3>São vários os fornecedores cadastrados</h3>
@else 
    <h3> Ainda não existem fornecedores cadastrados.</h3> 
@endif

 <?php

namespace App\Http\Controllers;

use Illuminate\Http\Request;

class FornecedorController extends Controller
{
    public function index(){
        $fornecedores = [
            0 => [
                'nome' => 'Fornecedor 1',
            'status' => 'N',
            'cnpj' => '00.000.000/0001/00'
            ],
            1 => [
                'nome' => 'Fornecedor 2',
                'status' => 'S',
                ]
            ];

        return view('app.fornecedor.index', compact('fornecedores'));
    }
}

<h2>Fornecedor</h2>
<?php
    echo 'ALBERTO <br>';
    if(isset($fornecedores)){
        echo 'existe com php puro'. '<hr>';
    }
?>
@unless(isset($x))
    <h2>Bloco com h2 - Não existe a 'x'</h2><br>
@endunless

@php
    if(isset($fornecedores))
    echo 'Bloco php endphp' . '<br>'
@endphp
 {{-- //@dd($fornecedores) --}}

{{ 'Fornecedor: '  }} <br>

<?= 'Teste' ?>

{{-- Comentário no Blade --}}

@php
    // Comentários dentro de uma tab php no blade
   
    /*
        Comentários de múltiplas
        linhas...
    */
@endphp

@if(count($fornecedores) > 0 && count($fornecedores) <= 10)
    <h3>Existem alguns fornecedores cadastrados.
@elseif(count($fornecedores) > 10)
    <h3>São vários os fornecedores cadastrados</h3>
@else 
    <h3> Ainda não existem fornecedores cadastrados.</h3> 
@endif
<hr>
@isset ($fornecedores[1]['cnpj'])
    CNPJ: {{ $fornecedorES[1]['cnpj'] }}
@unless  ($fornecedores[1]['cnpj'])
    Este fornecedor não tem CNPJ
@endunless
   
@endisset

<h2>Fornecedor</h2>
<?php
    echo 'ALBERTO <br>';
    if(isset($fornecedores)){
        echo 'existe com php puro'. '<hr>';
    }
?>
@unless(isset($x))
    <h2>Bloco com h2 - Não existe a 'x'</h2><br>
@endunless

@php
    if(isset($fornecedores))
    echo 'Bloco php endphp' . '<br>'
@endphp
 {{-- //@dd($fornecedores) --}}

{{ 'Fornecedor: '  }} <br>

<?= 'Teste' ?>

{{-- Comentário no Blade --}}

@php
    // Comentários dentro de uma tab php no blade
   
    /*
        Comentários de múltiplas
        linhas...
    */
@endphp

@if(count($fornecedores) > 0 && count($fornecedores) <= 10)
    <h3>Existem alguns fornecedores cadastrados.
@elseif(count($fornecedores) > 10)
    <h3>São vários os fornecedores cadastrados</h3>
@else 
    <h3> Ainda não existem fornecedores cadastrados.</h3> 
@endif
<hr>
@isset ($fornecedores[1]['cnpj'])
    CNPJ: {{ $fornecedorES[1]['cnpj'] }}
@endisset

@empty ($fornecedores[1]['cnpj'])
    -VAZIO
@endempty
<hr>
Operador condicional ternário:
## VALOR DEFAULT
<hr>
CNPJ: {{ $fornecedores[0]['cnpj'] ?? 'Não existe CNPJ' }}  // valor default

### CASE:
<h2>Fornecedor</h2>
<?php
    echo 'ALBERTO <br>';
    if(isset($fornecedores)){
        echo 'existe com php puro'. '<hr>';
    }
?>
@unless(isset($x))
    <h2>Bloco com h2 - Não existe a 'x'</h2><br>
@endunless

@php
    if(isset($fornecedores))
    echo 'Bloco php endphp' . '<br>'
@endphp
 {{-- //@dd($fornecedores) --}}

{{ 'Fornecedor: '  }} <br>

<?= 'Teste' ?>

{{-- Comentário no Blade --}}

@php
    // Comentários dentro de uma tab php no blade
   
    /*
        Comentários de múltiplas
        linhas...
    */
@endphp

@if(count($fornecedores) > 0 && count($fornecedores) <= 10)
    <h3>Existem alguns fornecedores cadastrados.
@elseif(count($fornecedores) > 10)
    <h3>São vários os fornecedores cadastrados</h3>
@else 
    <h3> Ainda não existem fornecedores cadastrados.</h3> 
@endif
<hr>
@isset ($fornecedores[1]['cnpj'])
    CNPJ: {{ $fornecedorES[1]['cnpj'] }}
@endisset

@empty ($fornecedores[1]['cnpj'])
    -VAZIO
@endempty
<hr>
Operador condicional ternário:
<hr>
CNPJ: {{ $fornecedores[0]['cnpj'] ?? 'Não existe CNPJ' }} <hr>  {{-- valor default --}}

@switch($fornecedores[1]['ddd'])
    @case ('11')
        - DDD: {{ $fornecedores[1]['ddd'] }} São Paulo - SP
        @break
    @case('32')
        - DDD: {{ $fornecedores[1]['ddd'] }} Juiz de Fora -MG
        @break
    @default
        Estado não informado
@endswitch

@@@ @for

<h2>Fornecedor</h2>
<?php
    echo 'ALBERTO <br>';
    if(isset($fornecedores)){
        echo 'existe com php puro'. '<hr>';
    }
?>
@unless(isset($x))
    <h2>Bloco com h2 - Não existe a 'x'</h2><br>
@endunless

@php
    if(isset($fornecedores))
    echo 'Bloco php endphp' . '<br>'
@endphp
 {{-- //@dd($fornecedores) --}}

{{ 'Fornecedor: '  }} <br>

<?= 'Teste' ?>

{{-- Comentário no Blade --}}

@php
    // Comentários dentro de uma tab php no blade
   
    /*
        Comentários de múltiplas
        linhas...
    */
@endphp

@if(count($fornecedores) > 0 && count($fornecedores) <= 10)
    <h3>Existem alguns fornecedores cadastrados.
@elseif(count($fornecedores) > 10)
    <h3>São vários os fornecedores cadastrados</h3>
@else 
    <h3> Ainda não existem fornecedores cadastrados.</h3> 
@endif
<hr>
@isset ($fornecedores[1]['cnpj'])
    CNPJ: {{ $fornecedores[1]['cnpj'] }}
@endisset

@empty ($fornecedores[1]['cnpj'])
    -VAZIO
@endempty
<hr>
Operador condicional ternário:
<hr>
CNPJ: {{ $fornecedores[0]['cnpj'] ?? 'Não existe CNPJ' }} <hr>  {{-- valor default --}}

@switch($fornecedores[1]['ddd'])
    @case ('11')
        - DDD: {{ $fornecedores[1]['ddd'] }} São Paulo - SP
        @break
    @case('32')
        - DDD: {{ $fornecedores[1]['ddd'] }} Juiz de Fora -MG
        @break
    @default
        Estado não informado
@endswitch

<hr>FOR: <br>


 @for ($i = 0 ; isset($fornecedores[$i]); $i++)
    Fornecedor:  {{ $fornecedores[$i]['nome'] }}  <br>
    Status:     {{ $fornecedores[$i]['status']}}  <br>
    DDD:     {{ $fornecedores[$i]['ddd']}}  <br>
    telefone:     {{ $fornecedores[$i]['telefone']}}  <hr>

    @endfor

### @WHILE
<h2>Fornecedor</h2>
<?php
    echo 'ALBERTO <br>';
    if(isset($fornecedores)){
        echo 'existe com php puro'. '<hr>';
    }
?>
@unless(isset($x))
    <h2>Bloco com h2 - Não existe a 'x'</h2><br>
@endunless

@php
    if(isset($fornecedores))
    echo 'Bloco php endphp' . '<br>'
@endphp
 {{-- //@dd($fornecedores) --}}

{{ 'Fornecedor: '  }} <br>

<?= 'Teste' ?>

{{-- Comentário no Blade --}}

@php
    // Comentários dentro de uma tab php no blade
   
    /*
        Comentários de múltiplas
        linhas...
    */
@endphp

@if(count($fornecedores) > 0 && count($fornecedores) <= 10)
    <h3>Existem alguns fornecedores cadastrados.
@elseif(count($fornecedores) > 10)
    <h3>São vários os fornecedores cadastrados</h3>
@else 
    <h3> Ainda não existem fornecedores cadastrados.</h3> 
@endif
<hr>
@isset ($fornecedores[1]['cnpj'])
    CNPJ: {{ $fornecedores[1]['cnpj'] }}
@endisset

@empty ($fornecedores[1]['cnpj'])
    -VAZIO
@endempty
<hr>
Operador condicional ternário:
<hr>
CNPJ: {{ $fornecedores[0]['cnpj'] ?? 'Não existe CNPJ' }} <hr>  {{-- valor default --}}

@switch($fornecedores[1]['ddd'])
    @case ('11')
        - DDD: {{ $fornecedores[1]['ddd'] }} São Paulo - SP
        @break
    @case('32')
        - DDD: {{ $fornecedores[1]['ddd'] }} Juiz de Fora -MG
        @break
    @default
        Estado não informado
@endswitch

<hr>FOR: <br>

 @for ($i = 0 ; isset($fornecedores[$i]); $i++)
    Fornecedor:  {{ $fornecedores[$i]['nome'] }}  <br>
    Status:     {{ $fornecedores[$i]['status']}}  <br>
    DDD:     {{ $fornecedores[$i]['ddd']}}  <br>
    telefone:     {{ $fornecedores[$i]['telefone']}}  <hr>

 @endfor
<hr> WHILE <hr>

@php $i = 0 @endphp
    @while (isset($fornecedores[$i]))
        Fornecedor:  {{ $fornecedores[$i]['nome'] }}  <br>
        Status:     {{ $fornecedores[$i]['status']}}  <br>
        DDD:     {{ $fornecedores[$i]['ddd']}}  <br>
        telefone:     {{ $fornecedores[$i]['telefone']}}  <br>
        @php $i++ @endphp
    @endwhile
<hr>

<hr>
FOREACH

FOREACH - Gera uma cópia do valor original <br>

@foreach ($fornecedores as $indice => $fornecedor)
  Fornecedor: {{ $fornecedor['nome']}} <br>
  Status: {{ $fornecedor['status'] }} <br>
  CNPJ: {{ $fornecedor['cnpj'] ?? '' }} <br>
  Telefone: ({{ $fornecedor['dd'] ?? '' }})  {{ $fornecedor['telefone'] ?? '' }} <br> <hr>

@endforeach

### @forelse
### FornecedorController.php
$fornecedores =[];
### index.blade.php

@forelse ($fornecedores as $indice => $fornecedor)
  Fornecedor: {{ $fornecedor['nome']}} <br>
  Status: {{ $fornecedor['status'] }} <br>
  CNPJ: {{ $fornecedor['cnpj'] ?? '' }} <br>
  Telefone: ({{ $fornecedor['dd'] ?? '' }})  {{ $fornecedor['telefone'] ?? '' }} <br> <hr>
@empty
        Não existem Registros

@endforelse


### ESCAPANDO A FORMA DE IMPRESSÃO
  Fornecedor: @{{ $fornecedor['nome']}} <br>
  Status: @{{ $fornecedor['status'] }} <br>
  CNPJ: @{{ $fornecedor['cnpj'] ?? '' }} <br>

### OBJETO LOOP CRIADO AUTOMATICAMENTE QUANDO USAMOS FOREACH E FORELSE
<h2>Fornecedor</h2>
### OBJETO LOOP -> Existe em @foreach e @forelse
    
@endforeach
@forelse ($fornecedores as $indice => $fornecedor)
@dd($loop)
    @if($loop->first)
        => Aqui é a primeira iteração do loop  
    @endif
    Iteração Atual: -> {{ $loop->iteration }}<br>
    Fornecedor: {{ $fornecedor['nome']}} <br>
    Status: {{ $fornecedor['status'] }} <br>
    CNPJ: {{ $fornecedor['cnpj'] ?? '' }} <br>  
    @if($loop->last)
        => Aqui é a última iteração do loop <hr>
    @else 
        <hr>
    @endif
@empty
    Telefone: ({{ $fornecedor['dd'] ?? '' }})  {{ $fornecedor['telefone'] ?? '' }} <br>  <hr>
        Não existem Registros

@endforelse


### LIMPAR AS VIEWS COMPILADAS NO CACHE 

php artisan view:clear

### ASSETS => Tudo aquilo que complementa os arquivos html ou a página web a pasta de assets(arquivos js, css, imagens, sons, etc ficam em /public do projeto)

  <body>
        <div class="topo">

            <div class="logo">
                <img src="img/logo.png">
                <img src="{{ asset('img/logo.png') }}">
            </div>

### CSS externo
  <link rel="stylesheet" href="{{asset('css/estilo_basico.css')}}" >

### layout_principal.php
<!DOCTYPE html>
<html lang="pt-br">
    <head>
        <title>Super Gestão - Sobre Nós</title>
        <meta charset="utf-8">

      <link rel="stylesheet" href="{{asset('css/estilo_basico.css')}}" >
       
    </head>

    <body>
        @yield('conteudo')
    </body>
</html>

### principal.php  /  contato.php / outras_paginas.php
@extends('site.layouts.basico')

@section('conteudo')
        <div class="topo">

            <div class="logo">
                <img src="{{asset('img/logo.png')}}">
            </div>

            <div class="menu">
                <ul>
                    <li><a href="{{ route('site.index') }}">Principal</a></li>
                    <li><a href="{{ route('site.sobrenos') }}">Sobre Nós</a></li>
                    <li><a href="{{ route('site.contato') }}">Contato</a></li>
                </ul>
            </div>
        </div>
 @endsection  

 ### PASSANDO PARÂMETROS PARA O LAYOUT PRINCIPAL
layout_principal.php
 @extends('site.layouts.basico')

@section('titulo', 'Página Principal')
@section('conteudo')
        <div class="topo">

            <div class="logo">
                <img src="img/logo.png">
            </div>

            <div class="menu">
                <ul>
                    <li><a href="{{ route('site.index') }}">Principal</a></li>
                    <li><a href="{{ route('site.sobrenos') }}">Sobre Nós</a></li>
                    <li><a href="{{ route('site.contato') }}">Contato</a></li>
                </ul>
            </div>
        </div>
@endsection

contato.php
@extends('site.layouts.basico')

@section('titulo', 'Contato')
@section('conteudo')
        <div class="topo">

            <div class="logo">
                <img src="{{asset('img/logo.png')}}">
            </div>
@endsection

sobre-nos.php
@extends('site.layouts.basico')

@section('titulo', 'Sobre Nos')
@section('conteudo')
        <div class="topo">

            <div class="logo">
                <img src="{{asset('img/logo.png')}}">
            </div>

            <div class="menu">
                <ul>
                    <li><a href="{{ route('site.index') }}">Principal</a></li>
                    <li><a href="{{ route('site.sobrenos') }}">Sobre Nós</a></li>
                    <li><a href="{{ route('site.contato') }}">Contato</a></li>
                </ul>
            </div>
      </div>
@endsection

######## Se quiser receber parâmetros vindo da view
CotatoController.php
<?php
namespace App\Http\Controllers;
use Illuminate\Http\Request;
class ContatoController extends Controller
{
    public function contato() {
        return view('site.contato', ['titulo' => 'Contato - titulo vindo do controlador']);
    }
}

/*** */
View recebendo parâmetro vindo do controlador 
contato.blade.php
@extends('site.layouts.basico')

@section('titulo', $titulo)
@section('titulo', 'Contato')
@section('conteudo')
        <div class="topo">




### INCLUINDO PÁGINAS include (é literalmente uma inclusão)

 @include('site.layouts._partials.topo')

### ENVIANDO O FORMULÁRIO DE CONTATO
form.blade.php
<form action={{ route('site.contato') }} method="get" > 
        <input type="text" name="nome" placeholder="Nome" class="borda-preta">
        <br>
        <input type="text" name="telefone" placeholder="Telefone" class="borda-preta">
        <br>
        <input type="text" name="email" placeholder="E-mail" class="borda-preta">
        <br>
        <select class="borda-preta">
            <option value="">Qual o motivo do contato?</option>
            <option value="1">Dúvida</option>
            <option value="2">Elogio</option>
            <option value="3">Reclamação</option>
        </select>
        <br>
        <textarea name="mensagem" class="borda-preta">Preencha aqui a sua mensagem</textarea>
        <br>
        <button type="submit" class="borda-preta">ENVIAR</button>
    </form>

web.php

Route::get('/contato', [\App\Http\Controllers\ContatoController::class, 'contato'])->name('site.contato');                    

ContatoController.php
<?php

namespace App\Http\Controllers;

use Illuminate\Http\Request;

class ContatoController extends Controller
{
    public function contato() {

        var_dump($_GET);
        return view('site.contato', ['titulo' => 'Contato - titulo vindo do controlador'], ['teste' => 'Alberto Gomes']);
    }
}




/**************** */
BLADE.PHP
<h1>Passando variável direto: {{ $name }} </h1>
<hr>
<h1>Listando o Retorno da Model User</h1>
<h2>{{ $user }} </h2>
<p>Selecionando o nome fica: {{ $user->name }} </p>
<p>Selecionando o Email fica: {{ $user->email }} </p>

DATABASE SEED
class DatabaseSeeder extends Seeder
{
    /**
     * Seed the application's database.
     *
     * @return void
     */
    public function run()
    {
        \App\Models\User::factory(10)->create();

        //  \App\Models\User::factory()->create([
        //      'name' => 'Test User',
        //      'email' => 'test@example.com',
        //  ]);
    }
}

## REDIRECIONAMENTO DE ROTAS
web.php

Route::get('/rota1', function(){
    echo 'Rota 1';
})->name('site.rota1');
Route::get('/rota2', function(){
    //echo 'Rota 2';
    return redirect()->route('site.rota1');
})->name('site.rota2');

//Route::redirect('/rota2', 'rota1');


### MÉTODO POST -> Exige o csrf (CROSS-SITE REQUEST FORGERY ou falsificação de solicitação entre sites)

<form action={{ route('site.contato') }} method="post" > 
@csrf
    <input type="text" name="nome" placeholder="Nome" class="borda-preta">
    <br>
    <input type="text" name="telefone" placeholder="Telefone" class="borda-preta">
    <br>
    <input type="text" name="email" placeholder="E-mail" class="borda-preta">
    <br>
    <select class="borda-preta">
        <option value="">Qual o motivo do contato?</option>
        <option value="1">Dúvida</option>
        <option value="2">Elogio</option>
        <option value="3">Reclamação</option>
    </select>
    <br>
    <textarea name="mensagem" class="borda-preta">Preencha aqui a sua mensagem</textarea>
    <br>
    <button type="submit" class="borda-preta">ENVIAR</button>
</form>

ContatoController.php
<?php

namespace App\Http\Controllers;

use Illuminate\Http\Request;

class ContatoController extends Controller
{
    public function contato() {

    use    var_dump($_POST);
    ou     dd($_POST);
        return view('site.contato', ['titulo' => 'Contato - titulo vindo do controlador'], ['teste' => 'Alberto Gomes']);
    }
}

### incluindo views ou partials @components
 @component('site.layouts._components.form_contato')
@endcomponent

### passando parâmetros por @components

   @component('site.layouts._components.form_contato')
                        <p>A nossa equipe analisará a sua mensagem e retornaremos o mais brevemente possível.</p>
                        <p> Nosso tempo médio de resposta é de 48horas.</p>
@endcomponent

NO COMPONENTE ADICIONAMOS A TAG {{ slot }} :
{{ $slot }}
<form action={{ route('site.contato') }} method="post" > 
            @csrf
            <input type="text" name="nome" placeholder="Nome" class="borda-preta">
            <br>
            <input type="text" name="telefone" placeholder="Telefone" class="borda-preta">
            <br>
            <input type="text" name="email" placeholder="E-mail" class="borda-preta">
            <br>
            <select class="borda-preta">
                <option value="">Qual o motivo do contato?</option>
                <option value="1">Dúvida</option>
                <option value="2">Elogio</option>
                <option value="3">Reclamação</option>
            </select>
            <br>
            <textarea name="mensagem" class="borda-preta">Preencha aqui a sua mensagem</textarea>
    <br>
    <button type="submit" class="borda-preta">ENVIAR</button>
</form>

principal.blade.php

@extends('site.layouts.basico')


@section('titulo', 'Página Principal')
@section('conteudo')
      {{-- @include('site.layouts._partials.topo') --}}
 
        <div class="conteudo-destaque">
        
            <div class="esquerda">
                <div class="informacoes">
                    <h1>Sistema Super Gestão</h1>
                    <p>Software para gestão empresarial ideal para sua empresa.<p>
                    <div class="chamada">
                        <img src="{{asset('/img/check.png') }}">
                        <span class="texto-branco">Gestão completa e descomplicada</span>
                    </div>
                    <div class="chamada">
                        <img src="{{asset('img/check.png') }}">
                        <span class="texto-branco">Sua empresa na nuvem</span>
                    </div>
                </div>

                <div class="video">
                    <img src="{{asset('img/player_video.jpg') }} ">
                </div>
            </div>

            <div class="direita">
                <div class="contato">
                    <h1>Contato</h1>
                    <p>Caso tenha qualquer dúvida por favor entre em contato com nossa equipe pelo formulário abaixo.<p>
                     @component('site.layouts._components.form_contato')
                        <h3> Entraremos em contato: aguarde 48 hs. </h3>
                    @endcomponent
                </div>
            </div>
        </div>
  @endsection

  ### SEGUNDA FORMA DE ENVIAR PARÂMETROS POR COMPONENTES @component

  principal.blade.php

    <h1>Contato</h1>
                    <p>Caso tenha qualquer dúvida por favor entre em contato com nossa equipe pelo formulário abaixo.<p>
                     @component('site.layouts._components.form_contato', ['x' => 10])
                        <h3> Entraremos em contato: aguarde 48 hs. </h3>
@endcomponent

ou 

 <p>Caso tenha qualquer dúvida por favor entre em contato com nossa equipe pelo formulário abaixo.<p>
                     @component('site.layouts._components.form_contato', ['x' => 'Entraremos em contato: aguarde 48 hs.'])
                      
                    @endcomponent


form_contato.ph
    {{ $slot }}
    {{ $x }}


    /************ */

contato.blade.php

@component('site.layouts._components.form_contato', ['x' => '48 horas.'])
    <p>A nossa equipe analisará a sua mensagem e retornaremos o mais brevemente possível.</p>
    <p> Nosso tempo médio de resposta é de</p>
@endcomponent

form_contato.blade.php
{{ $slot }}

{{ $x }}
<form action={{ route('site.contato') }} method="post" > 
    @csrf
    <input type="text" name="nome" placeholder="Nome" class="borda-preta">
    <br>
    <input type="text" name="telefone" placeholder="Telefone" class="borda-preta">
    <br>
    <input type="text" name="email" placeholder="E-mail" class="borda-preta">
    <br>
    <select class="borda-preta">
        <option value="">Qual o motivo do contato?</option>
        <option value="1">Dúvida</option>
        <option value="2">Elogio</option>
        <option value="3">Reclamação</option>
    </select>
    <br>
    <textarea name="mensagem" class="borda-preta">Preencha aqui a sua mensagem</textarea>
<br>
<button type="submit" class="borda-preta">ENVIAR</button>
</form>



### CRIANDO UMA MODEL E SUA MIGRATION
>php artisan make:model SiteContato -m
Dica - Resolvendo problema do php artisan migrate
Dica importante para próxima aula enviada pelo João Vitor Moraski. A dica se aplica a você caso você esteja utilizando o sistema operacional Linux na distro Ubuntu 20.04:



Tive um problema onde sempre que tentava executar a migrate aparecia algo do tipo could not find drive (SQL: PRAGMA foreign_keys = on;).

Algumas pessoas conseguem resolver o erro tirando o ";" de trás da escrita 'extension:pdo_sqlite' no php.ini. O arquivo php ini pode ser localizado por meio do comando php -i | grep 'php.ini' ou pelo comando php --ini (os comandos devem ser executado na linha de comando do sistema operacional).

Porém, se o procedimento acima não funcionar, tente realizar a instalação da extensão em seu sistema operacional. No meu caso, na versão 20.04 do Ubuntu, ocorreu que a extensão não estava instalada por padrão. O comando utilizado na linha de comando do sistema operacional para instalar a extensão é:

sudo apt install php7.4-sqlite3 <- comando para instalar a extensão certa

### SQLITE -> IDEAL PARA PEQUENOS PROJETOS SEM SEGURANÇA. /config/database.php (classe das configurações) -> alterções são feitas em .ven 
linha9 DB_CONNECTION=sqlite

Se DB_DATABASE não estiver configurada ele adotará o padrão.. Bastando criar um arquivo /database/database.sqlit Dentro da pasta database do projeto.

### Testa se o PDO está carregado:
>php -r "var_dump(extension_loaded('pdo_mysql'));" 
bool(true)




### CRIANDO E EXCECUTANDO migrations
2022_10_29_124933_create_site_contatos_table.php

<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     *
     * @return void
     */
    public function up()
    {
        Schema::create('site_contatos', function (Blueprint $table) {
            $table->id();
            $table->string('nome', 50);
            $table->string('telefone', 20);
            $table->string('email', 80);
            $table->integer('motivo_contato');
            $table->text('mensagem');
            $table->timestamps();
        });
    }

    /**
     * Reverse the migrations.
     *
     * @return void
     */
    public function down()
    {
        Schema::dropIfExists('site_contatos');
    }
};
 > php artisan migrate
 ### Criando Model e Migration uma de cada vez
>php artisan make:model Fornecedor 
>php artisan make:migration create_fornecedores_table
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     *
     * @return void
     */
    public function up()
    {
        Schema::create('fornecedores', function (Blueprint $table) {
            $table->id();
            $table->string('nome', 50);
            $table->timestamps();
        });
    }
>php artisan migrate
 ### MIGRATION: Adicionando campos a uma tabela já existente (MÉTODO UP) e DESFAZENDO AS ADIÇÕES (MÉTOD DOWN):
 ==> COMANDOS: 
 * Executar a criação das tabelas: php artisan migrate -> acontece da mais antiga para a mais atual
 * Reverter as migrações: php artisan migrate:rollback -> acontece da mais atual para a mais antiga
 * Podemos indicar quantos passos(sterps) podemos reverter ou quantas migrates queremos reverter: 
    > php artisan migrate:rollback  ou php artisan migrate:rollback --step=2
    > php artisan migrate -> Executa novamente todas as migrations recriando as tabelas e colunas.
 - php artisan make:migration alter_fornecedores_novas_colunas

2022_10_30_144326_alter_fornecedores_novas_colunas.php
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     *
     * @return void
     */
    public function up()
    {
        // CRIANDO NOVA COLUNAS NA TABELA
        Schema::table('fornecedores', function (Blueprint $table) {
            $table->string('uf', 2);
            $table->string('email', 150);
        });
    }

    /**
     * Reverse the migrations.
     *
     * @return void
     */
    public function down()
    {
        // PARA REMOVER AS COLUNAS CRIADA NO MÉTODO UP
        Schema::table('fornecedores', function (Blueprint $table) {
           // $table->$table->dropColumn('uf');
           // $table->dropColumn('email'); ou podemos usar apenas o comando abaixo passando um array de colunas
            $table->dropColumn(['uf', 'email']);
        });
    }
};

### CRIANDO A MIGRATION 2022_10_30_151416_create_produtos_table.php COM VALORES NULOS E DEFAULT (VALOR PADRÃO):
> php artisan make:migration create_produtos_table <ENTER>
<?php
use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     *
     * @return void
     */
    public function up()
    {
        Schema::create('produtos', function (Blueprint $table) {
            $table->id();
            $table->string('nome', 100);
            $table->text('descricao')->nullable();
            $table->integer('peso')->nullable();
            $table->float('preco_venda', 8, 2)->default(0.01);
            $table->integer('estoque_minimo')->default(1);
            $table->integer('estoque_maximo')->default(1);
            $table->timestamps();
        });
    }

    /**
     * Reverse the migrations.
     *
     * @return void
     */
    public function down()
    {
        Schema::dropIfExists('produtos');
    }
};
### EXECUTANDO A MIGRATION CRIADA:
> php artisan migrate






### CRIANDO MIGRATIONS COM RELACIONAMENTOS DE TABELAS
> php artisan make:migration create_produto_detalhes_table
2022_10_30_152706_create_produtos_detalhes_table.php
 * Para fazer o relacionamento de um para um entre tabelas, a chave primária de uma das tabelas do relacionamento, viage para a 
   outra tabela e lá, essa chave primária que viajou, seja recebida como chave estrageira. Vale lembra que no relacionamento de um para um tanto faz qual a tabela que vai receber a chave estrageira, mais o ideal, por convenção, o indicado é que a chave 
   primária da tabela mais forte do relacionamento, ou seja, aquela tabela que tem mais impacto no negócio, viage como chave 
   estrangeira para a tabela mais fraca do relacionamento, ou seja, aquela que tem menos impacto do ponto de vista do negócio.
   Sendo assim a tabela produto_detalhes tem que ter uma nova coluna "produto_id" para receber a chave primária da tabela "produtos":

<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     *
     * @return void
     */
    public function up()
    {
        Schema::create('produto_detalhes', function (Blueprint $table) {
            // Colunas
            $table->id();

            $table->unsignedBigInteger('produto_id'); // Por convensão usamos o singular do nome da tabela que envia a chave e o nome da coluna

            $table-> float('comprimento', 8, 2);
            $table-> float('largura', 8, 2);
            $table-> float('altura', 8, 2);

            $table->timestamps();

            // Constraint de de integridade referencial
            $table->foreign('produto_id')->references('id')->on('produtos');
            // Constraint para garantir que não tenha valor repetido
            $table->unique('produto_id');
        });
    }

    /**
     * Reverse the migrations.
     *
     * @return void
     */
    public function down()
    {
        Schema::dropIfExists('produto_detalhes');
    }
};

>php artisan migrate
### Migration - Adicionando Chaves Estrangeiras (Relacionamento de um para muitos):
### MÉTODOS UP E MÉTODO DOWN
>php artisan make:migration create_unicades_table
2022_10_30_163254_create_unidades_table.php
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     *
     * @return void
     */
    public function up()
    {
        Schema::create('unidades', function (Blueprint $table) {
            $table->id();
            $table->string('unidade', 5);
            $table->string('decricao', 30);
            $table->timestamps();

        
        });

            // adicionar o relacionamento com a tabela produtos
        Schema::table('produtos', function (Blueprint $table) {
            $table->unsignedBigInteger('unidade_id');
            $table->foreign('unidade_id')->references('id')->on('unidades');
        });
        
        // RELACIONAMENTOS NECESSÁRIOS (vamos usar a mesma migration)
        // adicionar o relacionamento com a tabela produtos_detalhes
        Schema::table('produto_detalhes', function (Blueprint $table) {
            $table->unsignedBigInteger('unidade_id');
            $table->foreign('unidade_id')->references('id')->on('unidades');
        });

       
    }

    /**
     * Reverse the migrations.
     *
     * @return void
     */
    public function down()
    {
        /* DESFAZENDO TUDO FEITO NO MÉTODO UP */
        // REMOVENDO AS CHAVES ESTRANGEIRAS
        // adicionar o relacionamento com a tabela produtos_detalhes
        Schema::table('produto_detalhes', function(Blueprint $table) {
            // remover a forekey(fk)
            $table->dropForeign('produto_detalhes_unidade_id_foreign');   // [table]_[coluna]_foreign ->verificar o nome criado na tablela
            
            // remover a coluna unidade_id
            $table->dropColumn('unidade_id');
            
        });
        
       
        // remover o relacionamento com a tabela produtos
        Schema::table('produtos', function(Blueprint $table) {
            // remover a forekey(fk)
            $table->dropForeign('produtos_unidade_id_foreign');   // [table]_[coluna]_foreign ->verificar o nome criado na tablela
            
            // remover a coluna unidade_id
            $table->dropColumn('unidade_id');
            
        });

        Schema::dropIfExists('unidades');
    }
};

### >php artisan migrate                -> EXECUTA TODOS OS MÉTODO UP CRIANDO AS TABELAS NO BANCO DE DADOS
### >php artisan migrate:rollback       -> DESFAZ TODOS OS MÉTODOS DOWN DESFAZENDO AS TABELAS DO BANCO DE DADOS

>php artisan migrate:rollback 
### ESTRUTURA DAS TABELAS PRODUTOS, UNIDADES E PRODUTO_DETALHES
Table: produtos
Columns:
id bigint(20) UN AI PK 
nome varchar(100) 
descricao text 
peso int(11) 
preco_venda double(8,2) 
estoque_minimo int(11) 
estoque_maximo int(11) 
created_at timestamp 
updated_at timestamp 
unidade_id bigint(20) UN

Table: unidades
Columns:
id bigint(20) UN AI PK 
unidade varchar(5) 
decricao varchar(30) 
created_at timestamp 
updated_at timestamp

Table: produto_detalhes
Columns:
id bigint(20) UN AI PK 
produto_id bigint(20) UN 
comprimento double(8,2) 
largura double(8,2) 
altura double(8,2) 
created_at timestamp 
updated_at timestamp 
unidade_id bigint(20) UN

Table: unidades
Columns:
id bigint(20) UN AI PK 
unidade varchar(5) 
decricao varchar(30) 
created_at timestamp 
updated_at timestamp

### ADICIONANDO CHAVE ESTRANGEIRAS - RELACIONAMENTO MUITOS PARA MUITOS -> Este tipo de relacionamento sempre envolve uma terceira tabela: vamos criar a tabela filiais e produto_filiais e estabelecer este relacionamento:
php artisan make:migration ajuste_produtos_filiais

2022_10_30_175104_ajuste_produtos_filiais.php

<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     *
     * @return void
     */
    public function up()
    {
        //Criando a tabela filiais
        Schema::create('filiais', function (Blueprint $table) {
            $table->id();
            $table->string('filial', 30);
            $table->timestamps();
        });
       
        //Criando a tabela produto_filiais
        Schema::create('produto_filiais', function (Blueprint $table) {
            $table->id();
            $table->unsignedBigInteger('filial_id');
            $table->unsignedBigInteger('produto_id');
            $table->decimal('preco_venda', 8, 2);
            $table->integer('estoque_minimo');
            $table->integer('estoque_maximo');
            $table->timestamps();

            //  Constraint de Relacionamentos - foreign key
            $table->foreign('filial_id')->references('id')->on('filiais');
            $table->foreign('produto_id')->references('id')->on('produtos');
        });

        // Removendo colunas da tabela produtos
        Schema::table('produtos', function (Blueprint $table) {
           $table->dropColumn(['preco_venda', 'estoque_minimo', 'estoque_maximo']);
        });
    }

    /**
     * Reverse the migrations.
     *
     * @return void
     */
    public function down()
    {
        // Recriando as colunas da tabela produtos
        Schema::table('produtos', function (Blueprint $table) {
            $table->decimal('preco_venda', 8, 2)->default(0.01);
            $table->integer('estoque_minimo')->default(1);
            $table->integer('estoque_maximo')->default(1);
         });

         Schema::dropIfExists('produto_filiais');

         Schema::dropIfExists('filiais');
    }
};
### TESTANDO AS MIGRATES
>php artisan migrate
>php artisan migrate:rollback
### MIGRATION -> MODIFICADOR After: Permite que novas colunas sejam inseridas em pontos específicos de uma coluna pre existente: após(after) uma coluna já existente: 'uf' e 'email' que foram colunas adicionadas na tabela 'fornecedores' ficaram no final, vamos criar então uma nova coluna 'site' na tabela 'fornecedores' e indicar a posição que será criada:
>php artisan make:migration nova_coluna_site_com_after
2022_10_30_182603_nova_coluna_site_com_after.php

<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     *
     * @return void
     */
    public function up()
    {
        //
        Schema::table('fornecedores', function (Blueprint $table) {
            $table->string('site', 150)->after('nome')->nullable()->default('https://www.albertogomesdasilva.com.br');
        });
    }

    /**
     * Reverse the migrations.
     *
     * @return void
     */
    public function down()
    {
        //
        Schema::table('fornecedores', function (Blueprint $table) {
            $table->dropColumn('site');
        });

    }
};

### COMANDOS MIGRATIONS: STATUS, RESET, REFRESH E FRESH
- >php artisan migrate:status -> Verifica se a migration já foi executada;
- >php artisan migrate:reset -> Executa todos os métodos down da mais atual para a mais antiga e retorna o status das migrations para pedente- apaga o banco de dados por completo;
- >php artisan migrate:refresh -> Reverte todas as migrations e na sequência executa todos os métodos up - apaga o banco de dados e na sequência recria;
- >php artisan migrate:fresh -> Dropa o banco de dados e executa todas as migrations - zera os id's das tabelas do banco de dados;

### ENTENDENDO O ELOQUENT ORM -> Object Relacional Maping nativo do Framework Laravel. O ORM (Mapeamento Objeto Relacional ) é uma técnica para aproximar o paradigma de desenvolvimento de aplicações orientadas a objetos com um banco de dados relacional ( Orientação a Objetos <==> Banco de Dados Relacional). As bibliotecas e frameworks definem como os dados serão mapeados entre os dois ambientes possibilitando o CRUD dimiundo significativamente o tempo de desenvolvimento de aplicações utilizando os recursos do ORM que independente de linguagem de programação. Atualmente dois padrões se destacam no mercado: Data Mapper e Active Record. O Framework Laravel o ORM Eloquente segue o padrão Active Record.

### TINKER -> É um a ferramenta nativa do framework Laravel, é um console interativo que possibilita o acesso as classes do projeto através do terminal. Através do Tinker podemos facilmente manipular as classes relativas aos Models do projeto, podemos instanciar as classes e executar os métodos dos objetos instanciados e os métodos estáticos também, podemos também testar o Mapeamento Objeto Relacional entre as classes relativas ao Models do projeto e o Banco de Dados. Sem o Tinker precisaremos usar uma interface previamente criada ou diretamente no banco de dados, ou através de um script para esse propósito. O Tinker é um atalho para testarmos os Models com o Eloquent ORM fazendo a persistência de dados no banco.
### INSERINDO REGISTROS NO BANCO
>php artisan tinker
Psy Shell v0.11.8 (PHP 8.1.11 — cli) by Justin Hileman
>>> $contato = new SiteContato                                                 
[!] Aliasing 'SiteContato' to 'App\Models\SiteContato' for this Tinker session.
=> App\Models\SiteContato {#3680}
>>> $contato->nome = 'Alberto'                                                 
=> "Alberto"
>>> $contato->telefone = '98981188434'                                         
=> "98981188434"
>>> $contato->email = 'albertoogmesdasilva@gmail.com'                          
=> "albertoogmesdasilva@gmail.com"
>>> $contato->motivo_contato = 1                                               
=> 1
>>> $contato->mensagem = 'Olá. Gostaria de maiores detalhes..'                 
=> "Olá. Gostaria de maiores detalhes.."    
>>> print_r($contato->getAttributes())                                         
Array
(
    [nome] => Alberto
    [telefone] => 98981188434
    [email] => albertoogmesdasilva@gmail.com
    [motivo_contato] => 1
    [mensagem] => Olá. Gostaria de maiores detalhes..
)
=> true
>>> $contato->save()                                                           
=> true
### INSERINDO NOVO REGISTRO COM TINKER
>>> $contato2 = new SiteContato();                                             
=> App\Models\SiteContato {#4017}
>>> $contato2->nome = 'Maria'                                                  
=> "Maria"
>>> $contato2->telefone = '98998887777'                                        
=> "98998887777"
>>> $contato2->email = 'maria@gmail.com'                                       
=> "maria@gmail.com"
>>> $contato2->mensagem = 'tudo ok..'                                          
=> "tudo ok.."
>>> $contato2->motivo_contato = 2                                              
=> 2
>>> print_r($contato2->getAttributes())                                        
Array
(
    [nome] => Maria
    [telefone] => 98998887777
    [email] => maria@gmail.com
    [mensagem] => tudo ok..
    [motivo_contato] => 2
)
=> true
>>> $contato2->save()                                                          
=> true
### AJUSTANDO O NOME DA TABELA NO MODEL PARA UM CORRETO ORM
* MODEL: SiteContato.php  ==> site_contato -> nome da tabela no banco de dados.
* MODEL: Fornecedor.php   ==> fornecedores -> nome da tabela no banco -> Neste caso vamos tentar salvar com o tinker na tabela fornecedores irá gerar um erro:
>>> $f->save()                                                                 
Illuminate\Database\QueryException with message 'SQLSTATE[42S02]: Base table or view not found: 1146 Table 'sg.fornecedors' doesn't exist (SQL: insert into `fornecedors` (`nome`, `site`, `uf`, `email`, `updated_at`, `created_at`) values (Fornecedor XYZ, http://fornecedorxyz.com.br, MA, fornecedorxyz@gmail.com.br, 2022-10-30 19:53:51, 2022-10-30 19:53:51))'
para corrigir isto no Model Fornecedor.php incluiremos a linha 
    protected $table = 'fornecedores';


<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;

class SiteContato extends Model   //site_contato -> nome da tabela no banco de dados.
{
    use HasFactory;
    protected $table = 'fornecedores';  // Ajustar quando o ORM não consegue salvar na tabela.

}


### SALVANDO NO BANCO DE DADOS USANDO O MÉTODO ESTÁTICO HERDADO DA CLASSE MODEL - CREATE (não depende da instância do objeto -> seu uso é mais comum - já usamos na criação das migrations.)
PARA ISSO ACRESCENTAMOS UMA LINHA DE PERMISSÃO PARA INSERÇÃO DE DADOS NO BANCO:   protected $fillable = ['nome', 'site', 'uf', 'email'];
Fornecedor.php
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;

class Fornecedor extends Model
{
    use HasFactory;
    protected $table = 'fornecedores';

    protected $fillable = ['nome', 'site', 'uf', 'email'];

}


>php artisan tinker
Psy Shell v0.11.8 (PHP 8.1.11 — cli) by Justin Hileman
>>> Fornecedor::create(['nome'=>'Fornecedro ABC', 'site'=>'fornecedor.com.br', 'uf'=>'SP', 'email'=>'contato@abc.com.br']) 
* OBS.: QUALQUER ERRO SAI DO TINKER COM 'quit' e retorna para que o tinker recarregue os Models.

### RECUPERANDO REGISTROS NO BANCO DE DADOS
* MÉTODO ESTÁTICO ALL -> Recupera todos os registros de uma tabela

>>> $fornecedores = Fornecedor::all()                                          
=> Illuminate\Database\Eloquent\Collection {#3695
     all: [
       App\Models\Fornecedor {#3692
         id: 1,
         nome: "Fornecedor XYZ",
         site: "https://www.albertogomesdasilva.com.br",
         created_at: "2022-10-30 20:01:42",
         updated_at: "2022-10-30 20:01:42",
         uf: "MA",
         email: "fornecedorxyz@gmail.com.br",
       },
       App\Models\Fornecedor {#3689
         id: 2,
         nome: "Brascopper-SLZ",
         site: "https://brascopper-slz.com.br",
         created_at: "2022-10-30 20:06:03",
         updated_at: "2022-10-30 20:06:03",
         updated_at: "2022-10-30 20:14:19",
         uf: "SP",
         email: "contato@abc.com.br",
       },
     ],
   }
>>>>>> $r=SiteContato::all()                                                      
[!] Aliasing 'SiteContato' to 'App\Models\SiteContato' for this Tinker session.
=> Illuminate\Database\Eloquent\Collection {#4022
     all: [
       App\Models\SiteContato {#4637
         id: 1,
         nome: "Alberto",
         telefone: "98981188434",
         email: "albertoogmesdasilva@gmail.com",
         motivo_contato: 1,
         mensagem: "Olá. Gostaria de maiores detalhes..",
         created_at: "2022-10-30 19:34:37",
         updated_at: "2022-10-30 19:34:37",
       },
       App\Models\SiteContato {#4638
         id: 2,
         nome: "Maria",
         telefone: "98998887777",
         email: "maria@gmail.com",
         motivo_contato: 2,
         mensagem: "tudo ok..",
         created_at: "2022-10-30 19:40:45",
         updated_at: "2022-10-30 19:40:45",
       },
     ],
   }
   - CLASSIFICANDO:
   >>> $registros->toArray()                                                            
=> [
     [
       "id" => 1,
       "nome" => "Fornecedor XYZ",
       "site" => "https://www.albertogomesdasilva.com.br",
       "created_at" => "2022-10-30T20:01:42.000000Z",
       "updated_at" => "2022-10-30T20:01:42.000000Z",
       "uf" => "MA",
       "email" => "fornecedorxyz@gmail.com.br",
     ],
     [
       "id" => 2,
       "nome" => "Brascopper-SLZ",
       "site" => "https://brascopper-slz.com.br",
       "created_at" => "2022-10-30T20:06:03.000000Z",
       "updated_at" => "2022-10-30T20:06:03.000000Z",
       "uf" => "MA",
       "email" => "brascopperslz@gmail.com.br",
     ],
       "email" => "contato@abc.com.br",
     ],
   ]
>>> foreach($registros as $r) { echo $r-nome; echo '-';}                             
                         
Fornecedor XYZ-Brascopper-SLZ-Fornecedro ABC-⏎
>>>                                                                                  

* MÉTODO ESTÁTICO FIND:
>>> $buscar = Fornecedor::find(2)                                                    
=> App\Models\Fornecedor {#5020
     id: 2,
     nome: "Brascopper-SLZ",
     site: "https://brascopper-slz.com.br",
     created_at: "2022-10-30 20:06:03",
     updated_at: "2022-10-30 20:06:03",
     uf: "MA",
     email: "brascopperslz@gmail.com.br",
   }
>>>echo $buscar->nome                                                               
Brascopper-SLZ⏎                  
ou ainda..
>>> $buscar = Fornecedor::find([1,2,3,4])                                            
=> Illuminate\Database\Eloquent\Collection {#5019
     all: [
       App\Models\Fornecedor {#5014
         id: 1,
         nome: "Fornecedor XYZ",
         site: "https://www.albertogomesdasilva.com.br",
         created_at: "2022-10-30 20:01:42",
         updated_at: "2022-10-30 20:01:42",
         uf: "MA",
         email: "fornecedorxyz@gmail.com.br",
       },
       App\Models\Fornecedor {#5021
         id: 2,
         nome: "Brascopper-SLZ",
         site: "https://brascopper-slz.com.br",
         created_at: "2022-10-30 20:06:03",
         updated_at: "2022-10-30 20:06:03",
         uf: "MA",
         email: "brascopperslz@gmail.com.br",
       },
       App\Models\Fornecedor {#4637
         id: 3,
         nome: "Fornecedro ABC",
         site: "fornecedor.com.br",
         created_at: "2022-10-30 20:14:19",
         updated_at: "2022-10-30 20:14:19",
         uf: "SP",
         email: "contato@abc.com.br",
       },
     ],
   }
* MÉTODO ESTÁTICO WHERE:          

>>> $contatos = SiteContato::where('id', '>=', 1)->get()                             
=> Illuminate\Database\Eloquent\Collection {#5012
     all: [
       App\Models\SiteContato {#3688
         id: 1,
         nome: "Alberto",
         telefone: "98981188434",
         email: "albertoogmesdasilva@gmail.com",
         motivo_contato: 1,
         mensagem: "Olá. Gostaria de maiores detalhes..",
         created_at: "2022-10-30 19:34:37",
         updated_at: "2022-10-30 19:34:37",
       },
       App\Models\SiteContato {#5011
         id: 2,
         nome: "Maria",
         telefone: "98998887777",
         email: "maria@gmail.com",
         motivo_contato: 2,
         mensagem: "tudo ok..",
         created_at: "2022-10-30 19:40:45",
         updated_at: "2022-10-30 19:40:45",
       },
     ],
   }
>>>>>> $contatos = SiteContato::where('nome', '=','Maria')->get()                       
=> Illuminate\Database\Eloquent\Collection {#5012
     all: [
       App\Models\SiteContato {#5020
         id: 2,
         nome: "Maria",
         telefone: "98998887777",
         email: "maria@gmail.com",
         motivo_contato: 2,
         mensagem: "tudo ok..",
         created_at: "2022-10-30 19:40:45",
         updated_at: "2022-10-30 19:40:45",
       },
     ],
   }
>>> $contatos = SiteContato::where('nome', '<>','Maria')->get()                      
=> Illuminate\Database\Eloquent\Collection {#5006
     all: [
       App\Models\SiteContato {#4645
         id: 1,
         nome: "Alberto",
         telefone: "98981188434",
         email: "albertoogmesdasilva@gmail.com",
         motivo_contato: 1,
         mensagem: "Olá. Gostaria de maiores detalhes..",
         created_at: "2022-10-30 19:34:37",
         updated_at: "2022-10-30 19:34:37",
       },
     ],
   }
* OBS.: QUANDO USAR IGUAL PODEMOS OMITIR O SEGUNDO PARÂMETRO, SIMPLIFICANDO A CONSULTA:
>>> $contatos = SiteContato::where('nome', 'Maria')->get()                           
=> Illuminate\Database\Eloquent\Collection {#4999
     all: [
       App\Models\SiteContato {#5001
         id: 2,
         nome: "Maria",
         telefone: "98998887777",
         email: "maria@gmail.com",
         motivo_contato: 2,
         mensagem: "tudo ok..",
         created_at: "2022-10-30 19:40:45",
         updated_at: "2022-10-30 19:40:45",
       },
     ],
   }
   >>> $contatos = SiteContato::where('email', 'like', '%gmail%')->get()                
=> Illuminate\Database\Eloquent\Collection {#4998
     all: [
       App\Models\SiteContato {#5009
         id: 1,
         nome: "Alberto",
         telefone: "98981188434",
         email: "albertoogmesdasilva@gmail.com",
         motivo_contato: 1,
         mensagem: "Olá. Gostaria de maiores detalhes..",
         created_at: "2022-10-30 19:34:37",
         updated_at: "2022-10-30 19:34:37",
       },
       App\Models\SiteContato {#5016
         id: 2,
         nome: "Maria",
         telefone: "98998887777",
         email: "maria@gmail.com",
         motivo_contato: 2,
         mensagem: "tudo ok..",
         created_at: "2022-10-30 19:40:45",
         updated_at: "2022-10-30 19:40:45",
       },
     ],
   }
### WHEREIN => É UMA COMPARAÇÃO POR IGUALDADE
>php artisan tinker
Psy Shell v0.11.8 (PHP 8.1.11 — cli) by Justin Hileman
>>> $contato = SiteContato::whereIn('motivo_contato', [1, 3])                                                                          
[!] Aliasing 'SiteContato' to 'App\Models\SiteContato' for this Tinker session.
=> Illuminate\Database\Eloquent\Builder {#3683}
>>> $contato = SiteContato::whereIn('motivo_contato', [1, 3])->get()
=> Illuminate\Database\Eloquent\Collection {#4633
     all: [
       App\Models\SiteContato {#4635
         id: 1,
         nome: "Alberto",
         telefone: "98981188434",
         email: "albertoogmesdasilva@gmail.com",
         motivo_contato: 1,
         mensagem: "Olá. Gostaria de maiores detalhes..",
         created_at: "2022-10-30 19:34:37",
         updated_at: "2022-10-30 19:34:37",
       },
       App\Models\SiteContato {#4636
         id: 3,
         nome: "João",
         telefone: "(88) 91111-2222",
         email: "joao@contato.com.br",
         motivo_contato: 3,
         mensagem: "É muito difícil localizar a opção de listar todos os produtos",
         created_at: null,
         updated_at: null,
       },
       App\Models\SiteContato {#4637
         id: 4,
         nome: "Rosa",
         telefone: "(33) 92222-3333",
         email: "rosa@contato.com.br",
         motivo_contato: 1,
         mensagem: "Quando custa essa aplicação?",
         created_at: null,
         updated_at: null,
       },
       App\Models\SiteContato {#3684
         id: 5,
         nome: "Fernando",
         telefone: "(11) 94444-5555",
         email: "fernando@contato.com.br",
         motivo_contato: 1,
         mensagem: "Como consigo criar multiplos usuários para minha empresa?",
         created_at: null,
         updated_at: null,
       },
       App\Models\SiteContato {#4640
         id: 7,
         nome: "Ana",
     ],
   }

### WHERE NOTIN => COMPARAÇÃO POR DIFERENÇA

* É possível passar quantos parâmetros forem necessários, basta separar os parâmetros por vírgula.
* O In e NotIn suportam comparações com valores numéricos, strings e datas.

>>> $contatos = SiteContato::whereNotIn('motivo_contato', [1,3])->get()                           
[!] Aliasing 'SiteContato' to 'App\Models\SiteContato' for this Tinker session.
=> Illuminate\Database\Eloquent\Collection {#4017
     all: [
       App\Models\SiteContato {#4633
         id: 2,
         nome: "Maria",
         telefone: "98998887777",
         email: "maria@gmail.com",
         motivo_contato: 2,
         mensagem: "tudo ok..",
         created_at: "2022-10-30 19:40:45",
         updated_at: "2022-10-30 19:40:45",
       },
       App\Models\SiteContato {#4634
         id: 6,
         nome: "André",
         telefone: "(88) 95555-6666",
         email: "andre@contato.com.br",
         motivo_contato: 2,
         mensagem: "Parabéns pela ferramenta, estou obtendo ótimos resultados!",
         created_at: null,
         updated_at: null,
       },
       App\Models\SiteContato {#4635
         id: 8,
         nome: "Helena",
         telefone: "(11) 97777-8888",
         email: "helena@contato.com.br",
         motivo_contato: 2,
         mensagem: "Consigo controlar toda a minha empresa de modo fácil e prático.",
         created_at: null,
         updated_at: null,
       },
     ],
   }
>>> $contatos = SiteContato::whereNotIn('created_at', ['2022-10-30 19:40:45','2022-10-30 19:40:45'
])->get()                                                                                         
=> Illuminate\Database\Eloquent\Collection {#3694
     all: [
       App\Models\SiteContato {#3685
         id: 1,
         nome: "Alberto",
         telefone: "98981188434",
         email: "albertoogmesdasilva@gmail.com",
         motivo_contato: 1,
         mensagem: "Olá. Gostaria de maiores detalhes..",
         created_at: "2022-10-30 19:34:37",
         updated_at: "2022-10-30 19:34:37",
       },
     ],
   }
### COMPARAÇÃO POR: ESTÁ ENTRE E INCLUSIVE:
* Pode ser usado tanto para números quanto para datas
- O EXEMPLO A SEGUIR RETORNARÁ OS ID's 3,4,5,6:
>>> $res = SiteContato::whereBetween('id', [3, 6])->get()                                         
=> Illuminate\Database\Eloquent\Collection {#4420
     all: [
       App\Models\SiteContato {#3684
         id: 3,
         nome: "João",
         telefone: "(88) 91111-2222",
         email: "joao@contato.com.br",
         motivo_contato: 3,
         mensagem: "É muito difícil localizar a opção de listar todos os produtos",
         created_at: null,
         updated_at: null,
       },
       App\Models\SiteContato {#3693
         id: 4,
         nome: "Rosa",
         telefone: "(33) 92222-3333",
         email: "rosa@contato.com.br",
         motivo_contato: 1,
         mensagem: "Quando custa essa aplicação?",
         created_at: null,
         updated_at: null,
       },
       App\Models\SiteContato {#4017
         id: 5,
         nome: "Fernando",
         telefone: "(11) 94444-5555",
         email: "fernando@contato.com.br",
         motivo_contato: 1,
         mensagem: "Como consigo criar multiplos usuários para minha empresa?",
         created_at: null,
         updated_at: null,
       },
       App\Models\SiteContato {#4633
         id: 6,
         nome: "André",
         telefone: "(88) 95555-6666",
         email: "andre@contato.com.br",
         motivo_contato: 2,
         mensagem: "Parabéns pela ferramenta, estou obtendo ótimos resultados!",
         created_at: null,
         updated_at: null,
       },
     ],
   }
### WHERENOTBETWIN: RETORNARÁ TUDO QUE NÃO ESTÁ ENTRE O RESCPECTIVO INTERVALO E INCLUSIVE:
* Pode ser usado tanto para números quanto para datas
- O EXEMPLO A SEGUIR RETORNARÁ OS ID's 1, 2, 7, 8  EXCLUINDO  3,4,5,6

>>> $res = SiteContato::whereNotBetween('id', [3, 6])->get()                                      
=> Illuminate\Database\Eloquent\Collection {#4640
     all: [
       App\Models\SiteContato {#4636
         id: 1,
         nome: "Alberto",
         telefone: "98981188434",
         email: "albertoogmesdasilva@gmail.com",
         motivo_contato: 1,
         mensagem: "Olá. Gostaria de maiores detalhes..",
         created_at: "2022-10-30 19:34:37",
         updated_at: "2022-10-30 19:34:37",
       },
       App\Models\SiteContato {#4635
         id: 2,
         nome: "Maria",
         telefone: "98998887777",
         email: "maria@gmail.com",
         motivo_contato: 2,
         mensagem: "tudo ok..",
         created_at: "2022-10-30 19:40:45",
         updated_at: "2022-10-30 19:40:45",
       },
       App\Models\SiteContato {#4641
         id: 7,
         nome: "Ana",
         telefone: "(33) 96666-7777",
         email: "ana@contato.com.br",
         motivo_contato: 3,
         mensagem: "Não gostei muito das cores, consigo mudar de tema?",
         created_at: null,
         updated_at: null,
       },
       App\Models\SiteContato {#4651
         id: 8,
         nome: "Helena",
         telefone: "(11) 97777-8888",
         email: "helena@contato.com.br",
         motivo_contato: 2,
         mensagem: "Consigo controlar toda a minha empresa de modo fácil e prático.",
         created_at: null,
         updated_at: null,
       },
     ],
   }
### SELECIONANDO REGISTROS COM DOIS OU MAIS WHERES - através do objeto query builder do ORM: 
SELECT * FROM site_contatos WHERE nome <> 'Fernando' and motivo_contato in (1,2) and creted_at between '2022-10-21 00:00:00' and '2022-10-31 23:59:59'; -> Esta consulta SQL retorna dois registros.
* Neste caso todas operações precisam ser verdadeiras para que o registro seja retornado.
>>>>>> $contatos = SiteContato::where('nome', '<>', 'Fernando')->whereIn('motivo_contato', [1,2])->w
hereBetween('created_at', ['2022-10-21 00:00:00', '2022-10-31 00:00:00'])->get()                  
[!] Aliasing 'SiteContato' to 'App\Models\SiteContato' for this Tinker session.
=> Illuminate\Database\Eloquent\Collection {#4017
     all: [
       App\Models\SiteContato {#4632
         id: 1,
         nome: "Alberto",
         telefone: "98981188434",
         email: "albertoogmesdasilva@gmail.com",
         motivo_contato: 1,
         mensagem: "Olá. Gostaria de maiores detalhes..",
         created_at: "2022-10-30 19:34:37",
         updated_at: "2022-10-30 19:34:37",
       },
       App\Models\SiteContato {#4633
         id: 2,
         nome: "Maria",
         telefone: "98998887777",
         email: "maria@gmail.com",
         motivo_contato: 2,
         mensagem: "tudo ok..",
         created_at: "2022-10-30 19:40:45",
         updated_at: "2022-10-30 19:40:45",
       },
     ],
   }
>>>                    
### SELECIONANDO REGISTROS COM DOIS OU MAIS ORWHERES - através do objeto query builder do ORM:    
SELECT * FROM site_contatos WHERE nome <> 'Fernando' or motivo_contato in (1,2) or creted_at between '2022-10-21 00:00:00' and '2022-10-31 23:59:59';
* Neste caso apenas uma das operações precisa ser verdadeira para que o registro seja retornado.
>>>  $contatos = SiteContato::where('nome', '<>', 'Fernando')->orwhereIn('motivo_contato', [1,2])-
>orwhereBetween('created_at', ['2022-10-21 00:00:00', '2022-10-31 00:00:00'])->get()              
=> Illuminate\Database\Eloquent\Collection {#4632
     all: [
       App\Models\SiteContato {#4421
         id: 1,
         nome: "Alberto",
         telefone: "98981188434",
         email: "albertoogmesdasilva@gmail.com",
         motivo_contato: 1,
         mensagem: "Olá. Gostaria de maiores detalhes..",
         created_at: "2022-10-30 19:34:37",
         updated_at: "2022-10-30 19:34:37",
       },
       App\Models\SiteContato {#3681
         id: 2,
         nome: "Maria",
         telefone: "98998887777",
         email: "maria@gmail.com",
         motivo_contato: 2,
         mensagem: "tudo ok..",
         created_at: "2022-10-30 19:40:45",
         updated_at: "2022-10-30 19:40:45",
       },
       App\Models\SiteContato {#4649
         id: 3,
         nome: "João",
         telefone: "(88) 91111-2222",
         email: "joao@contato.com.br",
         motivo_contato: 3,
         mensagem: "É muito difícil localizar a opção de listar todos os produtos",
         created_at: null,
         updated_at: null,
       },
       App\Models\SiteContato {#4650
         id: 4,
         nome: "Rosa",
         telefone: "(33) 92222-3333",
         email: "rosa@contato.com.br",
         motivo_contato: 1,
         mensagem: "Quando custa essa aplicação?",
         created_at: null,
         updated_at: null,
       },
       App\Models\SiteContato {#4651
         id: 5,
         nome: "Fernando",
         telefone: "(11) 94444-5555",
         email: "fernando@contato.com.br",
         motivo_contato: 1,
         mensagem: "Como consigo criar multiplos usuários para minha empresa?",
         created_at: null,
         updated_at: null,
       },
       App\Models\SiteContato {#4652
         id: 6,
         nome: "André",
         telefone: "(88) 95555-6666",
         email: "andre@contato.com.br",
         motivo_contato: 2,
         mensagem: "Parabéns pela ferramenta, estou obtendo ótimos resultados!",
         created_at: null,
         updated_at: null,
       },
       App\Models\SiteContato {#4653
         id: 7,
         nome: "Ana",
         telefone: "(33) 96666-7777",
         email: "ana@contato.com.br",
         motivo_contato: 3,
         mensagem: "Não gostei muito das cores, consigo mudar de tema?",
         created_at: null,
       },
     ],
   }
>>>Podemos ter:
* OBS.: orWhere, orWhereIn, orWhereNotIn, orWhereBetween ou orWhereNotBetween se não informarmos o 'or' o operador será o 'and' 
where->
### WHRENULL e WHERENOTNULL
SELECT * FROM site_contatos WHERE updated_at is null;  (null <> vazio)
SELECT * FROM site_contatos WHERE updated_at is not null;
SELECT * FROM site_contatos WHERE updated_at is null;

>>> $contatos = SiteContato::whereNull('updated_at')->get();                                      
=> Illuminate\Database\Eloquent\Collection {#4638
     all: [
       App\Models\SiteContato {#4640
         id: 3,
         nome: "João",
         telefone: "(88) 91111-2222",
         email: "joao@contato.com.br",
         motivo_contato: 3,
         mensagem: "É muito difícil localizar a opção de listar todos os produtos",
         created_at: null,
         updated_at: null,
       },
       App\Models\SiteContato {#4641
         id: 4,
         nome: "Rosa",
         telefone: "(33) 92222-3333",
         email: "rosa@contato.com.br",
         motivo_contato: 1,
         mensagem: "Quando custa essa aplicação?",
         created_at: null,
         updated_at: null,
       },
       App\Models\SiteContato {#4642
         id: 5,
         nome: "Fernando",
         telefone: "(11) 94444-5555",
         email: "fernando@contato.com.br",
         motivo_contato: 1,
         mensagem: "Como consigo criar multiplos usuários para minha empresa?",
         created_at: null,
         updated_at: null,
       },
       App\Models\SiteContato {#4643
         id: 6,
         nome: "André",
         telefone: "(88) 95555-6666",
         email: "andre@contato.com.br",
         motivo_contato: 2,
         mensagem: "Parabéns pela ferramenta, estou obtendo ótimos resultados!",
         created_at: null,
         updated_at: null,
       },
       App\Models\SiteContato {#4644
         id: 7,
         nome: "Ana",
         telefone: "(33) 96666-7777",
         email: "ana@contato.com.br",
         motivo_contato: 3,
         mensagem: "Não gostei muito das cores, consigo mudar de tema?",
         created_at: null,
         updated_at: null,
       },
       App\Models\SiteContato {#4645
         id: 8,
         nome: "Helena",
         telefone: "(11) 97777-8888",
         email: "helena@contato.com.br",
         motivo_contato: 2,
         mensagem: "Consigo controlar toda a minha empresa de modo fácil e prático.",
         created_at: null,
         updated_at: null,
       },
     ],
   }
### NOTNULL
>>> $contatos = SiteContato::whereNotNull('updated_at')->get();                                   
=> Illuminate\Database\Eloquent\Collection {#4646
     all: [
       App\Models\SiteContato {#4637
         id: 1,
         nome: "Alberto",
         telefone: "98981188434",
         email: "albertoogmesdasilva@gmail.com",
         motivo_contato: 1,
         mensagem: "Olá. Gostaria de maiores detalhes..",
         created_at: "2022-10-30 19:34:37",
         updated_at: "2022-10-30 19:34:37",
       },
       App\Models\SiteContato {#3682
         id: 2,
         nome: "Maria",
         telefone: "98998887777",
         email: "maria@gmail.com",
         motivo_contato: 2,
         mensagem: "tudo ok..",
         created_at: "2022-10-30 19:40:45",
         updated_at: "2022-10-30 19:40:45",
       },
     ],
   }
>>> $contatos = SiteContato::whereNotNull('updated_at')->orWhereNull('created_at')->get();        
=> Illuminate\Database\Eloquent\Collection {#4637
     all: [
       App\Models\SiteContato {#4641
         id: 1,
         nome: "Alberto",
         telefone: "98981188434",
         email: "albertoogmesdasilva@gmail.com",
         motivo_contato: 1,
         mensagem: "Olá. Gostaria de maiores detalhes..",
         created_at: "2022-10-30 19:34:37",
         updated_at: "2022-10-30 19:34:37",
       },
       App\Models\SiteContato {#4658
         id: 2,
         nome: "Maria",
         telefone: "98998887777",
         email: "maria@gmail.com",
         motivo_contato: 2,
         mensagem: "tudo ok..",
         created_at: "2022-10-30 19:40:45",
         updated_at: "2022-10-30 19:40:45",
       },
       App\Models\SiteContato {#4659
         id: 3,
         nome: "João",
         telefone: "(88) 91111-2222",
         email: "joao@contato.com.br",
         motivo_contato: 3,
         mensagem: "É muito difícil localizar a opção de listar todos os produtos",
         created_at: null,
         updated_at: null,
       },
       App\Models\SiteContato {#4660
         id: 4,
         nome: "Rosa",
         telefone: "(33) 92222-3333",
         email: "rosa@contato.com.br",
         motivo_contato: 1,
         mensagem: "Quando custa essa aplicação?",
         created_at: null,
         updated_at: null,
       },
       App\Models\SiteContato {#4661
         id: 5,
         nome: "Fernando",
         telefone: "(11) 94444-5555",
         email: "fernando@contato.com.br",
         motivo_contato: 1,
         mensagem: "Como consigo criar multiplos usuários para minha empresa?",
         created_at: null,
         updated_at: null,
       },
       App\Models\SiteContato {#4662
         id: 6,
         nome: "André",
         telefone: "(88) 95555-6666",
         email: "andre@contato.com.br",
         motivo_contato: 2,
         mensagem: "Parabéns pela ferramenta, estou obtendo ótimos resultados!",
         created_at: null,
         updated_at: null,
       },
       App\Models\SiteContato {#4663
         id: 7,
         nome: "Ana",
         telefone: "(33) 96666-7777",
         email: "ana@contato.com.br",
         motivo_contato: 3,
         mensagem: "Não gostei muito das cores, consigo mudar de tema?",
         created_at: null,
         updated_at: null,
       },
       App\Models\SiteContato {#4664
         id: 8,
         nome: "Helena",
         telefone: "(11) 97777-8888",
         email: "helena@contato.com.br",
         motivo_contato: 2,
         mensagem: "Consigo controlar toda a minha empresa de modo fácil e prático.",
         created_at: null,
         updated_at: null,
       },
     ],
   }
### SELECIONANDO REGISTROS COM BASE EM PARÂMETROS DO TIPO DATA E HORA
### WHEREDATE
o>php artisan tinker
Psy Shell v0.11.8 (PHP 8.1.11 — cli) by Justin Hileman
>>> $contatos = SiteContato::whereDate('created_at', '2022-10-30')->get()                         
[!] Aliasing 'SiteContato' to 'App\Models\SiteContato' for this Tinker session.
=> Illuminate\Database\Eloquent\Collection {#4418
     all: [
       App\Models\SiteContato {#4630
         id: 1,
         nome: "Alberto",
         telefone: "98981188434",
         email: "albertoogmesdasilva@gmail.com",
         motivo_contato: 1,
         mensagem: "Olá. Gostaria de maiores detalhes..",
         created_at: "2022-10-30 19:34:37",
         updated_at: "2022-10-30 19:34:37",
       },
       App\Models\SiteContato {#4631
         id: 2,
         nome: "Maria",
         telefone: "98998887777",
         email: "maria@gmail.com",
         motivo_contato: 2,
         mensagem: "tudo ok..",
         created_at: "2022-10-30 19:40:45",
         updated_at: "2022-10-30 19:40:45",
       },
     ],
   }
### WHEREDAY
>>> $contatos = SiteContato::whereDay('created_at', '30')->get()                                  
=> Illuminate\Database\Eloquent\Collection {#4639
     all: [
       App\Models\SiteContato {#4637
         id: 1,
         nome: "Alberto",
         telefone: "98981188434",
         email: "albertoogmesdasilva@gmail.com",
         motivo_contato: 1,
         mensagem: "Olá. Gostaria de maiores detalhes..",
         created_at: "2022-10-30 19:34:37",
         updated_at: "2022-10-30 19:34:37",
       },
       App\Models\SiteContato {#4636
         id: 2,
         nome: "Maria",
         telefone: "98998887777",
         email: "maria@gmail.com",
         motivo_contato: 2,
         mensagem: "tudo ok..",
         created_at: "2022-10-30 19:40:45",
         updated_at: "2022-10-30 19:40:45",
       },
     ],
   }
### WHEREMONTH
>>> $contatos = SiteContato::whereMonth('created_at', '10')->get()                                
=> Illuminate\Database\Eloquent\Collection {#4417
     all: [
       App\Models\SiteContato {#4484
         id: 1,
         nome: "Alberto",
         telefone: "98981188434",
         email: "albertoogmesdasilva@gmail.com",
         motivo_contato: 1,
         mensagem: "Olá. Gostaria de maiores detalhes..",
         created_at: "2022-10-30 19:34:37",
         updated_at: "2022-10-30 19:34:37",
       },
       App\Models\SiteContato {#3683
         id: 2,
         nome: "Maria",
         telefone: "98998887777",
         email: "maria@gmail.com",
         motivo_contato: 2,
         mensagem: "tudo ok..",
         created_at: "2022-10-30 19:40:45",
         updated_at: "2022-10-30 19:40:45",
       },
     ],
   }
### WHEREYEAR
>> $contatos = SiteContato::whereYear('created_at', '2022')->get()                               
=> Illuminate\Database\Eloquent\Collection {#4639
     all: [
       App\Models\SiteContato {#4640
         id: 1,
         nome: "Alberto",
         telefone: "98981188434",
         email: "albertoogmesdasilva@gmail.com",
         motivo_contato: 1,
         mensagem: "Olá. Gostaria de maiores detalhes..",
         created_at: "2022-10-30 19:34:37",
         updated_at: "2022-10-30 19:34:37",
       },
       App\Models\SiteContato {#4641
         id: 2,
         nome: "Maria",
         telefone: "98998887777",
         email: "maria@gmail.com",
         motivo_contato: 2,
         mensagem: "tudo ok..",
         created_at: "2022-10-30 19:40:45",
         updated_at: "2022-10-30 19:40:45",
       },
     ],
   }
>>> $contatos = SiteContato::whereTime('created_at', '19:40:45')->get()                           
=> Illuminate\Database\Eloquent\Collection {#3676
     all: [
       App\Models\SiteContato {#3687
         id: 2,
         nome: "Maria",
         telefone: "98998887777",
         email: "maria@gmail.com",
         motivo_contato: 2,
         mensagem: "tudo ok..",
         created_at: "2022-10-30 19:40:45",
         updated_at: "2022-10-30 19:40:45",
       },
     ],
   }
>>> $contatos = SiteContato::whereTime('created_at', '<>', '19:40:45')->get()                     
=> Illuminate\Database\Eloquent\Collection {#4639
     all: [
       App\Models\SiteContato {#3676
         id: 1,
         nome: "Alberto",
         telefone: "98981188434",
         email: "albertoogmesdasilva@gmail.com",
         motivo_contato: 1,
         mensagem: "Olá. Gostaria de maiores detalhes..",
         created_at: "2022-10-30 19:34:37",
         updated_at: "2022-10-30 19:34:37",
       },
     ],
   }
>>> $contatos = SiteContato::whereTime('created_at', '<>', '19:40:45')->get()                     
=> Illuminate\Database\Eloquent\Collection {#4639
     all: [
       App\Models\SiteContato {#3676
         id: 1,
         nome: "Alberto",
         telefone: "98981188434",
         email: "albertoogmesdasilva@gmail.com",
         motivo_contato: 1,
         mensagem: "Olá. Gostaria de maiores detalhes..",
         created_at: "2022-10-30 19:34:37",
         updated_at: "2022-10-30 19:34:37",
       },
     ],
   }
### ELOQUENT - SELECIONANDO REGISTROS COM WHERECOLUMN(): Filtra registros comparando valores de colunas do mesmo registro.
-> Trará registros onde 'created_at' e 'updated_at' com valores iguais
### passando apenas dois parâmetros significa ter subtendido o perador de igauldade:
>>> $contato = SiteContato::whereColumn('created_at', 'updated_at')->get();                       
[!] Aliasing 'SiteContato' to 'App\Models\SiteContato' for this Tinker session.
=> Illuminate\Database\Eloquent\Collection {#4383
     all: [
       App\Models\SiteContato {#4636
         id: 1,
         nome: "Alberto",
         telefone: "98981188434",
         email: "albertoogmesdasilva@gmail.com",
         motivo_contato: 1,
         mensagem: "Olá. Gostaria de maiores detalhes..",
         created_at: "2022-10-30 19:34:37",
         updated_at: "2022-10-30 19:34:37",
       },
       App\Models\SiteContato {#4637
         id: 2,
         nome: "Maria",
         telefone: "98998887777",
         email: "maria@gmail.com",
         motivo_contato: 2,
         mensagem: "tudo ok..",
         created_at: "2022-10-30 19:40:45",
         updated_at: "2022-10-30 19:40:45",
       },
     ],
   }
   >>> $contato = SiteContato::whereColumn('created_at', 'updated_at')->get();                       
[!] Aliasing 'SiteContato' to 'App\Models\SiteContato' for this Tinker session.
=> Illuminate\Database\Eloquent\Collection {#4383
     all: [
       App\Models\SiteContato {#4636
         id: 1,
         nome: "Alberto",
         telefone: "98981188434",
         email: "albertoogmesdasilva@gmail.com",
         motivo_contato: 1,
         mensagem: "Olá. Gostaria de maiores detalhes..",
         created_at: "2022-10-30 19:34:37",
         updated_at: "2022-10-30 19:34:37",
       },
       App\Models\SiteContato {#4637
         id: 2,
         nome: "Maria",
         telefone: "98998887777",
         email: "maria@gmail.com",
         motivo_contato: 2,
         mensagem: "tudo ok..",
         created_at: "2022-10-30 19:40:45",
         updated_at: "2022-10-30 19:40:45",
       },
     ],
   }
### ELOQUENT - SELECIONANDO REGISTROS COM WHERECOLUMN() -> Suporta 3 parâmetros, podemos usar o operador:
>>> $contact = SiteContato::whereColumn('created_at', '<>', 'updated_at')->get();                                                             
=> Illuminate\Database\Eloquent\Collection {#3676
     all: [
       App\Models\SiteContato {#3682
         id: 2,
         nome: "Maria",
         telefone: "98998887777",
         email: "maria@gmail.com",
         motivo_contato: 2,
         mensagem: "tudo ok..",
         created_at: "2022-10-31 19:40:45",
         updated_at: "2022-10-30 19:40:45",
       },
     ],
   }
   >>> $contact = SiteContato::where('id', '>', 1)->whereColumn('created_at', '>=', 'updated_at')->get();                                        
=> Illuminate\Database\Eloquent\Collection {#4647
     all: [
       App\Models\SiteContato {#4645
         id: 2,
         nome: "Maria",
         telefone: "98998887777",
         email: "maria@gmail.com",
         motivo_contato: 2,
         mensagem: "tudo ok..",
         created_at: "2022-10-31 19:40:45",
         updated_at: "2022-10-30 19:40:45",
       },
     ],
   }
### SELECIONANDO REGISTROS APLICANDO PRECEDÊNCIAS EM OPERAÇÕES LÓGICAS

SELECT * FROM site_contatos WHERE (nome = 'Jorge' OR nome = 'Ana') and (motivo_contato in (1, 2) or id between 4 and 7); ==> Resulta o registro de id=7 (Ana).



SELECT * FROM site_contatos WHERE nome = 'Jorge' OR nome 'Ana' and (motivo_contato in (1, 2) or id between 4 and 7;  ===> Resulta os registros 4, 5, 6 e 7 ( Rosa, Fernando, André e Ana).

>>> $contatos = SiteContato::where(function($query){ $query->where('nome', 'Jorge')->orWhere('nome', 'Ana'); })->where(function($query){ $query->whereIn('motivo_contato', [1, 2])->orWhereBeteen('id', [4, 7]); })->get();                                                           
BadMethodCallException with message 'Call to undefined method Illuminate\Database\Eloquent\Builder::orWhereBeteen()'
>>> $contatos = SiteContato::where(function($query){ $query->where('nome', 'Jorge')->orWhere('nome', 'Ana'); })->where(function($query){ $q
uery->whereIn('motivo_contato', [1, 2])->orWhereBetween('id', [4, 7]); })->get();                                                          
=> Illuminate\Database\Eloquent\Collection {#4652
     all: [
       App\Models\SiteContato {#4643
         id: 7,
         nome: "Ana",
         telefone: "(33) 96666-7777",
         email: "ana@contato.com.br",
         motivo_contato: 3,
         mensagem: "Não gostei muito das cores, consigo mudar de tema?",
         created_at: null,
         updated_at: null,
       },
     ],
   }
### ELOQUENT - ORDENANDO REGISTROS -> A ordenação pode ser feita com base em uma coluna podendo ser ascendente ou descendente, e é possível também combinar várias ordenações, ou seja, primeiro ordenamos com base em uma coluna e com base nesse resultado utilizamos uma segunda coluna para ordenação e assim consecutivamente de modo encadeado.
- $contatos = SiteContato::all();    -> o método all() exibe tudo;
- $contatos = SiteContato::orderBy('nome', 'asc')->get();  -> Ordena por nome (padrão é ascendente se não passar o segundo parâmetro 'asc');
- $contatos = SiteContato::orderBy('nome', 'desc')->get();
- $contatos = SiteContato::orderBy('motivo_contato')->orderBy('nome', 'asc')->get();

### FILTROS E ORDENAÇÃO:
>>> $contatos = SiteContato::whereBetween('id', [2,4])->orderBy('motivo_contato')->orderBy('nome','desc')->get();                          
=> Illuminate\Database\Eloquent\Collection {#4630
     all: [
       App\Models\SiteContato {#4638
         id: 4,
         nome: "Rosa",
         telefone: "(33) 92222-3333",
         email: "rosa@contato.com.br",
         motivo_contato: 1,
         mensagem: "Quando custa essa aplicação?",
         created_at: null,
         updated_at: null,
       },
       App\Models\SiteContato {#4642
         id: 2,
         nome: "Maria",
         telefone: "98998887777",
         email: "maria@gmail.com",
         motivo_contato: 2,
         mensagem: "tudo ok..",
         created_at: "2022-10-31 19:40:45",
         updated_at: "2022-10-30 19:40:45",
       },
       App\Models\SiteContato {#3685
         id: 3,
         nome: "João",
         telefone: "(88) 91111-2222",
         email: "joao@contato.com.br",
         motivo_contato: 3,
         mensagem: "É muito difícil localizar a opção de listar todos os produtos",
         created_at: null,
         updated_at: null,
       },
     ],
   }
### ELOQUENT ORM -> COLLECTIONS: (laravel.com/docs/8.x/collections) - Available Methods(Métodos disponíveis) -> Quando estamos construindo uma Query nós temos um objeto do tipo 'Builder', no instante em que executamos o método 'get' nós recuperamos com base na query que foi construída um objeto do tipo 'collection', a partir de um objeto do tipo collection podemo aplicar sobre esse objeto os métodos que são nativos dele:
>>> $resultado = SiteContato::where('id', '>', 5)       
=> Illuminate\Database\Eloquent\Builder {#4377}  ==> Objeto do tipo Builder
>>>                             
=> Illuminate\Database\Eloquent\Collection {#4654
     all: [
       App\Models\SiteContato {#4657
         id: 6,
         nome: "André",
         telefone: "(88) 95555-6666",
         email: "andre@contato.com.br",
         motivo_contato: 2,
         mensagem: "Parabéns pela ferramenta, estou obtendo ótimos resultados!",
         created_at: null,
         updated_at: null,
       },
       App\Models\SiteContato {#4653
         id: 7,
         nome: "Ana",
         telefone: "(33) 96666-7777",
         email: "ana@contato.com.br",
         motivo_contato: 3,
         mensagem: "Não gostei muito das cores, consigo mudar de tema?",
         created_at: null,
         updated_at: null,
       },
       App\Models\SiteContato {#4015
         id: 8,
         nome: "Helena",
         telefone: "(11) 97777-8888",
         email: "helena@contato.com.br",
         motivo_contato: 2,
         mensagem: "Consigo controlar toda a minha empresa de modo fácil e prático.",
         created_at: null,
         updated_at: null,
       },
     ],
   }
>>> $resultado->get()  ==> Obtenho uma coleção                                         
* first, last e reverse: 
>>> $resultador->first()  => Retorna o primeiro elemento
>>> $resultador->last()  => Retorna o último elemento
>>> $resultador->reverse() => Inverte a ordem na exibição
### ELOQUENT = COLLECTION TO ARRAY E TO JSON  => Convertem uma coleção de objetos para um array e para um json respectivamente:
$resultado = SiteContato::all()   -> Retorna uma collection
>>> $resultado = SiteContato::all()->toArray()  -> A Collection é convertida para um objeto do tipo Array. Quando é feita essa conversão os métodos estáticos de uma coleção, todos os métodos nativos nativos não se aplicam aqui.
=> [
     [
       "id" => 1,
       "nome" => "Alberto",
       "telefone" => "98981188434",
       "email" => "albertoogmesdasilva@gmail.com",
       "motivo_contato" => 1,
       "mensagem" => "Olá. Gostaria de maiores detalhes..",
       "created_at" => "2022-10-30T19:34:37.000000Z",
       "updated_at" => "2022-10-30T19:34:37.000000Z",
     ],
     [
       "id" => 2,
       "nome" => "Maria",
       "telefone" => "98998887777",
       "email" => "maria@gmail.com",
       "motivo_contato" => 2,
       "mensagem" => "tudo ok..",
       "created_at" => "2022-10-31T19:40:45.000000Z",
       "updated_at" => "2022-10-30T19:40:45.000000Z",
     ],
     [
       "id" => 3,
       "nome" => "João",
       "telefone" => "(88) 91111-2222",
       "email" => "joao@contato.com.br",
       "motivo_contato" => 3,
       "mensagem" => "É muito difícil localizar a opção de listar todos os produtos",
       "created_at" => null,
       "updated_at" => null,
     ],
     [
       "id" => 4,
       "nome" => "Rosa",
       "telefone" => "(33) 92222-3333",
       "email" => "rosa@contato.com.br",
       "motivo_contato" => 1,
       "mensagem" => "Quando custa essa aplicação?",
       "created_at" => null,
       "updated_at" => null,
     ],
     [
       "id" => 5,
       "nome" => "Fernando",
       "telefone" => "(11) 94444-5555",
       "email" => "fernando@contato.com.br",
       "motivo_contato" => 1,
       "mensagem" => "Como consigo criar multiplos usuários para minha empresa?",
       "created_at" => null,
       "updated_at" => null,
     ],
     [
       "id" => 6,
       "nome" => "André",
       "telefone" => "(88) 95555-6666",
       "email" => "andre@contato.com.br",
       "motivo_contato" => 2,
       "mensagem" => "Parabéns pela ferramenta, estou obtendo ótimos resultados!",
       "created_at" => null,
       "updated_at" => null,
     ],
     [
       "id" => 7,
       "nome" => "Ana",
       "telefone" => "(33) 96666-7777",
       "email" => "ana@contato.com.br",
       "motivo_contato" => 3,
       "mensagem" => "Não gostei muito das cores, consigo mudar de tema?",
       "created_at" => null,
       "updated_at" => null,
     ],
     [
       "id" => 8,
       "nome" => "Helena",
       "telefone" => "(11) 97777-8888",
       "email" => "helena@contato.com.br",
       "motivo_contato" => 2,
       "mensagem" => "Consigo controlar toda a minha empresa de modo fácil e prático.",
       "created_at" => null,
       "updated_at" => null,
     ],
   ]
### Convertendo a coleção para Json:
>>>>>> $resultado = SiteContato::all()->toJson()
=> "[{"id":1,"nome":"Alberto","telefone":"98981188434","email":"albertoogmesdasilva@gmail.com","motivo_contato":1,"mensagem":"Ol\u00e1. Gostaria de maiores detalhes..","created_at":"2022-10-30T19:34:37.000000Z","updated_at":"2022-10-30T19:34:37.000000Z"},{"id":2,"nome":"Maria","telefone":"98998887777","email":"maria@gmail.com","motivo_contato":2,"mensagem":"tudo ok..","created_at":"2022-10-31T19:40:45.000000Z","updated_at":"2022-10-30T19:40:45.000000Z"},{"id":3,"nome":"Jo\u00e3o","telefone":"(88) 91111-2222","email":"joao@contato.com.br","motivo_contato":3,"mensagem":"\u00c9 muito dif\u00edcil localizar a op\u00e7\u00e3o de listar todos os produtos","created_at":null,"updated_at":null},{"id":4,"nome":"Rosa","telefone":"(33) 92222-3333","email":"rosa@contato.com.br","motivo_contato":1,"mensagem":"Quando custa essa aplica\u00e7\u00e3o?","created_at":null,"updated_at":null},{"id":5,"nome":"Fernando","telefone":"(11) 94444-5555","email":"fernando@contato.com.br","motivo_contato":1,"mensagem":"Como consigo criar multiplos usu\u00e1rios para minha empresa?","created_at":null,"updated_at":null},{"id":6,"nome":"Andr\u00e9","telefone":"(88) 95555-6666","email":"andre@contato.com.br","motivo_contato":2,"mensagem":"Parab\u00e9ns pela ferramenta, estou obtendo \u00f3timos resultados!","created_at":null,"updated_at":null},{"id":7,"nome":"Ana","telefone":"(33) 96666-7777","email":"ana@contato.com.br","motivo_contato":3,"mensagem":"N\u00e3o gostei muito das cores, consigo mudar de tema?","created_at":null,"updated_at":null},{"id":8,"nome":"Helena","telefone":"(11) 97777-8888","email":"helena@contato.com.br","motivo_contato":2,"mensagem":"Consigo controlar toda a minha empresa de modo f\u00e1cil e pr\u00e1tico.","created_at":null,"updated_at":null}]"
### PLUCK -> Permite recuperar todos os valores de uma determinada chave. por exemplo: todos os emails, a partir daí combinar com outros métodos:
>>> SiteContato::all()->pluck('email')         
=> Illuminate\Support\Collection {#4657
     all: [
       "albertoogmesdasilva@gmail.com",
       "maria@gmail.com",
       "joao@contato.com.br",
       "rosa@contato.com.br",
       "fernando@contato.com.br",
       "andre@contato.com.br",
       "ana@contato.com.br",
       "helena@contato.com.br",
     ],
   }
>>> SiteContato::all()->pluck('email')->first() 
=> "albertoogmesdasilva@gmail.com"
* OBS.: APÓS CONVERTER EM ARRAY NÃO POSSO CHAMAR OUTROS MÉTODOS NATIVOS, SOMENTE ENQUANTO FOR UMA COLLECTION POSSO ENCADEAR MÉTODOS.

>>> SiteContato::all()->pluck('email')->toArray()->first()
PHP Error:  Call to a member function first() on array in C:\Users\alber\Desktop\PHP E LARAVEL-9eval()'d code on line 1
>>> SiteContato::all()->pluck('email')->reverse()->first()
=> "helena@contato.com.br"
### ATRIBUINDO UMA CHAVE PARA A CONSULTA
>>> SiteContato::all()->pluck('email', 'nome')
=> Illuminate\Support\Collection {#4663
     all: [
       "Alberto" => "albertoogmesdasilva@gmail.com",
       "Maria" => "maria@gmail.com",
       "João" => "joao@contato.com.br",
       "Rosa" => "rosa@contato.com.br",
       "Fernando" => "fernando@contato.com.br",
       "André" => "andre@contato.com.br",
       "Ana" => "ana@contato.com.br",
       "Helena" => "helena@contato.com.br",
     ],
   }                                                                                                                                        
### PARA CONHECER UM POUCO MAIS SOBRE OS MÉTODOS NATIVOS DOS OBJETOS COLLECTION
https://laravel.com/docs/8.x/collections
* ex.: >>> SiteContato::all()->pluck('id')                                                                                                        
=> Illuminate\Support\Collection {#5024
     all: [
       1,
       2,
       3,
       4,
       5,
       6,
       7,
       8,
     ],
   }

>>> SiteContato::all()->pluck('id')->sum() 
=> 36
### ATUALIZANDO REGISTROS - save()
>> $res = SiteContato::all()->first()                                                                                                     
=> App\Models\SiteContato {#4647
     id: 1,
     nome: "Alberto",
     telefone: "98981188434",
     email: "albertoogmesdasilva@gmail.com",
     motivo_contato: 1,
     mensagem: "Olá. Gostaria de maiores detalhes..",
     created_at: "2022-10-30 19:34:37",
     updated_at: "2022-10-30 19:34:37",
   }
>>>$res = SiteContato::all()->first()
=> App\Models\SiteContato {#4647
     id: 1,
     nome: "Alberto",
     telefone: "98981188434",
     email: "albertoogmesdasilva@gmail.com",
     motivo_contato: 1,
     mensagem: "Olá. Gostaria de maiores detalhes..",
     created_at: "2022-10-30 19:34:37",
     updated_at: "2022-10-30 19:34:37",
   }
>>> $res -> nome
=> "Alberto"
>>> $res -> nome = 'Adalberto'
=> "Adalberto"
>>> $res->save()
=> true
>>> dd($res)                                                                                                                               
App\Models\SiteContato^ {#4647 // vendor\psy\psysh\src\ExecutionLoopClosure.php(55) : eval()'d code:1
  #connection: "mysql"
  #table: "site_contatos"
  #primaryKey: "id"
  #keyType: "int"
  +incrementing: true
  #with: []
  #withCount: []
  +preventsLazyLoading: false
  #perPage: 15
  +exists: true
  +wasRecentlyCreated: false
  #escapeWhenCastingToString: false
  #attributes: array:8 [
    "id" => 1
    "nome" => "Adalberto"
    "telefone" => "98981188434"
    "email" => "adalberto@gmail.com"
    "motivo_contato" => 1
    "mensagem" => "Olá. Gostaria de maiores detalhes.."
    "created_at" => "2022-10-30 19:34:37"
    "updated_at" => "2022-10-31 20:53:29"
  ]
  #original: array:8 [
    "id" => 1
    "nome" => "Adalberto"
    "telefone" => "98981188434"
    "email" => "adalberto@gmail.com"
    "motivo_contato" => 1
    "mensagem" => "Olá. Gostaria de maiores detalhes.."
    "created_at" => "2022-10-30 19:34:37"
    "updated_at" => "2022-10-31 20:53:29"
  ]
  #changes: array:2 [
    "email" => "adalberto@gmail.com"
    "updated_at" => "2022-10-31 20:53:29"
  ]
  #casts: []
  #classCastCache: []
  #attributeCastCache: []
  #dates: []
  #dateFormat: null
  #appends: []
  #dispatchesEvents: []
  #observables: []
  #relations: []
  #touches: []
  +timestamps: true
  #hidden: []
  #visible: []
  #fillable: []
  #guarded: array:1 [
    0 => "*"
  ]
}
>>> print_r($res)                                                                                                                          
App\Models\SiteContato Object
(
    [connection:protected] => mysql
    [table:protected] => site_contatos
    [primaryKey:protected] => id
    [keyType:protected] => int
    [incrementing] => 1
    [with:protected] => Array
        (
        )
    [withCount:protected] => Array
        (
        )

    [preventsLazyLoading] =>
    [perPage:protected] => 15
    [exists] => 1
    [wasRecentlyCreated] =>
    [escapeWhenCastingToString:protected] =>
    [attributes:protected] => Array
        (
            [id] => 1
            [nome] => Adalberto
            [telefone] => 98981188434
            [email] => adalberto@gmail.com
            [motivo_contato] => 1
            [mensagem] => Olá. Gostaria de maiores detalhes..
            [created_at] => 2022-10-30 19:34:37
            [updated_at] => 2022-10-31 20:53:29
        )

    [original:protected] => Array
        (
            [id] => 1
            [nome] => Adalberto
            [telefone] => 98981188434
            [email] => adalberto@gmail.com
            [motivo_contato] => 1
            [mensagem] => Olá. Gostaria de maiores detalhes..
            [created_at] => 2022-10-30 19:34:37
            [updated_at] => 2022-10-31 20:53:29
        )

    [changes:protected] => Array
        (
        )

    [casts:protected] => Array
        (
        )

    [classCastCache:protected] => Array
        (
        )

    [attributeCastCache:protected] => Array
        (
        )

    [dates:protected] => Array
        (
        )

    [dateFormat:protected] =>
    [appends:protected] => Array
        (
        )

    [dispatchesEvents:protected] => Array
        (
        )

    [observables:protected] => Array
        (
        )

    [relations:protected] => Array
        (
        )

    [touches:protected] => Array
        (
        )

    [timestamps] => 1
    [hidden:protected] => Array
        (
        )

    [visible:protected] => Array
        (
        )

    [fillable:protected] => Array
        (
        )

    [guarded:protected] => Array
        (
            [0] => *
        )

)
=> true
>>> SiteContato::find(1)                                                                                                                   
=> App\Models\SiteContato {#4631
     id: 1,
     nome: "Adalberto",
     telefone: "98981188434",
     email: "adalberto@gmail.com",
     motivo_contato: 1,
     mensagem: "Olá. Gostaria de maiores detalhes..",
     created_at: "2022-10-30 19:34:37",
     updated_at: "2022-10-31 20:53:29",
   }
### ATUALIZANDO REGISTROS fill e save
>>> $res = Fornecedor::find(1)                                                                                                             
[!] Aliasing 'Fornecedor' to 'App\Models\Fornecedor' for this Tinker session.
=> App\Models\Fornecedor {#4646
     id: 1,
     nome: "Fornecedor XYZ",
     site: "https://www.albertogomesdasilva.com.br",
     created_at: "2022-10-30 20:01:42",
     updated_at: "2022-10-30 20:01:42",
     uf: "MA",
=> App\Models\Fornecedor {#4646
     id: 1,
     nome: "AGS - Fornecedores",
     site: "https://www.albertogomesdasilva.com.br",
     created_at: "2022-10-30 20:01:42",
     updated_at: "2022-10-30 20:01:42",
     uf: "MA",
     email: "fornecedorxyz@gmail.com.br",
   }
>>> $res->save()
=> true
### ATUALIZANDO REGISTROS WHERE E UPDATE
>>> Fornecedor::whereIn('id', [1, 2])                                                                                                      
=> Illuminate\Database\Eloquent\Builder {#4639}
>>> Fornecedor::whereIn('id', [1, 2])->get()                                                                                               
=> Illuminate\Database\Eloquent\Collection {#4635
     all: [
       App\Models\Fornecedor {#3681
         id: 1,
         nome: "AGS - Logística",
         site: "http://agslog.com.br",
         created_at: "2022-10-30 20:01:42",
         updated_at: "2022-10-31 21:15:09",
         uf: "MA",
         email: "agslog@gmail.com",
       },
       App\Models\Fornecedor {#4648
         id: 2,
         nome: "Brascopper-SLZ",
         site: "https://brascopper-slz.com.br",
         created_at: "2022-10-30 20:06:03",
         updated_at: "2022-10-30 20:06:03",
         uf: "MA",
         email: "brascopperslz@gmail.com.br",
       },
     ],
   }
>>> Fornecedor::whereIn('id', [1, 2])->update(['nome'=>'Nova Log', 'site'=>'http://nlog.com.br', 'email'=>'nlog@hotmail.com'])             
=> 2
>>> Fornecedor::whereIn('id', [1, 2])->get()                                                                                               
=> Illuminate\Database\Eloquent\Collection {#4418
     all: [
       App\Models\Fornecedor {#4631
         id: 1,
         nome: "Nova Log",
         site: "http://nlog.com.br",
         created_at: "2022-10-30 20:01:42",
         updated_at: "2022-10-31 21:21:31",
         uf: "MA",
         email: "nlog@hotmail.com",
       },
       App\Models\Fornecedor {#4641
         id: 2,
         nome: "Nova Log",
         site: "http://nlog.com.br",
         created_at: "2022-10-30 20:06:03",
         updated_at: "2022-10-31 21:21:31",
         uf: "MA",
         email: "nlog@hotmail.com",
       },
     ],
   }
   >>> Fornecedor::where('id', 1)->update(['nome' => 'AGS - Logística', 'site'=>'http://agslog.com.br', 'email'=>'agslog@gmail.com' ])        
=> 1
### DELETANDO REGISTROS - DELETE E DESTROY
>>> SiteContato::where('id', 1)->delete()
=> 1
>>> SiteContato::find(2)->delete('id', 2)
=> true
>>> $res = SiteContato::find(4)->delete()
=> true
>>> SiteContato::destroy(5)             
=> 1
>>> SiteContato::destroy(7, 8)   
=> 2
# php artisan make:seeder SiteContatoSeeder
# php artisan make:seeder Fornecedor
### SEEDERS (DatabaseSeeder) - (classes conhecidas como sementes) -> Inserindo poucos registros:
- Com o banco de dados completamente limpo vamos começar criando o nosso primeiro seed para popular a tabela 'fornecedores':
### php artisan make:seeder FornecedorSeeder  // Não existe convenção, mais o ideal é colocar no final do nome o nome seeder
# 3 FORMAS DIFERENTES:

FornecedorSeeder.php
<?php

namespace Database\Seeders;

use Illuminate\Database\Console\Seeds\WithoutModelEvents;
use Illuminate\Database\Seeder;

use App\Fornecedor;

class FornecedorSeeder extends Seeder
{
    /**
     * Run the database seeds.
     *
     * @return void
     */
    public function run()
    {
        // MÉTODO 1 DE FAZER -> Instanciando o objeto
        $fornecedor = new Fornecedor;

        $fornecedor->nome = 'Fornecedor 100';
        $fornecedor->site = 'https://fornecedor100.com.br';
        $fornecedor->uf = 'MA';
        $fornecedor->emal = 'fornecedor100@gmail.com';
        $fornecedor->save();

        // MÉTODO 2 DE FAZER => MÉTODO CREATE -> DESTA FORMA NO MODEL Fornecedor.php  DEVE INSERIR A LINHA:
        // protected $fillable = ['nome', 'site', 'uf', 'email'];
        Fornecedor::create([
            'nome'=>'Fornecedor200',
            'site' => 'https://forn200.com.br',
            'uf'=> 'RS',
            'email'=>'forn200@gmail.com'
        ]);

        // MÉTODO 3 -> USANDO O MÉTODO INSERT
        DB::table('fornecedores')->insert([
            'nome'=>'Fornecedor300',
            'site' => 'https://fornec300.com.br',
            'uf'=> 'SP',
            'email'=>'fornec300@hotmail.com'
        ]);
    }
}

# \App\Models\SiteContato::factory(100)->create(); -> esta instrução pode está no DatabaseSeeder.php ou no SiteContatoSeeder.php
# \App\Models\Fornecedor::factory(100)->create(); -> esta instrução pode está no DatabaseSeeder.php ou no FonnecedorSeeder.php;

->  $this->call(FornecedorSeeder::class);
->  $this->call(SiteContatoSeeder::class);
# CONFIGURAR O DatabaseSeeder.php

# para executar a seeder: php artisan db:seed   =>  $this->call(FornecedorSeeder::class);  
# php artisan db:seed -> Executa todas as seeders
# >php artisan db:seed --class=SiteContatoSeeder -> Executa uma seed específicada pelo nome

<?php

namespace Database\Seeders;

// use Illuminate\Database\Console\Seeds\WithoutModelEvents;
use Illuminate\Database\Seeder;

class DatabaseSeeder extends Seeder
{
    /**
     * Seed the application's database.
     *
     * @return void
     */
    public function run()
    {
         $this->call(FornecedorSeeder::class);  

        //   \App\Models\User::factory(10)->create();
        //   \App\Models\SiteContato::factory(100)->create();
        //   \App\Models\Fornecedor::factory(100)->create();
        //   \App\Models\FornecedorSeeder::class;

        // \App\Models\User::factory()->create([
        //     'name' => 'Test User',
        //     'email' => 'test@example.com',
        // ]);
    }
}

# FornecedorSeeder.php
<?php

namespace Database\Seeders;

use Illuminate\Database\Console\Seeds\WithoutModelEvents;
use Illuminate\Database\Seeder;

use App\Models\Fornecedor;

class FornecedorSeeder extends Seeder
{
    /**
     * Run the database seeds.
     *
     * @return void
     */
    public function run()
    {
        $fornecedor = new Fornecedor;

        $fornecedor->nome = 'Fornecedor 100';
        $fornecedor->site = 'https://fornecedor100.com.br';
        $fornecedor->uf = 'MA';
        $fornecedor->email = 'fornecedor100@gmail.com';
        $fornecedor->save();

        Fornecedor::create([
            'nome'=>'Fornecedor200',
            'site' => 'https://forn200.com.br',
            'uf'=> 'RS',
            'email'=>'forn200@gmail.com'
        ]);

    }
}

# SiteContatoSeeder.php
<?php

namespace Database\Seeders;

use Illuminate\Database\Console\Seeds\WithoutModelEvents;
use Illuminate\Database\Seeder;

use App\Models\SiteContato;

class SiteContatoSeeder extends Seeder
{
    /**
     * Run the database seeds.
     *
     * @return void
     */
    public function run()
    {
        $sitecontato = new SiteContato;

        $sitecontato->nome = 'Alberto Gomes';
        $sitecontato->telefone = '98981188434';
        $sitecontato->email = 'ags@silva.com.br';
        $sitecontato->motivo_contato = 2;
        $sitecontato->mensagem = 'Detalhes do produto';
        $sitecontato->save();

        SiteContato::create([
            'nome'=>'agsilva',
            'telefone' => '98988445577',
            'email'=> 'agsilva@gmail.com',
            'motivo_contato'=>1,
            'mensagem'=>'Mais informações.'
        ]);

    }
}

# DatabaseSeeder.php
<?php

namespace Database\Seeders;

// use Illuminate\Database\Console\Seeds\WithoutModelEvents;
use Illuminate\Database\Seeder;

class DatabaseSeeder extends Seeder
{
    /**
     * Seed the application's database.
     *
     * @return void
     */
    public function run()
    {
        // $this->call(FornecedorSeeder::class);
         $this->call(SiteContatoSeeder::class);

        //   \App\Models\User::factory(10)->create();
        //   \App\Models\SiteContato::factory(100)->create();
        //   \App\Models\Fornecedor::factory(100)->create();
        //   \App\Models\FornecedorSeeder::class;

        // \App\Models\User::factory()->create([
        //     'name' => 'Test User',
        //     'email' => 'test@example.com',
        // ]);
    }
}

>php artisan migrate:rollback
>php artisan migrate:fresh
>php artisan migrate --seed   
   INFO  Running migrations.

  2014_10_12_000000_create_users_table ..................................................... 71ms DONE
  2014_10_12_100000_create_password_resets_table ........................................... 59ms DONE
  2019_08_19_000000_create_failed_jobs_table ............................................... 58ms DONE
  2019_12_14_000001_create_personal_access_tokens_table .................................... 75ms DONE
  2022_10_29_124933_create_site_contatos_table ............................................. 27ms DONE
  2022_10_29_141119_create_fornecedores_table .............................................. 26ms DONE
  2022_10_30_144326_alter_fornecedores_novas_colunas ....................................... 50ms DONE
  2022_10_30_151416_create_produtos_table .................................................. 30ms DONE
  2022_10_30_152706_create_produtos_detalhes_table ........................................ 144ms DONE
  2022_10_30_163254_create_unidades_table ................................................. 291ms DONE
  2022_10_30_175104_ajuste_produtos_filiais ............................................... 269ms DONE
  2022_10_30_182603_nova_coluna_site_com_after ............................................. 51ms DONE
  2022_10_31_230638_alter_fornecedores_softdelete .......................................... 49ms DONE

   INFO  Seeding database.

  Database\Seeders\FornecedorSeeder .................................................... RUNNING  
  Database\Seeders\FornecedorSeeder .............................................. 11.04 ms DONE  

  Database\Seeders\SiteContatoSeeder ................................................... RUNNING  
  Database\Seeders\SiteContatoSeeder ............................................. 13.34 ms DONE  



### FACTORIES - FACTORY -> para popular o banco de dados criamos as factory

### https://github.com/fzaninotto/Faker/

# php artisan make:factory SiteContatoFactory --model SiteContato
# php artisan make:factory SiteContatoFactory --model SiteContato

>php artisan make:factory SiteContatoFactory --model SiteContato
<?php
namespace Database\Factories;

use Illuminate\Database\Eloquent\Factories\Factory;

/**
 * @extends \Illuminate\Database\Eloquent\Factories\Factory<\App\Models\SiteContato>
 */
class SiteContatoFactory extends Factory
{
    /**
     * Define the model's default state.
     *
     * @return array<string, mixed>
     */
    public function definition()
    {
        return [
            'nome' => fake()->name(),
            'telefone' => fake()->tollFreePhoneNumber(),
            'email' => fake()->email(),
            'motivo_contato' => fake()->numberBetween(1,3),
            'mensagem' => fake()->text(200)
        ];
    }
}


>php artisan make:factory FornecedorFactory --model Fornecedor
<?php

### https://github.com/fzaninotto/Faker/

namespace Database\Factories;

use Illuminate\Database\Eloquent\Factories\Factory;

/**
 * @extends \Illuminate\Database\Eloquent\Factories\Factory<\App\Models\Fornecedor>
 */
class FornecedorFactory extends Factory
{
    /**
     * Define the model's default state.
     *
     * @return array<string, mixed>
     */
    public function definition()
    {
        return [
            'nome' => fake()->name(),
            'site' => fake()->tollFreePhoneNumber(),
            'uf' => fake()->stateAbbr(),
            'email' => fake()->email(),
           
        ];
    }
}

### ALTERAMOS O ARQUIVO DatabaseSeeder.php para poder executar:
/database/seeders/DatabaseSeeder.php

<?php

namespace Database\Seeders;

// use Illuminate\Database\Console\Seeds\WithoutModelEvents;
use Illuminate\Database\Seeder;

class DatabaseSeeder extends Seeder
{
    /**
     * Seed the application's database.
     *
     * @return void
     */
    public function run()
    {
        // \App\Models\User::factory(10)->create();
         \App\Models\SiteContato::factory(100)->create();
         \App\Models\Fornecedor::factory(100)->create();

        // \App\Models\User::factory()->create([
        //     'name' => 'Test User',
        //     'email' => 'test@example.com',
        // ]);
    }
}

### EXECUTANDO A SEED E POPULANDO DADOS NO BANCO 

>php  artisan db:seed

### DELETANDO REGISTROS - SOFTDELETE -> Criamos uma coluna para marcamos um registro ao invés de excluir.
importamos com a linha:
 use Illuminate\Database\Eloquent\SoftDeletes; 
no Model Fornecedor.php

* Trait -> São pedaços de códigos que definem propriedades e métodos e que podem ser utilizados dentro de uma classe como um especie de include, de CTRL+C CTRL+V, com isso, a classe se expande incorporando as propriedades e métodos dessa respectiva trait. É parecida com extends, mas como não podemos ter herança múltiplas, as traits são utilizadas para poder contornar isso. Na O.O. temos essa restrição de herança multiplas. Implementa uma herança horizontal em vez da vertical de herança múltipla.

Fornecedor.php (Model)
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\SoftDeletes;

class Fornecedor extends Model
{
    use SoftDeletes;
    
    use HasFactory;
    protected $table = 'fornecedores';

    protected $fillable = ['nome', 'site', 'uf', 'email'];

}

O PRÓXIMO PASSO É AJUSTAR A MIGRATION DE CRIAÇÃO DA TABELA fornecedores:

$table->softDeletes();   //Cria a coluna deleted_at na tabela fornecedores

2022_10_29_141119_create_fornecedores_table.php

<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     *
     * @return void
     */
    public function up()
    {
        Schema::create('fornecedores', function (Blueprint $table) {
            $table->id();
            $table->string('nome', 50);
            $table->timestamps();
          //  $table->softDeletes();   //Cria a coluna deleted_at na tabela fornecedores
        });
    }

    /**
     * Reverse the migrations.
     *
     * @return void
     */
    public function down()
    {
        Schema::dropIfExists('fornecedores');
    }
};

Fazendo assim teremos que dá refresh no banco como um todo... 

### criando a migration para acrescentar a coluna deleted_at ao invés de acrescentar na migration de criação da tabela:

>php artisan make:migration alter_fornecedores_softdelete  

2022_10_31_230638_alter_fornecedores_softdelete.php

<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     *
     * @return void
     */
    public function up()
    {
        Schema::table('fornecedores', function(Blueprint $table) {
            $table->softDeletes();
        });
    }
    
    /**
     * Reverse the migrations.
     *
     * @return void
     */
    public function down()
    {
        Schema::table('fornecedores', function(Blueprint $table) {
            $table->dropSoftDeletes();
        });
        
    }
};


>php artisan migrate:status
Migration name ............................................................... Batch / Status  
  2014_10_12_000000_create_users_table ....................................... [1] Ran  
  2014_10_12_100000_create_password_resets_table ............................. [1] Ran  
  2019_08_19_000000_create_failed_jobs_table ................................. [1] Ran  
  2019_12_14_000001_create_personal_access_tokens_table ...................... [1] Ran  
  2022_10_29_124933_create_site_contatos_table ............................... [1] Ran  
  2022_10_29_141119_create_fornecedores_table ................................ [1] Ran  
  2022_10_30_144326_alter_fornecedores_novas_colunas ......................... [1] Ran  
  2022_10_30_151416_create_produtos_table .................................... [1] Ran  
  2022_10_30_152706_create_produtos_detalhes_table ........................... [1] Ran  
  2022_10_30_163254_create_unidades_table .................................... [1] Ran  
  2022_10_30_175104_ajuste_produtos_filiais .................................. [1] Ran  
  2022_10_30_182603_nova_coluna_site_com_after ................................ [1] Ran  
  2022_10_31_230638_alter_fornecedores_softdelete ............................. Pending  


> php artisan migrate
### DELETANDO E PREENCHENDO A COLUNA deleted_at
>>> $res = Fornecedor::find(1)                                                                                           
=> App\Models\Fornecedor {#3707
     id: 1,
     nome: "Santiago Wintheiser",
     site: "(888) 524-2135",
     created_at: "2022-10-31 22:40:51",
     updated_at: "2022-10-31 22:40:51",
     uf: "NC",
     email: "awalsh@yahoo.com",
     deleted_at: null,
   }
>>> $res->delete()                                                                                                       
=> true
ID   NOME          SITE      CREATED_AT UPDATED_AT  UF      EMAIL             DELETED_AT
1   Santiago Winth https.ww.com 22:40:51 23:13:33       NC  awalsh@yahoo.com    2022-10-31 23:13:33
>>> Fornecedor::find(1)                                                                                                  
=> null
### RESTAURANDO OS REGISTROS REMOVIDOS DE MODO SUAVE (SOFTDELETE)
* Exibindo os deletados com softDelete
>>> Fornecedor::withTrashed()->get()                                                                                     
         updated_at: "2022-10-31 23:13:33",
         uf: "NC",
         email: "awalsh@yahoo.com",
         deleted_at: "2022-10-31 23:13:33",
       },
     ],
   }
* criando um novo registro:
>>> Fornecedor::create(['nome' => 'Fornec123', 'site'=>'fornec123.com.br', 'uf'=>'MA', 'email'=>'f123@gmail.com'])     
=> App\Models\Fornecedor {#4079
     nome: "Fornec123",
     site: "fornec123.com.br",
     uf: "MA",
     email: "f123@gmail.com",
     updated_at: "2022-10-31 23:30:02",
     created_at: "2022-10-31 23:30:02",
     id: 201,
   }                                                                                                     
* EXIBINDO SOMENTE OS DELETADOS COM SOFTDELETES
>>> Fornecedor::onlyTrashed()->get()                                                                                   
=> Illuminate\Database\Eloquent\Collection {#3706
     all: [
       App\Models\Fornecedor {#4097
         id: 1,
         nome: "Santiago Wintheiser",
         site: "(888) 524-2135",
         created_at: "2022-10-31 22:40:51",
         updated_at: "2022-10-31 23:13:33",
         uf: "NC",
         email: "awalsh@yahoo.com",
         deleted_at: "2022-10-31 23:13:33",   // QUANDO DELETA INSERI A DATA E HORA SOMENTE
       },
     ],
   }
### RESTAURANDO O REGISTRO DELETADO (SOFTDELETES)          
>>> $res = Fornecedor::withTrashed()->get()                                                                            
=> Illuminate\Database\Eloquent\Collection {#4077
     all: [
       App\Models\Fornecedor {#4100
         id: 1,
         nome: "Santiago Wintheiser",
         site: "(888) 524-2135",
         created_at: "2022-10-31 22:40:51",
         email: "f123@gmail.com",
         deleted_at: null,
       },
     ],
   }
>>> $res[0]->restore()
=> true
>>> SIMPLISMENTE DELETA O REGISTRO DA COLUNA deleted_at
### ENTENDENDO O OBJETO REQUEST
# ROTA -> web.php
Route::get('/contato', [\App\Http\Controllers\ContatoController::class, 'contato'])->name('site.contato');

# ContatoController.php
<?php

namespace App\Http\Controllers;

use Illuminate\Http\Request;

class ContatoController extends Controller
{
    public function contato(Request $request) {

      //  var_dump($_POST);
      // dd($_POST);
      echo '<pre>';
       print_r($request->all());
       echo '<hr>';
       print_r($_POST);
      echo '</pre>';
      echo $request->input('nome') . '<br>';
      echo $request->input('email') . '<hr>';
        return view('site.contato', ['titulo' => 'Contato - titulo vindo do controlador'], ['teste' => 'Alberto Gomes']);
    }
}

# view localhost:8000/contato (depois de preenchido e enviado) - Exibição na view contato;
Array
(
    [_token] => iseKKj7lQwd4Jm0tpCp4q1qAdjHj20ANtLLZtVo9
    [nome] => Alberto Gomes
    [telefone] => 9999999999
    [email] => albe@gmail.com
    [mensagem] => aestou com uma dúvida
)
Array
(
    [_token] => iseKKj7lQwd4Jm0tpCp4q1qAdjHj20ANtLLZtVo9
    [nome] => Alberto Gomes
    [telefone] => 9999999999
    [email] => albe@gmail.com
    [mensagem] => aestou com uma dúvida
)
Alberto Gomes
albe@gmail.com

### GRAVANDO OS DADOS DO FORMULÁRIO NO BANCO DE DADOS:
<?php

namespace App\Http\Controllers;

use Illuminate\Http\Request;

use App\Models\SiteContato;

class ContatoController extends Controller
{
    public function contato(Request $request) {

      // //  var_dump($_POST);
      // // dd($_POST);
      // echo '<pre>';
      //  print_r($request->all());
      //  echo '<hr>';
      //  print_r($_POST);
      // echo '</pre>';
      // echo $request->input('nome') . '<br>';
      // echo $request->input('email') . '<hr>';
       
      $contato = new SiteContato;
      // $contato->nome = $request->input('nome');
      // $contato->telefone = $request->input('telefone');
      // $contato->email = $request->input('email');
      // $contato->motivo_contato = $request->input('motivo_contato');
      // $contato->mensagem = $request->input('mensagem');

      $contato->fill($request->all());      // PRECISO DA LINHA '$contato->save();' PARA USAR ESTE MÉTODO, 
                                             //   USANDO ESSE   MÉTODO E O 'fill' NA MODEL SiteContato.php ADICIONAR 
                                              // O ATTRUBUTO $fillable
      $contato->create($request->all());    AQUI NÃO PRECISO DA LINHA: $contato->save();  //TAMBÉM PARA USAR ESTE MÉTODO 'create' NA MODEL SiteContato.php ADICIONAR O ATTRUBUTO $fillable
      
      $contato->save();  // ==> SALVA NO BANCO DE DADOS

     print_r($contato->getAttributes());
    //  print_r($_POST);

        return view('site.contato', ['titulo' => 'Contato (teste)']);   // PASSANDO O TÍTULO POR VARIÁVEL COMO PARÂMETRO 
    }
}

# MODEL SiteContato.php

<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;

class SiteContato extends Model
{
    use HasFactory;
    // protected $table = 'site_contatos';

     protected $fillable = ['nome', 'telefone','email', 'motivo_contato', 'mensagem']; // necessário para os métodos fill e create
}

### VAIDAÇÃO DE CAMPOS OBRIGATÓRIOS - required
laravel.com/docs/7.x/validation

#Available Validation Rules

-> Validação de dados do lado do backend da aplicação
ContatoController.php
<?php

namespace App\Http\Controllers;

use Illuminate\Http\Request;

use App\Models\SiteContato;

class ContatoController extends Controller

    public function salvar(Request $request) {

      // REALIZAR A VALIDAÇÃO DOS DADOS RECEBIDOS - A VARIÁVEL $erros DO lARAVEL ESTÁ DISPONIVEL PARA ISSO EM QUALQUER VIEW
        $request->validate([
          'nome' => 'required',
          'telefone' => 'required',
          'email' => 'required',
          'motivo_contato' => 'required',
          'mensagem' => 'required',
        ]);

### VALIDAÇÃO DE QUANTIDADES MÍNIMAS E MÁXIMSA DE CARACTERES (min e max)

laravel.com/docs/7.x/validation

#Available Validation Rules

   'nome' => 'required|min:3|max:40',  //Nomes de 3 a 40 caracteres permitido nesse campo

### REPOPULAR O FORMULÁRIO COM O CONTEÚDO ANTES DO ERRO
Recuperando os dados do formulário com o conteúdo que foi digitado ao ocorrer o erro.

* old()

for_contato.php
{{ $slot }}

{{ $x }}

<form action={{ route('site.contato') }} method="post" > 
            @csrf
            <input name="nome" value="{{ old('nome') }}"  type="text" placeholder="Nome" class="{{ $classe }}">
            <br>
            <input type="text" name="telefone" value="{{ old('telefone') }}" placeholder="Telefone" class="{{ $classe }}">
            <br>
            <input type="text" name="email" value="{{ old('email') }}" placeholder="E-mail" class="{{ $classe }}">
            <br>
            <select name="motivo_contato" class="{{ $classe }}">
                <option value="">Qual o motivo do contato?</option>
                <option value="1">Dúvida</option>
                <option value="2">Elogio</option>
                <option value="3">Reclamação</option>
            </select>
            <br>
            <textarea name="mensagem" value="{{ old('mensagem') }}" class="{{ $classe }}" placeholder="Preencha aqui a sua mensagem"> {{ (old('mensagem') != '') ?  old('mensagem')  :'' }} </textarea>
    <br>
    <button type="submit" class="btn btn-suces">ENVIAR</button>
</form>
<div style="position:absolute; top:0px; left:0px; width:100%; height: 150px; background: orange; color: red;">
{{ print_r($errors); }}
</div>














 
###********************-> FIM LARAVEL UDEMY  END <-******************###

<!--  DOCKER INÍCIO:
1 instalar o docker
2 abrir wsl2/Windows ou linux
 curl -s "https://laravel.build/olw?with=mysql,redis,mailhog,minio" | bash
3 cd olw
./vendor/bin/sail up -d
    ou
4 cd olw && ./vendor/bin/sail up -d
5 ATRIBUINDO PERMISSÃO PARA A PASTA
cd .. -> sai da pasta
sudo chmod 777 olw/ -R ou sem o 'sudo' chmod 777 olw/ -R
6 CRIANDO ALIAS PARA O COMANDO ANTERIOR
alias sail='[ -f sail ] && sh sail || sh vendor/bin/sail'
passa a usar assim: sail ps
7 CONFIGURAR PORTAS PARA A APLICAÇÃO NO NAVEGADOR E MYSQL
.env
APP_PORT=8000
*porta do myql
FORWARD_DB_PORT=3307
8 INSTALANDO DEPENDÊNCIA AO PROJETO
./vendor/bin/sail composer require laravel/breeze --dev 
e depois tem que 
9 DEIXAR TELA DE AUTENTICAÇÃO PRONTA, ROTA AUTENTICADA, TAWINDCSS INSTALADO E INERTIA INSTALADO
./vendor/bin/sail artisan breeze:install vue 
ou
./vendor/bin/sail art breeze:install vue
10 RODAR AS MIGRATES PADRÕES DO PROJETO AI JÁ PODE CADASTRAR USUÁRIOS PARA LOGIN:
./vendor/bin/sail art migrate
-->

 /***************************************** */
 Route::prefix('usuarios')->group(function() {
    Route::get('', function(){
        return 'usuarios';
    })->name('usuarios');
    
    Route::get('/{id}', function($id){
        return 'mostrar detalhes do usuário';
    })->name('usuario-detalhes');

    Route::get('/{id}/tags', function($id){
        return 'mostrar tags do usuário';
    })->name('usuario_tags');

});


/*******************************************/
2a AULA:

O PROJETO CONSISTE EM RECEBER DADOS DE UMA API (punkapi.com) DE INFORMAÇÕES SOBRE CERVEJAS, VAMOS CONSTRUIR AS ROTAS PARA CONSUMIR A API E CRIAR A ESTRUTURA PARA O RELATÓRIO QUE IREMOS GERAR EM EXCEL E ENVIAR PARA O STORAGE...
1 CRIAR ROTAS:
code .
olw/routes/web.php


sail up -d -> SOBE O CONTAINER localhost:8000 (nesse projeto)

Route::get('/beers', fn()=> 'Olw - testando a rota /beers');

**************************************************
obs:
- laravel.com/api -> acesso a documentação do código;
- in line paramets for vscode -> extensão para vscode para exibir o nome dos métodos na hora que codificar;
- fira code -> extensão para fonte no vscode

git Hub Copilot vs Tabnine -> (pesquisar sobre)
Link para extensões vscode:
https://github.com/icarojobs/vscode-useful-extensions
*************************************************


Route::get('/beers', fn()=> 'Olw - testando a rota /beers')
                             ->middleware(['auth']);

* FLUXO PADRÃO DO MVC-LARAVEL: 
life cicle: sai do usuário pelo navegador, insomnia ou postman -> passa pelo index.php(pasta public) -> passa pelos arquivos do bootstrap retornando uma instância da aplicação -> passa pelo kernel do http (carrega mais instâncias) -> Service provider -> despacha a requisição pro Router -> Cai no arquivo Web.php -> Middleware (se tiver, geralmente tem os globais) -> Controller (faz as regras de negócio e pode chamar outras classes como Serviços por exemplo)
-> Retorna uma view ou um json (No caso estamos usando inértia, ele não vai reinderizar a 'view.blade' padrão, ele vai reinderizar componente vue.js através do inértia.).


* EM VEZ DE USAR A FUNÇÃO AQUI NA ROTA CRIAMOS UM CONTROLLER:

* ROTAS:
Route::prefix('usuarios')->group(function() {
    Route::get('', function(){
        return 'usuário';
    })->name('usuarios');
    Route::get('/{id}', function($id){
        return $id;
    })->name('usuario_id');

});



Route::get('/users/{id?}', function ($id = null) {
    return $id;
});


obs.: ​dica: php artisan make:controller -r cria o Resource também.
dica: limpar o cache do container:
./vendor/bin/sail art config:cache 
./vendor/bin/sail art optimize:clear
ou
./vendor/bin/sail art config:cache && art optimize:clear

sail artisan make:controller BeerController
ou 
sail art make:controller BeerController -> CRIA O ARQUIVO BeerController.php na pasta app/Http/Controllers
->
<?php

namespace App\Http\Controllers;

use Illuminate\Http\Request;

class BeerController extends Controller
{
    public function index()
    {
    return 'Virgu & Beer & Code'
    }
}

* NO ARQUIVO DE ROTAS Web.php CHAMA O BeersController:

importante importar o Controller <nomeDoController>+<CTRL=ENTER:
use App\Http\Controllers\BeerController;

Route::get('/beers', [BeerController::class, 'index'])
                        ->middleware(['auth']);


* PRECISAMOS CRIAR UM MÉTODO PARA PEGAR A LISTA, LISTAR OS DADOS DA API (listar as bebidas de https://api.punkapi.com/v2 ->
VAMOS CRIAR UMA NOVA CLASSE de serviços em app/Sevices/PunkapiService.php

* O LARAVEL POSSUI UM RECURSO CHAMADO HTTPClient que abstrai o uso de uma ferramenta chama guzeo, esse guzeo é o client http mais comum para php, com ele fazemos requisições pra diversos serviços web dentro do php para outras url, ele é robusto, então o laravel simplifica importando o recurso que faz tudo por 'detrás dos panos':

PunkapiService.php

<?php

namespace App\Services;

use Illuminate\Support\Facades\Http;

class PunkapiService
{
    public function getBeers()
    {
        return Http::get('https://api.punkapi.com/v2/beers');
    }
}

E NO BeerController.php fica:
<?php

namespace App\Http\Controllers;

use App\Services\PunkapiService;
use Illuminate\Http\Request;

class BeerController extends Controller
{
    public function index()
    {
    //return 'Virgu & Beer & Code';
    $service = new PunkapiService;

    return $service->getBeers();
    }
}

* TRATE É CARACTERÍSTICA QUE A CLASSE ADQUIRE (pode ter mesmos métodos e atributos substituindo o recurso de um classe extender várias classes que não tem no php, a trate é uma forma de fazer isso. O service  é uma outra camada na maioria das vezes abstrair seviços que vc vai consumir, por exemplo API.

Estando logado, os dados da api já serão exibidos em localhost:8000/beers, se usar um aplicativo cliente tipo insomnia pode apresentar os dados também, melhor comentar a linha de de autenticação da rota:
Route::get('/beers', [BeerController::class, 'index']);
linha de autenticação da rota // ->middleware(['auth']);

* ESSA API PERMITE FAZER FILTROS VIA PARÂMETROS NA PRÓPRIA ROTA. PRIMEIRO VAMOS REFATORAR O CÓDIO, A CLASSE PunkapiService.php:

USO DE CONFIG E MACRO


Vamos alterar a url, primeiro acessando a pasta config da raiz do projeto e criar o arquivo punkapi.php. O que acontece é que o config(pasta config da raiz) carrega todos os arquivos da pasta e permite que sejam acessados via funções simples(HELPERS), isso é muito legal porque podemos acessar esses arquivos de configurações de qualquer lugar do projeto: 

<?php

return [
    'url' => env('PUNK_BASE_URL', 'https://api.punkapi.com/v2')
];

Usando o helper env significa dizer que, se não houver a constante PUNK_BASE_URL setada no arquivo .env do projeto, seu valor será o segundo parâmetro: http://api.punkapi.com/v2 e no arquivo PunkapiService.php da pasta app/Services fica:

<?php

namespace App\Services;

use Illuminate\Support\Facades\Http;

class PunkapiService
{
    public function getBeers()
    {
        return Http::get('/beers');
    }
}

MACRO é uma forma de criar funções customizadas:
 em app\Providers vamos acessar o arquivo AppServiceProvider.php que é uma classe que tem dois métodos register e boot. No método boot vamos chamar o método Http do laravel e chamar o método macro, no primeiro parâmetro será um nome atribuído à função e e o segundo uma clausure (uma função).
Neste arquivo é passado o arquivo de configuração da url (em 'config/punkapi.php') além de tokens, headers,...
 

use Illuminate\Support\Facades\Http; -> deve ser importado
E a função boot fica:

  public function boot()
    {
        Http::macro('punkapi', function(){
            return Http::acceptJson()
            ->baseUrl(config('punkapi.url'));
        });
    }

Então criamos uma macro(uma função customizada) chamada punkapi que já retorna o client com accept/Json no Header e com o baseUrl configurado lá do arquivo /config/punkapi.php e se estiver setado no .env pegará de lá.

/app/Services/PunkapiService.php fica:

<?php

namespace App\Services;

use Illuminate\Support\Facades\Http;

class PunkapiService
{
    public function getBeers()
    {
        return Http::punkapi()->get('/beers');
    }
}

*obs.: a baseUrl poderia ser setada no construtor, que pode setar token também.(uma outra abordagem para versão sem macros);

->Testamos o retorno Json em localhost:8000/beers.

Refatorando o arquivo PunkapiService.php: O client Http não lança exceção e podemos forçar o retorno em modo Json:
<?php

namespace App\Services;

use Illuminate\Support\Facades\Http;

class PunkapiService
{
    public function getBeers()
    {
       // return Http::punkapi()->get('/beers');
       return Http::punkapi()
            ->get('/beers')
            ->throw()  // Exceção em caso de erro
            ->json();   // Força o retorno em formato Json
    }
}

Podemos testar forçando um erro alterando a constante PUNKAPI_BASE_URL criada em /config/punkapi.php, vamos atribuir um valor diferente no arquivo .env:

PUNKAPI_BASE_URL="adfjklj878"

Podemos usar a função retry tem dois parâmetros, o número de tentativas pra buscar a requisição e o intervalo entre elas. Refatorando o código fica:
<?php

namespace App\Services;

use Illuminate\Support\Facades\Http;

class PunkapiService
{
    public function getBeers()
    {
       // return Http::punkapi()->get('/beers');
       return Http::punkapi()
            ->get('/beers')
            ->throw()  // Exceção em caso de erro
            ->json();   // Força o retorno em formato Json
    }
}

- Quando sai a exceção nao deveriamos retornar o erro em json por ser um api neste caso estamos usamos um app web e não uma api. E usaríamos o Route Api.

Refatorando o método boot de /app/Providers/AppServiceProvider.php, inserindo o retry():

     */
    public function boot()
    {
        Http::macro('punkapi', function(){
            return Http::acceptJson()
            ->baseUrl(config('punkapi.url'))
            ->retry(3,100);
        });
    }
}

comando de help

* ./vendor/bin/sail composer dump-autoload
* Verificar Nome do arquivo se bate com o nome das rotas(Classes criadas e importar o nome errado);
* inteliphense

Refatorando BeerController.php
<?php

namespace App\Http\Controllers;

use App\Services\PunkapiService;

class BeerController extends Controller
{
    public function index()
    {

    $service = new PunkapiService();

    return $service->getBeers();
    }
}

Em vez de instanciar o método PunkapiService() dentro de index, vamos passar por parâmetro de index() declarando seu Próprio nome (PunkapiService) como tipo. Fica assim:

<?php

namespace App\Http\Controllers;

use App\Services\PunkapiService;

class BeerController extends Controller
{
    public function index(PunkapiService $service)
    {
    return $service->getBeers();
    }
}

Assim usamos feactures do php(injeção de dependências) e ao mesmo tempo feactures do laravel. Em vez de criar uma instância dentro do método index, vamos injetar a classe como parâmetro para o método index(), ficando index($service) e a instância de dentro da função passa como parâmetro de 'tipo da variável'. Isso quebra a cadeia de dependência entre as classes.
Assim, o método index ganha independência não mais dependendo da instância de new PunkapiService e passamos a olhar a função index em si.
Assim, o Laravel tenta fazer um binding, um match, o laravel tenta encontrar alguma classe PunkapiService e cria uma instância dessa classe e usa ali como parâmetro. Se não fizer assim, lá em Rotas teria que ser passado como parâmetro o que fica desnecessário.
Não poderia ser feito se na classe PunkapiService existisse o construtor para atribuir valores automaticamente à classe. Assim podemos usar porque não precisamos passar nenhum valor.

ADICIONAR OS FILTROS:
Vamos filtrar o retorno api com os seguintes itens: beer_name, food, ibu_gt, malte:

var_dump($v)
die();
dd($variável)
benchmarck -> ?

/*****REFATORA PARA TESTE alterando BeerController.php e PunkapiService.php
BeerController.php
<?php

namespace App\Http\Controllers;

use App\Services\PunkapiService;

class BeerController extends Controller
{
    public function index(PunkapiService $service)
    {
    return $service->getBeers(
        'heineken',
        'cheese',
        'corn',
        45
    );
    }
}

PunkapiService.php
<?php

namespace App\Services;

use Illuminate\Support\Facades\Http;

class PunkapiService
{
    public function getBeers(
        string $beer_name,
        string $food,
        string $malt,
        string $ibu_gt
    )
    {
        $params = get_defined_vars();

        dd($params);

        return Http::punkapi()
            ->get('/beers', $params)
            ->throw()  // Exceção em caso de erro
            ->json();   // Força o retorno em formato Json
    }
}

Resultado do debug no insomnia ou no navegador:
array:4 [▼ // app/Services/PunkapiService.php:18
  "beer_name" => "heineken"
  "food" => "cheese"
  "malt" => "corn"
  "ibu_gt" => "45"
]
//* fim teste

Refatorando:

class PunkapiService
{
    public function getBeers(
        string $beer_name = null,
        string $food = null,
        string $malt = null,
        string $ibu_gt = null
    )
    {
        $params = get_defined_vars();

        dd($params);

        return Http::punkapi()
            ->get('/beers', $params)
            ->throw()  // Exceção em caso de erro
            ->json();   // Força o retorno em formato Json
    }
}

Assim quando não passar o valor para a chave ele exibirá a chave e o valor Null, vamos refatorar para não exibir nem a chave englobando get_defined_vers() com array_filter no arquivo PunkapiService.php:

$params = array_filter(get_defined_vars());

<?php

namespace App\Http\Controllers;

use App\Services\PunkapiService;

class BeerController extends Controller
{
    public function index(PunkapiService $service)
    {
    return $service->getBeers(
        'heineken',
        'cheese',
        'corn',
       // 45 -> Esse não é passado
    );
    }
}


array:3 [▼ // app/Services/PunkapiService.php:18
  "beer_name" => "heineken"
  "food" => "cheese"
  "malt" => "corn"
    Aqui não exibiu o valor 45
]


USANDO A FUNÇÃO NAMED_ARGS passamos só os parâmetros que precisamos retornar da api e o php com essa função saberá qual a posição dela no array de argumentos passados como parâmetro sem a necessidade de seguir a mesma sequência dos argumentos:
class BeerController extends Controller
{
    public function index(PunkapiService $service)
    {
    return $service->getBeers(food: 'cheese');
    }
}

REFATORANDO:
BeerController.php
<?php

namespace App\Http\Controllers;

use App\Services\PunkapiService;
use Illuminate\Http\Request;

class BeerController extends Controller
{
    public function index( Request $request, PunkapiService $service)
    {
    return $service->getBeers(...$request->all());
    }
}

PunkapiService.php
<?php

namespace App\Services;

use Illuminate\Support\Facades\Http;

class PunkapiService
{
    public function getBeers(
        string $beer_name = null,
        string $food = null,
        string $malt = null,
        string $ibu_gt = null
    )
    {
        $params = array_filter(get_defined_vars());

     //   dd($params);

        return Http::punkapi()
            ->get('/beers', $params)
            ->throw()  // Exceção em caso de erro
            ->json();   // Força o retorno em formato Json
    }
}

CRIANDO UMA REQUEST
sail artisan make:request BeerRequest
/app/Http/Requests/BeerRequest.php

* Funções anônimas, também conhecidas como closures , permitem a criação de funções que não tem o nome especificado. Elas são mais úteis como o valor de parâmetros callable, mas podem ter vários outros usos.. É uma função passada como parâmetro

CRIANDO NOVA ROTA PARA SALVAR COMO EXCEL
* https://docs.laravel-excel.com/3.1/getting-started/installation.html

Route::group([
    'prefix' => 'beers',
], function() {

    Route::get('/', [BeerController::class, 'index']); //-> Se houver necessidade de salvar dados por essa rota mudamos o método(verbo html) para post(os dados não serão expostos na url).
                          //  ->middleware(['auth']);
    Route::get('/export', [BeerController::class, 'export']);

});

Então passamos a ter duas rotas: localhost:8000/beers
localhost:8000/beers/export

No BeerController incluimos o método export():
class BeerController extends Controller
{
    public function index( BeerRequest $request, PunkapiService $service)
    {
    // return $service->getBeers(...$request->all());
    return $service->getBeers(...$request->validated());
    }

    public function export()
    {
        return 'Relatório criado.';
    }
}



INSTALANDO PACOTE LARAVEL-EXCEL PARA GERAR OS RELATÓRIO EM EXCEL FILTRADOS DA API:

* https://docs.laravel-excel.com/3.1/getting-started/installation.html

COMANDO PARA INSTALAR VIA COMPOSER:
./vendor/bin/sail composer require psr/simple-cache:^2.0 maatwebsite/excel

CRIAR A CLASSE DO EXCEL
./vendor/bin/sail artisan make:export BeerExport  --> Cria o arquivo em  /app/Exports/BeerExport.php

<?php

namespace App\Exports;

use Maatwebsite\Excel\Concerns\FromCollection;

class BeerExport implements FromCollection
{


    /**
    * @return \I¢lluminate\Support\Collection
    */
    public function collection()
    {
        //
    }
}

-> Dentro de colletion buscaremos as informações que serão salvas no arquivo do excel, um array de dados;

criamos um __construct() que vai ter uma propriedade privada do tipo array chamamos de $reportData.

O retorn será uma collection como informa o comentário:
 /**
    * @return \I¢lluminate\Support\Collection
    */

Na função colletion(), está recebendo um array return $this->reportData; 
Observe que não precisa mais declarar uma propriedade que vai se setada via construct(), basta defifinir o escopo junto do argumento e o php faz isso pra você. Como o retorno da função é um array usamos o helper collect para o $this->reportData:

BeerExport.php

<?php

namespace App\Exports;

use Maatwebsite\Excel\Concerns\FromCollection;

class BeerExport implements FromCollection
{

    public function __construct(
        private array $reportData
    ){}

    /**
    * @return \Illuminate\Support\Collection
    */
    public function collection()
    {
       return collect($this->reportData);
    }
}
 

Consultamos a documentação do Laravel-excel em 'Exporting collections':
em Excel Store passa o nome da classe e o nome do arquivo:

BeerController.php
<?php

namespace App\Http\Controllers;


use App\Exports\BeerExport;
use App\Http\Requests\BeerRequest;
use App\Services\PunkapiService;
use Maatwebsite\Excel\Facades\Excel;


class BeerController extends Controller
{
    public function index( BeerRequest $request, PunkapiService $service)
    {
    // return $service->getBeers(...$request->all());
    return $service->getBeers(...$request->validated());
    }

    public function export()
    {
      $params = [
        ['name' => 'Tom', 'age' => '30'],
        ['name' => 'Virgu', 'age' => '27']
       ];

       Excel::store(new BeerExport($params), 'olw-report.xlsx');
       return "Relatório criado";

    }


}

********************************************
* REFATORANDO E SALVANDO O ARQUIVO EXCEL EM /storage/app

BeerExport.php
<?php

namespace App\Exports;

use Maatwebsite\Excel\Concerns\FromCollection;

class BeerExport implements FromCollection
{

    public function __construct(
        private array $reportData
    ){}

    /**
    * @return \Illuminate\Support\Collection
    */
    public function collection()
    {
       return collect($this->reportData);
    }
}
*****************************

BeerController.php

<?php

namespace App\Http\Controllers;


use App\Exports\BeerExport;
use App\Http\Requests\BeerRequest;
use App\Services\PunkapiService;
use Maatwebsite\Excel\Facades\Excel;


class BeerController extends Controller
{
    public function index( BeerRequest $request, PunkapiService $service)
    {
        return $service->getBeers(...$request->all());

    }

    public function export(BeerRequest $request, PunkapiService $service)
    {
        $beers = $service->getBeers(...$request->validated());

        $filteredBeers = collect($beers)->map(function($value, $key){
        return collect($value)
                ->only(['name', 'tagline', 'first_brewed', 'description'])
                ->toArray();
    })->toArray();

    //dd($filteredBeers);

      $params = [
        ['name' => 'Tom', 'age' => '30'],
        ['name' => 'Virgu', 'age' => '27']
       ];

       Excel::store(new BeerExport($filteredBeers), 'olw-report.xlsx');

           return "Relatório criado";

    }


}

PARA SALVAR O ARQUIVO EXCEL EM UM STORAGE S3:
ALTERA BeerController.php

<?php

namespace App\Http\Controllers;


use App\Exports\BeerExport;
use App\Http\Requests\BeerRequest;
use App\Services\PunkapiService;
use Maatwebsite\Excel\Facades\Excel;


class BeerController extends Controller
{
    public function index( BeerRequest $request, PunkapiService $service)
    {
        return $service->getBeers(...$request->all());

    }

    public function export(BeerRequest $request, PunkapiService $service)
    {
        $beers = $service->getBeers(...$request->validated());

        $filteredBeers = collect($beers)->map(function($value, $key){
        return collect($value)
                ->only(['name', 'tagline', 'first_brewed', 'description'])
                ->toArray();
    })->toArray();


       Excel::store(
            new BeerExport($filteredBeers),
             'olw-report.xlsx',
             's3');

           return "Relatório criado";

    }


}

************
O REPOSITÓRIO DE ARQUIVOS minio:
NO DOCKER COMPOSER TEMOS O minio, um S3 que tem
MINIO_ROOT_USER: 'sail'
MINIO_ROOT_PASSWORD: 'password' e roda na porta 9000
localhost:9000
usuário: sail
senha: password

vamos criar um buncket(uma pasta)

e configurar o .env da raiz da aplicação:
originalmente é assim:
AWS_ACCESS_KEY_ID=
AWS_SECRET_ACCESS_KEY=
AWS_DEFAULT_REGION=us-east-1
AWS_BUCKET=
AWS_USE_PATH_STYLE_ENDPOINT=false

 e acrescentamos as informações para:


AWS_ACCESS_KEY_ID=sail
AWS_SECRET_ACCESS_KEY=password
AWS_DEFAULT_REGION=us-east-1
AWS_BUCKET=local
AWS_ENDPOINT=http://minio:9000
AWS_URL=http://minio:9000/local
AWS_USE_PATH_STYLE_ENDPOINT=true

altera tambem:

FILESYSTEM_DISK=local 
para:
FILESYSTEM_DISK=s3

INSTALAR UMA DEPENDÊNCIA (ADAPTER) PARA FAZER CORRESPONDÊNCIA COM A AWS:

Flysystem 3.x em laravel.com/docs/9.x/upgrade
./vendor/bin/sail composer require -W league/flysystem-aws-s3-v3 "^3.0"

em caso de erro:
 artisan vendor:publish --tag=laravel-assets --ansi --force

.env
APP_NAME=Laravel
APP_ENV=local
APP_KEY=base64:UbVvTP6Cu+LF5GamJdB4dsZZvW05ep4bZqcCEhmiDCg=
APP_DEBUG=true
APP_URL=http://localhost
APP_PORT=8000

# PUNKAPI_BASE_URL="httpadfjkljdsdfdfasf878"

LOG_CHANNEL=stack
LOG_DEPRECATIONS_CHANNEL=null
LOG_LEVEL=debug

DB_CONNECTION=mysql
FORWARD_DB_PORT=3307
DB_HOST=mysql
DB_PORT=3306
DB_DATABASE=olw
DB_USERNAME=sail
DB_PASSWORD=password

BROADCAST_DRIVER=log
CACHE_DRIVER=file
FILESYSTEM_DISK=s3
QUEUE_CONNECTION=sync
SESSION_DRIVER=file
SESSION_LIFETIME=120

MEMCACHED_HOST=memcached

REDIS_HOST=redis
REDIS_PASSWORD=null
REDIS_PORT=6379

MAIL_MAILER=smtp
MAIL_HOST=mailhog
MAIL_PORT=1025
MAIL_USERNAME=null
MAIL_PASSWORD=null
MAIL_ENCRYPTION=null
MAIL_FROM_ADDRESS="hello@example.com"
MAIL_FROM_NAME="${APP_NAME}"

AWS_ACCESS_KEY_ID=sail
AWS_SECRET_ACCESS_KEY=password
AWS_DEFAULT_REGION=us-east-1
AWS_BUCKET=local
AWS_ENDPOINT=http://minio:9000
AWS_URL=http://minio:9000/local
AWS_USE_PATH_STYLE_ENDPOINT=true

PUSHER_APP_ID=
PUSHER_APP_KEY=
PUSHER_APP_SECRET=
PUSHER_HOST=
PUSHER_PORT=443
PUSHER_SCHEME=https
PUSHER_APP_CLUSTER=mt1

VITE_PUSHER_APP_KEY="${PUSHER_APP_KEY}"
VITE_PUSHER_HOST="${PUSHER_HOST}"
VITE_PUSHER_PORT="${PUSHER_PORT}"
VITE_PUSHER_SCHEME="${PUSHER_SCHEME}"
VITE_PUSHER_APP_CLUSTER="${PUSHER_APP_CLUSTER}"

PRONTO. ENVIANDO PARA O MINIO.

/**** Criando as Migrations com Virgu e tabela de históricos

























 







/***********************************************************
QUINTA FEIRA: 20/10/22

Open Laravel Week | Deploy com Terraform, EC2 e RDS | Fermentação

****
https://portal.aws.amazon.com/billing/signup?nc2=h_ct&src=header_signup&redirect_url=https%3A%2F%2Faws.amazon.com%2Fregistration-confirmation&language=pt_br#/start/email

Com terraform pode mudar de infra e configurar no git.

PROGRMAR A CONFIGURAÇÃO DO SERVIDOR: É basicamente construir uma nova aplicação para fazer isso, mais fácil de entender.
Terraform serve para (linguagem HCL -> linguagem própria - linguagem descritiva, descreve o resultado e não como irá ser feito), ou seja, descrever o que queremos.
Terraspace é o framework pra terraform.
Quando criamos o Terraform, ele pode variar conforme a infra cloud (aws, azure, google cloud). sua estrutura é a mesma para todos. mas cada provider tem a sua forma de usar, não consegue usar o mesmo código para mais de uma cloud.
Vamos rodar Terraform via container:

1. clonar do git: git clone 
Criar uma pasta para a infraestrutura

sail   (script que vamos usar)
#!/usr/bin/env bash

docker run -rm -it
    -u $(id -u):$(id -g) \
    -v $PWD:/workspace \
    -w /workspace
    hashicorp/terraform:light "%@"


    <no terminal

Logar em: aws.amazon.com
busca: iam
iam dashboard -> mysecurity credencials (root user) -> Acces keys ->clicar em create access keys -> salva o access key e secret access key
e coloca no arquivo credencials na maquina local.. .aws/credencials
















































//////////////////////////////////////////////////////////////////////////////////////////////////////
CONTEÚDO QUE FALTA ORGANIZAR:



/**************************************/

sail share

sail artisan sail:publish ->coloca em uma pasta na raiz chamada docker

sail --help

sail artisan optimizer:clear

sail ps

sail build --no-cache -> faz o bild da aplicação. (dá um sail down  por precaução antes.)










/*********************************

root@DELLAGS:~# curl -s "https://laravel.build/laravel-9-course?with=mysql,redis,mailhog" | bash

Dockerfile

root@DELLAGS:~/example-app# docker exec -it example-app-mysql-1 bash


FROM wyveo/nginx-php-fpm:latest
WORKDIR /usr/share/nginx
RUN rm -rf /usr/share/nginx/html
COPY . /usr/share/nginx
RUN chmod -R 755 /usr/share/nginx/storage/*
RUN ln -s public html

.env (do composer)

DB_CONNECTION=mysql
DB_HOST=mysql-app (serviço do mysql no docker-compose.yaml)
DB_PORT=3306
DB_DATABASE=laraveldockerdb
DB_USERNAME=root
DB_PASSWORD=123456



docker-compose.yaml

version: '3'

services:
  laraveldocker-app:
    build: .
    ports:
      - "3003:80"
    volumes:
      - ./:/usr/share/nginx
      - .docker/nginx:/etc/nginx/conf.d/
    networks:
      - app-network
  mysql-app:
    image: mysql:5.7.22
    ports:
      - "3306:3306"
    volumes:
      - .docker/dbdata:/var/lib/mysql
    environment:
      MYSQL_DATABASE: laraveldocker
      MYSQL_ROOT_PASSWORD: 123456
    networks:
      - app-network
networks:
  app-network:
    driver: bridge
    
https://calculator.aws/#/addService
################



/*************************************************
#criando um serviço com um nome qualquer
version: '3'

services:
  laravel-app:                    #criando um serviço com um nome qualquer
    build: . ou image: wyveo/nginx-php-fpm:latest -> neste caso sem Dockerfile.                    # endereço da imagem ou local do Dockerfile (neste caso o ponto siginifica a raiz do projeto)
    ports:
      - "8080:80"                 # 8080 porta do meu host: 80 é a porta do docker nginx
    volumes:                      # docker-compose up -d -> sobe a imagem e libera o terminal  
      - ./:/usr/share/nginx       # TUDO QUE ESTIVE NA RAIZ (na rais tem o meu projeto laravel) './' IRÁ SER REFLETIDO NA PASTA /usr/share/nginx (pasta de acesso da página html)
                                  # C:\Laravel-docker\laravel-docker>docker compose up -d --build atualiza a minha imagem

  mysql-app:
      image: mysql:5.7
      ports:
        - "3306:3306"
      volumes:
        - .docker/dbdata:/var/lib/mysql          # qualqer nome (para persistir -guardar os dados do banco de dados)


      environment:
        MYSQL_DATABASE: laravel
        MYSQL_ROOT_PASSWORD: laravel
    
      

      /***************************///


  
C:\Laravel-docker\laravel-docker>docker compose up -d --build

                                
                               

    

/******************************** Dockerfile
FROM wyveo/nginx-php-fpm:latest

/***************************///
  COMANDOS

docker compose down -> para todos os containers
C:\Laravel-docker\laravel-docker>docker exec -it laravel-docker-laravel-app-1 bash 
root@612ea0ea3340:/# cd /usr/share/nginx/
root@612ea0ea3340:/usr/share/nginx# php artisan migrate
root@612ea0ea3340:/usr/share/nginx# php artisan serve

        
/***********/
PS C:\Users\alber> docker run -e MYSQL_ROOT_PASSWORD=root --name meu-mysql -d mysql:5.7

docker inspect meu-mysql ou | grep IPAddress

PS C:\Users\alber> docker run -e MYSQL_ROOT_PASSWORD=root --name meu-mysql -d -p 3306:3306 mysql:5.7

docker ps
docker ps -l
docker ps -a
docker rm -f nome


/*** LARAVEL */
### CRIANDO UM PROJETO NO LARAVEL 
laravel new projeto_laravel_via_installer (ESTA É UM AOPÇÃO)
composer create-project --prefer-dist laravel/laravel app_controle_tarefas "8.5.9"
cd app_controle_tarefas
cd public
php -S localhost:8000

ou 
da raiz do projeto:
php artisan serve 
ou
php artisan serve --port=3000

### PARA ABRIR PORTA EM OUTRO SERVIDOR
php artisan serve --host test.com --port 8080

 **********************************************************************
cd app_controle_tarefas
cd public
php artisan serve
- acessa o navegador http://localhost:8000

### DENTRO DO PROJETO CRIADO INSTALAR O LARAVEL/UI:^3.2 - versão 3.2
composer require laravel/ui:^3.2

### SE OCORRER ERRO AUMENTAR A MEMÓRIA DISPONIVEL PARA O php

-php --ini -> localiza o arquivo de configuração do php
LOCALIZA memory_limit = 1000 e altera para 
         memory_limit  = -1 e Salva

### LISTA A RELAÇÃO DE COMANDOS 
php artisan list 

DEVERA SURGIR AS OPÇÕES ABAIXO:

 ui
  ui:auth               Scaffold basic login and registration views and routes
  ui:controllers        Scaffold the authentication controllers
 vendor

### ENTENDENDO O PACOTE UI E INICIANDO A AUTENTICAÇÃO WEB NATIVA DO LARAVEL

COMANDO PARA LISTAR ROUTES: 
php artisan route:list

### php artisan ui bootstrap --auth (bootstrap ou react ou vue)
aplicando o bootstrap incluindo os recursos de autenticação;
poderia ser aplicado o bootstrap sem os recursos de autenticação;

### php artisan route:list -> mostra as rotas - ver que aumentaram as rotas

### APÓS ESSE PROCESSO O SISTEMA PEDE PARA RODAR
npm install -> instala as dependências do package.json (inclusive o bootstrap)
npm run dev -> gera os assets da aplicação de acordo com a tecnologia selecionada (bootstrap, react ou vue) -> Geralmente roda mais de uma vez para compilar tudo.

### CRIA O BANCO DE DADOS NORMALMENTE

### EXECUTA AS MIGRATIONS PADRÕES CRIADAS PARA O SISTEMA DE login
php artisan migrate -> CRIA AS TABELAS NO BANCO DE DADOS


************************************** 
INSTALANDO O COMPOSER NO UBUNTU
**************************************
sudo apt update
sudo apt install php-cli unzip

cd ~

curl -sS https://getcomposer.org/installer -o composer-setup.php

HASH=`curl -sS https://composer.github.io/installer.sig`

echo $HASH ->saída: Output
e0012edf3e80b6978849f5eff0d4b4e4c79ff1609dd1e613307e16318854d24ae64f26d17af3ef0bf7cfb710ca74



php -r "if (hash_file('SHA384', 'composer-setup.php') === '$HASH') { echo 'Installer verified'; } else { echo 'Installer corrupt'; unlink('composer-setup.php'); } echo PHP_EOL;"

sudo php composer-setup.php --install-dir=/usr/local/bin --filename=composer





***********************

DigitalOcean Kubernetes: novo plano de controle é mais rápido e gratuito, habilita HA para SLA de 99,95% de tempo de atividade
Produtos
Preços

Documentos
divisa suspensa

Entrar
divisa suspensa

// Tutorial //
Como Instalar e Utilizar o Composer no Ubuntu 20.04
Publicado em 21 de maio de 2020
Ubuntu
PHP
Ubuntu 20.04
Avatar padrão
Por Erika Heidi
Advogado Desenvolvedor
Português
Como Instalar e Utilizar o Composer no Ubuntu 20.04
Introdução
O Composer é uma ferramenta popular de gerenciamento de dependências para o PHP, criado para facilitar a instalação e a atualização das dependências principalmente do projeto. Ele controla quais outros pacotes de projeto específico dependem e são instalados para você, usando as opções apropriadas de acordo com os requisitos do projeto. O Composer também é comumente utilizado para inicializar novos projetos em frameworks PHP populares, como o Symfon e o Laravel .

Neste tutorial, você instalará e começará a usar o Composer em um sistema Ubuntu 20.04.

Pré-requisitos
Para seguir este guia, você pode acessar um servidor como usuário Ubuntu20.04 como usuário sudonão-root um firewall habilitado em seu servidor Para configurar isto, siga nosso guia Configuração do servidor inicial para o Ubuntu 20.04

Passo 1 — Instalando o PHP e as Dependências Adicionais
Além das dependências que já devem estar incluídas em seu sistema Ubuntu 20.04, como o , o Composer exige ou gitexecuta scripts PHP na linha de comando e para extrair arquivos zipados. Vamos instalar essas dependências agora.curlphp-cliunzip

primeiro, atual, gerenciador de pacotes de soluções: o cache do gerenciador de pacotes

sudo apt update
Em seguida, o seguinte comando para instalar os pacotes, execute:

sudo apt install php-cli unzip
Você será solicitado a confirmar a instalação digitando Ye, depois, ENTER.

Assim que os pré-requisitos para instalação do Composer forem instalados, você poderá seguir.

Passo 2 — Baixando e Instalando o Compositor
O Composer fornece um instalador de script escrito em PHP. Vamos baixá-lo, verificar se ele não está danificado e, em seguida, o usaremos para instalar o Composer.

Certifique-se de estar em sua pasta home. Em seguida, baixe o instalador usando o curl:

cd ~
curl -sS https://getcomposer.org/installer -o composer-setup.php
Em seguida, vamos verificar se o instalador baixado corresponde ao hash SHA-384 para o instalador mais recente encontrado na página Composer Public Keys / Signatures . Para facilitar o passo de seleção, você pode usar o seguinte comando para obter programaticamente o hash mais recente da página do Composer e armazená-lo em uma variável do shell:

HASH=`curl -sS https://composer.github.io/installer.sig`
Se você quiser verificar o valor realizado, execute:

echo $HASH
Output
e0012edf3e80b6978849f5eff0d4b4e4c79ff1609dd1e613307e16318854d24ae64f26d17af3ef0bf7cfb710ca74755a
Agora o código PHP a seguir, execute conforme a página de download do Composer, para verificar se o script de instalação está seguro para ser executado:

php -r "if (hash_file('SHA384', 'composer-setup.php') === '$HASH') { echo 'Installer verified'; } else { echo 'Installer corrupt'; unlink('composer-setup.php'); } echo PHP_EOL;"
Você verá o seguinte resultado:

Resultado
Installer verified
Se Installer corruptvocê estiver usando o hash correto, verifique se você está usando o hash correto. Em seguida, repita o processo de verificação. Quando você tiver um instalador selecionado, você pode continuar.

Para instalar o composerglobalmente, use o seguinte comando que baixará e instalará o Composer como um comando disponível em todo o sistema chamado composer, sob /usr/local/bin:

sudo php composer-setup.php --install-dir=/usr/local/bin --filename=composer
Você verá um resultado semelhante com este:

Output
All settings correct for using Composer
Downloading...

Composer (version 1.10.5) successfully installed to: /usr/local/bin/composer
Use it: php /usr/local/bin/composer
Para testar sua instalação, execute:

composer
Output
   ______
  / ____/___  ____ ___  ____  ____  ________  _____
 / /   / __ \/ __ `__ \/ __ \/ __ \/ ___/ _ \/ ___/
/ /___/ /_/ / / / / / / /_/ / /_/ (__  )  __/ /
\____/\____/_/ /_/ /_/ .___/\____/____/\___/_/
                    /_/
Composer version 1.10.5 2020-04-10 11:44:22
Usage:
  command [options] [arguments]
Options:
  -h, --help                     Display this help message
  -q, --quiet                    Do not output any message
  -V, --version                  Display this application version
      --ansi                     Force ANSI output
      --no-ansi                  Disable ANSI output
  -n, --no-interaction           Do not ask any interactive question
      --profile                  Display timing and memory usage information
      --no-plugins               Whether to disable plugins.
  -d, --working-dir=WORKING-DIR  If specified, use the given directory as working directory.
      --no-cache                 Prevent use of the cache
  -v|vv|vvv, --verbose           Increase the verbosity of messages: 1 for normal output, 2 for more verbose output and 3 for debug
...
Isso verifica que o Composer foi instalado com sucesso em seu sistema e está disponível em todo o sistema.
Nota: se você preferirá ter-lhe-ão separados separados do Composer para projeto hospedado neste servidor, você pode instalar localmente, em uma base por projeto. Este método também é útil quando o usuário do sistema não possui permissão para instalar o software disponível em todo o sistema.
Para fazer isso, use o comando php composer-setup.php. Isso irá gerar um arquivo composer.pharem seu diretório atual, que pode ser executado com o seu atual php composer.phar.
Agora podemos dar uma dependência em como usar o Compose como gerenciar.
Passo 3 — Usando o Compositor em um Projeto PHP
Os projetos PHP geralmente dependentes de bibliotecas externas, e o gerenciamento de dependências e suas versões podem ser complicados. O Composer resolve esse problema de manter um controle de projeto de extensões e dependências, também facilita o processo de descoberta, instalação e atualização de pacotes que são definidos por enquanto.
Para usar o seu projeto, você pode compor um arquivo composer.json. O arquivo composer.jsonComposer quais dependências precisa para baixar seu projeto quais serão as versões de cada pacote tem permissão para instalações e instalações. Isso é muito importante para manter seu projeto consistente e evitar a instalação de versões instáveis ​​que podem causar problemas de compatibilidade retroativa.
Você não precisa criar este arquivo manualmente - é comum ocorrer erros de sintaxe quando fizer isso. O Composer oferece uma maneira de criar um novo arquivo composer.jsoncom base na entrada do usuário, o que é uma boa escolha se você planeja compartilhar seu projeto mais tarde como um pacote público no Packagist . O Composer gera automaticamente um arquivo básico composer.jsonquando você executa um comando composer requirepara incluir uma dependência em um projeto recém-criado.
O processo de uso do Composer para instalar um pacote como uma dependência em um projeto envolve os passos a seguir:
Identifique o tipo de biblioteca que o aplicativo precisa.
uma biblioteca de código aberto adequada no agist.org , o responsável oficial de pacotes para o Compose.
Escolha o pacote de dependência.
Execute composer requirepara incluir a dependência no arquivo composer.jsone instalar o pacote.
Vamos testar isso com uma aplicação de demonstração.
O objetivo desta aplicação é transformar uma determinação determinada em uma string de URL amigável - um slug . Isso é comumente usado para converter os títulos de página para caminhos de URL (Assim como a parte final da URL para este tutorial).
Vamos começar a criar um diretório para o nosso projeto. Vamos chamá-lo de slugify :
cd ~
mkdir slugify
cd slugify
Embora não seja necessário, você pode executar agora um comando composer init para criar um arquivo composer.json detalhado para seu projeto. Como o único objetivo do nosso projeto é demonstrar como instalar dependências com o Composer, usaremos um arquivo composer.json mais simples que será gerado automaticamente quando exigirmos nosso primeiro pacote.
Agora é hora de procurar no Packagist.org por um pacote que pode nos ajudar a gerar slugs. Se você procurar pelo termo “slug” no Packagist, receberá um resultado parecido com este:
Resultados da Pesquisa do Packagist para o termo "slug"
Você verá dois números no lado direito de cada pacote na lista. O número no topo representa quantas vezes o pacote foi instalado através do Composer, e o número em baixo mostra quantas vezes um pacote foi estrelado no GitHub. De um modo geral, os pacotes com mais instalações e mais estrelas tendem a ser mais estáveis, pois mais pessoas os utilizam. Também é importante verificar a descrição do pacote para relevância para garantir que ele é o que você precisa.
Precisamos de um conversor string-to-slug A partir dos resultados da pesquisa, o pacote cocur/slugify, que aparece como o primeiro resultado naquela página, parece ser um bom candidato, com uma quantidade razoável de instalações e estrelas.
Os pacotes no Packagist têm um nome de vendor e um nome de package. Cada pacote tem um identificador único (um namespace) no mesmo formato que o GitHub utiliza para seus repositórios: vendor/package. A biblioteca que queremos instalar utiliza o namespace cocur/slugify. Você precisa de um namespace do pacote para exigi-lo em seu projeto.
Agora que você sabe exatamente qual pacote deseja instalar, você pode executar o composer require para incluí-lo como uma dependência e gerar também o arquivo composer.json para seu projeto. Uma coisa importante é observar a exigência de pacotes. O Composer rastreia as dependências no nível da aplicação e do sistema. As dependências no nível do sistema são importantes para indicar de quais módulos PHP um pacote depende. No caso do pacote cocur/slugify, ele exige um módulo PHP que ainda não instalamos.
Quando um pacote necessário depende de uma biblioteca de sistema que não está atualmente instalada em seu servidor, você receberá um erro informando qual requisito está faltando:
composer require cocur/slugify
Output
Using version ^4.0 for cocur/slugify
./composer.json has been updated
Loading composer repositories with package information
Updating dependencies (including require-dev)
Your requirements could not be resolved to an installable set of packages.
  Problem 1
    - Installation request for cocur/slugify ^4.0 -> satisfiable by cocur/slugify[v4.0.0].
    - cocur/slugify v4.0.0 requires ext-mbstring * -> the requested PHP extension mbstring is missing from your system.
...
Para resolver o problema de dependência do sistema, podemos procurar pelo pacote que falta usando o apt search:
apt search mbstring
Output
Sorting... Done
Full Text Search... Done
php-mbstring/focal 2:7.4+75 all
  MBSTRING module for PHP [default]
php-patchwork-utf8/focal 1.3.1-1 all
  UTF-8 strings handling for PHP
php7.4-mbstring/focal 7.4.3-4ubuntu1 amd64
  MBSTRING module for PHP
Após localizar o nome do pacote correto, você pode utilizar o apt novamente para instalar a dependência de sistema:
sudo apt install php-mbstring
Assim que a instalação terminar, você pode executar novamente o comando composer require:
composer require cocur/slugify
Output
Using version ^4.0 for cocur/slugify
./composer.json has been created
Loading composer repositories with package information
Updating dependencies (including require-dev)
Package operations: 1 install, 0 updates, 0 removals
  - Installing cocur/slugify (v4.0.0): Downloading (100%)         
Writing lock file
Generating autoload files
Como você pode ver na saída, o Composer decidiu automaticamente qual versão do pacote utilizar. Se você verificar o diretório do seu projeto agora, ele irá conter dois arquivos novos: composer.json e composer.lock, e um diretório vendor:
ls -l
Output
total 12
-rw-rw-r-- 1 sammy sammy   59 May  4 13:56 composer.json
-rw-rw-r-- 1 sammy sammy 3229 May  4 13:56 composer.lock
drwxrwxr-x 4 sammy sammy 4096 May  4 13:56 vendor
O arquivo composer.lock é usado para armazenar informações sobre quais versões de cada pacote estão instaladas, e garantir que as mesmas versões sejam usadas se outra pessoa clonar seu projeto e instalar suas dependências. O diretório vendor é onde as dependêncialas do projeto estão localizadas. Você não deve fazer commit da pasta vendor no controle de versão - você precisa apenas incluir os arquivos composer.json e composer.lock.
Ao instalar um projeto que já contém um arquivo composer.json, execute o composer install para baixar as dependências do projeto.
Vamos dar uma olhada rápida em restrições de versão. Se você verificar o conteúdo do seu arquivo composer.json, verá algo parecido com isto:
cat composer.json
Output
{
    "require": {
        "cocur/slugify": "^4.0"
    }
}
Note que há o caractere especial ^ antes do número da versão no composer.json. O Composer suporta várias restrições diferentes e formatos para definir a versão necessária do pacote, para fornecer flexibilidade enquanto também mantém seu projeto estável. O operador circunflexo (^) utilizado pelo arquivo composer.json criado automaticamente é o operador recomendado para a interoperabilidade máxima, seguindo o versionamento semântico. Neste caso, ele define 4.0 como a versão mínima compatível e permite atualizações para qualquer versão futura abaixo de 5.0.
De um modo geral, você não precisará alterar as restrições de versão em seu arquivo composer.json. No entanto, algumas situações podem exigir que você edite manualmente as restrições – por exemplo, quando uma nova versão principal da sua biblioteca requerida é liberada e você deseja atualizar, ou quando a biblioteca que você deseja usar não segue o versionamento semântico.
Aqui estão alguns exemplos para lhe dar um melhor entendimento sobre como as restrições de versão do Composer funcionam:
Restrição   Significado Exemplo de Versões Permitidas
^1.0    >= 1.0 < 2.0    1.0, 1.2.3, 1.9.9
^1.1.0  >= 1.1.0 < 2.0  1.1.0, 1.5.6, 1.9.9
~1.0    >= 1.0 < 2.0.0  1.0, 1.4.1, 1.9.9
~1.0.0  >= 1.0.0 < 1.1  1.0.0, 1.0.4, 1.0.9
1.2.1   1.2.1   1.2.1
1.* >= 1.0 < 2.0    1.0.0, 1.4.5, 1.9.9
1.2. *  >= 1.2 < 1.3    1.2.0, 1.2.3, 1.2.9
Para uma visualização mais detalhada das restrições de versão do Composer, consulte a documentação oficial.
A seguir, vamos ver como carregar dependências automaticamente com o Composer.
Passo 4 — Incluindo o Script Autoload
Como o PHP por si só não carrega classes automaticamente, o Composer fornece um script autoload que você pode incluir em seu projeto para obter o carregamento automático para ele. Este arquivo é gerado automaticamente pelo Composer quando você adiciona sua primeira dependência.
A única coisa que você precisa fazer é incluir o arquivo vendor/autoload.php em seus scripts PHP antes de qualquer instância de classe.
Vamos testar isso em nossa aplicação de demonstração. Abra um novo arquivo chamado test.php em seu editor de texto:
nano test.php
Adicione o código a seguir que vem no arquivo vendor/autoload.php, carrega a dependência cocur/slugify, e o utiliza para criar um slug:
test.php
<?php
require __DIR__ . '/vendor/autoload.php';
use Cocur\Slugify\Slugify;
$slugify = new Slugify();
echo $slugify->slugify('Hello World, this is a long sentence and I need to make a slug from it!');
Salve o arquivo e saia do seu editor.
Agora, execute o script.
php test.php
Isso produz a saída hello-world-this-is-a-long-sentence-and-i-need-to-make-a-slug-from-it.
As dependências precisam de atualizações quando novas versões são liberadas. Dessa forma, vamos ver como lidar com isso.
Passo 5 — Atualizando as Dependências do Projeto
Sempre que você quiser atualizar suas dependências do projeto para versões mais recentes, execute o comando update:
composer update
Isso irá verificar por versões mais recentes das bibliotecas que você requer em seu projeto. Se uma versão mais recente for encontrada e ela for compatível com a restrição de versão definida no arquivo composer.json, o Composer substituirá a versão anterior instalada. O arquivo composer.lock será atualizado para refletir essas alterações.
Você também pode atualizar uma ou mais bibliotecas específicas, especificando-as desta forma:
composer update vendor/package vendor2/package2
Certifique-se de verificar em seus arquivos composer.json e composer.lock dentro do seu sistema de controle de versão após atualizar suas dependências de modo que outros também possam instalar essas versões mais recentes.
Conclusão
***********
Algoritmo "CalculoMedia2"
// Disciplina: Lógica de programação
// Professor : Antonio Carlos Nicolodi
// Descrição : calculo da média aritimética
// Autor     : Professor Antonio
// Data atual: 01/04/2015
var
// Seção de Declarações
   v1, v2, total: Real
   sinal : Caracter
Inicio
// Seção dos Comandos
   Escreva ("Digite o primeiro valor: ")
   Leia (v1)
   Escreva ("Digite a operação + - * / : ")
   Leia (sinal)
   Escreva ("Digite o segundo valor: ")
   Leia (v2)
   Se sinal = "+" entao
   total <- v1 + v2
   Escreva("O Resultado é: ", total)
   Senao
   Se sinal = "-" entao
   total <- v1 - v2
   Escreva("O Resultado é: ", total)
   Senao
   Se sinal = "*" entao
   total <- v1 * v2
   Escreva("O Resultado é: ", total)
   Senao
     Escreva("OPERAÇÃO INVÁLIDA! ")
      Escreval("total")
   fimse
Fimalgoritmo
****
COMANDOS DOCKER
root@DELLAGS:~# curl -s "https://laravel.build/laravel-9-course?with=mysql,redis,mailhog" | bash
root@DELLAGS:~/example-app# ./vendor/bin/sail  artisan migrate --seed -> criar o banco de dados e copular dados;
### DatabaseSeeder.php
class DatabaseSeeder extends Seeder
{
    /**
     * Seed the application's database.
     *
     * @return void
     */
    public function run()
    {
        \App\Models\User::factory(10)->create();
        //  \App\Models\User::factory()->create([
        //      'name' => 'Test User',
        //      'email' => 'test@example.com',
        //  ]);
    }
}
### Rota get por id ou email
// Route::get('user/{user:email}', function(\App\Models\User $user){
Route::get('user/{user}', function(\App\Models\User $user){
    
  //  ddd($user);
  //  dd($user);
    var_dump($user);
    die();
    return $user;
})->name('user');
Dockerfile
root@DELLAGS:~/example-app# docker exec -it example-app-mysql-1 bash
FROM wyveo/nginx-php-fpm:latest
WORKDIR /usr/share/nginx
RUN rm -rf /usr/share/nginx/html
COPY . /usr/share/nginx
RUN chmod -R 755 /usr/share/nginx/storage/*
RUN ln -s public html
.env (do composer)
DB_CONNECTION=mysql
DB_HOST=mysql-app (serviço do mysql no docker-compose.yaml)
DB_PORT=3306
DB_DATABASE=laraveldockerdb
DB_USERNAME=root
DB_PASSWORD=123456
docker-compose.yaml
version: '3'
services:
  laraveldocker-app:
    build: .
    ports:
      - "3003:80"
    volumes:
      - ./:/usr/share/nginx
      - .docker/nginx:/etc/nginx/conf.d/
    networks:
      - app-network
  mysql-app:
    image: mysql:5.7.22
    ports:
      - "3306:3306"
    volumes:
      - .docker/dbdata:/var/lib/mysql
    environment:
      MYSQL_DATABASE: laraveldocker
      MYSQL_ROOT_PASSWORD: 123456
    networks:
      - app-network
networks:
  app-network:
    driver: bridge
    
/*************************************************
#criando um serviço com um nome qualquer
version: '3'
services:
  laravel-app:                    #criando um serviço com um nome qualquer
    build: . ou image: wyveo/nginx-php-fpm:latest -> neste caso sem Dockerfile.                    # endereço da imagem ou local do Dockerfile (neste caso o ponto siginifica a raiz do projeto)
    ports:
      - "8080:80"                 # 8080 porta do meu host: 80 é a porta do docker nginx
    volumes:                      # docker-compose up -d -> sobe a imagem e libera o terminal  
      - ./:/usr/share/nginx       # TUDO QUE ESTIVE NA RAIZ (na rais tem o meu projeto laravel) './' IRÁ SER REFLETIDO NA PASTA /usr/share/nginx (pasta de acesso da página html)
                                  # C:\Laravel-docker\laravel-docker>docker compose up -d --build atualiza a minha imagem
  mysql-app:
      image: mysql:5.7
      ports:
        - "3306:3306"
      volumes:
        - .docker/dbdata:/var/lib/mysql          # qualqer nome (para persistir -guardar os dados do banco de dados)
      environment:
        MYSQL_DATABASE: laravel
        MYSQL_ROOT_PASSWORD: laravel
    
      
      /***************************///
  
C:\Laravel-docker\laravel-docker>docker compose up -d --build
                                
                               
    
/******************************** Dockerfile
FROM wyveo/nginx-php-fpm:latest
/***************************///
  COMANDOS
docker compose down -> para todos os containers
C:\Laravel-docker\laravel-docker>docker exec -it laravel-docker-laravel-app-1 bash 
root@612ea0ea3340:/# cd /usr/share/nginx/
root@612ea0ea3340:/usr/share/nginx# php artisan migrate
root@612ea0ea3340:/usr/share/nginx# php artisan serve
        
/***********/
PS C:\Users\alber> docker run -e MYSQL_ROOT_PASSWORD=root --name meu-mysql -d mysql:5.7
docker inspect meu-mysql ou | grep IPAddress
PS C:\Users\alber> docker run -e MYSQL_ROOT_PASSWORD=root --name meu-mysql -d -p 3306:3306 mysql:5.7
docker ps
docker ps -l
docker ps -a
docker rm -f nome
/*** LARAVEL */
### CRIANDO UM PROJETO NO LARAVEL 
laravel new projeto_laravel_via_installer (ESTA É UM AOPÇÃO)
composer create-project --prefer-dist laravel/laravel app_controle_tarefas "8.5.9"
cd app_controle_tarefas
cd public
php -S localhost:8000
ou 
da raiz do projeto:
php artisan serve 
ou
php artisan serve --port=3000
### PARA ABRIR PORTA EM OUTRO SERVIDOR
php artisan serve --host test.com --port 8080
 **********************************************************************
cd app_controle_tarefas
cd public
php artisan serve
- acessa o navegador http://localhost:8000
### DENTRO DO PROJETO CRIADO INSTALAR O LARAVEL/UI:^3.2 - versão 3.2
composer require laravel/ui:^3.2
### SE OCORRER ERRO AUMENTAR A MEMÓRIA DISPONIVEL PARA O php
-php --ini -> localiza o arquivo de configuração do php
LOCALIZA memory_limit = 1000 e altera para 
         memory_limit  = -1 e Salva
### LISTA A RELAÇÃO DE COMANDOS 
php artisan list 
DEVERA SURGIR AS OPÇÕES ABAIXO:
 ui
  ui:auth               Scaffold basic login and registration views and routes
  ui:controllers        Scaffold the authentication controllers
 vendor
### ENTENDENDO O PACOTE UI E INICIANDO A AUTENTICAÇÃO WEB NATIVA DO LARAVEL
COMANDO PARA LISTAR ROUTES: 
php artisan route:list
### php artisan ui bootstrap --auth (bootstrap ou react ou vue)
aplicando o bootstrap incluindo os recursos de autenticação;
poderia ser aplicado o bootstrap sem os recursos de autenticação;
### php artisan route:list -> mostra as rotas - ver que aumentaram as rotas
### APÓS ESSE PROCESSO O SISTEMA PEDE PARA RODAR
npm install -> instala as dependências do package.json (inclusive o bootstrap)
npm run dev -> gera os assets da aplicação de acordo com a tecnologia selecionada (bootstrap, react ou vue) -> Geralmente roda mais de uma vez para compilar tudo.
### CRIA O BANCO DE DADOS NORMALMENTE
### EXECUTA AS MIGRATIONS PADRÕES CRIADAS PARA O SISTEMA DE login
php artisan migrate -> CRIA AS TABELAS NO BANCO DE DADOS
************************************** 
INSTALANDO O COMPOSER NO UBUNTU
**************************************
sudo apt update
sudo apt install php-cli unzip
cd ~
curl -sS https://getcomposer.org/installer -o composer-setup.php
HASH=`curl -sS https://composer.github.io/installer.sig`

echo $HASH ->saída: Output
e0012edf3e80b6978849f5eff0d4b4e4c79ff1609dd1e613307e16318854d24ae64f26d17af3ef0bf7cfb710ca74



php -r "if (hash_file('SHA384', 'composer-setup.php') === '$HASH') { echo 'Installer verified'; } else { echo 'Installer corrupt'; unlink('composer-setup.php'); } echo PHP_EOL;"

sudo php composer-setup.php --install-dir=/usr/local/bin --filename=composer





***********************

DigitalOcean Kubernetes: novo plano de controle é mais rápido e gratuito, habilita HA para SLA de 99,95% de tempo de atividade
Produtos
Preços

Documentos
divisa suspensa

Entrar
divisa suspensa

// Tutorial //
Como Instalar e Utilizar o Composer no Ubuntu 20.04
Publicado em 21 de maio de 2020
Ubuntu
PHP
Ubuntu 20.04
Avatar padrão
Por Erika Heidi
Advogado Desenvolvedor
Português
Como Instalar e Utilizar o Composer no Ubuntu 20.04
Introdução
O Composer é uma ferramenta popular de gerenciamento de dependências para o PHP, criado para facilitar a instalação e a atualização das dependências principalmente do projeto. Ele controla quais outros pacotes de projeto específico dependem e são instalados para você, usando as opções apropriadas de acordo com os requisitos do projeto. O Composer também é comumente utilizado para inicializar novos projetos em frameworks PHP populares, como o Symfon e o Laravel .

Neste tutorial, você instalará e começará a usar o Composer em um sistema Ubuntu 20.04.

Pré-requisitos
Para seguir este guia, você pode acessar um servidor como usuário Ubuntu20.04 como usuário sudonão-root um firewall habilitado em seu servidor Para configurar isto, siga nosso guia Configuração do servidor inicial para o Ubuntu 20.04

Passo 1 — Instalando o PHP e as Dependências Adicionais
Além das dependências que já devem estar incluídas em seu sistema Ubuntu 20.04, como o , o Composer exige ou gitexecuta scripts PHP na linha de comando e para extrair arquivos zipados. Vamos instalar essas dependências agora.curlphp-cliunzip

primeiro, atual, gerenciador de pacotes de soluções: o cache do gerenciador de pacotes

sudo apt update
Em seguida, o seguinte comando para instalar os pacotes, execute:

sudo apt install php-cli unzip
Você será solicitado a confirmar a instalação digitando Ye, depois, ENTER.

Assim que os pré-requisitos para instalação do Composer forem instalados, você poderá seguir.

Passo 2 — Baixando e Instalando o Compositor
O Composer fornece um instalador de script escrito em PHP. Vamos baixá-lo, verificar se ele não está danificado e, em seguida, o usaremos para instalar o Composer.

Certifique-se de estar em sua pasta home. Em seguida, baixe o instalador usando o curl:

cd ~
curl -sS https://getcomposer.org/installer -o composer-setup.php
Em seguida, vamos verificar se o instalador baixado corresponde ao hash SHA-384 para o instalador mais recente encontrado na página Composer Public Keys / Signatures . Para facilitar o passo de seleção, você pode usar o seguinte comando para obter programaticamente o hash mais recente da página do Composer e armazená-lo em uma variável do shell:

HASH=`curl -sS https://composer.github.io/installer.sig`
Se você quiser verificar o valor realizado, execute:

echo $HASH
Output
e0012edf3e80b6978849f5eff0d4b4e4c79ff1609dd1e613307e16318854d24ae64f26d17af3ef0bf7cfb710ca74755a
Agora o código PHP a seguir, execute conforme a página de download do Composer, para verificar se o script de instalação está seguro para ser executado:

php -r "if (hash_file('SHA384', 'composer-setup.php') === '$HASH') { echo 'Installer verified'; } else { echo 'Installer corrupt'; unlink('composer-setup.php'); } echo PHP_EOL;"
Você verá o seguinte resultado:

Resultado
Installer verified
Se Installer corruptvocê estiver usando o hash correto, verifique se você está usando o hash correto. Em seguida, repita o processo de verificação. Quando você tiver um instalador selecionado, você pode continuar.

Para instalar o composerglobalmente, use o seguinte comando que baixará e instalará o Composer como um comando disponível em todo o sistema chamado composer, sob /usr/local/bin:

sudo php composer-setup.php --install-dir=/usr/local/bin --filename=composer
Você verá um resultado semelhante com este:

Output
All settings correct for using Composer
Downloading...

Composer (version 1.10.5) successfully installed to: /usr/local/bin/composer
Use it: php /usr/local/bin/composer
Para testar sua instalação, execute:

composer
Output
   ______
  / ____/___  ____ ___  ____  ____  ________  _____
 / /   / __ \/ __ `__ \/ __ \/ __ \/ ___/ _ \/ ___/
/ /___/ /_/ / / / / / / /_/ / /_/ (__  )  __/ /
\____/\____/_/ /_/ /_/ .___/\____/____/\___/_/
                    /_/
Composer version 1.10.5 2020-04-10 11:44:22
Usage:
  command [options] [arguments]
Options:
  -h, --help                     Display this help message
  -q, --quiet                    Do not output any message
  -V, --version                  Display this application version
      --ansi                     Force ANSI output
      --no-ansi                  Disable ANSI output
  -n, --no-interaction           Do not ask any interactive question
      --profile                  Display timing and memory usage information
      --no-plugins               Whether to disable plugins.
  -d, --working-dir=WORKING-DIR  If specified, use the given directory as working directory.
      --no-cache                 Prevent use of the cache
  -v|vv|vvv, --verbose           Increase the verbosity of messages: 1 for normal output, 2 for more verbose output and 3 for debug
...
Isso verifica que o Composer foi instalado com sucesso em seu sistema e está disponível em todo o sistema.
Nota: se você preferirá ter-lhe-ão separados separados do Composer para projeto hospedado neste servidor, você pode instalar localmente, em uma base por projeto. Este método também é útil quando o usuário do sistema não possui permissão para instalar o software disponível em todo o sistema.
Para fazer isso, use o comando php composer-setup.php. Isso irá gerar um arquivo composer.pharem seu diretório atual, que pode ser executado com o seu atual php composer.phar.
Agora podemos dar uma dependência em como usar o Compose como gerenciar.
Passo 3 — Usando o Compositor em um Projeto PHP
Os projetos PHP geralmente dependentes de bibliotecas externas, e o gerenciamento de dependências e suas versões podem ser complicados. O Composer resolve esse problema de manter um controle de projeto de extensões e dependências, também facilita o processo de descoberta, instalação e atualização de pacotes que são definidos por enquanto.
Para usar o seu projeto, você pode compor um arquivo composer.json. O arquivo composer.jsonComposer quais dependências precisa para baixar seu projeto quais serão as versões de cada pacote tem permissão para instalações e instalações. Isso é muito importante para manter seu projeto consistente e evitar a instalação de versões instáveis ​​que podem causar problemas de compatibilidade retroativa.
Você não precisa criar este arquivo manualmente - é comum ocorrer erros de sintaxe quando fizer isso. O Composer oferece uma maneira de criar um novo arquivo composer.jsoncom base na entrada do usuário, o que é uma boa escolha se você planeja compartilhar seu projeto mais tarde como um pacote público no Packagist . O Composer gera automaticamente um arquivo básico composer.jsonquando você executa um comando composer requirepara incluir uma dependência em um projeto recém-criado.
O processo de uso do Composer para instalar um pacote como uma dependência em um projeto envolve os passos a seguir:
Identifique o tipo de biblioteca que o aplicativo precisa.
uma biblioteca de código aberto adequada no agist.org , o responsável oficial de pacotes para o Compose.
Escolha o pacote de dependência.
Execute composer requirepara incluir a dependência no arquivo composer.jsone instalar o pacote.
Vamos testar isso com uma aplicação de demonstração.
O objetivo desta aplicação é transformar uma determinação determinada em uma string de URL amigável - um slug . Isso é comumente usado para converter os títulos de página para caminhos de URL (Assim como a parte final da URL para este tutorial).
Vamos começar a criar um diretório para o nosso projeto. Vamos chamá-lo de slugify :
cd ~
mkdir slugify
cd slugify
Embora não seja necessário, você pode executar agora um comando composer init para criar um arquivo composer.json detalhado para seu projeto. Como o único objetivo do nosso projeto é demonstrar como instalar dependências com o Composer, usaremos um arquivo composer.json mais simples que será gerado automaticamente quando exigirmos nosso primeiro pacote.
Agora é hora de procurar no Packagist.org por um pacote que pode nos ajudar a gerar slugs. Se você procurar pelo termo “slug” no Packagist, receberá um resultado parecido com este:
Resultados da Pesquisa do Packagist para o termo "slug"
Você verá dois números no lado direito de cada pacote na lista. O número no topo representa quantas vezes o pacote foi instalado através do Composer, e o número em baixo mostra quantas vezes um pacote foi estrelado no GitHub. De um modo geral, os pacotes com mais instalações e mais estrelas tendem a ser mais estáveis, pois mais pessoas os utilizam. Também é importante verificar a descrição do pacote para relevância para garantir que ele é o que você precisa.
Precisamos de um conversor string-to-slug A partir dos resultados da pesquisa, o pacote cocur/slugify, que aparece como o primeiro resultado naquela página, parece ser um bom candidato, com uma quantidade razoável de instalações e estrelas.
Os pacotes no Packagist têm um nome de vendor e um nome de package. Cada pacote tem um identificador único (um namespace) no mesmo formato que o GitHub utiliza para seus repositórios: vendor/package. A biblioteca que queremos instalar utiliza o namespace cocur/slugify. Você precisa de um namespace do pacote para exigi-lo em seu projeto.
Agora que você sabe exatamente qual pacote deseja instalar, você pode executar o composer require para incluí-lo como uma dependência e gerar também o arquivo composer.json para seu projeto. Uma coisa importante é observar a exigência de pacotes. O Composer rastreia as dependências no nível da aplicação e do sistema. As dependências no nível do sistema são importantes para indicar de quais módulos PHP um pacote depende. No caso do pacote cocur/slugify, ele exige um módulo PHP que ainda não instalamos.
Quando um pacote necessário depende de uma biblioteca de sistema que não está atualmente instalada em seu servidor, você receberá um erro informando qual requisito está faltando:
composer require cocur/slugify
Output
Using version ^4.0 for cocur/slugify
./composer.json has been updated
Loading composer repositories with package information
Updating dependencies (including require-dev)
Your requirements could not be resolved to an installable set of packages.
  Problem 1
    - Installation request for cocur/slugify ^4.0 -> satisfiable by cocur/slugify[v4.0.0].
    - cocur/slugify v4.0.0 requires ext-mbstring * -> the requested PHP extension mbstring is missing from your system.
...
Para resolver o problema de dependência do sistema, podemos procurar pelo pacote que falta usando o apt search:
apt search mbstring
Output
Sorting... Done
Full Text Search... Done
php-mbstring/focal 2:7.4+75 all
  MBSTRING module for PHP [default]
php-patchwork-utf8/focal 1.3.1-1 all
  UTF-8 strings handling for PHP
php7.4-mbstring/focal 7.4.3-4ubuntu1 amd64
  MBSTRING module for PHP
Após localizar o nome do pacote correto, você pode utilizar o apt novamente para instalar a dependência de sistema:
sudo apt install php-mbstring
Assim que a instalação terminar, você pode executar novamente o comando composer require:
composer require cocur/slugify
Output
Using version ^4.0 for cocur/slugify
./composer.json has been created
Loading composer repositories with package information
Updating dependencies (including require-dev)
Package operations: 1 install, 0 updates, 0 removals
  - Installing cocur/slugify (v4.0.0): Downloading (100%)         
Writing lock file
Generating autoload files
Como você pode ver na saída, o Composer decidiu automaticamente qual versão do pacote utilizar. Se você verificar o diretório do seu projeto agora, ele irá conter dois arquivos novos: composer.json e composer.lock, e um diretório vendor:
ls -l
Output
total 12
-rw-rw-r-- 1 sammy sammy   59 May  4 13:56 composer.json
-rw-rw-r-- 1 sammy sammy 3229 May  4 13:56 composer.lock
drwxrwxr-x 4 sammy sammy 4096 May  4 13:56 vendor
O arquivo composer.lock é usado para armazenar informações sobre quais versões de cada pacote estão instaladas, e garantir que as mesmas versões sejam usadas se outra pessoa clonar seu projeto e instalar suas dependências. O diretório vendor é onde as dependências do projeto estão localizadas. Você não deve fazer commit da pasta vendor no controle de versão - você precisa apenas incluir os arquivos composer.json e composer.lock.
Ao instalar um projeto que já contém um arquivo composer.json, execute o composer install para baixar as dependências do projeto.
Vamos dar uma olhada rápida em restrições de versão. Se você verificar o conteúdo do seu arquivo composer.json, verá algo parecido com isto:
cat composer.json
Output
{
    "require": {
        "cocur/slugify": "^4.0"
    }
}
Note que há o caractere especial ^ antes do número da versão no composer.json. O Composer suporta várias restrições diferentes e formatos para definir a versão necessária do pacote, para fornecer flexibilidade enquanto também mantém seu projeto estável. O operador circunflexo (^) utilizado pelo arquivo composer.json criado automaticamente é o operador recomendado para a interoperabilidade máxima, seguindo o versionamento semântico. Neste caso, ele define 4.0 como a versão mínima compatível e permite atualizações para qualquer versão futura abaixo de 5.0.
De um modo geral, você não precisará alterar as restrições de versão em seu arquivo composer.json. No entanto, algumas situações podem exigir que você edite manualmente as restrições – por exemplo, quando uma nova versão principal da sua biblioteca requerida é liberada e você deseja atualizar, ou quando a biblioteca que você deseja usar não segue o versionamento semântico.
Aqui estão alguns exemplos para lhe dar um melhor entendimento sobre como as restrições de versão do Composer funcionam:
Restrição   Significado Exemplo de Versões Permitidas
^1.0    >= 1.0 < 2.0    1.0, 1.2.3, 1.9.9
^1.1.0  >= 1.1.0 < 2.0  1.1.0, 1.5.6, 1.9.9
~1.0    >= 1.0 < 2.0.0  1.0, 1.4.1, 1.9.9
~1.0.0  >= 1.0.0 < 1.1  1.0.0, 1.0.4, 1.0.9
1.2.1   1.2.1   1.2.1
1.* >= 1.0 < 2.0    1.0.0, 1.4.5, 1.9.9
1.2. *  >= 1.2 < 1.3    1.2.0, 1.2.3, 1.2.9
Para uma visualização mais detalhada das restrições de versão do Composer, consulte a documentação oficial.
A seguir, vamos ver como carregar dependências automaticamente com o Composer.
Passo 4 — Incluindo o Script Autoload
Como o PHP por si só não carrega classes automaticamente, o Composer fornece um script autoload que você pode incluir em seu projeto para obter o carregamento automático para ele. Este arquivo é gerado automaticamente pelo Composer quando você adiciona sua primeira dependência.
A única coisa que você precisa fazer é incluir o arquivo vendor/autoload.php em seus scripts PHP antes de qualquer instância de classe.
Vamos testar isso em nossa aplicação de demonstração. Abra um novo arquivo chamado test.php em seu editor de texto:
nano test.php
Adicione o código a seguir que vem no arquivo vendor/autoload.php, carrega a dependência cocur/slugify, e o utiliza para criar um slug:
test.php
<?php
require __DIR__ . '/vendor/autoload.php';
use Cocur\Slugify\Slugify;
$slugify = new Slugify();
echo $slugify->slugify('Hello World, this is a long sentence and I need to make a slug from it!');
Salve o arquivo e saia do seu editor.
Agora, execute o script.
php test.php
Isso produz a saída hello-world-this-is-a-long-sentence-and-i-need-to-make-a-slug-from-it.
As dependências precisam de atualizações quando novas versões são liberadas. Dessa forma, vamos ver como lidar com isso.
Passo 5 — Atualizando as Dependências do Projeto
Sempre que você quiser atualizar suas dependências do projeto para versões mais recentes, execute o comando update:
composer update
Isso irá verificar por versões mais recentes das bibliotecas que você requer em seu projeto. Se uma versão mais recente for encontrada e ela for compatível com a restrição de versão definida no arquivo composer.json, o Composer substituirá a versão anterior instalada. O arquivo composer.lock será atualizado para refletir essas alterações.
Você também pode atualizar uma ou mais bibliotecas específicas, especificando-as desta forma:
composer update vendor/package vendor2/package2
Certifique-se de verificar em seus arquivos composer.json e composer.lock dentro do seu sistema de controle de versão após atualizar suas dependências de modo que outros também possam instalar essas versões mais recentes.
INÍCIO:
1 instalar o docker
2 abrir wsl2/Windows ou linux
 curl -s "https://laravel.build/olw?with=mysql,redis,mailhog,minio" | bash
3 cd olw
./vendor/bin/sail up -d
    ou
4 cd olw && ./vendor/bin/sail up -d
5 ATRIBUINDO PERMISSÃO PARA A PASTA
cd .. -> sai da pasta
sudo chmod 777 olw/ -R ou sem o 'sudo' chmod 777 olw/ -R
6 CRIANDO ALIAS PARA O COMANDO ANTERIOR
alias sail='[ -f sail ] && sh sail || sh vendor/bin/sail'
passa a usar assim: sail ps
7 CONFIGURAR PORTAS PARA A APLICAÇÃO NO NAVEGADOR E MYSQL
.env
APP_PORT=8000
*porta do myql
FORWARD_DB_PORT=3307
8 INSTALANDO DEPENDÊNCIA AO PROJETO
./vendor/bin/sail composer require laravel/breeze --dev
9 DEIXAR TELA DE AUTENTICAÇÃO PRONTA, ROTA AUTENTICADA, TAWINDCSS INSTALADO E INERTIA INSTALADO
./vendor/bin/sail artisan breeze:install vue 
ou
./vendor/bin/sail art breeze:install vue
10 RODAR AS MIGRATES PADRÕES DO PROJETO AI JÁ PODE CADASTRAR USUÁRIOS PARA LOGIN:
./vendor/bin/sail art migrate
11 
/*******************************************/
2a AULA:
O PROJETO CONSISTE EM RECEBER DADOS DE UMA API (punkapi.com) DE INFORMAÇÕES SOBRE CERVEJAS, VAMOS CONSTRUIR AS ROTAS PARA CONSUMIR A API E CRIAR A ESTRUTURA PARA O RELATÓRIO QUE IREMOS GERAR EM EXCEL E ENVIAR PARA O STORAGE...
1 CRIAR ROTAS:
code .
olw/routes/web.php
sail up -d -> SOBE O CONTAINER localhost:8000 (nesse projeto)
Route::get('/beers', fn()=> 'Olw - testando a rota /beers');
**************************************************
obs:
- laravel.com/api -> acesso a documentação do código;
- in line paramets for vscode -> extensão para vscode para exibir o nome dos métodos na hora que codificar;
- fira code -> extensão para fonte no vscode
git Hub Copilot vs Tabnine -> (pesquisar sobre)
Link para extensões vscode:
https://github.com/icarojobs/vscode-useful-extensions
*************************************************
Route::get('/beers', fn()=> 'Olw - testando a rota /beers')
                             ->middleware(['auth']);
* FLUXO PADRÃO DO MVC-LARAVEL: 
life cicle: sai do usuário pelo navegador, insomnia ou postman -> passa pelo index.php(pasta public) -> passa pelos arquivos do bootstrap retornando uma instância da aplicação -> passa pelo kernel do http (carrega mais instâncias) -> Service provider -> despacha a requisição pro Router -> Cai no arquivo Web.php -> Middleware (se tiver, geralmente tem os globais) -> Controller (faz as regras de negócio e pode chamar outras classes como Serviços por exemplo)
-> Retorna uma view ou um json (No caso estamos usando inértia, ele não vai reinderizar a 'view.blade' padrão, ele vai reinderizar componente vue.js através do inértia.).
* EM VEZ DE USAR A FUNÇÃO AQUI NA ROTA CRIAMOS UM CONTROLLER:
obs.: ​dica: php artisan make:controller -r cria o Resource também.
dica: limpar o cache do container:
./vendor/bin/sail art config:cache
./vendor/bin/sail art optimize:clear
sail artisan make:controller BeerController
ou 
sail art make:controller BeerController -> CRIA O ARQUIVO BeerController.php na pasta app/Http/Controllers
->
<?php
namespace App\Http\Controllers;
use Illuminate\Http\Request;
class BeerController extends Controller
{
    public function index()
    {
    return 'Virgu & Beer & Code'
    }
}
* NO ARQUIVO DE ROTAS Web.php CHAMA O BeersController:
importante importar o Controller <nomeDoController>+<CTRL=ENTER:
use App\Http\Controllers\BeerController;
Route::get('/beers', [BeerController::class, 'index'])
                        ->middleware(['auth']);
* PRECISAMOS CRIAR UM MÉTODO PARA PEGAR A LISTA, LISTAR OS DADOS DA API (listar as bebidas de https://api.punkapi.com/v2 ->
VAMOS CRIAR UMA NOVA CLASSE de serviços em app/Sevices/PunkapiService.php
* O LARAVEL POSSUI UM RECURSO CHAMADO HTTPClient que abstrai o uso de uma ferramenta chama guzeo, esse guzeo é o client http mais comum para php, com ele fazemos requisições pra diversos serviços web dentro do php para outras url, ele é robusto, então o laravel simplifica importando o recurso que faz tudo por 'detrás dos panos':
PunkapiService.php
<?php
namespace App\Services;
use Illuminate\Support\Facades\Http;
class PunkapiService
{
    public function getBeers()
    {
        return Http::get('https://api.punkapi.com/v2/beers');
    }
}
E NO BeerController.php fica:
<?php
namespace App\Http\Controllers;
use App\Services\PunkapiService;
use Illuminate\Http\Request;
class BeerController extends Controller
{
    public function index()
    {
    //return 'Virgu & Beer & Code';
    $service = new PunkapiService;
    return $service->getBeers();
    }
}
* TRATE É CARACTERÍSTICA QUE A CLASSE ADQUIRE (pode ter mesmos métodos e atributos substituindo o recurso de um classe extender várias classes que não tem no php, a trate é uma forma de fazer isso. O service  é uma outra camada na maioria das vezes abstrair seviços que vc vai consumir, por exemplo API.
Estando logado, os dados da api já serão exibidos em localhost:8000/beers, se usar um aplicativo cliente tipo insomnia pode apresentar os dados também, melhor comentar a linha de de autenticação da rota:
Route::get('/beers', [BeerController::class, 'index']);
linha de autenticação da rota // ->middleware(['auth']);
* ESSA API PERMITE FAZER FILTROS VIA PARÂMETROS NA PRÓPRIA ROTA. PRIMEIRO VAMOS REFATORAR O CÓDIO, A CLASSE PunkapiService.php:
USO DE CONFIG E MACRO
Vamos alterar a url, primeiro acessando a pasta config da raiz do projeto e criar o arquivo punkapi.php. O que acontece é que o config(pasta config da raiz) carrega todos os arquivos da pasta e permite que sejam acessados via funções simples(HELPERS), isso é muito legal porque podemos acessar esses arquivos de configurações de qualquer lugar do projeto: 
<?php
return [
    'url' => env('PUNK_BASE_URL', 'https://api.punkapi.com/v2')
];
Usando o helper env significa dizer que, se não houver a constante PUNK_BASE_URL setada no arquivo .env do projeto, seu valor será o segundo parâmetro: http://api.punkapi.com/v2 e no arquivo PunkapiService.php da pasta app/Services fica:
<?php
namespace App\Services;
use Illuminate\Support\Facades\Http;
class PunkapiService
{
    public function getBeers()
    {
        return Http::get('/beers');
    }
}
MACRO é uma forma de criar funções customizadas:
 em app\Providers vamos acessar o arquivo AppServiceProvider.php que é uma classe que tem dois métodos register e boot. No método boot vamos chamar o método Http do laravel e chamar o método macro, no primeiro parâmetro será um nome atribuído à função e e o segundo uma clausure (uma função).
Neste arquivo é passado o arquivo de configuração da url (em 'config/punkapi.php') além de tokens, headers,...
 
use Illuminate\Support\Facades\Http; -> deve ser importado
E a função boot fica:
  public function boot()
    {
        Http::macro('punkapi', function(){
            return Http::acceptJson()
            ->baseUrl(config('punkapi.url'));
        });
    }
Então criamos uma macro(uma função customizada) chamada punkapi que já retorna o client com accept/Json no Header e com o baseUrl configurado lá do arquivo /config/punkapi.php e se estiver setado no .env pegará de lá.
/app/Services/PunkapiService.php fica:
<?php
namespace App\Services;
use Illuminate\Support\Facades\Http;
class PunkapiService
{
    public function getBeers()
    {
        return Http::punkapi()->get('/beers');
    }
}
*obs.: a baseUrl poderia ser setada no construtor, que pode setar token também.(uma outra abordagem para versão sem macros);
->Testamos o retorno Json em localhost:8000/beers.
Refatorando o arquivo PunkapiService.php: O client Http não lança exceção e podemos forçar o retorno em modo Json:
<?php
namespace App\Services;
use Illuminate\Support\Facades\Http;
class PunkapiService
{
    public function getBeers()
    {
       // return Http::punkapi()->get('/beers');
       return Http::punkapi()
            ->get('/beers')
            ->throw()  // Exceção em caso de erro
            ->json();   // Força o retorno em formato Json
    }
}
Podemos testar forçando um erro alterando a constante PUNKAPI_BASE_URL criada em /config/punkapi.php, vamos atribuir um valor diferente no arquivo .env:
PUNKAPI_BASE_URL="adfjklj878"
Podemos usar a função retry tem dois parâmetros, o número de tentativas pra buscar a requisição e o intervalo entre elas. Refatorando o código fica:
<?php
namespace App\Services;
use Illuminate\Support\Facades\Http;
class PunkapiService
{
    public function getBeers()
    {
       // return Http::punkapi()->get('/beers');
       return Http::punkapi()
            ->get('/beers')
            ->throw()  // Exceção em caso de erro
            ->json();   // Força o retorno em formato Json
    }
}
- Quando sai a exceção nao deveriamos retornar o erro em json por ser um api neste caso estamos usamos um app web e não uma api. E usaríamos o Route Api.
Refatorando o método boot de /app/Providers/AppServiceProvider.php, inserindo o retry():
     */
    public function boot()
    {
        Http::macro('punkapi', function(){
            return Http::acceptJson()
            ->baseUrl(config('punkapi.url'))
            ->retry(3,100);
        });
    }
}
comando de help
* ./vendor/bin/sail composer dump-autoload
* Verificar Nome do arquivo se bate com o nome das rotas(Classes criadas e importar o nome errado);
* inteliphense
Refatorando BeerController.php
<?php
namespace App\Http\Controllers;
use App\Services\PunkapiService;
class BeerController extends Controller
{
    public function index()
    {
    $service = new PunkapiService();
    return $service->getBeers();
    }
}
Em vez de instanciar o método PunkapiService() dentro de index, vamos passar por parâmetro de index() declarando seu Próprio nome (PunkapiService) como tipo. Fica assim:
<?php
namespace App\Http\Controllers;
use App\Services\PunkapiService;
class BeerController extends Controller
{
    public function index(PunkapiService $service)
    {
    return $service->getBeers();
    }
}
Assim usamos feactures do php(injeção de dependências) e ao mesmo tempo feactures do laravel. Em vez de criar uma instância dentro do método index, vamos injetar a classe como parâmetro para o método index(), ficando index($service) e a instância de dentro da função passa como parâmetro de 'tipo da variável'. Isso quebra a cadeia de dependência entre as classes.
Assim, o método index ganha independência não mais dependendo da instância de new PunkapiService e passamos a olhar a função index em si.
Assim, o Laravel tenta fazer um binding, um match, o laravel tenta encontrar alguma classe PunkapiService e cria uma instância dessa classe e usa ali como parâmetro. Se não fizer assim, lá em Rotas teria que ser passado como parâmetro o que fica desnecessário.
Não poderia ser feito se na classe PunkapiService existisse o construtor para atribuir valores automaticamente à classe. Assim podemos usar porque não precisamos passar nenhum valor.
ADICIONAR OS FILTROS:
Vamos filtrar o retorno api com os seguintes itens: beer_name, food, ibu_gt, malte:
var_dump($v)
die();
dd($variável)
benchmarck -> ?
/*****REFATORA PARA TESTE alterando BeerController.php e PunkapiService.php
BeerController.php
<?php
namespace App\Http\Controllers;
use App\Services\PunkapiService;
class BeerController extends Controller
{
    public function index(PunkapiService $service)
    {
    return $service->getBeers(
        'heineken',
        'cheese',
        'corn',
        45
    );
    }
}
PunkapiService.php
<?php
namespace App\Services;
use Illuminate\Support\Facades\Http;
class PunkapiService
{
    public function getBeers(
        string $beer_name,
        string $food,
        string $malt,
        string $ibu_gt
    )
    {
        $params = get_defined_vars();
        dd($params);
        return Http::punkapi()
            ->get('/beers', $params)
            ->throw()  // Exceção em caso de erro
            ->json();   // Força o retorno em formato Json
    }
}
Resultado do debug no insomnia ou no navegador:
array:4 [▼ // app/Services/PunkapiService.php:18
  "beer_name" => "heineken"
  "food" => "cheese"
  "malt" => "corn"
  "ibu_gt" => "45"
]
//* fim teste
Refatorando:
class PunkapiService
{
    public function getBeers(
        string $beer_name = null,
        string $food = null,
        string $malt = null,
        string $ibu_gt = null
    )
    {
        $params = get_defined_vars();
        dd($params);
        return Http::punkapi()
            ->get('/beers', $params)
            ->throw()  // Exceção em caso de erro
            ->json();   // Força o retorno em formato Json
    }
}
Assim quando não passar o valor para a chave ele exibirá a chave e o valor Null, vamos refatorar para não exibir nem a chave englobando get_defined_vers() com array_filter no arquivo PunkapiService.php:
$params = array_filter(get_defined_vars());
<?php
namespace App\Http\Controllers;
use App\Services\PunkapiService;
class BeerController extends Controller
{
    public function index(PunkapiService $service)
    {
    return $service->getBeers(
        'heineken',
        'cheese',
        'corn',
       // 45 -> Esse não é passado
    );
    }
}
array:3 [▼ // app/Services/PunkapiService.php:18
  "beer_name" => "heineken"
  "food" => "cheese"
  "malt" => "corn"
    Aqui não exibiu o valor 45
]
USANDO A FUNÇÃO NAMED_ARGS passamos só os parâmetros que precisamos retornar da api e o php com essa função saberá qual a posição dela no array de argumentos passados como parâmetro sem a necessidade de seguir a mesma sequência dos argumentos:
class BeerController extends Controller
{
    public function index(PunkapiService $service)
    {
    return $service->getBeers(food: 'cheese');
    }
}
REFATORANDO:
BeerController.php
<?php
namespace App\Http\Controllers;
use App\Services\PunkapiService;
use Illuminate\Http\Request;
class BeerController extends Controller
{
    public function index( Request $request, PunkapiService $service)
    {
    return $service->getBeers(...$request->all());
    }
}
PunkapiService.php
<?php
namespace App\Services;
use Illuminate\Support\Facades\Http;
class PunkapiService
{
    public function getBeers(
        string $beer_name = null,
        string $food = null,
        string $malt = null,
        string $ibu_gt = null
    )
    {
        $params = array_filter(get_defined_vars());
     //   dd($params);
        return Http::punkapi()
            ->get('/beers', $params)
            ->throw()  // Exceção em caso de erro
            ->json();   // Força o retorno em formato Json
    }
}
CRIANDO UMA REQUEST
sail artisan make:request BeerRequest
/app/Http/Requests/BeerRequest.php
* Funções anônimas, também conhecidas como closures , permitem a criação de funções que não tem o nome especificado. Elas são mais úteis como o valor de parâmetros callable, mas podem ter vários outros usos.. É uma função passada como parâmetro
CRIANDO NOVA ROTA PARA SALVAR COMO EXCEL
* https://docs.laravel-excel.com/3.1/getting-started/installation.html
Route::group([
    'prefix' => 'beers',
], function() {
    Route::get('/', [BeerController::class, 'index']); //-> Se houver necessidade de salvar dados por essa rota mudamos o método(verbo html) para post(os dados não serão expostos na url).
                          //  ->middleware(['auth']);
    Route::get('/export', [BeerController::class, 'export']);
});
Então passamos a ter duas rotas: localhost:8000/beers
localhost:8000/beers/export
No BeerController incluimos o método export():
class BeerController extends Controller
{
    public function index( BeerRequest $request, PunkapiService $service)
    {
    // return $service->getBeers(...$request->all());
    return $service->getBeers(...$request->validated());
    }
    public function export()
    {
        return 'Relatório criado.';
    }
}
INSTALANDO PACOTE LARAVEL-EXCEL PARA GERAR OS RELATÓRIO EM EXCEL FILTRADOS DA API:
* https://docs.laravel-excel.com/3.1/getting-started/installation.html
COMANDO PARA INSTALAR VIA COMPOSER:
./vendor/bin/sail composer require psr/simple-cache:^2.0 maatwebsite/excel
CRIAR A CLASSE DO EXCEL
./vendor/bin/sail artisan make:export BeerExport  --> Cria o arquivo em  /app/Exports/BeerExport.php
<?php
namespace App\Exports;
use Maatwebsite\Excel\Concerns\FromCollection;
class BeerExport implements FromCollection
{
    /**
    * @return \I¢lluminate\Support\Collection
    */
    public function collection()
    {
        //
    }
}
-> Dentro de colletion buscaremos as informações que serão salvas no arquivo do excel, um array de dados;
criamos um __construct() que vai ter uma propriedade privada do tipo array chamamos de $reportData.
O retorn será uma collection como informa o comentário:
 /**
    * @return \I¢lluminate\Support\Collection
    */
Na função colletion(), está recebendo um array return $this->reportData; 
Observe que não precisa mais declarar uma propriedade que vai se setada via construct(), basta defifinir o escopo junto do argumento e o php faz isso pra você. Como o retorno da função é um array usamos o helper collect para o $this->reportData:
BeerExport.php
<?php
namespace App\Exports;
use Maatwebsite\Excel\Concerns\FromCollection;
class BeerExport implements FromCollection
{
    public function __construct(
        private array $reportData
    ){}
    /**
    * @return \Illuminate\Support\Collection
    */
    public function collection()
    {
       return collect($this->reportData);
    }
}
 
Consultamos a documentação do Laravel-excel em 'Exporting collections':
em Excel Store passa o nome da classe e o nome do arquivo:
BeerController.php
<?php
namespace App\Http\Controllers;
use App\Exports\BeerExport;
use App\Http\Requests\BeerRequest;
use App\Services\PunkapiService;
use Maatwebsite\Excel\Facades\Excel;
class BeerController extends Controller
{
    public function index( BeerRequest $request, PunkapiService $service)
    {
    // return $service->getBeers(...$request->all());
    return $service->getBeers(...$request->validated());
    }
    public function export()
    {
      $params = [
        ['name' => 'Tom', 'age' => '30'],
        ['name' => 'Virgu', 'age' => '27']
       ];
       Excel::store(new BeerExport($params), 'olw-report.xlsx');
       return "Relatório criado";
    }
}
********************************************
* REFATORANDO E SALVANDO O ARQUIVO EXCEL EM /storage/app
BeerExport.php
<?php
namespace App\Exports;
use Maatwebsite\Excel\Concerns\FromCollection;
class BeerExport implements FromCollection
{
    public function __construct(
        private array $reportData
    ){}
    /**
    * @return \Illuminate\Support\Collection
    */
    public function collection()
    {
       return collect($this->reportData);
    }
}
*****************************
BeerController.php
<?php
namespace App\Http\Controllers;
use App\Exports\BeerExport;
use App\Http\Requests\BeerRequest;
use App\Services\PunkapiService;
use Maatwebsite\Excel\Facades\Excel;
class BeerController extends Controller
{
    public function index( BeerRequest $request, PunkapiService $service)
    {
        return $service->getBeers(...$request->all());
    }
    public function export(BeerRequest $request, PunkapiService $service)
    {
        $beers = $service->getBeers(...$request->validated());
        $filteredBeers = collect($beers)->map(function($value, $key){
        return collect($value)
                ->only(['name', 'tagline', 'first_brewed', 'description'])
                ->toArray();
    })->toArray();
    //dd($filteredBeers);
      $params = [
        ['name' => 'Tom', 'age' => '30'],
        ['name' => 'Virgu', 'age' => '27']
       ];
       Excel::store(new BeerExport($filteredBeers), 'olw-report.xlsx');
           return "Relatório criado";
    }
}
PARA SALVAR O ARQUIVO EXCEL EM UM STORAGE S3:
ALTERA BeerController.php
<?php
namespace App\Http\Controllers;
use App\Exports\BeerExport;
use App\Http\Requests\BeerRequest;
use App\Services\PunkapiService;
use Maatwebsite\Excel\Facades\Excel;
class BeerController extends Controller
{
    public function index( BeerRequest $request, PunkapiService $service)
    {
        return $service->getBeers(...$request->all());
    }
    public function export(BeerRequest $request, PunkapiService $service)
    {
        $beers = $service->getBeers(...$request->validated());
        $filteredBeers = collect($beers)->map(function($value, $key){
        return collect($value)
                ->only(['name', 'tagline', 'first_brewed', 'description'])
                ->toArray();
    })->toArray();
       Excel::store(
            new BeerExport($filteredBeers),
             'olw-report.xlsx',
             's3');
           return "Relatório criado";
    }
}
************
O REPOSITÓRIO DE ARQUIVOS minio:
NO DOCKER COMPOSER TEMOS O minio, um S3 que tem
MINIO_ROOT_USER: 'sail'
MINIO_ROOT_PASSWORD: 'password' e roda na porta 9000
localhost:9000
usuário: sail
senha: password
vamos criar um buncket(uma pasta)
e configurar o .env da raiz da aplicação:
originalmente é assim:
AWS_ACCESS_KEY_ID=
AWS_SECRET_ACCESS_KEY=
AWS_DEFAULT_REGION=us-east-1
AWS_BUCKET=
AWS_USE_PATH_STYLE_ENDPOINT=false
 e acrescentamos as informações para:
AWS_ACCESS_KEY_ID=sail
AWS_SECRET_ACCESS_KEY=password
AWS_DEFAULT_REGION=us-east-1
AWS_BUCKET=local
AWS_ENDPOINT=http://minio:9000
AWS_URL=http://minio:9000/local
AWS_USE_PATH_STYLE_ENDPOINT=true
altera tambem:
FILESYSTEM_DISK=local 
para:
FILESYSTEM_DISK=s3
INSTALAR UMA DEPENDÊNCIA (ADAPTER) PARA FAZER CORRESPONDÊNCIA COM A AWS:
Flysystem 3.x em laravel.com/docs/9.x/upgrade
./vendor/bin/sail composer require -W league/flysystem-aws-s3-v3 "^3.0"
em caso de erro:
 artisan vendor:publish --tag=laravel-assets --ansi --force
.env
APP_NAME=Laravel
APP_ENV=local
APP_KEY=base64:UbVvTP6Cu+LF5GamJdB4dsZZvW05ep4bZqcCEhmiDCg=
APP_DEBUG=true
APP_URL=http://localhost
APP_PORT=8000
# PUNKAPI_BASE_URL="httpadfjkljdsdfdfasf878"
LOG_CHANNEL=stack
LOG_DEPRECATIONS_CHANNEL=null
LOG_LEVEL=debug
DB_CONNECTION=mysql
FORWARD_DB_PORT=3307
DB_HOST=mysql
DB_PORT=3306
DB_DATABASE=olw
DB_USERNAME=sail
DB_PASSWORD=password
BROADCAST_DRIVER=log
CACHE_DRIVER=file
FILESYSTEM_DISK=s3
QUEUE_CONNECTION=sync
SESSION_DRIVER=file
SESSION_LIFETIME=120
MEMCACHED_HOST=memcached
REDIS_HOST=redis
REDIS_PASSWORD=null
REDIS_PORT=6379
MAIL_MAILER=smtp
MAIL_HOST=mailhog
MAIL_PORT=1025
MAIL_USERNAME=null
MAIL_PASSWORD=null
MAIL_ENCRYPTION=null
MAIL_FROM_ADDRESS="hello@example.com"
MAIL_FROM_NAME="${APP_NAME}"
AWS_ACCESS_KEY_ID=sail
AWS_SECRET_ACCESS_KEY=password
AWS_DEFAULT_REGION=us-east-1
AWS_BUCKET=local
AWS_ENDPOINT=http://minio:9000
AWS_URL=http://minio:9000/local
AWS_USE_PATH_STYLE_ENDPOINT=true
PUSHER_APP_ID=
PUSHER_APP_KEY=
PUSHER_APP_SECRET=
PUSHER_HOST=
PUSHER_PORT=443
PUSHER_SCHEME=https
PUSHER_APP_CLUSTER=mt1
VITE_PUSHER_APP_KEY="${PUSHER_APP_KEY}"
VITE_PUSHER_HOST="${PUSHER_HOST}"
VITE_PUSHER_PORT="${PUSHER_PORT}"
VITE_PUSHER_SCHEME="${PUSHER_SCHEME}"
VITE_PUSHER_APP_CLUSTER="${PUSHER_APP_CLUSTER}"
PRONTO. ENVIANDO PARA O MINIO.
### /**** ABAIXO AULA DE FRONT END -> FALTA
virgu 3a. aula seed model factory
olw# sail art make:migration create_history_table
/olw# sail art make:model Export -mr
/olw# sail art migrate:fresh --seed ->
 
/***********************************************************
QUINTA FEIRA: 20/10/22
Open Laravel Week | Deploy com Terraform, EC2 e RDS | Fermentação
****
https://portal.aws.amazon.com/billing/signup?nc2=h_ct&src=header_signup&redirect_url=https%3A%2F%2Faws.amazon.com%2Fregistration-confirmation&language=pt_br#/start/email
Com terraform pode mudar de infra e configurar no git.
PROGRMAR A CONFIGURAÇÃO DO SERVIDOR: É basicamente construir uma nova aplicação para fazer isso, mais fácil de entender.
Terraform serve para (linguagem HCL -> linguagem própria - linguagem descritiva, descreve o resultado e não como irá ser feito), ou seja, descrever o que queremos.
Terraspace é o framework pra terraform.
Quando criamos o Terraform, ele pode variar conforme a infra cloud (aws, azure, google cloud). sua estrutura é a mesma para todos. mas cada provider tem a sua forma de usar, não consegue usar o mesmo código para mais de uma cloud.
Vamos rodar Terraform via container:
1. clonar do git: git clone 
Criar uma pasta para a infraestrutura
sail   (script que vamos usar)
#!/usr/bin/env bash
docker run -rm -it
    -u $(id -u):$(id -g) \
    -v $PWD:/workspace \
    -w /workspace
    hashicorp/terraform:light "%@"
    <no terminal
Logar em: aws.amazon.com
busca: iam
iam dashboard -> mysecurity credencials (root user) -> Acces keys ->clicar em create access keys -> salva o access key e secret access key
e coloca no arquivo credencials na maquina local.. .aws/credencials
//////////////////////////////////////////////////////////////////////////////////////////////////////
CONTEÚDO QUE FALTA ORGANIZAR:
/**************************************/
sail share
sail artisan sail:publish ->coloca em uma pasta na raiz chamada docker
sail --help
sail artisan optimizer:clear
sail ps
sail build --no-cache -> faz o bild da aplicação. (dá um sail down  por precaução antes.)
/*********************************
root@DELLAGS:~# curl -s "https://laravel.build/laravel-9-course?with=mysql,redis,mailhog" | bash
Dockerfile
root@DELLAGS:~/example-app# docker exec -it example-app-mysql-1 bash
FROM wyveo/nginx-php-fpm:latest
WORKDIR /usr/share/nginx
RUN rm -rf /usr/share/nginx/html
COPY . /usr/share/nginx
RUN chmod -R 755 /usr/share/nginx/storage/*
RUN ln -s public html
.env (do composer)
DB_CONNECTION=mysql
DB_HOST=mysql-app (serviço do mysql no docker-compose.yaml)
DB_PORT=3306
DB_DATABASE=laraveldockerdb
DB_USERNAME=root
DB_PASSWORD=123456
docker-compose.yaml
version: '3'
services:
  laraveldocker-app:
    build: .
    ports:
      - "3003:80"
    volumes:
      - ./:/usr/share/nginx
      - .docker/nginx:/etc/nginx/conf.d/
    networks:
      - app-network
  mysql-app:
    image: mysql:5.7.22
    ports:
      - "3306:3306"
    volumes:
      - .docker/dbdata:/var/lib/mysql
    environment:
      MYSQL_DATABASE: laraveldocker
      MYSQL_ROOT_PASSWORD: 123456
    networks:
      - app-network
networks:
  app-network:
    driver: bridge
    
/*************************************************
#criando um serviço com um nome qualquer
version: '3'
services:
  laravel-app:                    #criando um serviço com um nome qualquer
    build: . ou image: wyveo/nginx-php-fpm:latest -> neste caso sem Dockerfile.                    # endereço da imagem ou local do Dockerfile (neste caso o ponto siginifica a raiz do projeto)
    ports:
      - "8080:80"                 # 8080 porta do meu host: 80 é a porta do docker nginx
    volumes:                      # docker-compose up -d -> sobe a imagem e libera o terminal  
      - ./:/usr/share/nginx       # TUDO QUE ESTIVE NA RAIZ (na rais tem o meu projeto laravel) './' IRÁ SER REFLETIDO NA PASTA /usr/share/nginx (pasta de acesso da página html)
                                  # C:\Laravel-docker\laravel-docker>docker compose up -d --build atualiza a minha imagem
  mysql-app:
      image: mysql:5.7
      ports:
        - "3306:3306"
      volumes:
        - .docker/dbdata:/var/lib/mysql          # qualqer nome (para persistir -guardar os dados do banco de dados)
      environment:
        MYSQL_DATABASE: laravel
        MYSQL_ROOT_PASSWORD: laravel
    
      
      /***************************///
  
C:\Laravel-docker\laravel-docker>docker compose up -d --build
                                
                               
    
/******************************** Dockerfile
FROM wyveo/nginx-php-fpm:latest
/***************************///
  COMANDOS
docker compose down -> para todos os containers
C:\Laravel-docker\laravel-docker>docker exec -it laravel-docker-laravel-app-1 bash 
root@612ea0ea3340:/# cd /usr/share/nginx/
root@612ea0ea3340:/usr/share/nginx# php artisan migrate
root@612ea0ea3340:/usr/share/nginx# php artisan serve
        
/***********/
PS C:\Users\alber> docker run -e MYSQL_ROOT_PASSWORD=root --name meu-mysql -d mysql:5.7
docker inspect meu-mysql ou | grep IPAddress
PS C:\Users\alber> docker run -e MYSQL_ROOT_PASSWORD=root --name meu-mysql -d -p 3306:3306 mysql:5.7
docker ps
docker ps -l
docker ps -a
docker rm -f nome
/*** LARAVEL */
### CRIANDO UM PROJETO NO LARAVEL 
laravel new projeto_laravel_via_installer (ESTA É UM AOPÇÃO)
composer create-project --prefer-dist laravel/laravel app_controle_tarefas "8.5.9"
cd app_controle_tarefas
cd public
php -S localhost:8000
ou 
da raiz do projeto:
php artisan serve 
ou
php artisan serve --port=3000
### PARA ABRIR PORTA EM OUTRO SERVIDOR
php artisan serve --host test.com --port 8080
 **********************************************************************
cd app_controle_tarefas
cd public
php artisan serve
- acessa o navegador http://localhost:8000
### DENTRO DO PROJETO CRIADO INSTALAR O LARAVEL/UI:^3.2 - versão 3.2
composer require laravel/ui:^3.2
### SE OCORRER ERRO AUMENTAR A MEMÓRIA DISPONIVEL PARA O php
-php --ini -> localiza o arquivo de configuração do php
LOCALIZA memory_limit = 1000 e altera para 
         memory_limit  = -1 e Salva
### LISTA A RELAÇÃO DE COMANDOS 
php artisan list 
DEVERA SURGIR AS OPÇÕES ABAIXO:
 ui
  ui:auth               Scaffold basic login and registration views and routes
  ui:controllers        Scaffold the authentication controllers
 vendor
### ENTENDENDO O PACOTE UI E INICIANDO A AUTENTICAÇÃO WEB NATIVA DO LARAVEL
COMANDO PARA LISTAR ROUTES: 
php artisan route:list
### php artisan ui bootstrap --auth (bootstrap ou react ou vue)
aplicando o bootstrap incluindo os recursos de autenticação;
poderia ser aplicado o bootstrap sem os recursos de autenticação;
### php artisan route:list -> mostra as rotas - ver que aumentaram as rotas
### APÓS ESSE PROCESSO O SISTEMA PEDE PARA RODAR
npm install -> instala as dependências do package.json (inclusive o bootstrap)
npm run dev -> gera os assets da aplicação de acordo com a tecnologia selecionada (bootstrap, react ou vue) -> Geralmente roda mais de uma vez para compilar tudo.
### CRIA O BANCO DE DADOS NORMALMENTE
### EXECUTA AS MIGRATIONS PADRÕES CRIADAS PARA O SISTEMA DE login
php artisan migrate -> CRIA AS TABELAS NO BANCO DE DADOS
************************************** 
INSTALANDO O COMPOSER NO UBUNTU
**************************************
sudo apt update
sudo apt install php-cli unzip
cd ~
curl -sS https://getcomposer.org/installer -o composer-setup.php
HASH=`curl -sS https://composer.github.io/installer.sig`

echo $HASH ->saída: Output
e0012edf3e80b6978849f5eff0d4b4e4c79ff1609dd1e613307e16318854d24ae64f26d17af3ef0bf7cfb710ca74



php -r "if (hash_file('SHA384', 'composer-setup.php') === '$HASH') { echo 'Installer verified'; } else { echo 'Installer corrupt'; unlink('composer-setup.php'); } echo PHP_EOL;"

sudo php composer-setup.php --install-dir=/usr/local/bin --filename=composer





***********************

DigitalOcean Kubernetes: novo plano de controle é mais rápido e gratuito, habilita HA para SLA de 99,95% de tempo de atividade
Produtos
Preços

Documentos
divisa suspensa

Entrar
divisa suspensa

// Tutorial //
Como Instalar e Utilizar o Composer no Ubuntu 20.04
Publicado em 21 de maio de 2020
Ubuntu
PHP
Ubuntu 20.04
Avatar padrão
Por Erika Heidi
Advogado Desenvolvedor
Português
Como Instalar e Utilizar o Composer no Ubuntu 20.04
Introdução
O Composer é uma ferramenta popular de gerenciamento de dependências para o PHP, criado para facilitar a instalação e a atualização das dependências principalmente do projeto. Ele controla quais outros pacotes de projeto específico dependem e são instalados para você, usando as opções apropriadas de acordo com os requisitos do projeto. O Composer também é comumente utilizado para inicializar novos projetos em frameworks PHP populares, como o Symfon e o Laravel .

Neste tutorial, você instalará e começará a usar o Composer em um sistema Ubuntu 20.04.

Pré-requisitos
Para seguir este guia, você pode acessar um servidor como usuário Ubuntu20.04 como usuário sudonão-root um firewall habilitado em seu servidor Para configurar isto, siga nosso guia Configuração do servidor inicial para o Ubuntu 20.04

Passo 1 — Instalando o PHP e as Dependências Adicionais
Além das dependências que já devem estar incluídas em seu sistema Ubuntu 20.04, como o , o Composer exige ou gitexecuta scripts PHP na linha de comando e para extrair arquivos zipados. Vamos instalar essas dependências agora.curlphp-cliunzip

primeiro, atual, gerenciador de pacotes de soluções: o cache do gerenciador de pacotes

sudo apt update
Em seguida, o seguinte comando para instalar os pacotes, execute:

sudo apt install php-cli unzip
Você será solicitado a confirmar a instalação digitando Ye, depois, ENTER.

Assim que os pré-requisitos para instalação do Composer forem instalados, você poderá seguir.

Passo 2 — Baixando e Instalando o Compositor
O Composer fornece um instalador de script escrito em PHP. Vamos baixá-lo, verificar se ele não está danificado e, em seguida, o usaremos para instalar o Composer.

Certifique-se de estar em sua pasta home. Em seguida, baixe o instalador usando o curl:

cd ~
curl -sS https://getcomposer.org/installer -o composer-setup.php
Em seguida, vamos verificar se o instalador baixado corresponde ao hash SHA-384 para o instalador mais recente encontrado na página Composer Public Keys / Signatures . Para facilitar o passo de seleção, você pode usar o seguinte comando para obter programaticamente o hash mais recente da página do Composer e armazená-lo em uma variável do shell:

HASH=`curl -sS https://composer.github.io/installer.sig`
Se você quiser verificar o valor realizado, execute:

echo $HASH
Output
e0012edf3e80b6978849f5eff0d4b4e4c79ff1609dd1e613307e16318854d24ae64f26d17af3ef0bf7cfb710ca74755a
Agora o código PHP a seguir, execute conforme a página de download do Composer, para verificar se o script de instalação está seguro para ser executado:

php -r "if (hash_file('SHA384', 'composer-setup.php') === '$HASH') { echo 'Installer verified'; } else { echo 'Installer corrupt'; unlink('composer-setup.php'); } echo PHP_EOL;"
Você verá o seguinte resultado:

Resultado
Installer verified
Se Installer corruptvocê estiver usando o hash correto, verifique se você está usando o hash correto. Em seguida, repita o processo de verificação. Quando você tiver um instalador selecionado, você pode continuar.

Para instalar o composerglobalmente, use o seguinte comando que baixará e instalará o Composer como um comando disponível em todo o sistema chamado composer, sob /usr/local/bin:

sudo php composer-setup.php --install-dir=/usr/local/bin --filename=composer
Você verá um resultado semelhante com este:

Output
All settings correct for using Composer
Downloading...

Composer (version 1.10.5) successfully installed to: /usr/local/bin/composer
Use it: php /usr/local/bin/composer
Para testar sua instalação, execute:

composer
Output
   ______
  / ____/___  ____ ___  ____  ____  ________  _____
 / /   / __ \/ __ `__ \/ __ \/ __ \/ ___/ _ \/ ___/
/ /___/ /_/ / / / / / / /_/ / /_/ (__  )  __/ /
\____/\____/_/ /_/ /_/ .___/\____/____/\___/_/
                    /_/
Composer version 1.10.5 2020-04-10 11:44:22
Usage:
  command [options] [arguments]
Options:
  -h, --help                     Display this help message
  -q, --quiet                    Do not output any message
  -V, --version                  Display this application version
      --ansi                     Force ANSI output
      --no-ansi                  Disable ANSI output
  -n, --no-interaction           Do not ask any interactive question
      --profile                  Display timing and memory usage information
      --no-plugins               Whether to disable plugins.
  -d, --working-dir=WORKING-DIR  If specified, use the given directory as working directory.
      --no-cache                 Prevent use of the cache
  -v|vv|vvv, --verbose           Increase the verbosity of messages: 1 for normal output, 2 for more verbose output and 3 for debug
...
Isso verifica que o Composer foi instalado com sucesso em seu sistema e está disponível em todo o sistema.
Nota: se você preferirá ter-lhe-ão separados separados do Composer para projeto hospedado neste servidor, você pode instalar localmente, em uma base por projeto. Este método também é útil quando o usuário do sistema não possui permissão para instalar o software disponível em todo o sistema.
Para fazer isso, use o comando php composer-setup.php. Isso irá gerar um arquivo composer.pharem seu diretório atual, que pode ser executado com o seu atual php composer.phar.
Agora podemos dar uma dependência em como usar o Compose como gerenciar.
Passo 3 — Usando o Compositor em um Projeto PHP
Os projetos PHP geralmente dependentes de bibliotecas externas, e o gerenciamento de dependências e suas versões podem ser complicados. O Composer resolve esse problema de manter um controle de projeto de extensões e dependências, também facilita o processo de descoberta, instalação e atualização de pacotes que são definidos por enquanto.
Para usar o seu projeto, você pode compor um arquivo composer.json. O arquivo composer.jsonComposer quais dependências precisa para baixar seu projeto quais serão as versões de cada pacote tem permissão para instalações e instalações. Isso é muito importante para manter seu projeto consistente e evitar a instalação de versões instáveis ​​que podem causar problemas de compatibilidade retroativa.
Você não precisa criar este arquivo manualmente - é comum ocorrer erros de sintaxe quando fizer isso. O Composer oferece uma maneira de criar um novo arquivo composer.jsoncom base na entrada do usuário, o que é uma boa escolha se você planeja compartilhar seu projeto mais tarde como um pacote público no Packagist . O Composer gera automaticamente um arquivo básico composer.jsonquando você executa um comando composer requirepara incluir uma dependência em um projeto recém-criado.
O processo de uso do Composer para instalar um pacote como uma dependência em um projeto envolve os passos a seguir:
Identifique o tipo de biblioteca que o aplicativo precisa.
uma biblioteca de código aberto adequada no agist.org , o responsável oficial de pacotes para o Compose.
Escolha o pacote de dependência.
Execute composer requirepara incluir a dependência no arquivo composer.jsone instalar o pacote.
Vamos testar isso com uma aplicação de demonstração.
O objetivo desta aplicação é transformar uma determinação determinada em uma string de URL amigável - um slug . Isso é comumente usado para converter os títulos de página para caminhos de URL (Assim como a parte final da URL para este tutorial).
Vamos começar a criar um diretório para o nosso projeto. Vamos chamá-lo de slugify :
cd ~
mkdir slugify
cd slugify
Embora não seja necessário, você pode executar agora um comando composer init para criar um arquivo composer.json detalhado para seu projeto. Como o único objetivo do nosso projeto é demonstrar como instalar dependências com o Composer, usaremos um arquivo composer.json mais simples que será gerado automaticamente quando exigirmos nosso primeiro pacote.
Agora é hora de procurar no Packagist.org por um pacote que pode nos ajudar a gerar slugs. Se você procurar pelo termo “slug” no Packagist, receberá um resultado parecido com este:
Resultados da Pesquisa do Packagist para o termo "slug"
Você verá dois números no lado direito de cada pacote na lista. O número no topo representa quantas vezes o pacote foi instalado através do Composer, e o número em baixo mostra quantas vezes um pacote foi estrelado no GitHub. De um modo geral, os pacotes com mais instalações e mais estrelas tendem a ser mais estáveis, pois mais pessoas os utilizam. Também é importante verificar a descrição do pacote para relevância para garantir que ele é o que você precisa.
Precisamos de um conversor string-to-slug A partir dos resultados da pesquisa, o pacote cocur/slugify, que aparece como o primeiro resultado naquela página, parece ser um bom candidato, com uma quantidade razoável de instalações e estrelas.
Os pacotes no Packagist têm um nome de vendor e um nome de package. Cada pacote tem um identificador único (um namespace) no mesmo formato que o GitHub utiliza para seus repositórios: vendor/package. A biblioteca que queremos instalar utiliza o namespace cocur/slugify. Você precisa de um namespace do pacote para exigi-lo em seu projeto.
Agora que você sabe exatamente qual pacote deseja instalar, você pode executar o composer require para incluí-lo como uma dependência e gerar também o arquivo composer.json para seu projeto. Uma coisa importante é observar a exigência de pacotes. O Composer rastreia as dependências no nível da aplicação e do sistema. As dependências no nível do sistema são importantes para indicar de quais módulos PHP um pacote depende. No caso do pacote cocur/slugify, ele exige um módulo PHP que ainda não instalamos.
Quando um pacote necessário depende de uma biblioteca de sistema que não está atualmente instalada em seu servidor, você receberá um erro informando qual requisito está faltando:
composer require cocur/slugify
Output
Using version ^4.0 for cocur/slugify
./composer.json has been updated
Loading composer repositories with package information
Updating dependencies (including require-dev)
Your requirements could not be resolved to an installable set of packages.
  Problem 1
    - Installation request for cocur/slugify ^4.0 -> satisfiable by cocur/slugify[v4.0.0].
    - cocur/slugify v4.0.0 requires ext-mbstring * -> the requested PHP extension mbstring is missing from your system.
...
Para resolver o problema de dependência do sistema, podemos procurar pelo pacote que falta usando o apt search:
apt search mbstring
Output
Sorting... Done
Full Text Search... Done
php-mbstring/focal 2:7.4+75 all
  MBSTRING module for PHP [default]
php-patchwork-utf8/focal 1.3.1-1 all
  UTF-8 strings handling for PHP
php7.4-mbstring/focal 7.4.3-4ubuntu1 amd64
  MBSTRING module for PHP
Após localizar o nome do pacote correto, você pode utilizar o apt novamente para instalar a dependência de sistema:
sudo apt install php-mbstring
Assim que a instalação terminar, você pode executar novamente o comando composer require:
composer require cocur/slugify
Output
Using version ^4.0 for cocur/slugify
./composer.json has been created
Loading composer repositories with package information
Updating dependencies (including require-dev)
Package operations: 1 install, 0 updates, 0 removals
  - Installing cocur/slugify (v4.0.0): Downloading (100%)         
Writing lock file
Generating autoload files
Como você pode ver na saída, o Composer decidiu automaticamente qual versão do pacote utilizar. Se você verificar o diretório do seu projeto agora, ele irá conter dois arquivos novos: composer.json e composer.lock, e um diretório vendor:
ls -l
Output
total 12
-rw-rw-r-- 1 sammy sammy   59 May  4 13:56 composer.json
-rw-rw-r-- 1 sammy sammy 3229 May  4 13:56 composer.lock
drwxrwxr-x 4 sammy sammy 4096 May  4 13:56 vendor
O arquivo composer.lock é usado para armazenar informações sobre quais versões de cada pacote estão instaladas, e garantir que as mesmas versões sejam usadas se outra pessoa clonar seu projeto e instalar suas dependências. O diretório vendor é onde as dependências do projeto estão localizadas. Você não deve fazer commit da pasta vendor no controle de versão - você precisa apenas incluir os arquivos composer.json e composer.lock.
Ao instalar um projeto que já contém um arquivo composer.json, execute o composer install para baixar as dependências do projeto.
Vamos dar uma olhada rápida em restrições de versão. Se você verificar o conteúdo do seu arquivo composer.json, verá algo parecido com isto:
cat composer.json
Output
{
    "require": {
        "cocur/slugify": "^4.0"
    }
}
Note que há o caractere especial ^ antes do número da versão no composer.json. O Composer suporta várias restrições diferentes e formatos para definir a versão necessária do pacote, para fornecer flexibilidade enquanto também mantém seu projeto estável. O operador circunflexo (^) utilizado pelo arquivo composer.json criado automaticamente é o operador recomendado para a interoperabilidade máxima, seguindo o versionamento semântico. Neste caso, ele define 4.0 como a versão mínima compatível e permite atualizações para qualquer versão futura abaixo de 5.0.
De um modo geral, você não precisará alterar as restrições de versão em seu arquivo composer.json. No entanto, algumas situações podem exigir que você edite manualmente as restrições – por exemplo, quando uma nova versão principal da sua biblioteca requerida é liberada e você deseja atualizar, ou quando a biblioteca que você deseja usar não segue o versionamento semântico.
Aqui estão alguns exemplos para lhe dar um melhor entendimento sobre como as restrições de versão do Composer funcionam:
Restrição   Significado Exemplo de Versões Permitidas
^1.0    >= 1.0 < 2.0    1.0, 1.2.3, 1.9.9
^1.1.0  >= 1.1.0 < 2.0  1.1.0, 1.5.6, 1.9.9
~1.0    >= 1.0 < 2.0.0  1.0, 1.4.1, 1.9.9
~1.0.0  >= 1.0.0 < 1.1  1.0.0, 1.0.4, 1.0.9
1.2.1   1.2.1   1.2.1
1.* >= 1.0 < 2.0    1.0.0, 1.4.5, 1.9.9
1.2. *  >= 1.2 < 1.3    1.2.0, 1.2.3, 1.2.9
Para uma visualização mais detalhada das restrições de versão do Composer, consulte a documentação oficial.
A seguir, vamos ver como carregar dependências automaticamente com o Composer.
Passo 4 — Incluindo o Script Autoload
Como o PHP por si só não carrega classes automaticamente, o Composer fornece um script autoload que você pode incluir em seu projeto para obter o carregamento automático para ele. Este arquivo é gerado automaticamente pelo Composer quando você adiciona sua primeira dependência.
A única coisa que você precisa fazer é incluir o arquivo vendor/autoload.php em seus scripts PHP antes de qualquer instância de classe.
Vamos testar isso em nossa aplicação de demonstração. Abra um novo arquivo chamado test.php em seu editor de texto:
nano test.php
Adicione o código a seguir que vem no arquivo vendor/autoload.php, carrega a dependência cocur/slugify, e o utiliza para criar um slug:
test.php
<?php
require __DIR__ . '/vendor/autoload.php';
use Cocur\Slugify\Slugify;
$slugify = new Slugify();
echo $slugify->slugify('Hello World, this is a long sentence and I need to make a slug from it!');
Salve o arquivo e saia do seu editor.
Agora, execute o script.
php test.php
Isso produz a saída hello-world-this-is-a-long-sentence-and-i-need-to-make-a-slug-from-it.
As dependências precisam de atualizações quando novas versões são liberadas. Dessa forma, vamos ver como lidar com isso.
Passo 5 — Atualizando as Dependências do Projeto
Sempre que você quiser atualizar suas dependências do projeto para versões mais recentes, execute o comando update:
composer update
Isso irá verificar por versões mais recentes das bibliotecas que você requer em seu projeto. Se uma versão mais recente for encontrada e ela for compatível com a restrição de versão definida no arquivo composer.json, o Composer substituirá a versão anterior instalada. O arquivo composer.lock será atualizado para refletir essas alterações.
Você também pode atualizar uma ou mais bibliotecas específicas, especificando-as desta forma:
composer update vendor/package vendor2/package2
Certifique-se de verificar em seus arquivos composer.json e composer.lock dentro do seu sistema de controle de versão após atualizar suas dependências de modo que outros também possam instalar essas versões mais recentes.
Conclusão
***********
Algoritmo "CalculoMedia2"
// Disciplina: Lógica de programação
// Professor : Antonio Carlos Nicolodi
// Descrição : calculo da média aritimética
// Autor     : Professor Antonio
// Data atual: 01/04/2015
var
// Seção de Declarações
   v1, v2, total: Real
   sinal : Caracter
Inicio
// Seção dos Comandos
   Escreva ("Digite o primeiro valor: ")
   Leia (v1)
   Escreva ("Digite a operação + - * / : ")
   Leia (sinal)
   Escreva ("Digite o segundo valor: ")
   Leia (v2)
   Se sinal = "+" entao
   total <- v1 + v2
   Escreva("O Resultado é: ", total)
   Senao
   Se sinal = "-" entao
   total <- v1 - v2
   Escreva("O Resultado é: ", total)
   Senao
   Se sinal = "*" entao
   total <- v1 * v2
   Escreva("O Resultado é: ", total)
   Senao
     Escreva("OPERAÇÃO INVÁLIDA! ")
      Escreval("total")
   fimse
Fimalgoritmo
****
COMANDOS DOCKER
root@DELLAGS:~# curl -s "https://laravel.build/laravel-9-course?with=mysql,redis,mailhog" | bash
root@DELLAGS:~/example-app# ./vendor/bin/sail  artisan migrate --seed -> criar o banco de dados e copular dados;
Dockerfile
root@DELLAGS:~/example-app# docker exec -it example-app-mysql-1 bash
FROM wyveo/nginx-php-fpm:latest
WORKDIR /usr/share/nginx
RUN rm -rf /usr/share/nginx/html
COPY . /usr/share/nginx
RUN chmod -R 755 /usr/share/nginx/storage/*
RUN ln -s public html
.env (do composer)
DB_CONNECTION=mysql
DB_HOST=mysql-app (serviço do mysql no docker-compose.yaml)
DB_PORT=3306
DB_DATABASE=laraveldockerdb
DB_USERNAME=root
DB_PASSWORD=123456
docker-compose.yaml
version: '3'
services:
  laraveldocker-app:
    build: .
    ports:
      - "3003:80"
    volumes:
      - ./:/usr/share/nginx
      - .docker/nginx:/etc/nginx/conf.d/
    networks:
      - app-network
  mysql-app:
    image: mysql:5.7.22
    ports:
      - "3306:3306"
    volumes:
      - .docker/dbdata:/var/lib/mysql
    environment:
      MYSQL_DATABASE: laraveldocker
      MYSQL_ROOT_PASSWORD: 123456
    networks:
      - app-network
networks:
  app-network:
    driver: bridge
    
/*************************************************
#criando um serviço com um nome qualquer
version: '3'
services:
  laravel-app:                    #criando um serviço com um nome qualquer
    build: . ou image: wyveo/nginx-php-fpm:latest -> neste caso sem Dockerfile.                    # endereço da imagem ou local do Dockerfile (neste caso o ponto siginifica a raiz do projeto)
    ports:
      - "8080:80"                 # 8080 porta do meu host: 80 é a porta do docker nginx
    volumes:                      # docker-compose up -d -> sobe a imagem e libera o terminal  
      - ./:/usr/share/nginx       # TUDO QUE ESTIVE NA RAIZ (na rais tem o meu projeto laravel) './' IRÁ SER REFLETIDO NA PASTA /usr/share/nginx (pasta de acesso da página html)
                                  # C:\Laravel-docker\laravel-docker>docker compose up -d --build atualiza a minha imagem
  mysql-app:
      image: mysql:5.7
      ports:
        - "3306:3306"
      volumes:
        - .docker/dbdata:/var/lib/mysql          # qualqer nome (para persistir -guardar os dados do banco de dados)
      environment:
        MYSQL_DATABASE: laravel
        MYSQL_ROOT_PASSWORD: laravel
    
      
      /***************************///
  
C:\Laravel-docker\laravel-docker>docker compose up -d --build
                                
                               
    
/******************************** Dockerfile
FROM wyveo/nginx-php-fpm:latest
/***************************///
  COMANDOS
docker compose down -> para todos os containers
C:\Laravel-docker\laravel-docker>docker exec -it laravel-docker-laravel-app-1 bash 
root@612ea0ea3340:/# cd /usr/share/nginx/
root@612ea0ea3340:/usr/share/nginx# php artisan migrate
root@612ea0ea3340:/usr/share/nginx# php artisan serve
        
/***********/
PS C:\Users\alber> docker run -e MYSQL_ROOT_PASSWORD=root --name meu-mysql -d mysql:5.7
docker inspect meu-mysql ou | grep IPAddress
PS C:\Users\alber> docker run -e MYSQL_ROOT_PASSWORD=root --name meu-mysql -d -p 3306:3306 mysql:5.7
docker ps
docker ps -l
docker ps -a
docker rm -f nome
/*** LARAVEL */
### CRIANDO UM PROJETO NO LARAVEL 
laravel new projeto_laravel_via_installer (ESTA É UM AOPÇÃO)
composer create-project --prefer-dist laravel/laravel app_controle_tarefas "8.5.9"
cd app_controle_tarefas
cd public
php -S localhost:8000
ou 
da raiz do projeto:
php artisan serve 
ou
php artisan serve --port=3000
### PARA ABRIR PORTA EM OUTRO SERVIDOR
php artisan serve --host test.com --port 8080
 **********************************************************************
cd app_controle_tarefas
cd public
php artisan serve
- acessa o navegador http://localhost:8000
### DENTRO DO PROJETO CRIADO INSTALAR O LARAVEL/UI:^3.2 - versão 3.2
composer require laravel/ui:^3.2
### SE OCORRER ERRO AUMENTAR A MEMÓRIA DISPONIVEL PARA O php
-php --ini -> localiza o arquivo de configuração do php
LOCALIZA memory_limit = 1000 e altera para 
         memory_limit  = -1 e Salva
### LISTA A RELAÇÃO DE COMANDOS 
php artisan list 
DEVERA SURGIR AS OPÇÕES ABAIXO:
 ui
  ui:auth               Scaffold basic login and registration views and routes
  ui:controllers        Scaffold the authentication controllers
 vendor
### ENTENDENDO O PACOTE UI E INICIANDO A AUTENTICAÇÃO WEB NATIVA DO LARAVEL
COMANDO PARA LISTAR ROUTES: 
php artisan route:list
### php artisan ui bootstrap --auth (bootstrap ou react ou vue)
aplicando o bootstrap incluindo os recursos de autenticação;
poderia ser aplicado o bootstrap sem os recursos de autenticação;
### php artisan route:list -> mostra as rotas - ver que aumentaram as rotas
### APÓS ESSE PROCESSO O SISTEMA PEDE PARA RODAR
npm install -> instala as dependências do package.json (inclusive o bootstrap)
npm run dev -> gera os assets da aplicação de acordo com a tecnologia selecionada (bootstrap, react ou vue) -> Geralmente roda mais de uma vez para compilar tudo.
### CRIA O BANCO DE DADOS NORMALMENTE
### EXECUTA AS MIGRATIONS PADRÕES CRIADAS PARA O SISTEMA DE login
php artisan migrate -> CRIA AS TABELAS NO BANCO DE DADOS
************************************** 
INSTALANDO O COMPOSER NO UBUNTU
**************************************
sudo apt update
sudo apt install php-cli unzip
cd ~
curl -sS https://getcomposer.org/installer -o composer-setup.php
HASH=`curl -sS https://composer.github.io/installer.sig`

echo $HASH ->saída: Output
e0012edf3e80b6978849f5eff0d4b4e4c79ff1609dd1e613307e16318854d24ae64f26d17af3ef0bf7cfb710ca74



php -r "if (hash_file('SHA384', 'composer-setup.php') === '$HASH') { echo 'Installer verified'; } else { echo 'Installer corrupt'; unlink('composer-setup.php'); } echo PHP_EOL;"

sudo php composer-setup.php --install-dir=/usr/local/bin --filename=composer





***********************

DigitalOcean Kubernetes: novo plano de controle é mais rápido e gratuito, habilita HA para SLA de 99,95% de tempo de atividade
Produtos
Preços

Documentos
divisa suspensa

Entrar
divisa suspensa

// Tutorial //
Como Instalar e Utilizar o Composer no Ubuntu 20.04
Publicado em 21 de maio de 2020
Ubuntu
PHP
Ubuntu 20.04
Avatar padrão
Por Erika Heidi
Advogado Desenvolvedor
Português
Como Instalar e Utilizar o Composer no Ubuntu 20.04
Introdução
O Composer é uma ferramenta popular de gerenciamento de dependências para o PHP, criado para facilitar a instalação e a atualização das dependências principalmente do projeto. Ele controla quais outros pacotes de projeto específico dependem e são instalados para você, usando as opções apropriadas de acordo com os requisitos do projeto. O Composer também é comumente utilizado para inicializar novos projetos em frameworks PHP populares, como o Symfon e o Laravel .

Neste tutorial, você instalará e começará a usar o Composer em um sistema Ubuntu 20.04.

Pré-requisitos
Para seguir este guia, você pode acessar um servidor como usuário Ubuntu20.04 como usuário sudonão-root um firewall habilitado em seu servidor Para configurar isto, siga nosso guia Configuração do servidor inicial para o Ubuntu 20.04

Passo 1 — Instalando o PHP e as Dependências Adicionais
Além das dependências que já devem estar incluídas em seu sistema Ubuntu 20.04, como o , o Composer exige ou gitexecuta scripts PHP na linha de comando e para extrair arquivos zipados. Vamos instalar essas dependências agora.curlphp-cliunzip

primeiro, atual, gerenciador de pacotes de soluções: o cache do gerenciador de pacotes

sudo apt update
Em seguida, o seguinte comando para instalar os pacotes, execute:

sudo apt install php-cli unzip
Você será solicitado a confirmar a instalação digitando Ye, depois, ENTER.

Assim que os pré-requisitos para instalação do Composer forem instalados, você poderá seguir.

Passo 2 — Baixando e Instalando o Compositor
O Composer fornece um instalador de script escrito em PHP. Vamos baixá-lo, verificar se ele não está danificado e, em seguida, o usaremos para instalar o Composer.

Certifique-se de estar em sua pasta home. Em seguida, baixe o instalador usando o curl:

cd ~
curl -sS https://getcomposer.org/installer -o composer-setup.php
Em seguida, vamos verificar se o instalador baixado corresponde ao hash SHA-384 para o instalador mais recente encontrado na página Composer Public Keys / Signatures . Para facilitar o passo de seleção, você pode usar o seguinte comando para obter programaticamente o hash mais recente da página do Composer e armazená-lo em uma variável do shell:

HASH=`curl -sS https://composer.github.io/installer.sig`
Se você quiser verificar o valor realizado, execute:

echo $HASH
Output
e0012edf3e80b6978849f5eff0d4b4e4c79ff1609dd1e613307e16318854d24ae64f26d17af3ef0bf7cfb710ca74755a
Agora o código PHP a seguir, execute conforme a página de download do Composer, para verificar se o script de instalação está seguro para ser executado:

php -r "if (hash_file('SHA384', 'composer-setup.php') === '$HASH') { echo 'Installer verified'; } else { echo 'Installer corrupt'; unlink('composer-setup.php'); } echo PHP_EOL;"
Você verá o seguinte resultado:

Resultado
Installer verified
Se Installer corruptvocê estiver usando o hash correto, verifique se você está usando o hash correto. Em seguida, repita o processo de verificação. Quando você tiver um instalador selecionado, você pode continuar.

Para instalar o composerglobalmente, use o seguinte comando que baixará e instalará o Composer como um comando disponível em todo o sistema chamado composer, sob /usr/local/bin:

sudo php composer-setup.php --install-dir=/usr/local/bin --filename=composer
Você verá um resultado semelhante com este:

Output
All settings correct for using Composer
Downloading...

Composer (version 1.10.5) successfully installed to: /usr/local/bin/composer
Use it: php /usr/local/bin/composer
Para testar sua instalação, execute:

composer
Output
   ______
  / ____/___  ____ ___  ____  ____  ________  _____
 / /   / __ \/ __ `__ \/ __ \/ __ \/ ___/ _ \/ ___/
/ /___/ /_/ / / / / / / /_/ / /_/ (__  )  __/ /
\____/\____/_/ /_/ /_/ .___/\____/____/\___/_/
                    /_/
Composer version 1.10.5 2020-04-10 11:44:22
Usage:
  command [options] [arguments]
Options:
  -h, --help                     Display this help message
  -q, --quiet                    Do not output any message
  -V, --version                  Display this application version
      --ansi                     Force ANSI output
      --no-ansi                  Disable ANSI output
  -n, --no-interaction           Do not ask any interactive question
      --profile                  Display timing and memory usage information
      --no-plugins               Whether to disable plugins.
  -d, --working-dir=WORKING-DIR  If specified, use the given directory as working directory.
      --no-cache                 Prevent use of the cache
  -v|vv|vvv, --verbose           Increase the verbosity of messages: 1 for normal output, 2 for more verbose output and 3 for debug
...
Isso verifica que o Composer foi instalado com sucesso em seu sistema e está disponível em todo o sistema.
Nota: se você preferirá ter-lhe-ão separados separados do Composer para projeto hospedado neste servidor, você pode instalar localmente, em uma base por projeto. Este método também é útil quando o usuário do sistema não possui permissão para instalar o software disponível em todo o sistema.
Para fazer isso, use o comando php composer-setup.php. Isso irá gerar um arquivo composer.pharem seu diretório atual, que pode ser executado com o seu atual php composer.phar.
Agora podemos dar uma dependência em como usar o Compose como gerenciar.
Passo 3 — Usando o Compositor em um Projeto PHP
Os projetos PHP geralmente dependentes de bibliotecas externas, e o gerenciamento de dependências e suas versões podem ser complicados. O Composer resolve esse problema de manter um controle de projeto de extensões e dependências, também facilita o processo de descoberta, instalação e atualização de pacotes que são definidos por enquanto.
Para usar o seu projeto, você pode compor um arquivo composer.json. O arquivo composer.jsonComposer quais dependências precisa para baixar seu projeto quais serão as versões de cada pacote tem permissão para instalações e instalações. Isso é muito importante para manter seu projeto consistente e evitar a instalação de versões instáveis ​​que podem causar problemas de compatibilidade retroativa.
Você não precisa criar este arquivo manualmente - é comum ocorrer erros de sintaxe quando fizer isso. O Composer oferece uma maneira de criar um novo arquivo composer.jsoncom base na entrada do usuário, o que é uma boa escolha se você planeja compartilhar seu projeto mais tarde como um pacote público no Packagist . O Composer gera automaticamente um arquivo básico composer.jsonquando você executa um comando composer requirepara incluir uma dependência em um projeto recém-criado.
O processo de uso do Composer para instalar um pacote como uma dependência em um projeto envolve os passos a seguir:
Identifique o tipo de biblioteca que o aplicativo precisa.
uma biblioteca de código aberto adequada no agist.org , o responsável oficial de pacotes para o Compose.
Escolha o pacote de dependência.
Execute composer requirepara incluir a dependência no arquivo composer.jsone instalar o pacote.
Vamos testar isso com uma aplicação de demonstração.
O objetivo desta aplicação é transformar uma determinação determinada em uma string de URL amigável - um slug . Isso é comumente usado para converter os títulos de página para caminhos de URL (Assim como a parte final da URL para este tutorial).
Vamos começar a criar um diretório para o nosso projeto. Vamos chamá-lo de slugify :
cd ~
mkdir slugify
cd slugify
Embora não seja necessário, você pode executar agora um comando composer init para criar um arquivo composer.json detalhado para seu projeto. Como o único objetivo do nosso projeto é demonstrar como instalar dependências com o Composer, usaremos um arquivo composer.json mais simples que será gerado automaticamente quando exigirmos nosso primeiro pacote.
Agora é hora de procurar no Packagist.org por um pacote que pode nos ajudar a gerar slugs. Se você procurar pelo termo “slug” no Packagist, receberá um resultado parecido com este:
Resultados da Pesquisa do Packagist para o termo "slug"
Você verá dois números no lado direito de cada pacote na lista. O número no topo representa quantas vezes o pacote foi instalado através do Composer, e o número em baixo mostra quantas vezes um pacote foi estrelado no GitHub. De um modo geral, os pacotes com mais instalações e mais estrelas tendem a ser mais estáveis, pois mais pessoas os utilizam. Também é importante verificar a descrição do pacote para relevância para garantir que ele é o que você precisa.
Precisamos de um conversor string-to-slug A partir dos resultados da pesquisa, o pacote cocur/slugify, que aparece como o primeiro resultado naquela página, parece ser um bom candidato, com uma quantidade razoável de instalações e estrelas.
Os pacotes no Packagist têm um nome de vendor e um nome de package. Cada pacote tem um identificador único (um namespace) no mesmo formato que o GitHub utiliza para seus repositórios: vendor/package. A biblioteca que queremos instalar utiliza o namespace cocur/slugify. Você precisa de um namespace do pacote para exigi-lo em seu projeto.
Agora que você sabe exatamente qual pacote deseja instalar, você pode executar o composer require para incluí-lo como uma dependência e gerar também o arquivo composer.json para seu projeto. Uma coisa importante é observar a exigência de pacotes. O Composer rastreia as dependências no nível da aplicação e do sistema. As dependências no nível do sistema são importantes para indicar de quais módulos PHP um pacote depende. No caso do pacote cocur/slugify, ele exige um módulo PHP que ainda não instalamos.
Quando um pacote necessário depende de uma biblioteca de sistema que não está atualmente instalada em seu servidor, você receberá um erro informando qual requisito está faltando:
composer require cocur/slugify
Output
Using version ^4.0 for cocur/slugify
./composer.json has been updated
Loading composer repositories with package information
Updating dependencies (including require-dev)
Your requirements could not be resolved to an installable set of packages.
  Problem 1
    - Installation request for cocur/slugify ^4.0 -> satisfiable by cocur/slugify[v4.0.0].
    - cocur/slugify v4.0.0 requires ext-mbstring * -> the requested PHP extension mbstring is missing from your system.
...
Para resolver o problema de dependência do sistema, podemos procurar pelo pacote que falta usando o apt search:
apt search mbstring
Output
Sorting... Done
Full Text Search... Done
php-mbstring/focal 2:7.4+75 all
  MBSTRING module for PHP [default]
php-patchwork-utf8/focal 1.3.1-1 all
  UTF-8 strings handling for PHP
php7.4-mbstring/focal 7.4.3-4ubuntu1 amd64
  MBSTRING module for PHP
Após localizar o nome do pacote correto, você pode utilizar o apt novamente para instalar a dependência de sistema:
sudo apt install php-mbstring
Assim que a instalação terminar, você pode executar novamente o comando composer require:
composer require cocur/slugify
Output
Using version ^4.0 for cocur/slugify
./composer.json has been created
Loading composer repositories with package information
Updating dependencies (including require-dev)
Package operations: 1 install, 0 updates, 0 removals
  - Installing cocur/slugify (v4.0.0): Downloading (100%)         
Writing lock file
Generating autoload files
Como você pode ver na saída, o Composer decidiu automaticamente qual versão do pacote utilizar. Se você verificar o diretório do seu projeto agora, ele irá conter dois arquivos novos: composer.json e composer.lock, e um diretório vendor:
ls -l
Output
total 12
-rw-rw-r-- 1 sammy sammy   59 May  4 13:56 composer.json
-rw-rw-r-- 1 sammy sammy 3229 May  4 13:56 composer.lock
drwxrwxr-x 4 sammy sammy 4096 May  4 13:56 vendor
O arquivo composer.lock é usado para armazenar informações sobre quais versões de cada pacote estão instaladas, e garantir que as mesmas versões sejam usadas se outra pessoa clonar seu projeto e instalar suas dependências. O diretório vendor é onde as dependências do projeto estão localizadas. Você não deve fazer commit da pasta vendor no controle de versão - você precisa apenas incluir os arquivos composer.json e composer.lock.
Ao instalar um projeto que já contém um arquivo composer.json, execute o composer install para baixar as dependências do projeto.
Vamos dar uma olhada rápida em restrições de versão. Se você verificar o conteúdo do seu arquivo composer.json, verá algo parecido com isto:
cat composer.json
Output
{
    "require": {
        "cocur/slugify": "^4.0"
    }
}
Note que há o caractere especial ^ antes do número da versão no composer.json. O Composer suporta várias restrições diferentes e formatos para definir a versão necessária do pacote, para fornecer flexibilidade enquanto também mantém seu projeto estável. O operador circunflexo (^) utilizado pelo arquivo composer.json criado automaticamente é o operador recomendado para a interoperabilidade máxima, seguindo o versionamento semântico. Neste caso, ele define 4.0 como a versão mínima compatível e permite atualizações para qualquer versão futura abaixo de 5.0.
De um modo geral, você não precisará alterar as restrições de versão em seu arquivo composer.json. No entanto, algumas situações podem exigir que você edite manualmente as restrições – por exemplo, quando uma nova versão principal da sua biblioteca requerida é liberada e você deseja atualizar, ou quando a biblioteca que você deseja usar não segue o versionamento semântico.
Aqui estão alguns exemplos para lhe dar um melhor entendimento sobre como as restrições de versão do Composer funcionam:
Restrição   Significado Exemplo de Versões Permitidas
^1.0    >= 1.0 < 2.0    1.0, 1.2.3, 1.9.9
^1.1.0  >= 1.1.0 < 2.0  1.1.0, 1.5.6, 1.9.9
~1.0    >= 1.0 < 2.0.0  1.0, 1.4.1, 1.9.9
~1.0.0  >= 1.0.0 < 1.1  1.0.0, 1.0.4, 1.0.9
1.2.1   1.2.1   1.2.1
1.* >= 1.0 < 2.0    1.0.0, 1.4.5, 1.9.9
1.2. *  >= 1.2 < 1.3    1.2.0, 1.2.3, 1.2.9
Para uma visualização mais detalhada das restrições de versão do Composer, consulte a documentação oficial.
A seguir, vamos ver como carregar dependências automaticamente com o Composer.
Passo 4 — Incluindo o Script Autoload
Como o PHP por si só não carrega classes automaticamente, o Composer fornece um script autoload que você pode incluir em seu projeto para obter o carregamento automático para ele. Este arquivo é gerado automaticamente pelo Composer quando você adiciona sua primeira dependência.
A única coisa que você precisa fazer é incluir o arquivo vendor/autoload.php em seus scripts PHP antes de qualquer instância de classe.
Vamos testar isso em nossa aplicação de demonstração. Abra um novo arquivo chamado test.php em seu editor de texto:
nano test.php
Adicione o código a seguir que vem no arquivo vendor/autoload.php, carrega a dependência cocur/slugify, e o utiliza para criar um slug:
test.php
<?php
require __DIR__ . '/vendor/autoload.php';
use Cocur\Slugify\Slugify;
$slugify = new Slugify();
echo $slugify->slugify('Hello World, this is a long sentence and I need to make a slug from it!');
Salve o arquivo e saia do seu editor.
Agora, execute o script.
php test.php
Isso produz a saída hello-world-this-is-a-long-sentence-and-i-need-to-make-a-slug-from-it.
As dependências precisam de atualizações quando novas versões são liberadas. Dessa forma, vamos ver como lidar com isso.
Passo 5 — Atualizando as Dependências do Projeto
Sempre que você quiser atualizar suas dependências do projeto para versões mais recentes, execute o comando update:
composer update
Isso irá verificar por versões mais recentes das bibliotecas que você requer em seu projeto. Se uma versão mais recente for encontrada e ela for compatível com a restrição de versão definida no arquivo composer.json, o Composer substituirá a versão anterior instalada. O arquivo composer.lock será atualizado para refletir essas alterações.
Você também pode atualizar uma ou mais bibliotecas específicas, especificando-as desta forma:
composer update vendor/package vendor2/package2
Certifique-se de verificar em seus arquivos composer.json e composer.lock dentro do seu sistema de controle de versão após atualizar suas dependências de modo que outros também possam instalar essas versões mais recentes.
INÍCIO:
1 instalar o docker
2 abrir wsl2/Windows ou linux
 curl -s "https://laravel.build/olw?with=mysql,redis,mailhog,minio" | bash
3 cd olw
./vendor/bin/sail up -d
    ou
4 cd olw && ./vendor/bin/sail up -d
5 ATRIBUINDO PERMISSÃO PARA A PASTA
cd .. -> sai da pasta
sudo chmod 777 olw/ -R ou sem o 'sudo' chmod 777 olw/ -R
6 CRIANDO ALIAS PARA O COMANDO ANTERIOR
alias sail='[ -f sail ] && sh sail || sh vendor/bin/sail'
passa a usar assim: sail ps
7 CONFIGURAR PORTAS PARA A APLICAÇÃO NO NAVEGADOR E MYSQL
.env
APP_PORT=8000
*porta do myql
FORWARD_DB_PORT=3307
8 INSTALANDO DEPENDÊNCIA AO PROJETO
./vendor/bin/sail composer require laravel/breeze --dev
9 DEIXAR TELA DE AUTENTICAÇÃO PRONTA, ROTA AUTENTICADA, TAWINDCSS INSTALADO E INERTIA INSTALADO
./vendor/bin/sail artisan breeze:install vue 
ou
./vendor/bin/sail art breeze:install vue
10 RODAR AS MIGRATES PADRÕES DO PROJETO AI JÁ PODE CADASTRAR USUÁRIOS PARA LOGIN:
./vendor/bin/sail art migrate
11 
/*******************************************/
2a AULA:
O PROJETO CONSISTE EM RECEBER DADOS DE UMA API (punkapi.com) DE INFORMAÇÕES SOBRE CERVEJAS, VAMOS CONSTRUIR AS ROTAS PARA CONSUMIR A API E CRIAR A ESTRUTURA PARA O RELATÓRIO QUE IREMOS GERAR EM EXCEL E ENVIAR PARA O STORAGE...
1 CRIAR ROTAS:
code .
olw/routes/web.php
sail up -d -> SOBE O CONTAINER localhost:8000 (nesse projeto)
Route::get('/beers', fn()=> 'Olw - testando a rota /beers');
**************************************************
obs:
- laravel.com/api -> acesso a documentação do código;
- Inline Parameters for VSCode-> extensão para vscode para exibir o nome dos métodos na hora que codificar;
- fira code -> extensão para fonte no vscode
git Hub Copilot vs Tabnine -> (pesquisar sobre)
Link para extensões vscode:
https://github.com/icarojobs/vscode-useful-extensions
*************************************************
Route::get('/beers', fn()=> 'Olw - testando a rota /beers')
                             ->middleware(['auth']);
* FLUXO PADRÃO DO MVC-LARAVEL: 
life cicle: sai do usuário pelo navegador, insomnia ou postman -> passa pelo index.php(pasta public) -> passa pelos arquivos do bootstrap retornando uma instância da aplicação -> passa pelo kernel do http (carrega mais instâncias) -> Service provider -> despacha a requisição pro Router -> Cai no arquivo Web.php -> Middleware (se tiver, geralmente tem os globais) -> Controller (faz as regras de negócio e pode chamar outras classes como Serviços por exemplo)
-> Retorna uma view ou um json (No caso estamos usando inértia, ele não vai reinderizar a 'view.blade' padrão, ele vai reinderizar componente vue.js através do inértia.).
* EM VEZ DE USAR A FUNÇÃO AQUI NA ROTA CRIAMOS UM CONTROLLER:
obs.: ​dica: php artisan make:controller -r cria o Resource também.
dica: limpar o cache do container:
./vendor/bin/sail art config:cache
./vendor/bin/sail art optimize:clear
sail artisan make:controller BeerController
ou 
sail art make:controller BeerController -> CRIA O ARQUIVO BeerController.php na pasta app/Http/Controllers
->
<?php
namespace App\Http\Controllers;
use Illuminate\Http\Request;
class BeerController extends Controller
{
    public function index()
    {
    return 'Virgu & Beer & Code'
    }
}
* NO ARQUIVO DE ROTAS Web.php CHAMA O BeersController:
importante importar o Controller <nomeDoController>+<CTRL=ENTER:
use App\Http\Controllers\BeerController;
Route::get('/beers', [BeerController::class, 'index'])
                        ->middleware(['auth']);
* PRECISAMOS CRIAR UM MÉTODO PARA PEGAR A LISTA, LISTAR OS DADOS DA API (listar as bebidas de https://api.punkapi.com/v2 ->
VAMOS CRIAR UMA NOVA CLASSE de serviços em app/Sevices/PunkapiService.php
* O LARAVEL POSSUI UM RECURSO CHAMADO HTTPClient que abstrai o uso de uma ferramenta chama guzeo, esse guzeo é o client http mais comum para php, com ele fazemos requisições pra diversos serviços web dentro do php para outras url, ele é robusto, então o laravel simplifica importando o recurso que faz tudo por 'detrás dos panos':
PunkapiService.php
<?php
namespace App\Services;
use Illuminate\Support\Facades\Http;
class PunkapiService
{
    public function getBeers()
    {
        return Http::get('https://api.punkapi.com/v2/beers');
    }
}
E NO BeerController.php fica:
<?php
namespace App\Http\Controllers;
use App\Services\PunkapiService;
use Illuminate\Http\Request;
class BeerController extends Controller
{
    public function index()
    {
    //return 'Virgu & Beer & Code';
    $service = new PunkapiService;
    return $service->getBeers();
    }
}
* TRATE É CARACTERÍSTICA QUE A CLASSE ADQUIRE (pode ter mesmos métodos e atributos substituindo o recurso de um classe extender várias classes que não tem no php, a trate é uma forma de fazer isso. O service  é uma outra camada na maioria das vezes abstrair seviços que vc vai consumir, por exemplo API.
Estando logado, os dados da api já serão exibidos em localhost:8000/beers, se usar um aplicativo cliente tipo insomnia pode apresentar os dados também, melhor comentar a linha de de autenticação da rota:
Route::get('/beers', [BeerController::class, 'index']);
linha de autenticação da rota // ->middleware(['auth']);
* ESSA API PERMITE FAZER FILTROS VIA PARÂMETROS NA PRÓPRIA ROTA. PRIMEIRO VAMOS REFATORAR O CÓDIO, A CLASSE PunkapiService.php:
USO DE CONFIG E MACRO
Vamos alterar a url, primeiro acessando a pasta config da raiz do projeto e criar o arquivo punkapi.php. O que acontece é que o config(pasta config da raiz) carrega todos os arquivos da pasta e permite que sejam acessados via funções simples(HELPERS), isso é muito legal porque podemos acessar esses arquivos de configurações de qualquer lugar do projeto: 
<?php
return [
    'url' => env('PUNK_BASE_URL', 'https://api.punkapi.com/v2')
];
Usando o helper env significa dizer que, se não houver a constante PUNK_BASE_URL setada no arquivo .env do projeto, seu valor será o segundo parâmetro: http://api.punkapi.com/v2 e no arquivo PunkapiService.php da pasta app/Services fica:
<?php
namespace App\Services;
use Illuminate\Support\Facades\Http;
class PunkapiService
{
    public function getBeers()
    {
        return Http::get('/beers');
    }
}
MACRO é uma forma de criar funções customizadas:
 em app\Providers vamos acessar o arquivo AppServiceProvider.php que é uma classe que tem dois métodos register e boot. No método boot vamos chamar o método Http do laravel e chamar o método macro, no primeiro parâmetro será um nome atribuído à função e e o segundo uma clausure (uma função).
Neste arquivo é passado o arquivo de configuração da url (em 'config/punkapi.php') além de tokens, headers,...
 
use Illuminate\Support\Facades\Http; -> deve ser importado
E a função boot fica:
  public function boot()
    {
        Http::macro('punkapi', function(){
            return Http::acceptJson()
            ->baseUrl(config('punkapi.url'));
        });
    }
Então criamos uma macro(uma função customizada) chamada punkapi que já retorna o client com accept/Json no Header e com o baseUrl configurado lá do arquivo /config/punkapi.php e se estiver setado no .env pegará de lá.
/app/Services/PunkapiService.php fica:
<?php
namespace App\Services;
use Illuminate\Support\Facades\Http;
class PunkapiService
{
    public function getBeers()
    {
        return Http::punkapi()->get('/beers');
    }
}
*obs.: a baseUrl poderia ser setada no construtor, que pode setar token também.(uma outra abordagem para versão sem macros);
->Testamos o retorno Json em localhost:8000/beers.
Refatorando o arquivo PunkapiService.php: O client Http não lança exceção e podemos forçar o retorno em modo Json:
<?php
namespace App\Services;
use Illuminate\Support\Facades\Http;
class PunkapiService
{
    public function getBeers()
    {
       // return Http::punkapi()->get('/beers');
       return Http::punkapi()
            ->get('/beers')
            ->throw()  // Exceção em caso de erro
            ->json();   // Força o retorno em formato Json
    }
}
Podemos testar forçando um erro alterando a constante PUNKAPI_BASE_URL criada em /config/punkapi.php, vamos atribuir um valor diferente no arquivo .env:
PUNKAPI_BASE_URL="adfjklj878"
Podemos usar a função retry tem dois parâmetros, o número de tentativas pra buscar a requisição e o intervalo entre elas. Refatorando o código fica:
<?php
namespace App\Services;
use Illuminate\Support\Facades\Http;
class PunkapiService
{
    public function getBeers()
    {
       // return Http::punkapi()->get('/beers');
       return Http::punkapi()
            ->get('/beers')
            ->throw()  // Exceção em caso de erro
            ->json();   // Força o retorno em formato Json
    }
}
- Quando sai a exceção nao deveriamos retornar o erro em json por ser um api neste caso estamos usamos um app web e não uma api. E usaríamos o Route Api.
Refatorando o método boot de /app/Providers/AppServiceProvider.php, inserindo o retry():
     */
    public function boot()
    {
        Http::macro('punkapi', function(){
            return Http::acceptJson()
            ->baseUrl(config('punkapi.url'))
            ->retry(3,100);
        });
    }
}
comando de help
* ./vendor/bin/sail composer dump-autoload
* Verificar Nome do arquivo se bate com o nome das rotas(Classes criadas e importar o nome errado);
* inteliphense
Refatorando BeerController.php
<?php
namespace App\Http\Controllers;
use App\Services\PunkapiService;
class BeerController extends Controller
{
    public function index()
    {
    $service = new PunkapiService();
    return $service->getBeers();
    }
}
Em vez de instanciar o método PunkapiService() dentro de index, vamos passar por parâmetro de index() declarando seu Próprio nome (PunkapiService) como tipo. Fica assim:
<?php
namespace App\Http\Controllers;
use App\Services\PunkapiService;
class BeerController extends Controller
{
    public function index(PunkapiService $service)
    {
    return $service->getBeers();
    }
}
Assim usamos feactures do php(injeção de dependências) e ao mesmo tempo feactures do laravel. Em vez de criar uma instância dentro do método index, vamos injetar a classe como parâmetro para o método index(), ficando index($service) e a instância de dentro da função passa como parâmetro de 'tipo da variável'. Isso quebra a cadeia de dependência entre as classes.
Assim, o método index ganha independência não mais dependendo da instância de new PunkapiService e passamos a olhar a função index em si.
Assim, o Laravel tenta fazer um binding, um match, o laravel tenta encontrar alguma classe PunkapiService e cria uma instância dessa classe e usa ali como parâmetro. Se não fizer assim, lá em Rotas teria que ser passado como parâmetro o que fica desnecessário.
Não poderia ser feito se na classe PunkapiService existisse o construtor para atribuir valores automaticamente à classe. Assim podemos usar porque não precisamos passar nenhum valor.
ADICIONAR OS FILTROS:
Vamos filtrar o retorno api com os seguintes itens: beer_name, food, ibu_gt, malte:
var_dump($v)
die();
dd($variável)
benchmarck -> ?
/*****REFATORA PARA TESTE alterando BeerController.php e PunkapiService.php
BeerController.php
<?php
namespace App\Http\Controllers;
use App\Services\PunkapiService;
class BeerController extends Controller
{
    public function index(PunkapiService $service)
    {
    return $service->getBeers(
        'heineken',
        'cheese',
        'corn',
        45
    );
    }
}
PunkapiService.php
<?php
namespace App\Services;
use Illuminate\Support\Facades\Http;
class PunkapiService
{
    public function getBeers(
        string $beer_name,
        string $food,
        string $malt,
        string $ibu_gt
    )
    {
        $params = get_defined_vars();
        dd($params);
        return Http::punkapi()
            ->get('/beers', $params)
            ->throw()  // Exceção em caso de erro
            ->json();   // Força o retorno em formato Json
    }
}
Resultado do debug no insomnia ou no navegador:
array:4 [▼ // app/Services/PunkapiService.php:18
  "beer_name" => "heineken"
  "food" => "cheese"
  "malt" => "corn"
  "ibu_gt" => "45"
]
//* fim teste
Refatorando:
class PunkapiService
{
    public function getBeers(
        string $beer_name = null,
        string $food = null,
        string $malt = null,
        string $ibu_gt = null
    )
    {
        $params = get_defined_vars();
        dd($params);
        return Http::punkapi()
            ->get('/beers', $params)
            ->throw()  // Exceção em caso de erro
            ->json();   // Força o retorno em formato Json
    }
}
Assim quando não passar o valor para a chave ele exibirá a chave e o valor Null, vamos refatorar para não exibir nem a chave englobando get_defined_vers() com array_filter no arquivo PunkapiService.php:
$params = array_filter(get_defined_vars());
<?php
namespace App\Http\Controllers;
use App\Services\PunkapiService;
class BeerController extends Controller
{
    public function index(PunkapiService $service)
    {
    return $service->getBeers(
        'heineken',
        'cheese',
        'corn',
       // 45 -> Esse não é passado
    );
    }
}
array:3 [▼ // app/Services/PunkapiService.php:18
  "beer_name" => "heineken"
  "food" => "cheese"
  "malt" => "corn"
    Aqui não exibiu o valor 45
]
USANDO A FUNÇÃO NAMED_ARGS passamos só os parâmetros que precisamos retornar da api e o php com essa função saberá qual a posição dela no array de argumentos passados como parâmetro sem a necessidade de seguir a mesma sequência dos argumentos:
class BeerController extends Controller
{
    public function index(PunkapiService $service)
    {
    return $service->getBeers(food: 'cheese');
    }
}
REFATORANDO:
BeerController.php
<?php
namespace App\Http\Controllers;
use App\Services\PunkapiService;
use Illuminate\Http\Request;
class BeerController extends Controller
{
    public function index( Request $request, PunkapiService $service)
    {
    return $service->getBeers(...$request->all());
    }
}
PunkapiService.php
<?php
namespace App\Services;
use Illuminate\Support\Facades\Http;
class PunkapiService
{
    public function getBeers(
        string $beer_name = null,
        string $food = null,
        string $malt = null,
        string $ibu_gt = null
    )
    {
        $params = array_filter(get_defined_vars());
     //   dd($params);
        return Http::punkapi()
            ->get('/beers', $params)
            ->throw()  // Exceção em caso de erro
            ->json();   // Força o retorno em formato Json
    }
}
CRIANDO UMA REQUEST
sail artisan make:request BeerRequest
/app/Http/Requests/BeerRequest.php
* Funções anônimas, também conhecidas como closures , permitem a criação de funções que não tem o nome especificado. Elas são mais úteis como o valor de parâmetros callable, mas podem ter vários outros usos.. É uma função passada como parâmetro
CRIANDO NOVA ROTA PARA SALVAR COMO EXCEL
* https://docs.laravel-excel.com/3.1/getting-started/installation.html
Route::group([
    'prefix' => 'beers',
], function() {
    Route::get('/', [BeerController::class, 'index']); //-> Se houver necessidade de salvar dados por essa rota mudamos o método(verbo html) para post(os dados não serão expostos na url).
                          //  ->middleware(['auth']);
    Route::get('/export', [BeerController::class, 'export']);
});
Então passamos a ter duas rotas: localhost:8000/beers
localhost:8000/beers/export
No BeerController incluimos o método export():
class BeerController extends Controller
{
    public function index( BeerRequest $request, PunkapiService $service)
    {
    // return $service->getBeers(...$request->all());
    return $service->getBeers(...$request->validated());
    }
    public function export()
    {
        return 'Relatório criado.';
    }
}
INSTALANDO PACOTE LARAVEL-EXCEL PARA GERAR OS RELATÓRIO EM EXCEL FILTRADOS DA API:
* https://docs.laravel-excel.com/3.1/getting-started/installation.html
COMANDO PARA INSTALAR VIA COMPOSER:
./vendor/bin/sail composer require psr/simple-cache:^2.0 maatwebsite/excel
CRIAR A CLASSE DO EXCEL
./vendor/bin/sail artisan make:export BeerExport  --> Cria o arquivo em  /app/Exports/BeerExport.php
<?php
namespace App\Exports;
use Maatwebsite\Excel\Concerns\FromCollection;
class BeerExport implements FromCollection
{
    /**
    * @return \I¢lluminate\Support\Collection
    */
    public function collection()
    {
        //
    }
}
-> Dentro de colletion buscaremos as informações que serão salvas no arquivo do excel, um array de dados;
criamos um __construct() que vai ter uma propriedade privada do tipo array chamamos de $reportData.
O retorn será uma collection como informa o comentário:
 /**
    * @return \I¢lluminate\Support\Collection
    */
Na função colletion(), está recebendo um array return $this->reportData; 
Observe que não precisa mais declarar uma propriedade que vai se setada via construct(), basta defifinir o escopo junto do argumento e o php faz isso pra você. Como o retorno da função é um array usamos o helper collect para o $this->reportData:
BeerExport.php
<?php
namespace App\Exports;
use Maatwebsite\Excel\Concerns\FromCollection;
class BeerExport implements FromCollection
{
    public function __construct(
        private array $reportData
    ){}
    /**
    * @return \Illuminate\Support\Collection
    */
    public function collection()
    {
       return collect($this->reportData);
    }
}
 
Consultamos a documentação do Laravel-excel em 'Exporting collections':
em Excel Store passa o nome da classe e o nome do arquivo:
BeerController.php
<?php
namespace App\Http\Controllers;
use App\Exports\BeerExport;
use App\Http\Requests\BeerRequest;
use App\Services\PunkapiService;
use Maatwebsite\Excel\Facades\Excel;
class BeerController extends Controller
{
    public function index( BeerRequest $request, PunkapiService $service)
    {
    // return $service->getBeers(...$request->all());
    return $service->getBeers(...$request->validated());
    }
    public function export()
    {
      $params = [
        ['name' => 'Tom', 'age' => '30'],
        ['name' => 'Virgu', 'age' => '27']
       ];
       Excel::store(new BeerExport($params), 'olw-report.xlsx');
       return "Relatório criado";
    }
}
********************************************
* REFATORANDO E SALVANDO O ARQUIVO EXCEL EM /storage/app
BeerExport.php
<?php
namespace App\Exports;
use Maatwebsite\Excel\Concerns\FromCollection;
class BeerExport implements FromCollection
{
    public function __construct(
        private array $reportData
    ){}
    /**
    * @return \Illuminate\Support\Collection
    */
    public function collection()
    {
       return collect($this->reportData);
    }
}
*****************************
BeerController.php
<?php
namespace App\Http\Controllers;
use App\Exports\BeerExport;
use App\Http\Requests\BeerRequest;
use App\Services\PunkapiService;
use Maatwebsite\Excel\Facades\Excel;
class BeerController extends Controller
{
    public function index( BeerRequest $request, PunkapiService $service)
    {
        return $service->getBeers(...$request->all());
    }
    public function export(BeerRequest $request, PunkapiService $service)
    {
        $beers = $service->getBeers(...$request->validated());
        $filteredBeers = collect($beers)->map(function($value, $key){
        return collect($value)
                ->only(['name', 'tagline', 'first_brewed', 'description'])
                ->toArray();
    })->toArray();
    //dd($filteredBeers);
      $params = [
        ['name' => 'Tom', 'age' => '30'],
        ['name' => 'Virgu', 'age' => '27']
       ];
       Excel::store(new BeerExport($filteredBeers), 'olw-report.xlsx');
           return "Relatório criado";
    }
}
PARA SALVAR O ARQUIVO EXCEL EM UM STORAGE S3:
ALTERA BeerController.php
<?php
namespace App\Http\Controllers;
use App\Exports\BeerExport;
use App\Http\Requests\BeerRequest;
use App\Services\PunkapiService;
use Maatwebsite\Excel\Facades\Excel;
class BeerController extends Controller
{
    public function index( BeerRequest $request, PunkapiService $service)
    {
        return $service->getBeers(...$request->all());
    }
    public function export(BeerRequest $request, PunkapiService $service)
    {
        $beers = $service->getBeers(...$request->validated());
        $filteredBeers = collect($beers)->map(function($value, $key){
        return collect($value)
                ->only(['name', 'tagline', 'first_brewed', 'description'])
                ->toArray();
    })->toArray();
       Excel::store(
            new BeerExport($filteredBeers),
             'olw-report.xlsx',
             's3');
           return "Relatório criado";
    }
}
************
O REPOSITÓRIO DE ARQUIVOS minio:
NO DOCKER COMPOSER TEMOS O minio, um S3 que tem
MINIO_ROOT_USER: 'sail'
MINIO_ROOT_PASSWORD: 'password' e roda na porta 9000
localhost:9000
usuário: sail
senha: password
vamos criar um buncket(uma pasta)
e configurar o .env da raiz da aplicação:
originalmente é assim:
AWS_ACCESS_KEY_ID=
AWS_SECRET_ACCESS_KEY=
AWS_DEFAULT_REGION=us-east-1
AWS_BUCKET=
AWS_USE_PATH_STYLE_ENDPOINT=false
 e acrescentamos as informações para:
AWS_ACCESS_KEY_ID=sail
AWS_SECRET_ACCESS_KEY=password
AWS_DEFAULT_REGION=us-east-1
AWS_BUCKET=local
AWS_ENDPOINT=http://minio:9000
AWS_URL=http://minio:9000/local
AWS_USE_PATH_STYLE_ENDPOINT=true
altera tambem:
FILESYSTEM_DISK=local 
para:
FILESYSTEM_DISK=s3
INSTALAR UMA DEPENDÊNCIA (ADAPTER) PARA FAZER CORRESPONDÊNCIA COM A AWS:
Flysystem 3.x em laravel.com/docs/9.x/upgrade
./vendor/bin/sail composer require -W league/flysystem-aws-s3-v3 "^3.0"
em caso de erro:
 artisan vendor:publish --tag=laravel-assets --ansi --force
.env
APP_NAME=Laravel
APP_ENV=local
APP_KEY=base64:UbVvTP6Cu+LF5GamJdB4dsZZvW05ep4bZqcCEhmiDCg=
APP_DEBUG=true
APP_URL=http://localhost
APP_PORT=8000
# PUNKAPI_BASE_URL="httpadfjkljdsdfdfasf878"
LOG_CHANNEL=stack
LOG_DEPRECATIONS_CHANNEL=null
LOG_LEVEL=debug
DB_CONNECTION=mysql
FORWARD_DB_PORT=3307
DB_HOST=mysql
DB_PORT=3306
DB_DATABASE=olw
DB_USERNAME=sail
DB_PASSWORD=password
BROADCAST_DRIVER=log
CACHE_DRIVER=file
FILESYSTEM_DISK=s3
QUEUE_CONNECTION=sync
SESSION_DRIVER=file
SESSION_LIFETIME=120
MEMCACHED_HOST=memcached
REDIS_HOST=redis
REDIS_PASSWORD=null
REDIS_PORT=6379
MAIL_MAILER=smtp
MAIL_HOST=mailhog
MAIL_PORT=1025
MAIL_USERNAME=null
MAIL_PASSWORD=null
MAIL_ENCRYPTION=null
MAIL_FROM_ADDRESS="hello@example.com"
MAIL_FROM_NAME="${APP_NAME}"
AWS_ACCESS_KEY_ID=sail
AWS_SECRET_ACCESS_KEY=password
AWS_DEFAULT_REGION=us-east-1
AWS_BUCKET=local
AWS_ENDPOINT=http://minio:9000
AWS_URL=http://minio:9000/local
AWS_USE_PATH_STYLE_ENDPOINT=true
PUSHER_APP_ID=
PUSHER_APP_KEY=
PUSHER_APP_SECRET=
PUSHER_HOST=
PUSHER_PORT=443
PUSHER_SCHEME=https
PUSHER_APP_CLUSTER=mt1
VITE_PUSHER_APP_KEY="${PUSHER_APP_KEY}"
VITE_PUSHER_HOST="${PUSHER_HOST}"
VITE_PUSHER_PORT="${PUSHER_PORT}"
VITE_PUSHER_SCHEME="${PUSHER_SCHEME}"
VITE_PUSHER_APP_CLUSTER="${PUSHER_APP_CLUSTER}"
PRONTO. ENVIANDO PARA O MINIO.
/**** ABAIXO AULA DE FRONT END -> FALTA
 
/***********************************************************
QUINTA FEIRA: 20/10/22
Open Laravel Week | Deploy com Terraform, EC2 e RDS | Fermentação
****
https://portal.aws.amazon.com/billing/signup?nc2=h_ct&src=header_signup&redirect_url=https%3A%2F%2Faws.amazon.com%2Fregistration-confirmation&language=pt_br#/start/email
Com terraform pode mudar de infra e configurar no git.
PROGRMAR A CONFIGURAÇÃO DO SERVIDOR: É basicamente construir uma nova aplicação para fazer isso, mais fácil de entender.
Terraform serve para (linguagem HCL -> linguagem própria - linguagem descritiva, descreve o resultado e não como irá ser feito), ou seja, descrever o que queremos.
Terraspace é o framework pra terraform.
Quando criamos o Terraform, ele pode variar conforme a infra cloud (aws, azure, google cloud). sua estrutura é a mesma para todos. mas cada provider tem a sua forma de usar, não consegue usar o mesmo código para mais de uma cloud.
Vamos rodar Terraform via container:
1. clonar do git: git clone 
Criar uma pasta para a infraestrutura
sail   (script que vamos usar)
#!/usr/bin/env bash
docker run -rm -it
    -u $(id -u):$(id -g) \
    -v $PWD:/workspace \
    -w /workspace
    hashicorp/terraform:light "%@"
    <no terminal
Logar em: aws.amazon.com
busca: iam
iam dashboard -> mysecurity credencials (root user) -> Acces keys ->clicar em create access keys -> salva o access key e secret access key
e coloca no arquivo credencials na maquina local.. .aws/credencials
//////////////////////////////////////////////////////////////////////////////////////////////////////
CONTEÚDO QUE FALTA ORGANIZAR:
/**************************************/
sail share
sail artisan sail:publish ->coloca em uma pasta na raiz chamada docker
sail --help
sail artisan optimizer:clear
sail ps
sail build --no-cache -> faz o bild da aplicação. (dá um sail down  por precaução antes.)
/*********************************
root@DELLAGS:~# curl -s "https://laravel.build/laravel-9-course?with=mysql,redis,mailhog" | bash
Dockerfile
root@DELLAGS:~/example-app# docker exec -it example-app-mysql-1 bash
FROM wyveo/nginx-php-fpm:latest
WORKDIR /usr/share/nginx
RUN rm -rf /usr/share/nginx/html
COPY . /usr/share/nginx
RUN chmod -R 755 /usr/share/nginx/storage/*
RUN ln -s public html
.env (do composer)
DB_CONNECTION=mysql
DB_HOST=mysql-app (serviço do mysql no docker-compose.yaml)
DB_PORT=3306
DB_DATABASE=laraveldockerdb
DB_USERNAME=root
DB_PASSWORD=123456
docker-compose.yaml
version: '3'
services:
  laraveldocker-app:
    build: .
    ports:
      - "3003:80"
    volumes:
      - ./:/usr/share/nginx
      - .docker/nginx:/etc/nginx/conf.d/
    networks:
      - app-network
  mysql-app:
    image: mysql:5.7.22
    ports:
      - "3306:3306"
    volumes:
      - .docker/dbdata:/var/lib/mysql
    environment:
      MYSQL_DATABASE: laraveldocker
      MYSQL_ROOT_PASSWORD: 123456
    networks:
      - app-network
networks:
  app-network:
    driver: bridge
    
/*************************************************
#criando um serviço com um nome qualquer
version: '3'
services:
  laravel-app:                    #criando um serviço com um nome qualquer
    build: . ou image: wyveo/nginx-php-fpm:latest -> neste caso sem Dockerfile.                    # endereço da imagem ou local do Dockerfile (neste caso o ponto siginifica a raiz do projeto)
    ports:
      - "8080:80"                 # 8080 porta do meu host: 80 é a porta do docker nginx
    volumes:                      # docker-compose up -d -> sobe a imagem e libera o terminal  
      - ./:/usr/share/nginx       # TUDO QUE ESTIVE NA RAIZ (na rais tem o meu projeto laravel) './' IRÁ SER REFLETIDO NA PASTA /usr/share/nginx (pasta de acesso da página html)
                                  # C:\Laravel-docker\laravel-docker>docker compose up -d --build atualiza a minha imagem
  mysql-app:
      image: mysql:5.7
      ports:
        - "3306:3306"
      volumes:
        - .docker/dbdata:/var/lib/mysql          # qualqer nome (para persistir -guardar os dados do banco de dados)
      environment:
        MYSQL_DATABASE: laravel
        MYSQL_ROOT_PASSWORD: laravel
    
      
      /***************************///
  
C:\Laravel-docker\laravel-docker>docker compose up -d --build
                                
                               
    
/******************************** Dockerfile
FROM wyveo/nginx-php-fpm:latest
/***************************///
  COMANDOS
docker compose down -> para todos os containers
C:\Laravel-docker\laravel-docker>docker exec -it laravel-docker-laravel-app-1 bash 
root@612ea0ea3340:/# cd /usr/share/nginx/
root@612ea0ea3340:/usr/share/nginx# php artisan migrate
root@612ea0ea3340:/usr/share/nginx# php artisan serve
        
/***********/
PS C:\Users\alber> docker run -e MYSQL_ROOT_PASSWORD=root --name meu-mysql -d mysql:5.7
docker inspect meu-mysql ou | grep IPAddress
PS C:\Users\alber> docker run -e MYSQL_ROOT_PASSWORD=root --name meu-mysql -d -p 3306:3306 mysql:5.7
docker ps
docker ps -l
docker ps -a
docker rm -f nome
/*** LARAVEL */
### CRIANDO UM PROJETO NO LARAVEL 
laravel new projeto_laravel_via_installer (ESTA É UM AOPÇÃO)
composer create-project --prefer-dist laravel/laravel app_controle_tarefas "8.5.9"
cd app_controle_tarefas
cd public
php -S localhost:8000
ou 
da raiz do projeto:
php artisan serve 
ou
php artisan serve --port=3000
### PARA ABRIR PORTA EM OUTRO SERVIDOR
php artisan serve --host test.com --port 8080
 **********************************************************************
cd app_controle_tarefas
cd public
php artisan serve
- acessa o navegador http://localhost:8000
### DENTRO DO PROJETO CRIADO INSTALAR O LARAVEL/UI:^3.2 - versão 3.2
composer require laravel/ui:^3.2
### SE OCORRER ERRO AUMENTAR A MEMÓRIA DISPONIVEL PARA O php
-php --ini -> localiza o arquivo de configuração do php
LOCALIZA memory_limit = 1000 e altera para 
         memory_limit  = -1 e Salva
### LISTA A RELAÇÃO DE COMANDOS 
php artisan list 
DEVERA SURGIR AS OPÇÕES ABAIXO:
 ui
  ui:auth               Scaffold basic login and registration views and routes
  ui:controllers        Scaffold the authentication controllers
 vendor
### ENTENDENDO O PACOTE UI E INICIANDO A AUTENTICAÇÃO WEB NATIVA DO LARAVEL
COMANDO PARA LISTAR ROUTES: 
php artisan route:list
### php artisan ui bootstrap --auth (bootstrap ou react ou vue)
aplicando o bootstrap incluindo os recursos de autenticação;
poderia ser aplicado o bootstrap sem os recursos de autenticação;
### php artisan route:list -> mostra as rotas - ver que aumentaram as rotas
### APÓS ESSE PROCESSO O SISTEMA PEDE PARA RODAR
npm install -> instala as dependências do package.json (inclusive o bootstrap)
npm run dev -> gera os assets da aplicação de acordo com a tecnologia selecionada (bootstrap, react ou vue) -> Geralmente roda mais de uma vez para compilar tudo.
### CRIA O BANCO DE DADOS NORMALMENTE
### EXECUTA AS MIGRATIONS PADRÕES CRIADAS PARA O SISTEMA DE login
php artisan migrate -> CRIA AS TABELAS NO BANCO DE DADOS
************************************** 
INSTALANDO O COMPOSER NO UBUNTU
**************************************
sudo apt update
sudo apt install php-cli unzip
cd ~
curl -sS https://getcomposer.org/installer -o composer-setup.php
HASH=`curl -sS https://composer.github.io/installer.sig`

echo $HASH ->saída: Output
e0012edf3e80b6978849f5eff0d4b4e4c79ff1609dd1e613307e16318854d24ae64f26d17af3ef0bf7cfb710ca74



php -r "if (hash_file('SHA384', 'composer-setup.php') === '$HASH') { echo 'Installer verified'; } else { echo 'Installer corrupt'; unlink('composer-setup.php'); } echo PHP_EOL;"

sudo php composer-setup.php --install-dir=/usr/local/bin --filename=composer





***********************

DigitalOcean Kubernetes: novo plano de controle é mais rápido e gratuito, habilita HA para SLA de 99,95% de tempo de atividade
Produtos
Preços

Documentos
divisa suspensa

Entrar
divisa suspensa

// Tutorial //
Como Instalar e Utilizar o Composer no Ubuntu 20.04
Publicado em 21 de maio de 2020
Ubuntu
PHP
Ubuntu 20.04
Avatar padrão
Por Erika Heidi
Advogado Desenvolvedor
Português
Como Instalar e Utilizar o Composer no Ubuntu 20.04
Introdução
O Composer é uma ferramenta popular de gerenciamento de dependências para o PHP, criado para facilitar a instalação e a atualização das dependências principalmente do projeto. Ele controla quais outros pacotes de projeto específico dependem e são instalados para você, usando as opções apropriadas de acordo com os requisitos do projeto. O Composer também é comumente utilizado para inicializar novos projetos em frameworks PHP populares, como o Symfon e o Laravel .

Neste tutorial, você instalará e começará a usar o Composer em um sistema Ubuntu 20.04.

Pré-requisitos
Para seguir este guia, você pode acessar um servidor como usuário Ubuntu20.04 como usuário sudonão-root um firewall habilitado em seu servidor Para configurar isto, siga nosso guia Configuração do servidor inicial para o Ubuntu 20.04

Passo 1 — Instalando o PHP e as Dependências Adicionais
Além das dependências que já devem estar incluídas em seu sistema Ubuntu 20.04, como o , o Composer exige ou gitexecuta scripts PHP na linha de comando e para extrair arquivos zipados. Vamos instalar essas dependências agora.curlphp-cliunzip

primeiro, atual, gerenciador de pacotes de soluções: o cache do gerenciador de pacotes

sudo apt update
Em seguida, o seguinte comando para instalar os pacotes, execute:

sudo apt install php-cli unzip
Você será solicitado a confirmar a instalação digitando Ye, depois, ENTER.

Assim que os pré-requisitos para instalação do Composer forem instalados, você poderá seguir.

Passo 2 — Baixando e Instalando o Compositor
O Composer fornece um instalador de script escrito em PHP. Vamos baixá-lo, verificar se ele não está danificado e, em seguida, o usaremos para instalar o Composer.

Certifique-se de estar em sua pasta home. Em seguida, baixe o instalador usando o curl:

cd ~
curl -sS https://getcomposer.org/installer -o composer-setup.php
Em seguida, vamos verificar se o instalador baixado corresponde ao hash SHA-384 para o instalador mais recente encontrado na página Composer Public Keys / Signatures . Para facilitar o passo de seleção, você pode usar o seguinte comando para obter programaticamente o hash mais recente da página do Composer e armazená-lo em uma variável do shell:

HASH=`curl -sS https://composer.github.io/installer.sig`
Se você quiser verificar o valor realizado, execute:

echo $HASH
Output
e0012edf3e80b6978849f5eff0d4b4e4c79ff1609dd1e613307e16318854d24ae64f26d17af3ef0bf7cfb710ca74755a
Agora o código PHP a seguir, execute conforme a página de download do Composer, para verificar se o script de instalação está seguro para ser executado:

php -r "if (hash_file('SHA384', 'composer-setup.php') === '$HASH') { echo 'Installer verified'; } else { echo 'Installer corrupt'; unlink('composer-setup.php'); } echo PHP_EOL;"
Você verá o seguinte resultado:

Resultado
Installer verified
Se Installer corruptvocê estiver usando o hash correto, verifique se você está usando o hash correto. Em seguida, repita o processo de verificação. Quando você tiver um instalador selecionado, você pode continuar.

Para instalar o composerglobalmente, use o seguinte comando que baixará e instalará o Composer como um comando disponível em todo o sistema chamado composer, sob /usr/local/bin:

sudo php composer-setup.php --install-dir=/usr/local/bin --filename=composer
Você verá um resultado semelhante com este:

Output
All settings correct for using Composer
Downloading...

Composer (version 1.10.5) successfully installed to: /usr/local/bin/composer
Use it: php /usr/local/bin/composer
Para testar sua instalação, execute:

composer
Output
   ______
  / ____/___  ____ ___  ____  ____  ________  _____
 / /   / __ \/ __ `__ \/ __ \/ __ \/ ___/ _ \/ ___/
/ /___/ /_/ / / / / / / /_/ / /_/ (__  )  __/ /
\____/\____/_/ /_/ /_/ .___/\____/____/\___/_/
                    /_/
Composer version 1.10.5 2020-04-10 11:44:22
Usage:
  command [options] [arguments]
Options:
  -h, --help                     Display this help message
  -q, --quiet                    Do not output any message
  -V, --version                  Display this application version
      --ansi                     Force ANSI output
      --no-ansi                  Disable ANSI output
  -n, --no-interaction           Do not ask any interactive question
      --profile                  Display timing and memory usage information
      --no-plugins               Whether to disable plugins.
  -d, --working-dir=WORKING-DIR  If specified, use the given directory as working directory.
      --no-cache                 Prevent use of the cache
  -v|vv|vvv, --verbose           Increase the verbosity of messages: 1 for normal output, 2 for more verbose output and 3 for debug
...
Isso verifica que o Composer foi instalado com sucesso em seu sistema e está disponível em todo o sistema.
Nota: se você preferirá ter-lhe-ão separados separados do Composer para projeto hospedado neste servidor, você pode instalar localmente, em uma base por projeto. Este método também é útil quando o usuário do sistema não possui permissão para instalar o software disponível em todo o sistema.
Para fazer isso, use o comando php composer-setup.php. Isso irá gerar um arquivo composer.pharem seu diretório atual, que pode ser executado com o seu atual php composer.phar.
Agora podemos dar uma dependência em como usar o Compose como gerenciar.
Passo 3 — Usando o Compositor em um Projeto PHP
Os projetos PHP geralmente dependentes de bibliotecas externas, e o gerenciamento de dependências e suas versões podem ser complicados. O Composer resolve esse problema de manter um controle de projeto de extensões e dependências, também facilita o processo de descoberta, instalação e atualização de pacotes que são definidos por enquanto.
Para usar o seu projeto, você pode compor um arquivo composer.json. O arquivo composer.jsonComposer quais dependências precisa para baixar seu projeto quais serão as versões de cada pacote tem permissão para instalações e instalações. Isso é muito importante para manter seu projeto consistente e evitar a instalação de versões instáveis ​​que podem causar problemas de compatibilidade retroativa.
Você não precisa criar este arquivo manualmente - é comum ocorrer erros de sintaxe quando fizer isso. O Composer oferece uma maneira de criar um novo arquivo composer.jsoncom base na entrada do usuário, o que é uma boa escolha se você planeja compartilhar seu projeto mais tarde como um pacote público no Packagist . O Composer gera automaticamente um arquivo básico composer.jsonquando você executa um comando composer requirepara incluir uma dependência em um projeto recém-criado.
O processo de uso do Composer para instalar um pacote como uma dependência em um projeto envolve os passos a seguir:
Identifique o tipo de biblioteca que o aplicativo precisa.
uma biblioteca de código aberto adequada no agist.org , o responsável oficial de pacotes para o Compose.
Escolha o pacote de dependência.
Execute composer requirepara incluir a dependência no arquivo composer.jsone instalar o pacote.
Vamos testar isso com uma aplicação de demonstração.
O objetivo desta aplicação é transformar uma determinação determinada em uma string de URL amigável - um slug . Isso é comumente usado para converter os títulos de página para caminhos de URL (Assim como a parte final da URL para este tutorial).
Vamos começar a criar um diretório para o nosso projeto. Vamos chamá-lo de slugify :
cd ~
mkdir slugify
cd slugify
Embora não seja necessário, você pode executar agora um comando composer init para criar um arquivo composer.json detalhado para seu projeto. Como o único objetivo do nosso projeto é demonstrar como instalar dependências com o Composer, usaremos um arquivo composer.json mais simples que será gerado automaticamente quando exigirmos nosso primeiro pacote.
Agora é hora de procurar no Packagist.org por um pacote que pode nos ajudar a gerar slugs. Se você procurar pelo termo “slug” no Packagist, receberá um resultado parecido com este:
Resultados da Pesquisa do Packagist para o termo "slug"
Você verá dois números no lado direito de cada pacote na lista. O número no topo representa quantas vezes o pacote foi instalado através do Composer, e o número em baixo mostra quantas vezes um pacote foi estrelado no GitHub. De um modo geral, os pacotes com mais instalações e mais estrelas tendem a ser mais estáveis, pois mais pessoas os utilizam. Também é importante verificar a descrição do pacote para relevância para garantir que ele é o que você precisa.
Precisamos de um conversor string-to-slug A partir dos resultados da pesquisa, o pacote cocur/slugify, que aparece como o primeiro resultado naquela página, parece ser um bom candidato, com uma quantidade razoável de instalações e estrelas.
Os pacotes no Packagist têm um nome de vendor e um nome de package. Cada pacote tem um identificador único (um namespace) no mesmo formato que o GitHub utiliza para seus repositórios: vendor/package. A biblioteca que queremos instalar utiliza o namespace cocur/slugify. Você precisa de um namespace do pacote para exigi-lo em seu projeto.
Agora que você sabe exatamente qual pacote deseja instalar, você pode executar o composer require para incluí-lo como uma dependência e gerar também o arquivo composer.json para seu projeto. Uma coisa importante é observar a exigência de pacotes. O Composer rastreia as dependências no nível da aplicação e do sistema. As dependências no nível do sistema são importantes para indicar de quais módulos PHP um pacote depende. No caso do pacote cocur/slugify, ele exige um módulo PHP que ainda não instalamos.
Quando um pacote necessário depende de uma biblioteca de sistema que não está atualmente instalada em seu servidor, você receberá um erro informando qual requisito está faltando:
composer require cocur/slugify
Output
Using version ^4.0 for cocur/slugify
./composer.json has been updated
Loading composer repositories with package information
Updating dependencies (including require-dev)
Your requirements could not be resolved to an installable set of packages.
  Problem 1
    - Installation request for cocur/slugify ^4.0 -> satisfiable by cocur/slugify[v4.0.0].
    - cocur/slugify v4.0.0 requires ext-mbstring * -> the requested PHP extension mbstring is missing from your system.
...
Para resolver o problema de dependência do sistema, podemos procurar pelo pacote que falta usando o apt search:
apt search mbstring
Output
Sorting... Done
Full Text Search... Done
php-mbstring/focal 2:7.4+75 all
  MBSTRING module for PHP [default]
php-patchwork-utf8/focal 1.3.1-1 all
  UTF-8 strings handling for PHP
php7.4-mbstring/focal 7.4.3-4ubuntu1 amd64
  MBSTRING module for PHP
Após localizar o nome do pacote correto, você pode utilizar o apt novamente para instalar a dependência de sistema:
sudo apt install php-mbstring
Assim que a instalação terminar, você pode executar novamente o comando composer require:
composer require cocur/slugify
Output
Using version ^4.0 for cocur/slugify
./composer.json has been created
Loading composer repositories with package information
Updating dependencies (including require-dev)
Package operations: 1 install, 0 updates, 0 removals
  - Installing cocur/slugify (v4.0.0): Downloading (100%)         
Writing lock file
Generating autoload files
Como você pode ver na saída, o Composer decidiu automaticamente qual versão do pacote utilizar. Se você verificar o diretório do seu projeto agora, ele irá conter dois arquivos novos: composer.json e composer.lock, e um diretório vendor:
ls -l
Output
total 12
-rw-rw-r-- 1 sammy sammy   59 May  4 13:56 composer.json
-rw-rw-r-- 1 sammy sammy 3229 May  4 13:56 composer.lock
drwxrwxr-x 4 sammy sammy 4096 May  4 13:56 vendor
O arquivo composer.lock é usado para armazenar informações sobre quais versões de cada pacote estão instaladas, e garantir que as mesmas versões sejam usadas se outra pessoa clonar seu projeto e instalar suas dependências. O diretório vendor é onde as dependências do projeto estão localizadas. Você não deve fazer commit da pasta vendor no controle de versão - você precisa apenas incluir os arquivos composer.json e composer.lock.
Ao instalar um projeto que já contém um arquivo composer.json, execute o composer install para baixar as dependências do projeto.
Vamos dar uma olhada rápida em restrições de versão. Se você verificar o conteúdo do seu arquivo composer.json, verá algo parecido com isto:
cat composer.json
Output
{
    "require": {
        "cocur/slugify": "^4.0"
    }
}
Note que há o caractere especial ^ antes do número da versão no composer.json. O Composer suporta várias restrições diferentes e formatos para definir a versão necessária do pacote, para fornecer flexibilidade enquanto também mantém seu projeto estável. O operador circunflexo (^) utilizado pelo arquivo composer.json criado automaticamente é o operador recomendado para a interoperabilidade máxima, seguindo o versionamento semântico. Neste caso, ele define 4.0 como a versão mínima compatível e permite atualizações para qualquer versão futura abaixo de 5.0.
De um modo geral, você não precisará alterar as restrições de versão em seu arquivo composer.json. No entanto, algumas situações podem exigir que você edite manualmente as restrições – por exemplo, quando uma nova versão principal da sua biblioteca requerida é liberada e você deseja atualizar, ou quando a biblioteca que você deseja usar não segue o versionamento semântico.
Aqui estão alguns exemplos para lhe dar um melhor entendimento sobre como as restrições de versão do Composer funcionam:
Restrição   Significado Exemplo de Versões Permitidas
^1.0    >= 1.0 < 2.0    1.0, 1.2.3, 1.9.9
^1.1.0  >= 1.1.0 < 2.0  1.1.0, 1.5.6, 1.9.9
~1.0    >= 1.0 < 2.0.0  1.0, 1.4.1, 1.9.9
~1.0.0  >= 1.0.0 < 1.1  1.0.0, 1.0.4, 1.0.9
1.2.1   1.2.1   1.2.1
1.* >= 1.0 < 2.0    1.0.0, 1.4.5, 1.9.9
1.2. *  >= 1.2 < 1.3    1.2.0, 1.2.3, 1.2.9
Para uma visualização mais detalhada das restrições de versão do Composer, consulte a documentação oficial.
A seguir, vamos ver como carregar dependências automaticamente com o Composer.
Passo 4 — Incluindo o Script Autoload
Como o PHP por si só não carrega classes automaticamente, o Composer fornece um script autoload que você pode incluir em seu projeto para obter o carregamento automático para ele. Este arquivo é gerado automaticamente pelo Composer quando você adiciona sua primeira dependência.
A única coisa que você precisa fazer é incluir o arquivo vendor/autoload.php em seus scripts PHP antes de qualquer instância de classe.
Vamos testar isso em nossa aplicação de demonstração. Abra um novo arquivo chamado test.php em seu editor de texto:
nano test.php
Adicione o código a seguir que vem no arquivo vendor/autoload.php, carrega a dependência cocur/slugify, e o utiliza para criar um slug:
test.php
<?php
require __DIR__ . '/vendor/autoload.php';
use Cocur\Slugify\Slugify;
$slugify = new Slugify();
echo $slugify->slugify('Hello World, this is a long sentence and I need to make a slug from it!');
Salve o arquivo e saia do seu editor.
Agora, execute o script.
php test.php
Isso produz a saída hello-world-this-is-a-long-sentence-and-i-need-to-make-a-slug-from-it.
As dependências precisam de atualizações quando novas versões são liberadas. Dessa forma, vamos ver como lidar com isso.
Passo 5 — Atualizando as Dependências do Projeto
Sempre que você quiser atualizar suas dependências do projeto para versões mais recentes, execute o comando update:
composer update
Isso irá verificar por versões mais recentes das bibliotecas que você requer em seu projeto. Se uma versão mais recente for encontrada e ela for compatível com a restrição de versão definida no arquivo composer.json, o Composer substituirá a versão anterior instalada. O arquivo composer.lock será atualizado para refletir essas alterações.
Você também pode atualizar uma ou mais bibliotecas específicas, especificando-as desta forma:
composer update vendor/package vendor2/package2
Certifique-se de verificar em seus arquivos composer.json e composer.lock dentro do seu sistema de controle de versão após atualizar suas dependências de modo que outros também possam instalar essas versões mais recentes.
Conclusão
***********
Algoritmo "CalculoMedia2"
// Disciplina: Lógica de programação
// Professor : Antonio Carlos Nicolodi
// Descrição : calculo da média aritimética
// Autor     : Professor Antonio
// Data atual: 01/04/2015
var
// Seção de Declarações
   v1, v2, total: Real
   sinal : Caracter
Inicio
// Seção dos Comandos
   Escreva ("Digite o primeiro valor: ")
   Leia (v1)
   Escreva ("Digite a operação + - * / : ")
   Leia (sinal)
   Escreva ("Digite o segundo valor: ")
   Leia (v2)
   Se sinal = "+" entao
   total <- v1 + v2
   Escreva("O Resultado é: ", total)
   Senao
   Se sinal = "-" entao
   total <- v1 - v2
   Escreva("O Resultado é: ", total)
   Senao
   Se sinal = "*" entao
   total <- v1 * v2
   Escreva("O Resultado é: ", total)
   Senao
     Escreva("OPERAÇÃO INVÁLIDA! ")
      Escreval("total")
   fimse
Fimalgoritmo
****
COMANDOS DOCKER
root@DELLAGS:~# curl -s "https://laravel.build/laravel-9-course?with=mysql,redis,mailhog" | bash
root@DELLAGS:~/example-app# ./vendor/bin/sail  artisan migrate --seed -> criar o banco de dados e copular dados;
Dockerfile
root@DELLAGS:~/example-app# docker exec -it example-app-mysql-1 bash
FROM wyveo/nginx-php-fpm:latest
WORKDIR /usr/share/nginx
RUN rm -rf /usr/share/nginx/html
COPY . /usr/share/nginx
RUN chmod -R 755 /usr/share/nginx/storage/*
RUN ln -s public html
.env (do composer)
DB_CONNECTION=mysql
DB_HOST=mysql-app (serviço do mysql no docker-compose.yaml)
DB_PORT=3306
DB_DATABASE=laraveldockerdb
DB_USERNAME=root
DB_PASSWORD=123456
docker-compose.yaml
version: '3'
services:
  laraveldocker-app:
    build: .
    ports:
      - "3003:80"
    volumes:
      - ./:/usr/share/nginx
      - .docker/nginx:/etc/nginx/conf.d/
    networks:
      - app-network
  mysql-app:
    image: mysql:5.7.22
    ports:
      - "3306:3306"
    volumes:
      - .docker/dbdata:/var/lib/mysql
    environment:
      MYSQL_DATABASE: laraveldocker
      MYSQL_ROOT_PASSWORD: 123456
    networks:
      - app-network
networks:
  app-network:
    driver: bridge
    
/*************************************************
#criando um serviço com um nome qualquer
version: '3'
services:
  laravel-app:                    #criando um serviço com um nome qualquer
    build: . ou image: wyveo/nginx-php-fpm:latest -> neste caso sem Dockerfile.                    # endereço da imagem ou local do Dockerfile (neste caso o ponto siginifica a raiz do projeto)
    ports:
      - "8080:80"                 # 8080 porta do meu host: 80 é a porta do docker nginx
    volumes:                      # docker-compose up -d -> sobe a imagem e libera o terminal  
      - ./:/usr/share/nginx       # TUDO QUE ESTIVE NA RAIZ (na rais tem o meu projeto laravel) './' IRÁ SER REFLETIDO NA PASTA /usr/share/nginx (pasta de acesso da página html)
                                  # C:\Laravel-docker\laravel-docker>docker compose up -d --build atualiza a minha imagem
  mysql-app:
      image: mysql:5.7
      ports:
        - "3306:3306"
      volumes:
        - .docker/dbdata:/var/lib/mysql          # qualqer nome (para persistir -guardar os dados do banco de dados)
      environment:
        MYSQL_DATABASE: laravel
        MYSQL_ROOT_PASSWORD: laravel
    
      
      /***************************///
  
C:\Laravel-docker\laravel-docker>docker compose up -d --build
                                
                               
    
/******************************** Dockerfile
FROM wyveo/nginx-php-fpm:latest
/***************************///
  COMANDOS
docker compose down -> para todos os containers
C:\Laravel-docker\laravel-docker>docker exec -it laravel-docker-laravel-app-1 bash 
root@612ea0ea3340:/# cd /usr/share/nginx/
root@612ea0ea3340:/usr/share/nginx# php artisan migrate
root@612ea0ea3340:/usr/share/nginx# php artisan serve
        
/***********/
PS C:\Users\alber> docker run -e MYSQL_ROOT_PASSWORD=root --name meu-mysql -d mysql:5.7
docker inspect meu-mysql ou | grep IPAddress
PS C:\Users\alber> docker run -e MYSQL_ROOT_PASSWORD=root --name meu-mysql -d -p 3306:3306 mysql:5.7
docker ps
docker ps -l
docker ps -a
docker rm -f nome
/*** LARAVEL */
### CRIANDO UM PROJETO NO LARAVEL 
laravel new projeto_laravel_via_installer (ESTA É UM AOPÇÃO)
composer create-project --prefer-dist laravel/laravel app_controle_tarefas "8.5.9"
cd app_controle_tarefas
cd public
php -S localhost:8000
ou 
da raiz do projeto:
php artisan serve 
ou
php artisan serve --port=3000
### PARA ABRIR PORTA EM OUTRO SERVIDOR
php artisan serve --host test.com --port 8080
 **********************************************************************
cd app_controle_tarefas
cd public
php artisan serve
- acessa o navegador http://localhost:8000
### DENTRO DO PROJETO CRIADO INSTALAR O LARAVEL/UI:^3.2 - versão 3.2
composer require laravel/ui:^3.2
### SE OCORRER ERRO AUMENTAR A MEMÓRIA DISPONIVEL PARA O php
-php --ini -> localiza o arquivo de configuração do php
LOCALIZA memory_limit = 1000 e altera para 
         memory_limit  = -1 e Salva
### LISTA A RELAÇÃO DE COMANDOS 
php artisan list 
DEVERA SURGIR AS OPÇÕES ABAIXO:
 ui
  ui:auth               Scaffold basic login and registration views and routes
  ui:controllers        Scaffold the authentication controllers
 vendor
### ENTENDENDO O PACOTE UI E INICIANDO A AUTENTICAÇÃO WEB NATIVA DO LARAVEL
COMANDO PARA LISTAR ROUTES: 
php artisan route:list
### php artisan ui bootstrap --auth (bootstrap ou react ou vue)
aplicando o bootstrap incluindo os recursos de autenticação;
poderia ser aplicado o bootstrap sem os recursos de autenticação;
### php artisan route:list -> mostra as rotas - ver que aumentaram as rotas
### APÓS ESSE PROCESSO O SISTEMA PEDE PARA RODAR
npm install -> instala as dependências do package.json (inclusive o bootstrap)
npm run dev -> gera os assets da aplicação de acordo com a tecnologia selecionada (bootstrap, react ou vue) -> Geralmente roda mais de uma vez para compilar tudo.
### CRIA O BANCO DE DADOS NORMALMENTE
### EXECUTA AS MIGRATIONS PADRÕES CRIADAS PARA O SISTEMA DE login
php artisan migrate -> CRIA AS TABELAS NO BANCO DE DADOS
************************************** 
INSTALANDO O COMPOSER NO UBUNTU
**************************************
sudo apt update
sudo apt install php-cli unzip
cd ~
curl -sS https://getcomposer.org/installer -o composer-setup.php
HASH=`curl -sS https://composer.github.io/installer.sig`

echo $HASH ->saída: Output
e0012edf3e80b6978849f5eff0d4b4e4c79ff1609dd1e613307e16318854d24ae64f26d17af3ef0bf7cfb710ca74



php -r "if (hash_file('SHA384', 'composer-setup.php') === '$HASH') { echo 'Installer verified'; } else { echo 'Installer corrupt'; unlink('composer-setup.php'); } echo PHP_EOL;"

sudo php composer-setup.php --install-dir=/usr/local/bin --filename=composer





***********************

DigitalOcean Kubernetes: novo plano de controle é mais rápido e gratuito, habilita HA para SLA de 99,95% de tempo de atividade
Produtos
Preços

Documentos
divisa suspensa

Entrar
divisa suspensa

// Tutorial //
Como Instalar e Utilizar o Composer no Ubuntu 20.04
Publicado em 21 de maio de 2020
Ubuntu
PHP
Ubuntu 20.04
Avatar padrão
Por Erika Heidi
Advogado Desenvolvedor
Português
Como Instalar e Utilizar o Composer no Ubuntu 20.04
Introdução
O Composer é uma ferramenta popular de gerenciamento de dependências para o PHP, criado para facilitar a instalação e a atualização das dependências principalmente do projeto. Ele controla quais outros pacotes de projeto específico dependem e são instalados para você, usando as opções apropriadas de acordo com os requisitos do projeto. O Composer também é comumente utilizado para inicializar novos projetos em frameworks PHP populares, como o Symfon e o Laravel .

Neste tutorial, você instalará e começará a usar o Composer em um sistema Ubuntu 20.04.

Pré-requisitos
Para seguir este guia, você pode acessar um servidor como usuário Ubuntu20.04 como usuário sudonão-root um firewall habilitado em seu servidor Para configurar isto, siga nosso guia Configuração do servidor inicial para o Ubuntu 20.04

Passo 1 — Instalando o PHP e as Dependências Adicionais
Além das dependências que já devem estar incluídas em seu sistema Ubuntu 20.04, como o , o Composer exige ou gitexecuta scripts PHP na linha de comando e para extrair arquivos zipados. Vamos instalar essas dependências agora.curlphp-cliunzip

primeiro, atual, gerenciador de pacotes de soluções: o cache do gerenciador de pacotes

sudo apt update
Em seguida, o seguinte comando para instalar os pacotes, execute:

sudo apt install php-cli unzip
Você será solicitado a confirmar a instalação digitando Ye, depois, ENTER.

Assim que os pré-requisitos para instalação do Composer forem instalados, você poderá seguir.

Passo 2 — Baixando e Instalando o Compositor
O Composer fornece um instalador de script escrito em PHP. Vamos baixá-lo, verificar se ele não está danificado e, em seguida, o usaremos para instalar o Composer.

Certifique-se de estar em sua pasta home. Em seguida, baixe o instalador usando o curl:

cd ~
curl -sS https://getcomposer.org/installer -o composer-setup.php
Em seguida, vamos verificar se o instalador baixado corresponde ao hash SHA-384 para o instalador mais recente encontrado na página Composer Public Keys / Signatures . Para facilitar o passo de seleção, você pode usar o seguinte comando para obter programaticamente o hash mais recente da página do Composer e armazená-lo em uma variável do shell:

HASH=`curl -sS https://composer.github.io/installer.sig`
Se você quiser verificar o valor realizado, execute:

echo $HASH
Output
e0012edf3e80b6978849f5eff0d4b4e4c79ff1609dd1e613307e16318854d24ae64f26d17af3ef0bf7cfb710ca74755a
Agora o código PHP a seguir, execute conforme a página de download do Composer, para verificar se o script de instalação está seguro para ser executado:

php -r "if (hash_file('SHA384', 'composer-setup.php') === '$HASH') { echo 'Installer verified'; } else { echo 'Installer corrupt'; unlink('composer-setup.php'); } echo PHP_EOL;"
Você verá o seguinte resultado:

Resultado
Installer verified
Se Installer corruptvocê estiver usando o hash correto, verifique se você está usando o hash correto. Em seguida, repita o processo de verificação. Quando você tiver um instalador selecionado, você pode continuar.

Para instalar o composerglobalmente, use o seguinte comando que baixará e instalará o Composer como um comando disponível em todo o sistema chamado composer, sob /usr/local/bin:

sudo php composer-setup.php --install-dir=/usr/local/bin --filename=composer
Você verá um resultado semelhante com este:

Output
All settings correct for using Composer
Downloading...

Composer (version 1.10.5) successfully installed to: /usr/local/bin/composer
Use it: php /usr/local/bin/composer
Para testar sua instalação, execute:

composer
Output
   ______
  / ____/___  ____ ___  ____  ____  ________  _____
 / /   / __ \/ __ `__ \/ __ \/ __ \/ ___/ _ \/ ___/
/ /___/ /_/ / / / / / / /_/ / /_/ (__  )  __/ /
\____/\____/_/ /_/ /_/ .___/\____/____/\___/_/
                    /_/
Composer version 1.10.5 2020-04-10 11:44:22
Usage:
  command [options] [arguments]
Options:
  -h, --help                     Display this help message
  -q, --quiet                    Do not output any message
  -V, --version                  Display this application version
      --ansi                     Force ANSI output
      --no-ansi                  Disable ANSI output
  -n, --no-interaction           Do not ask any interactive question
      --profile                  Display timing and memory usage information
      --no-plugins               Whether to disable plugins.
  -d, --working-dir=WORKING-DIR  If specified, use the given directory as working directory.
      --no-cache                 Prevent use of the cache
  -v|vv|vvv, --verbose           Increase the verbosity of messages: 1 for normal output, 2 for more verbose output and 3 for debug
...
Isso verifica que o Composer foi instalado com sucesso em seu sistema e está disponível em todo o sistema.
Nota: se você preferirá ter-lhe-ão separados separados do Composer para projeto hospedado neste servidor, você pode instalar localmente, em uma base por projeto. Este método também é útil quando o usuário do sistema não possui permissão para instalar o software disponível em todo o sistema.
Para fazer isso, use o comando php composer-setup.php. Isso irá gerar um arquivo composer.pharem seu diretório atual, que pode ser executado com o seu atual php composer.phar.
Agora podemos dar uma dependência em como usar o Compose como gerenciar.
Passo 3 — Usando o Compositor em um Projeto PHP
Os projetos PHP geralmente dependentes de bibliotecas externas, e o gerenciamento de dependências e suas versões podem ser complicados. O Composer resolve esse problema de manter um controle de projeto de extensões e dependências, também facilita o processo de descoberta, instalação e atualização de pacotes que são definidos por enquanto.
Para usar o seu projeto, você pode compor um arquivo composer.json. O arquivo composer.jsonComposer quais dependências precisa para baixar seu projeto quais serão as versões de cada pacote tem permissão para instalações e instalações. Isso é muito importante para manter seu projeto consistente e evitar a instalação de versões instáveis ​​que podem causar problemas de compatibilidade retroativa.
Você não precisa criar este arquivo manualmente - é comum ocorrer erros de sintaxe quando fizer isso. O Composer oferece uma maneira de criar um novo arquivo composer.jsoncom base na entrada do usuário, o que é uma boa escolha se você planeja compartilhar seu projeto mais tarde como um pacote público no Packagist . O Composer gera automaticamente um arquivo básico composer.jsonquando você executa um comando composer requirepara incluir uma dependência em um projeto recém-criado.
O processo de uso do Composer para instalar um pacote como uma dependência em um projeto envolve os passos a seguir:
Identifique o tipo de biblioteca que o aplicativo precisa.
uma biblioteca de código aberto adequada no agist.org , o responsável oficial de pacotes para o Compose.
Escolha o pacote de dependência.
Execute composer requirepara incluir a dependência no arquivo composer.jsone instalar o pacote.
Vamos testar isso com uma aplicação de demonstração.
O objetivo desta aplicação é transformar uma determinação determinada em uma string de URL amigável - um slug . Isso é comumente usado para converter os títulos de página para caminhos de URL (Assim como a parte final da URL para este tutorial).
Vamos começar a criar um diretório para o nosso projeto. Vamos chamá-lo de slugify :
cd ~
mkdir slugify
cd slugify
Embora não seja necessário, você pode executar agora um comando composer init para criar um arquivo composer.json detalhado para seu projeto. Como o único objetivo do nosso projeto é demonstrar como instalar dependências com o Composer, usaremos um arquivo composer.json mais simples que será gerado automaticamente quando exigirmos nosso primeiro pacote.
Agora é hora de procurar no Packagist.org por um pacote que pode nos ajudar a gerar slugs. Se você procurar pelo termo “slug” no Packagist, receberá um resultado parecido com este:
Resultados da Pesquisa do Packagist para o termo "slug"
Você verá dois números no lado direito de cada pacote na lista. O número no topo representa quantas vezes o pacote foi instalado através do Composer, e o número em baixo mostra quantas vezes um pacote foi estrelado no GitHub. De um modo geral, os pacotes com mais instalações e mais estrelas tendem a ser mais estáveis, pois mais pessoas os utilizam. Também é importante verificar a descrição do pacote para relevância para garantir que ele é o que você precisa.
Precisamos de um conversor string-to-slug A partir dos resultados da pesquisa, o pacote cocur/slugify, que aparece como o primeiro resultado naquela página, parece ser um bom candidato, com uma quantidade razoável de instalações e estrelas.
Os pacotes no Packagist têm um nome de vendor e um nome de package. Cada pacote tem um identificador único (um namespace) no mesmo formato que o GitHub utiliza para seus repositórios: vendor/package. A biblioteca que queremos instalar utiliza o namespace cocur/slugify. Você precisa de um namespace do pacote para exigi-lo em seu projeto.
Agora que você sabe exatamente qual pacote deseja instalar, você pode executar o composer require para incluí-lo como uma dependência e gerar também o arquivo composer.json para seu projeto. Uma coisa importante é observar a exigência de pacotes. O Composer rastreia as dependências no nível da aplicação e do sistema. As dependências no nível do sistema são importantes para indicar de quais módulos PHP um pacote depende. No caso do pacote cocur/slugify, ele exige um módulo PHP que ainda não instalamos.
Quando um pacote necessário depende de uma biblioteca de sistema que não está atualmente instalada em seu servidor, você receberá um erro informando qual requisito está faltando:
composer require cocur/slugify
Output
Using version ^4.0 for cocur/slugify
./composer.json has been updated
Loading composer repositories with package information
Updating dependencies (including require-dev)
Your requirements could not be resolved to an installable set of packages.
  Problem 1
    - Installation request for cocur/slugify ^4.0 -> satisfiable by cocur/slugify[v4.0.0].
    - cocur/slugify v4.0.0 requires ext-mbstring * -> the requested PHP extension mbstring is missing from your system.
...
Para resolver o problema de dependência do sistema, podemos procurar pelo pacote que falta usando o apt search:
apt search mbstring
Output
Sorting... Done
Full Text Search... Done
php-mbstring/focal 2:7.4+75 all
  MBSTRING module for PHP [default]
php-patchwork-utf8/focal 1.3.1-1 all
  UTF-8 strings handling for PHP
php7.4-mbstring/focal 7.4.3-4ubuntu1 amd64
  MBSTRING module for PHP
Após localizar o nome do pacote correto, você pode utilizar o apt novamente para instalar a dependência de sistema:
sudo apt install php-mbstring
Assim que a instalação terminar, você pode executar novamente o comando composer require:
composer require cocur/slugify
Output
Using version ^4.0 for cocur/slugify
./composer.json has been created
Loading composer repositories with package information
Updating dependencies (including require-dev)
Package operations: 1 install, 0 updates, 0 removals
  - Installing cocur/slugify (v4.0.0): Downloading (100%)         
Writing lock file
Generating autoload files
Como você pode ver na saída, o Composer decidiu automaticamente qual versão do pacote utilizar. Se você verificar o diretório do seu projeto agora, ele irá conter dois arquivos novos: composer.json e composer.lock, e um diretório vendor:
ls -l
Output
total 12
-rw-rw-r-- 1 sammy sammy   59 May  4 13:56 composer.json
-rw-rw-r-- 1 sammy sammy 3229 May  4 13:56 composer.lock
drwxrwxr-x 4 sammy sammy 4096 May  4 13:56 vendor
O arquivo composer.lock é usado para armazenar informações sobre quais versões de cada pacote estão instaladas, e garantir que as mesmas versões sejam usadas se outra pessoa clonar seu projeto e instalar suas dependências. O diretório vendor é onde as dependências do projeto estão localizadas. Você não deve fazer commit da pasta vendor no controle de versão - você precisa apenas incluir os arquivos composer.json e composer.lock.
Ao instalar um projeto que já contém um arquivo composer.json, execute o composer install para baixar as dependências do projeto.
Vamos dar uma olhada rápida em restrições de versão. Se você verificar o conteúdo do seu arquivo composer.json, verá algo parecido com isto:
cat composer.json
Output
{
    "require": {
        "cocur/slugify": "^4.0"
    }
}
Note que há o caractere especial ^ antes do número da versão no composer.json. O Composer suporta várias restrições diferentes e formatos para definir a versão necessária do pacote, para fornecer flexibilidade enquanto também mantém seu projeto estável. O operador circunflexo (^) utilizado pelo arquivo composer.json criado automaticamente é o operador recomendado para a interoperabilidade máxima, seguindo o versionamento semântico. Neste caso, ele define 4.0 como a versão mínima compatível e permite atualizações para qualquer versão futura abaixo de 5.0.
De um modo geral, você não precisará alterar as restrições de versão em seu arquivo composer.json. No entanto, algumas situações podem exigir que você edite manualmente as restrições – por exemplo, quando uma nova versão principal da sua biblioteca requerida é liberada e você deseja atualizar, ou quando a biblioteca que você deseja usar não segue o versionamento semântico.
Aqui estão alguns exemplos para lhe dar um melhor entendimento sobre como as restrições de versão do Composer funcionam:
Restrição   Significado Exemplo de Versões Permitidas
^1.0    >= 1.0 < 2.0    1.0, 1.2.3, 1.9.9
^1.1.0  >= 1.1.0 < 2.0  1.1.0, 1.5.6, 1.9.9
~1.0    >= 1.0 < 2.0.0  1.0, 1.4.1, 1.9.9
~1.0.0  >= 1.0.0 < 1.1  1.0.0, 1.0.4, 1.0.9
1.2.1   1.2.1   1.2.1
1.* >= 1.0 < 2.0    1.0.0, 1.4.5, 1.9.9
1.2. *  >= 1.2 < 1.3    1.2.0, 1.2.3, 1.2.9
Para uma visualização mais detalhada das restrições de versão do Composer, consulte a documentação oficial.
A seguir, vamos ver como carregar dependências automaticamente com o Composer.
Passo 4 — Incluindo o Script Autoload
Como o PHP por si só não carrega classes automaticamente, o Composer fornece um script autoload que você pode incluir em seu projeto para obter o carregamento automático para ele. Este arquivo é gerado automaticamente pelo Composer quando você adiciona sua primeira dependência.
A única coisa que você precisa fazer é incluir o arquivo vendor/autoload.php em seus scripts PHP antes de qualquer instância de classe.
Vamos testar isso em nossa aplicação de demonstração. Abra um novo arquivo chamado test.php em seu editor de texto:
nano test.php
Adicione o código a seguir que vem no arquivo vendor/autoload.php, carrega a dependência cocur/slugify, e o utiliza para criar um slug:
test.php
<?php
require __DIR__ . '/vendor/autoload.php';
use Cocur\Slugify\Slugify;
$slugify = new Slugify();
echo $slugify->slugify('Hello World, this is a long sentence and I need to make a slug from it!');
Salve o arquivo e saia do seu editor.
Agora, execute o script.
php test.php
Isso produz a saída hello-world-this-is-a-long-sentence-and-i-need-to-make-a-slug-from-it.
As dependências precisam de atualizações quando novas versões são liberadas. Dessa forma, vamos ver como lidar com isso.
Passo 5 — Atualizando as Dependências do Projeto
Sempre que você quiser atualizar suas dependências do projeto para versões mais recentes, execute o comando update:
composer update
Isso irá verificar por versões mais recentes das bibliotecas que você requer em seu projeto. Se uma versão mais recente for encontrada e ela for compatível com a restrição de versão definida no arquivo composer.json, o Composer substituirá a versão anterior instalada. O arquivo composer.lock será atualizado para refletir essas alterações.
Você também pode atualizar uma ou mais bibliotecas específicas, especificando-as desta forma:
composer update vendor/package vendor2/package2
Certifique-se de verificar em seus arquivos composer.json e composer.lock dentro do seu sistema de controle de versão após atualizar suas dependências de modo que outros também possam instalar essas versões mais recentes.
INÍCIO:
1 instalar o docker
2 abrir wsl2/Windows ou linux
 curl -s "https://laravel.build/olw?with=mysql,redis,mailhog,minio" | bash
3 cd olw
./vendor/bin/sail up -d
    ou
4 cd olw && ./vendor/bin/sail up -d
5 ATRIBUINDO PERMISSÃO PARA A PASTA
cd .. -> sai da pasta
sudo chmod 777 olw/ -R ou sem o 'sudo' chmod 777 olw/ -R
6 CRIANDO ALIAS PARA O COMANDO ANTERIOR
alias sail='[ -f sail ] && sh sail || sh vendor/bin/sail'
passa a usar assim: sail ps
7 CONFIGURAR PORTAS PARA A APLICAÇÃO NO NAVEGADOR E MYSQL
.env
APP_PORT=8000
*porta do myql
FORWARD_DB_PORT=3307
8 INSTALANDO DEPENDÊNCIA AO PROJETO
./vendor/bin/sail composer require laravel/breeze --dev
9 DEIXAR TELA DE AUTENTICAÇÃO PRONTA, ROTA AUTENTICADA, TAWINDCSS INSTALADO E INERTIA INSTALADO
./vendor/bin/sail artisan breeze:install vue 
ou
./vendor/bin/sail art breeze:install vue
10 RODAR AS MIGRATES PADRÕES DO PROJETO AI JÁ PODE CADASTRAR USUÁRIOS PARA LOGIN:
./vendor/bin/sail art migrate
11 
/*******************************************/
2a AULA:
O PROJETO CONSISTE EM RECEBER DADOS DE UMA API (punkapi.com) DE INFORMAÇÕES SOBRE CERVEJAS, VAMOS CONSTRUIR AS ROTAS PARA CONSUMIR A API E CRIAR A ESTRUTURA PARA O RELATÓRIO QUE IREMOS GERAR EM EXCEL E ENVIAR PARA O STORAGE...
1 CRIAR ROTAS:
code .
olw/routes/web.php
sail up -d -> SOBE O CONTAINER localhost:8000 (nesse projeto)
Route::get('/beers', fn()=> 'Olw - testando a rota /beers');
**************************************************
obs:
- laravel.com/api -> acesso a documentação do código;
- in line paramets for vscode -> extensão para vscode para exibir o nome dos métodos na hora que codificar;
- fira code -> extensão para fonte no vscode
Copilot vs Tabnine, qual preferem? (pesquisar sobre)
Link para extensões vscode:
https://github.com/icarojobs/vscode-useful-extensions
*************************************************
Route::get('/beers', fn()=> 'Olw - testando a rota /beers')
                             ->middleware(['auth']);
* FLUXO PADRÃO DO MVC-LARAVEL: 
life cicle: sai do usuário pelo navegador, insomnia ou postman -> passa pelo index.php(pasta public) -> passa pelos arquivos do bootstrap retornando uma instância da aplicação -> passa pelo kernel do http (carrega mais instâncias) -> Service provider -> despacha a requisição pro Router -> Cai no arquivo Web.php -> Middleware (se tiver, geralmente tem os globais) -> Controller (faz as regras de negócio e pode chamar outras classes como Serviços por exemplo)
-> Retorna uma view ou um json (No caso estamos usando inértia, ele não vai reinderizar a 'view.blade' padrão, ele vai reinderizar componente vue.js através do inértia.).
* EM VEZ DE USAR A FUNÇÃO AQUI NA ROTA CRIAMOS UM CONTROLLER:
obs.: ​dica: php artisan make:controller -r cria o Resource também.
sail artisan make:controller BeerController
ou 
sail art make:controller BeerController -> CRIA O ARQUIVO BeerController.php na pasta app/Http/Controllers
->
<?php
namespace App\Http\Controllers;
use Illuminate\Http\Request;
class BeerController extends Controller
{
    public function index()
    {
    return 'Virgu & Beer & Code'
    }
}
* NO ARQUIVO DE ROTAS Web.php CHAMA O BeersController:
importante importar o Controller <nomeDoController>+<CTRL=ENTER:
use App\Http\Controllers\BeerController;
Route::get('/beers', [BeerController::class, 'index'])
                        ->middleware(['auth']);
* PRECISAMOS CRIAR UM MÉTODO PARA PEGAR A LISTA, LISTAR OS DADOS DA API (listar as bebidas de https://api.punkapi.com/v2 ->
VAMOS CRIAR UMA NOVA CLASSE de serviços em app/Sevices/PunkapiService.php
* O LARAVEL POSSUI UM RECURSO CHAMADO HTTPClient que abstrai o uso de uma ferramenta chama guzeo, esse guzeo é o client http mais comum para php, com ele fazemos requisições pra diversos serviços web dentro do php para outras url, ele é robusto, então o laravel simplifica importando o recurso que faz tudo por 'detrás dos panos':
PunkapiService.php
<?php
namespace App\Services;
use Illuminate\Support\Facades\Http;
class PunkapiService
{
    public function getBeers()
    {
        return Http::get('https://api.punkapi.com/v2/beers');
    }
}
E NO BeerController.php fica:
<?php
namespace App\Http\Controllers;
use App\Services\PunkapiService;
use Illuminate\Http\Request;
class BeerController extends Controller
{
    public function index()
    {
    //return 'Virgu & Beer & Code';
    $service = new PunkapiService;
    return $service->getBeers();
    }
}
* TRATE É CARACTERÍSTICA QUE A CLASSE ADQUIRE (pode ter mesmos métodos e atributos substituindo o recurso de um classe extender várias classes que não tem no php, a trate é uma forma de fazer isso. O service  é uma outra camada na maioria das vezes abstrair seviços que vc vai consumir, por exemplo API.
Estando logado, os dados da api já serão exibidos em localhost:8000/beers, se usar um aplicativo cliente tipo insomnia pode apresentar os dados também, melhor comentar a linha de de autenticação da rota:
Route::get('/beers', [BeerController::class, 'index']);
linha de autenticação da rota // ->middleware(['auth']);
* ESSA API PERMITE FAZER FILTROS VIA PARÂMETROS NA PRÓPRIA ROTA. PRIMEIRO VAMOS REFATORAR O CÓDIO, A CLASSE PunkapiService.php:
USO DE CONFIG E MACRO
Vamos alterar a url, primeiro acessando a pasta config da raiz do projeto e criar o arquivo punkapi.php. O que acontece é que o config(pasta config da raiz) carrega todos os arquivos da pasta e permite que sejam acessados via funções simples(HELPERS), isso é muito legal porque podemos acessar esses arquivos de configurações de qualquer lugar do projeto: 
<?php
return [
    'url' => env('PUNK_BASE_URL', 'https://api.punkapi.com/v2')
];
Usando o helper env significa dizer que, se não houver a constante PUNK_BASE_URL setada no arquivo .env do projeto, seu valor será o segundo parâmetro: http://api.punkapi.com/v2 e no arquivo PunkapiService.php da pasta app/Services fica:
<?php
namespace App\Services;
use Illuminate\Support\Facades\Http;
class PunkapiService
{
    public function getBeers()
    {
        return Http::get('/beers');
    }
}
MACRO é uma forma de criar funções customizadas:
 em app\Providers vamos acessar o arquivo AppServiceProvider.php que é uma classe que tem dois métodos register e boot. No método boot vamos chamar o método Http do laravel e chamar o método macro, no primeiro parâmetro será um nome atribuído à função e e o segundo uma clausure (uma função).
Neste arquivo é passado o arquivo de configuração da url (em 'config/punkapi.php') além de tokens, headers,...
 
use Illuminate\Support\Facades\Http; -> deve ser importado
E a função boot fica:
  public function boot()
    {
        Http::macro('punkapi', function(){
            return Http::acceptJson()
            ->baseUrl(config('punkapi.url'));
        });
    }
Então criamos uma macro(uma função customizada) chamada punkapi que já retorna o client com accept/Json no Header e com o baseUrl configurado lá do arquivo /config/punkapi.php e se estiver setado no .env pegará de lá.
/app/Services/PunkapiService.php fica:
<?php
namespace App\Services;
use Illuminate\Support\Facades\Http;
class PunkapiService
{
    public function getBeers()
    {
        return Http::punkapi()->get('/beers');
    }
}
*obs.: a baseUrl poderia ser setada no construtor, que pode setar token também.(uma outra abordagem para versão sem macros);
->Testamos o retorno Json em localhost:8000/beers.
Refatorando o arquivo PunkapiService.php: O client Http não lança exceção e podemos forçar o retorno em modo Json:
<?php
namespace App\Services;
use Illuminate\Support\Facades\Http;
class PunkapiService
{
    public function getBeers()
    {
       // return Http::punkapi()->get('/beers');
       return Http::punkapi()
            ->get('/beers')
            ->throw()  // Exceção em caso de erro
            ->json();   // Força o retorno em formato Json
    }
}
Podemos testar forçando um erro alterando a constante PUNKAPI_BASE_URL criada em /config/punkapi.php, vamos atribuir um valor diferente no arquivo .env:
PUNKAPI_BASE_URL="adfjklj878"
Podemos usar a função retry tem dois parâmetros, o número de tentativas pra buscar a requisição e o intervalo entre elas. Refatorando o código fica:
<?php
namespace App\Services;
use Illuminate\Support\Facades\Http;
class PunkapiService
{
    public function getBeers()
    {
       // return Http::punkapi()->get('/beers');
       return Http::punkapi()
            ->get('/beers')
            ->throw()  // Exceção em caso de erro
            ->json();   // Força o retorno em formato Json
    }
}
- Quando sai a exceção nao deveriamos retornar o erro em json por ser um api neste caso estamos usamos um app web e não uma api. E usaríamos o Route Api.
Refatorando o método boot de /app/Providers/AppServiceProvider.php, inserindo o retry():
     */
    public function boot()
    {
        Http::macro('punkapi', function(){
            return Http::acceptJson()
            ->baseUrl(config('punkapi.url'))
            ->retry(3,100);
        });
    }
}
comando de help
* sail composer dump-autoload
* Verificar Nome do arquivo se bate com o nome das rotas(Classes criadas e importar o nome errado);
* inteliphense
Refatorando BeerController.php
<?php
namespace App\Http\Controllers;
use App\Services\PunkapiService;
class BeerController extends Controller
{
    public function index()
    {
    $service = new PunkapiService();
    return $service->getBeers();
    }
}
Em vez de instanciar o método PunkapiService() dentro de index, vamos passar por parâmetro de index() declarando seu Próprio nome (PunkapiService) como tipo. Fica assim:
<?php
namespace App\Http\Controllers;
use App\Services\PunkapiService;
class BeerController extends Controller
{
    public function index(PunkapiService $service)
    {
    return $service->getBeers();
    }
}
Assim usamos feactures do php(injeção de dependências) e ao mesmo tempo feactures do laravel. Em vez de criar uma instância dentro do método index, vamos injetar a classe como parâmetro para o método index(), ficando index($service) e a instância de dentro da função passa como parâmetro de 'tipo da variável'. Isso quebra a cadeia de dependência entre as classes.
Assim, o método index ganha independência não mais dependendo da instância de new PunkapiService e passamos a olhar a função index em si.
Assim, o Laravel tenta fazer um binding, um match, o laravel tenta encontrar alguma classe PunkapiService e cria uma instância dessa classe e usa ali como parâmetro. Se não fizer assim, lá em Rotas teria que ser passado como parâmetro o que fica desnecessário.
Não poderia ser feito se na classe PunkapiService existisse o construtor para atribuir valores automaticamente à classe. Assim podemos usar porque não precisamos passar nenhum valor.
ADICIONAR OS FILTROS:
Vamos filtrar o retorno api com os seguintes itens: beer_name, food, ibu_gt, malte:
var_dump($v)
die();
dd($variável)
benchmarck -> ?
/*****REFATORA PARA TESTE alterando BeerController.php e PunkapiService.php
BeerController.php
<?php
namespace App\Http\Controllers;
use App\Services\PunkapiService;
class BeerController extends Controller
{
    public function index(PunkapiService $service)
    {
    return $service->getBeers(
        'heineken',
        'cheese',
        'corn',
        45
    );
    }
}
PunkapiService.php
<?php
namespace App\Services;
use Illuminate\Support\Facades\Http;
class PunkapiService
{
    public function getBeers(
        string $beer_name,
        string $food,
        string $malt,
        string $ibu_gt
    )
    {
        $params = get_defined_vars();
        dd($params);
        return Http::punkapi()
            ->get('/beers', $params)
            ->throw()  // Exceção em caso de erro
            ->json();   // Força o retorno em formato Json
    }
}
Resultado do debug no insomnia ou no navegador:
array:4 [▼ // app/Services/PunkapiService.php:18
  "beer_name" => "heineken"
  "food" => "cheese"
  "malt" => "corn"
  "ibu_gt" => "45"
]
//* fim teste
Refatorando:
class PunkapiService
{
    public function getBeers(
        string $beer_name = null,
        string $food = null,
        string $malt = null,
        string $ibu_gt = null
    )
    {
        $params = get_defined_vars();
        dd($params);
        return Http::punkapi()
            ->get('/beers', $params)
            ->throw()  // Exceção em caso de erro
            ->json();   // Força o retorno em formato Json
    }
}
Assim quando não passar o valor para a chave ele exibirá a chave e o valor Null, vamos refatorar para não exibir nem a chave englobando get_defined_vers() com array_filter no arquivo PunkapiService.php:
$params = array_filter(get_defined_vars());
<?php
namespace App\Http\Controllers;
use App\Services\PunkapiService;
class BeerController extends Controller
{
    public function index(PunkapiService $service)
    {
    return $service->getBeers(
        'heineken',
        'cheese',
        'corn',
       // 45 -> Esse não é passado
    );
    }
}
array:3 [▼ // app/Services/PunkapiService.php:18
  "beer_name" => "heineken"
  "food" => "cheese"
  "malt" => "corn"
    Aqui não exibiu o valor 45
]
USANDO A FUNÇÃO NAMED_ARGS passamos só os parâmetros que precisamos retornar da api e o php com essa função saberá qual a posição dela no array de argumentos passados como parâmetro sem a necessidade de seguir a mesma sequência dos argumentos:
class BeerController extends Controller
{
    public function index(PunkapiService $service)
    {
    return $service->getBeers(food: 'cheese');
    }
}
REFATORANDO:
BeerController.php
<?php
namespace App\Http\Controllers;
use App\Services\PunkapiService;
use Illuminate\Http\Request;
class BeerController extends Controller
{
    public function index( Request $request, PunkapiService $service)
    {
    return $service->getBeers(...$request->all());
    }
}
PunkapiService.php
<?php
namespace App\Services;
use Illuminate\Support\Facades\Http;
class PunkapiService
{
    public function getBeers(
        string $beer_name = null,
        string $food = null,
        string $malt = null,
        string $ibu_gt = null
    )
    {
        $params = array_filter(get_defined_vars());
     //   dd($params);
        return Http::punkapi()
            ->get('/beers', $params)
            ->throw()  // Exceção em caso de erro
            ->json();   // Força o retorno em formato Json
    }
}
CRIANDO UMA REQUEST
sail artisan make:request BeerRequest
/app/Http/Requests/BeerRequest.php
* clouser é uma função passada como parâmetro
AGRUPANDO AS ROTAS 2:01MINUTO 
open laravel week | MVC, rotas , services, api, filas, redis laravel Excel e S3 | Mosturação
 
/**************************************/
sail share
sail artisan sail:publish ->coloca em uma pasta na raiz chamada docker
sail --help
sail artisan optimizer:clear
sail ps
sail build --no-cache -> faz o bild da aplicação. (dá um sail down  por precaução antes.)
/*********************************
root@DELLAGS:~# curl -s "https://laravel.build/laravel-9-course?with=mysql,redis,mailhog" | bash
Dockerfile
root@DELLAGS:~/example-app# docker exec -it example-app-mysql-1 bash
FROM wyveo/nginx-php-fpm:latest
WORKDIR /usr/share/nginx
RUN rm -rf /usr/share/nginx/html
COPY . /usr/share/nginx
RUN chmod -R 755 /usr/share/nginx/storage/*
RUN ln -s public html
.env (do composer)
DB_CONNECTION=mysql
DB_HOST=mysql-app (serviço do mysql no docker-compose.yaml)
DB_PORT=3306
DB_DATABASE=laraveldockerdb
DB_USERNAME=root
DB_PASSWORD=123456
docker-compose.yaml
version: '3'
services:
  laraveldocker-app:
    build: .
    ports:
      - "3003:80"
    volumes:
      - ./:/usr/share/nginx
      - .docker/nginx:/etc/nginx/conf.d/
    networks:
      - app-network
  mysql-app:
    image: mysql:5.7.22
    ports:
      - "3306:3306"
    volumes:
      - .docker/dbdata:/var/lib/mysql
    environment:
      MYSQL_DATABASE: laraveldocker
      MYSQL_ROOT_PASSWORD: 123456
    networks:
      - app-network
networks:
  app-network:
    driver: bridge
    
/*************************************************
#criando um serviço com um nome qualquer
version: '3'
services:
  laravel-app:                    #criando um serviço com um nome qualquer
    build: . ou image: wyveo/nginx-php-fpm:latest -> neste caso sem Dockerfile.                    # endereço da imagem ou local do Dockerfile (neste caso o ponto siginifica a raiz do projeto)
    ports:
      - "8080:80"                 # 8080 porta do meu host: 80 é a porta do docker nginx
    volumes:                      # docker-compose up -d -> sobe a imagem e libera o terminal  
      - ./:/usr/share/nginx       # TUDO QUE ESTIVE NA RAIZ (na rais tem o meu projeto laravel) './' IRÁ SER REFLETIDO NA PASTA /usr/share/nginx (pasta de acesso da página html)
                                  # C:\Laravel-docker\laravel-docker>docker compose up -d --build atualiza a minha imagem
  mysql-app:
      image: mysql:5.7
      ports:
        - "3306:3306"
      volumes:
        - .docker/dbdata:/var/lib/mysql          # qualqer nome (para persistir -guardar os dados do banco de dados)
      environment:
        MYSQL_DATABASE: laravel
        MYSQL_ROOT_PASSWORD: laravel
    
      
      /***************************///
  
C:\Laravel-docker\laravel-docker>docker compose up -d --build
                                
                               
    
/******************************** Dockerfile
FROM wyveo/nginx-php-fpm:latest
/***************************///
  COMANDOS
docker compose down -> para todos os containers
C:\Laravel-docker\laravel-docker>docker exec -it laravel-docker-laravel-app-1 bash 
root@612ea0ea3340:/# cd /usr/share/nginx/
root@612ea0ea3340:/usr/share/nginx# php artisan migrate
root@612ea0ea3340:/usr/share/nginx# php artisan serve
        
/***********/
PS C:\Users\alber> docker run -e MYSQL_ROOT_PASSWORD=root --name meu-mysql -d mysql:5.7
docker inspect meu-mysql ou | grep IPAddress
PS C:\Users\alber> docker run -e MYSQL_ROOT_PASSWORD=root --name meu-mysql -d -p 3306:3306 mysql:5.7
docker ps
docker ps -l
docker ps -a
docker rm -f nome
/*** LARAVEL */
### CRIANDO UM PROJETO NO LARAVEL 
laravel new projeto_laravel_via_installer (ESTA É UM AOPÇÃO)
composer create-project --prefer-dist laravel/laravel app_controle_tarefas "8.5.9"
cd app_controle_tarefas
cd public
php -S localhost:8000
ou 
da raiz do projeto:
php artisan serve 
ou
php artisan serve --port=3000
### PARA ABRIR PORTA EM OUTRO SERVIDOR
php artisan serve --host test.com --port 8080
 **********************************************************************
cd app_controle_tarefas
cd public
php artisan serve
- acessa o navegador http://localhost:8000
### DENTRO DO PROJETO CRIADO INSTALAR O LARAVEL/UI:^3.2 - versão 3.2
composer require laravel/ui:^3.2
### SE OCORRER ERRO AUMENTAR A MEMÓRIA DISPONIVEL PARA O php
-php --ini -> localiza o arquivo de configuração do php
LOCALIZA memory_limit = 1000 e altera para 
         memory_limit  = -1 e Salva
### LISTA A RELAÇÃO DE COMANDOS 
php artisan list 
DEVERA SURGIR AS OPÇÕES ABAIXO:
 ui
  ui:auth               Scaffold basic login and registration views and routes
  ui:controllers        Scaffold the authentication controllers
 vendor
### ENTENDENDO O PACOTE UI E INICIANDO A AUTENTICAÇÃO WEB NATIVA DO LARAVEL
COMANDO PARA LISTAR ROUTES: 
php artisan route:list
### php artisan ui bootstrap --auth (bootstrap ou react ou vue)
aplicando o bootstrap incluindo os recursos de autenticação;
poderia ser aplicado o bootstrap sem os recursos de autenticação;
### php artisan route:list -> mostra as rotas - ver que aumentaram as rotas
### APÓS ESSE PROCESSO O SISTEMA PEDE PARA RODAR
npm install -> instala as dependências do package.json (inclusive o bootstrap)
npm run dev -> gera os assets da aplicação de acordo com a tecnologia selecionada (bootstrap, react ou vue) -> Geralmente roda mais de uma vez para compilar tudo.
### CRIA O BANCO DE DADOS NORMALMENTE
### EXECUTA AS MIGRATIONS PADRÕES CRIADAS PARA O SISTEMA DE login
php artisan migrate -> CRIA AS TABELAS NO BANCO DE DADOS
************************************** 
INSTALANDO O COMPOSER NO UBUNTU
**************************************
sudo apt update
sudo apt install php-cli unzip
cd ~
curl -sS https://getcomposer.org/installer -o composer-setup.php
HASH=`curl -sS https://composer.github.io/installer.sig`

echo $HASH ->saída: Output
e0012edf3e80b6978849f5eff0d4b4e4c79ff1609dd1e613307e16318854d24ae64f26d17af3ef0bf7cfb710ca74



php -r "if (hash_file('SHA384', 'composer-setup.php') === '$HASH') { echo 'Installer verified'; } else { echo 'Installer corrupt'; unlink('composer-setup.php'); } echo PHP_EOL;"

sudo php composer-setup.php --install-dir=/usr/local/bin --filename=composer





***********************

DigitalOcean Kubernetes: novo plano de controle é mais rápido e gratuito, habilita HA para SLA de 99,95% de tempo de atividade
Produtos
Preços

Documentos
divisa suspensa

Entrar
divisa suspensa

// Tutorial //
Como Instalar e Utilizar o Composer no Ubuntu 20.04
Publicado em 21 de maio de 2020
Ubuntu
PHP
Ubuntu 20.04
Avatar padrão
Por Erika Heidi
Advogado Desenvolvedor
Português
Como Instalar e Utilizar o Composer no Ubuntu 20.04
Introdução
O Composer é uma ferramenta popular de gerenciamento de dependências para o PHP, criado para facilitar a instalação e a atualização das dependências principalmente do projeto. Ele controla quais outros pacotes de projeto específico dependem e são instalados para você, usando as opções apropriadas de acordo com os requisitos do projeto. O Composer também é comumente utilizado para inicializar novos projetos em frameworks PHP populares, como o Symfon e o Laravel .

Neste tutorial, você instalará e começará a usar o Composer em um sistema Ubuntu 20.04.

Pré-requisitos
Para seguir este guia, você pode acessar um servidor como usuário Ubuntu20.04 como usuário sudonão-root um firewall habilitado em seu servidor Para configurar isto, siga nosso guia Configuração do servidor inicial para o Ubuntu 20.04

Passo 1 — Instalando o PHP e as Dependências Adicionais
Além das dependências que já devem estar incluídas em seu sistema Ubuntu 20.04, como o , o Composer exige ou gitexecuta scripts PHP na linha de comando e para extrair arquivos zipados. Vamos instalar essas dependências agora.curlphp-cliunzip

primeiro, atual, gerenciador de pacotes de soluções: o cache do gerenciador de pacotes

sudo apt update
Em seguida, o seguinte comando para instalar os pacotes, execute:

sudo apt install php-cli unzip
Você será solicitado a confirmar a instalação digitando Ye, depois, ENTER.

Assim que os pré-requisitos para instalação do Composer forem instalados, você poderá seguir.

Passo 2 — Baixando e Instalando o Compositor
O Composer fornece um instalador de script escrito em PHP. Vamos baixá-lo, verificar se ele não está danificado e, em seguida, o usaremos para instalar o Composer.

Certifique-se de estar em sua pasta home. Em seguida, baixe o instalador usando o curl:

cd ~
curl -sS https://getcomposer.org/installer -o composer-setup.php
Em seguida, vamos verificar se o instalador baixado corresponde ao hash SHA-384 para o instalador mais recente encontrado na página Composer Public Keys / Signatures . Para facilitar o passo de seleção, você pode usar o seguinte comando para obter programaticamente o hash mais recente da página do Composer e armazená-lo em uma variável do shell:

HASH=`curl -sS https://composer.github.io/installer.sig`
Se você quiser verificar o valor realizado, execute:

echo $HASH
Output
e0012edf3e80b6978849f5eff0d4b4e4c79ff1609dd1e613307e16318854d24ae64f26d17af3ef0bf7cfb710ca74755a
Agora o código PHP a seguir, execute conforme a página de download do Composer, para verificar se o script de instalação está seguro para ser executado:

php -r "if (hash_file('SHA384', 'composer-setup.php') === '$HASH') { echo 'Installer verified'; } else { echo 'Installer corrupt'; unlink('composer-setup.php'); } echo PHP_EOL;"
Você verá o seguinte resultado:

Resultado
Installer verified
Se Installer corruptvocê estiver usando o hash correto, verifique se você está usando o hash correto. Em seguida, repita o processo de verificação. Quando você tiver um instalador selecionado, você pode continuar.

Para instalar o composerglobalmente, use o seguinte comando que baixará e instalará o Composer como um comando disponível em todo o sistema chamado composer, sob /usr/local/bin:

sudo php composer-setup.php --install-dir=/usr/local/bin --filename=composer
Você verá um resultado semelhante com este:

Output
All settings correct for using Composer
Downloading...

Composer (version 1.10.5) successfully installed to: /usr/local/bin/composer
Use it: php /usr/local/bin/composer
Para testar sua instalação, execute:

composer
Output
   ______
  / ____/___  ____ ___  ____  ____  ________  _____
 / /   / __ \/ __ `__ \/ __ \/ __ \/ ___/ _ \/ ___/
/ /___/ /_/ / / / / / / /_/ / /_/ (__  )  __/ /
\____/\____/_/ /_/ /_/ .___/\____/____/\___/_/
                    /_/
Composer version 1.10.5 2020-04-10 11:44:22
Usage:
  command [options] [arguments]
Options:
  -h, --help                     Display this help message
  -q, --quiet                    Do not output any message
  -V, --version                  Display this application version
      --ansi                     Force ANSI output
      --no-ansi                  Disable ANSI output
  -n, --no-interaction           Do not ask any interactive question
      --profile                  Display timing and memory usage information
      --no-plugins               Whether to disable plugins.
  -d, --working-dir=WORKING-DIR  If specified, use the given directory as working directory.
      --no-cache                 Prevent use of the cache
  -v|vv|vvv, --verbose           Increase the verbosity of messages: 1 for normal output, 2 for more verbose output and 3 for debug
...
Isso verifica que o Composer foi instalado com sucesso em seu sistema e está disponível em todo o sistema.
Nota: se você preferirá ter-lhe-ão separados separados do Composer para projeto hospedado neste servidor, você pode instalar localmente, em uma base por projeto. Este método também é útil quando o usuário do sistema não possui permissão para instalar o software disponível em todo o sistema.
Para fazer isso, use o comando php composer-setup.php. Isso irá gerar um arquivo composer.pharem seu diretório atual, que pode ser executado com o seu atual php composer.phar.
Agora podemos dar uma dependência em como usar o Compose como gerenciar.
Passo 3 — Usando o Compositor em um Projeto PHP
Os projetos PHP geralmente dependentes de bibliotecas externas, e o gerenciamento de dependências e suas versões podem ser complicados. O Composer resolve esse problema de manter um controle de projeto de extensões e dependências, também facilita o processo de descoberta, instalação e atualização de pacotes que são definidos por enquanto.
Para usar o seu projeto, você pode compor um arquivo composer.json. O arquivo composer.jsonComposer quais dependências precisa para baixar seu projeto quais serão as versões de cada pacote tem permissão para instalações e instalações. Isso é muito importante para manter seu projeto consistente e evitar a instalação de versões instáveis ​​que podem causar problemas de compatibilidade retroativa.
Você não precisa criar este arquivo manualmente - é comum ocorrer erros de sintaxe quando fizer isso. O Composer oferece uma maneira de criar um novo arquivo composer.jsoncom base na entrada do usuário, o que é uma boa escolha se você planeja compartilhar seu projeto mais tarde como um pacote público no Packagist . O Composer gera automaticamente um arquivo básico composer.jsonquando você executa um comando composer requirepara incluir uma dependência em um projeto recém-criado.
O processo de uso do Composer para instalar um pacote como uma dependência em um projeto envolve os passos a seguir:
Identifique o tipo de biblioteca que o aplicativo precisa.
uma biblioteca de código aberto adequada no agist.org , o responsável oficial de pacotes para o Compose.
Escolha o pacote de dependência.
Execute composer requirepara incluir a dependência no arquivo composer.jsone instalar o pacote.
Vamos testar isso com uma aplicação de demonstração.
O objetivo desta aplicação é transformar uma determinação determinada em uma string de URL amigável - um slug . Isso é comumente usado para converter os títulos de página para caminhos de URL (Assim como a parte final da URL para este tutorial).
Vamos começar a criar um diretório para o nosso projeto. Vamos chamá-lo de slugify :
cd ~
mkdir slugify
cd slugify
Embora não seja necessário, você pode executar agora um comando composer init para criar um arquivo composer.json detalhado para seu projeto. Como o único objetivo do nosso projeto é demonstrar como instalar dependências com o Composer, usaremos um arquivo composer.json mais simples que será gerado automaticamente quando exigirmos nosso primeiro pacote.
Agora é hora de procurar no Packagist.org por um pacote que pode nos ajudar a gerar slugs. Se você procurar pelo termo “slug” no Packagist, receberá um resultado parecido com este:
Resultados da Pesquisa do Packagist para o termo "slug"
Você verá dois números no lado direito de cada pacote na lista. O número no topo representa quantas vezes o pacote foi instalado através do Composer, e o número em baixo mostra quantas vezes um pacote foi estrelado no GitHub. De um modo geral, os pacotes com mais instalações e mais estrelas tendem a ser mais estáveis, pois mais pessoas os utilizam. Também é importante verificar a descrição do pacote para relevância para garantir que ele é o que você precisa.
Precisamos de um conversor string-to-slug A partir dos resultados da pesquisa, o pacote cocur/slugify, que aparece como o primeiro resultado naquela página, parece ser um bom candidato, com uma quantidade razoável de instalações e estrelas.
Os pacotes no Packagist têm um nome de vendor e um nome de package. Cada pacote tem um identificador único (um namespace) no mesmo formato que o GitHub utiliza para seus repositórios: vendor/package. A biblioteca que queremos instalar utiliza o namespace cocur/slugify. Você precisa de um namespace do pacote para exigi-lo em seu projeto.
Agora que você sabe exatamente qual pacote deseja instalar, você pode executar o composer require para incluí-lo como uma dependência e gerar também o arquivo composer.json para seu projeto. Uma coisa importante é observar a exigência de pacotes. O Composer rastreia as dependências no nível da aplicação e do sistema. As dependências no nível do sistema são importantes para indicar de quais módulos PHP um pacote depende. No caso do pacote cocur/slugify, ele exige um módulo PHP que ainda não instalamos.
Quando um pacote necessário depende de uma biblioteca de sistema que não está atualmente instalada em seu servidor, você receberá um erro informando qual requisito está faltando:
composer require cocur/slugify
Output
Using version ^4.0 for cocur/slugify
./composer.json has been updated
Loading composer repositories with package information
Updating dependencies (including require-dev)
Your requirements could not be resolved to an installable set of packages.
  Problem 1
    - Installation request for cocur/slugify ^4.0 -> satisfiable by cocur/slugify[v4.0.0].
    - cocur/slugify v4.0.0 requires ext-mbstring * -> the requested PHP extension mbstring is missing from your system.
...
Para resolver o problema de dependência do sistema, podemos procurar pelo pacote que falta usando o apt search:
apt search mbstring
Output
Sorting... Done
Full Text Search... Done
php-mbstring/focal 2:7.4+75 all
  MBSTRING module for PHP [default]
php-patchwork-utf8/focal 1.3.1-1 all
  UTF-8 strings handling for PHP
php7.4-mbstring/focal 7.4.3-4ubuntu1 amd64
  MBSTRING module for PHP
Após localizar o nome do pacote correto, você pode utilizar o apt novamente para instalar a dependência de sistema:
sudo apt install php-mbstring
Assim que a instalação terminar, você pode executar novamente o comando composer require:
composer require cocur/slugify
Output
Using version ^4.0 for cocur/slugify
./composer.json has been created
Loading composer repositories with package information
Updating dependencies (including require-dev)
Package operations: 1 install, 0 updates, 0 removals
  - Installing cocur/slugify (v4.0.0): Downloading (100%)         
Writing lock file
Generating autoload files
Como você pode ver na saída, o Composer decidiu automaticamente qual versão do pacote utilizar. Se você verificar o diretório do seu projeto agora, ele irá conter dois arquivos novos: composer.json e composer.lock, e um diretório vendor:
ls -l
Output
total 12
-rw-rw-r-- 1 sammy sammy   59 May  4 13:56 composer.json
-rw-rw-r-- 1 sammy sammy 3229 May  4 13:56 composer.lock
drwxrwxr-x 4 sammy sammy 4096 May  4 13:56 vendor
O arquivo composer.lock é usado para armazenar informações sobre quais versões de cada pacote estão instaladas, e garantir que as mesmas versões sejam usadas se outra pessoa clonar seu projeto e instalar suas dependências. O diretório vendor é onde as dependências do projeto estão localizadas. Você não deve fazer commit da pasta vendor no controle de versão - você precisa apenas incluir os arquivos composer.json e composer.lock.
Ao instalar um projeto que já contém um arquivo composer.json, execute o composer install para baixar as dependências do projeto.
Vamos dar uma olhada rápida em restrições de versão. Se você verificar o conteúdo do seu arquivo composer.json, verá algo parecido com isto:
cat composer.json
Output
{
    "require": {
        "cocur/slugify": "^4.0"
    }
}
Note que há o caractere especial ^ antes do número da versão no composer.json. O Composer suporta várias restrições diferentes e formatos para definir a versão necessária do pacote, para fornecer flexibilidade enquanto também mantém seu projeto estável. O operador circunflexo (^) utilizado pelo arquivo composer.json criado automaticamente é o operador recomendado para a interoperabilidade máxima, seguindo o versionamento semântico. Neste caso, ele define 4.0 como a versão mínima compatível e permite atualizações para qualquer versão futura abaixo de 5.0.
De um modo geral, você não precisará alterar as restrições de versão em seu arquivo composer.json. No entanto, algumas situações podem exigir que você edite manualmente as restrições – por exemplo, quando uma nova versão principal da sua biblioteca requerida é liberada e você deseja atualizar, ou quando a biblioteca que você deseja usar não segue o versionamento semântico.
Aqui estão alguns exemplos para lhe dar um melhor entendimento sobre como as restrições de versão do Composer funcionam:
Restrição   Significado Exemplo de Versões Permitidas
^1.0    >= 1.0 < 2.0    1.0, 1.2.3, 1.9.9
^1.1.0  >= 1.1.0 < 2.0  1.1.0, 1.5.6, 1.9.9
~1.0    >= 1.0 < 2.0.0  1.0, 1.4.1, 1.9.9
~1.0.0  >= 1.0.0 < 1.1  1.0.0, 1.0.4, 1.0.9
1.2.1   1.2.1   1.2.1
1.* >= 1.0 < 2.0    1.0.0, 1.4.5, 1.9.9
1.2. *  >= 1.2 < 1.3    1.2.0, 1.2.3, 1.2.9
Para uma visualização mais detalhada das restrições de versão do Composer, consulte a documentação oficial.
A seguir, vamos ver como carregar dependências automaticamente com o Composer.
Passo 4 — Incluindo o Script Autoload
Como o PHP por si só não carrega classes automaticamente, o Composer fornece um script autoload que você pode incluir em seu projeto para obter o carregamento automático para ele. Este arquivo é gerado automaticamente pelo Composer quando você adiciona sua primeira dependência.
A única coisa que você precisa fazer é incluir o arquivo vendor/autoload.php em seus scripts PHP antes de qualquer instância de classe.
Vamos testar isso em nossa aplicação de demonstração. Abra um novo arquivo chamado test.php em seu editor de texto:
nano test.php
Adicione o código a seguir que vem no arquivo vendor/autoload.php, carrega a dependência cocur/slugify, e o utiliza para criar um slug:
test.php
<?php
require __DIR__ . '/vendor/autoload.php';
use Cocur\Slugify\Slugify;
$slugify = new Slugify();
echo $slugify->slugify('Hello World, this is a long sentence and I need to make a slug from it!');
Salve o arquivo e saia do seu editor.
Agora, execute o script.
php test.php
Isso produz a saída hello-world-this-is-a-long-sentence-and-i-need-to-make-a-slug-from-it.
As dependências precisam de atualizações quando novas versões são liberadas. Dessa forma, vamos ver como lidar com isso.
Passo 5 — Atualizando as Dependências do Projeto
Sempre que você quiser atualizar suas dependências do projeto para versões mais recentes, execute o comando update:
composer update
Isso irá verificar por versões mais recentes das bibliotecas que você requer em seu projeto. Se uma versão mais recente for encontrada e ela for compatível com a restrição de versão definida no arquivo composer.json, o Composer substituirá a versão anterior instalada. O arquivo composer.lock será atualizado para refletir essas alterações.
Você também pode atualizar uma ou mais bibliotecas específicas, especificando-as desta forma:
composer update vendor/package vendor2/package2
Certifique-se de verificar em seus arquivos composer.json e composer.lock dentro do seu sistema de controle de versão após atualizar suas dependências de modo que outros também possam instalar essas versões mais recentes.
Conclusão
***********
Algoritmo "CalculoMedia2"
// Disciplina: Lógica de programação
// Professor : Antonio Carlos Nicolodi
// Descrição : calculo da média aritimética
// Autor     : Professor Antonio
// Data atual: 01/04/2015
var
// Seção de Declarações
   v1, v2, total: Real
   sinal : Caracter
Inicio
// Seção dos Comandos
   Escreva ("Digite o primeiro valor: ")
   Leia (v1)
   Escreva ("Digite a operação + - * / : ")
   Leia (sinal)
   Escreva ("Digite o segundo valor: ")
   Leia (v2)
   Se sinal = "+" entao
   total <- v1 + v2
   Escreva("O Resultado é: ", total)
   Senao
   Se sinal = "-" entao
   total <- v1 - v2
   Escreva("O Resultado é: ", total)
   Senao
   Se sinal = "*" entao
   total <- v1 * v2
   Escreva("O Resultado é: ", total)
   Senao
     Escreva("OPERAÇÃO INVÁLIDA! ")
      Escreval("total")
   fimse
Fimalgoritmo
****
COMANDOS DOCKER
root@DELLAGS:~# curl -s "https://laravel.build/laravel-9-course?with=mysql,redis,mailhog" | bash
root@DELLAGS:~/example-app# ./vendor/bin/sail  artisan migrate --seed -> criar o banco de dados e copular dados;
Dockerfile
root@DELLAGS:~/example-app# docker exec -it example-app-mysql-1 bash
FROM wyveo/nginx-php-fpm:latest
WORKDIR /usr/share/nginx
RUN rm -rf /usr/share/nginx/html
COPY . /usr/share/nginx
RUN chmod -R 755 /usr/share/nginx/storage/*
RUN ln -s public html
.env (do composer)
DB_CONNECTION=mysql
DB_HOST=mysql-app (serviço do mysql no docker-compose.yaml)
DB_PORT=3306
DB_DATABASE=laraveldockerdb
DB_USERNAME=root
DB_PASSWORD=123456
docker-compose.yaml
version: '3'
services:
  laraveldocker-app:
    build: .
    ports:
      - "3003:80"
    volumes:
      - ./:/usr/share/nginx
      - .docker/nginx:/etc/nginx/conf.d/
    networks:
      - app-network
  mysql-app:
    image: mysql:5.7.22
    ports:
      - "3306:3306"
    volumes:
      - .docker/dbdata:/var/lib/mysql
    environment:
      MYSQL_DATABASE: laraveldocker
      MYSQL_ROOT_PASSWORD: 123456
    networks:
      - app-network
networks:
  app-network:
    driver: bridge
    
/*************************************************
#criando um serviço com um nome qualquer
version: '3'
services:
  laravel-app:                    #criando um serviço com um nome qualquer
    build: . ou image: wyveo/nginx-php-fpm:latest -> neste caso sem Dockerfile.                    # endereço da imagem ou local do Dockerfile (neste caso o ponto siginifica a raiz do projeto)
    ports:
      - "8080:80"                 # 8080 porta do meu host: 80 é a porta do docker nginx
    volumes:                      # docker-compose up -d -> sobe a imagem e libera o terminal  
      - ./:/usr/share/nginx       # TUDO QUE ESTIVE NA RAIZ (na rais tem o meu projeto laravel) './' IRÁ SER REFLETIDO NA PASTA /usr/share/nginx (pasta de acesso da página html)
                                  # C:\Laravel-docker\laravel-docker>docker compose up -d --build atualiza a minha imagem
  mysql-app:
      image: mysql:5.7
      ports:
        - "3306:3306"
      volumes:
        - .docker/dbdata:/var/lib/mysql          # qualqer nome (para persistir -guardar os dados do banco de dados)
      environment:
        MYSQL_DATABASE: laravel
        MYSQL_ROOT_PASSWORD: laravel
    
      
      /***************************///
  
C:\Laravel-docker\laravel-docker>docker compose up -d --build
                                
                               
    
/******************************** Dockerfile
FROM wyveo/nginx-php-fpm:latest
/***************************///
  COMANDOS
docker compose down -> para todos os containers
C:\Laravel-docker\laravel-docker>docker exec -it laravel-docker-laravel-app-1 bash 
root@612ea0ea3340:/# cd /usr/share/nginx/
root@612ea0ea3340:/usr/share/nginx# php artisan migrate
root@612ea0ea3340:/usr/share/nginx# php artisan serve
        
/***********/
PS C:\Users\alber> docker run -e MYSQL_ROOT_PASSWORD=root --name meu-mysql -d mysql:5.7
docker inspect meu-mysql ou | grep IPAddress
PS C:\Users\alber> docker run -e MYSQL_ROOT_PASSWORD=root --name meu-mysql -d -p 3306:3306 mysql:5.7
docker ps
docker ps -l
docker ps -a
docker rm -f nome
/*** LARAVEL */
### CRIANDO UM PROJETO NO LARAVEL 
laravel new projeto_laravel_via_installer (ESTA É UM AOPÇÃO)
composer create-project --prefer-dist laravel/laravel app_controle_tarefas "8.5.9"
cd app_controle_tarefas
cd public
php -S localhost:8000
ou 
da raiz do projeto:
php artisan serve 
ou
php artisan serve --port=3000
### PARA ABRIR PORTA EM OUTRO SERVIDOR
php artisan serve --host test.com --port 8080
 **********************************************************************
cd app_controle_tarefas
cd public
php artisan serve
- acessa o navegador http://localhost:8000
### DENTRO DO PROJETO CRIADO INSTALAR O LARAVEL/UI:^3.2 - versão 3.2
composer require laravel/ui:^3.2
### SE OCORRER ERRO AUMENTAR A MEMÓRIA DISPONIVEL PARA O php
-php --ini -> localiza o arquivo de configuração do php
LOCALIZA memory_limit = 1000 e altera para 
         memory_limit  = -1 e Salva
### LISTA A RELAÇÃO DE COMANDOS 
php artisan list 
DEVERA SURGIR AS OPÇÕES ABAIXO:
 ui
  ui:auth               Scaffold basic login and registration views and routes
  ui:controllers        Scaffold the authentication controllers
 vendor
### ENTENDENDO O PACOTE UI E INICIANDO A AUTENTICAÇÃO WEB NATIVA DO LARAVEL
COMANDO PARA LISTAR ROUTES: 
php artisan route:list
### php artisan ui bootstrap --auth (bootstrap ou react ou vue)
aplicando o bootstrap incluindo os recursos de autenticação;
poderia ser aplicado o bootstrap sem os recursos de autenticação;
### php artisan route:list -> mostra as rotas - ver que aumentaram as rotas
### APÓS ESSE PROCESSO O SISTEMA PEDE PARA RODAR
npm install -> instala as dependências do package.json (inclusive o bootstrap)
npm run dev -> gera os assets da aplicação de acordo com a tecnologia selecionada (bootstrap, react ou vue) -> Geralmente roda mais de uma vez para compilar tudo.
### CRIA O BANCO DE DADOS NORMALMENTE
### EXECUTA AS MIGRATIONS PADRÕES CRIADAS PARA O SISTEMA DE login
php artisan migrate -> CRIA AS TABELAS NO BANCO DE DADOS
************************************** 
INSTALANDO O COMPOSER NO UBUNTU
**************************************
sudo apt update
sudo apt install php-cli unzip
cd ~
curl -sS https://getcomposer.org/installer -o composer-setup.php
HASH=`curl -sS https://composer.github.io/installer.sig`

echo $HASH ->saída: Output
e0012edf3e80b6978849f5eff0d4b4e4c79ff1609dd1e613307e16318854d24ae64f26d17af3ef0bf7cfb710ca74



php -r "if (hash_file('SHA384', 'composer-setup.php') === '$HASH') { echo 'Installer verified'; } else { echo 'Installer corrupt'; unlink('composer-setup.php'); } echo PHP_EOL;"

sudo php composer-setup.php --install-dir=/usr/local/bin --filename=composer





***********************

DigitalOcean Kubernetes: novo plano de controle é mais rápido e gratuito, habilita HA para SLA de 99,95% de tempo de atividade
Produtos
Preços

Documentos
divisa suspensa

Entrar
divisa suspensa

// Tutorial //
Como Instalar e Utilizar o Composer no Ubuntu 20.04
Publicado em 21 de maio de 2020
Ubuntu
PHP
Ubuntu 20.04
Avatar padrão
Por Erika Heidi
Advogado Desenvolvedor
Português
Como Instalar e Utilizar o Composer no Ubuntu 20.04
Introdução
O Composer é uma ferramenta popular de gerenciamento de dependências para o PHP, criado para facilitar a instalação e a atualização das dependências principalmente do projeto. Ele controla quais outros pacotes de projeto específico dependem e são instalados para você, usando as opções apropriadas de acordo com os requisitos do projeto. O Composer também é comumente utilizado para inicializar novos projetos em frameworks PHP populares, como o Symfon e o Laravel .

Neste tutorial, você instalará e começará a usar o Composer em um sistema Ubuntu 20.04.

Pré-requisitos
Para seguir este guia, você pode acessar um servidor como usuário Ubuntu20.04 como usuário sudonão-root um firewall habilitado em seu servidor Para configurar isto, siga nosso guia Configuração do servidor inicial para o Ubuntu 20.04

Passo 1 — Instalando o PHP e as Dependências Adicionais
Além das dependências que já devem estar incluídas em seu sistema Ubuntu 20.04, como o , o Composer exige ou gitexecuta scripts PHP na linha de comando e para extrair arquivos zipados. Vamos instalar essas dependências agora.curlphp-cliunzip

primeiro, atual, gerenciador de pacotes de soluções: o cache do gerenciador de pacotes

sudo apt update
Em seguida, o seguinte comando para instalar os pacotes, execute:

sudo apt install php-cli unzip
Você será solicitado a confirmar a instalação digitando Ye, depois, ENTER.

Assim que os pré-requisitos para instalação do Composer forem instalados, você poderá seguir.

Passo 2 — Baixando e Instalando o Compositor
O Composer fornece um instalador de script escrito em PHP. Vamos baixá-lo, verificar se ele não está danificado e, em seguida, o usaremos para instalar o Composer.

Certifique-se de estar em sua pasta home. Em seguida, baixe o instalador usando o curl:

cd ~
curl -sS https://getcomposer.org/installer -o composer-setup.php
Em seguida, vamos verificar se o instalador baixado corresponde ao hash SHA-384 para o instalador mais recente encontrado na página Composer Public Keys / Signatures . Para facilitar o passo de seleção, você pode usar o seguinte comando para obter programaticamente o hash mais recente da página do Composer e armazená-lo em uma variável do shell:

HASH=`curl -sS https://composer.github.io/installer.sig`
Se você quiser verificar o valor realizado, execute:

echo $HASH
Output
e0012edf3e80b6978849f5eff0d4b4e4c79ff1609dd1e613307e16318854d24ae64f26d17af3ef0bf7cfb710ca74755a
Agora o código PHP a seguir, execute conforme a página de download do Composer, para verificar se o script de instalação está seguro para ser executado:

php -r "if (hash_file('SHA384', 'composer-setup.php') === '$HASH') { echo 'Installer verified'; } else { echo 'Installer corrupt'; unlink('composer-setup.php'); } echo PHP_EOL;"
Você verá o seguinte resultado:

Resultado
Installer verified
Se Installer corruptvocê estiver usando o hash correto, verifique se você está usando o hash correto. Em seguida, repita o processo de verificação. Quando você tiver um instalador selecionado, você pode continuar.

Para instalar o composerglobalmente, use o seguinte comando que baixará e instalará o Composer como um comando disponível em todo o sistema chamado composer, sob /usr/local/bin:

sudo php composer-setup.php --install-dir=/usr/local/bin --filename=composer
Você verá um resultado semelhante com este:

Output
All settings correct for using Composer
Downloading...

Composer (version 1.10.5) successfully installed to: /usr/local/bin/composer
Use it: php /usr/local/bin/composer
Para testar sua instalação, execute:

composer
Output
   ______
  / ____/___  ____ ___  ____  ____  ________  _____
 / /   / __ \/ __ `__ \/ __ \/ __ \/ ___/ _ \/ ___/
/ /___/ /_/ / / / / / / /_/ / /_/ (__  )  __/ /
\____/\____/_/ /_/ /_/ .___/\____/____/\___/_/
                    /_/
Composer version 1.10.5 2020-04-10 11:44:22
Usage:
  command [options] [arguments]
Options:
  -h, --help                     Display this help message
  -q, --quiet                    Do not output any message
  -V, --version                  Display this application version
      --ansi                     Force ANSI output
      --no-ansi                  Disable ANSI output
  -n, --no-interaction           Do not ask any interactive question
      --profile                  Display timing and memory usage information
      --no-plugins               Whether to disable plugins.
  -d, --working-dir=WORKING-DIR  If specified, use the given directory as working directory.
      --no-cache                 Prevent use of the cache
  -v|vv|vvv, --verbose           Increase the verbosity of messages: 1 for normal output, 2 for more verbose output and 3 for debug
...
Isso verifica que o Composer foi instalado com sucesso em seu sistema e está disponível em todo o sistema.
Nota: se você preferirá ter-lhe-ão separados separados do Composer para projeto hospedado neste servidor, você pode instalar localmente, em uma base por projeto. Este método também é útil quando o usuário do sistema não possui permissão para instalar o software disponível em todo o sistema.
Para fazer isso, use o comando php composer-setup.php. Isso irá gerar um arquivo composer.pharem seu diretório atual, que pode ser executado com o seu atual php composer.phar.
Agora podemos dar uma dependência em como usar o Compose como gerenciar.
Passo 3 — Usando o Compositor em um Projeto PHP
Os projetos PHP geralmente dependentes de bibliotecas externas, e o gerenciamento de dependências e suas versões podem ser complicados. O Composer resolve esse problema de manter um controle de projeto de extensões e dependências, também facilita o processo de descoberta, instalação e atualização de pacotes que são definidos por enquanto.
Para usar o seu projeto, você pode compor um arquivo composer.json. O arquivo composer.jsonComposer quais dependências precisa para baixar seu projeto quais serão as versões de cada pacote tem permissão para instalações e instalações. Isso é muito importante para manter seu projeto consistente e evitar a instalação de versões instáveis ​​que podem causar problemas de compatibilidade retroativa.
Você não precisa criar este arquivo manualmente - é comum ocorrer erros de sintaxe quando fizer isso. O Composer oferece uma maneira de criar um novo arquivo composer.jsoncom base na entrada do usuário, o que é uma boa escolha se você planeja compartilhar seu projeto mais tarde como um pacote público no Packagist . O Composer gera automaticamente um arquivo básico composer.jsonquando você executa um comando composer requirepara incluir uma dependência em um projeto recém-criado.
O processo de uso do Composer para instalar um pacote como uma dependência em um projeto envolve os passos a seguir:
Identifique o tipo de biblioteca que o aplicativo precisa.
uma biblioteca de código aberto adequada no agist.org , o responsável oficial de pacotes para o Compose.
Escolha o pacote de dependência.
Execute composer requirepara incluir a dependência no arquivo composer.jsone instalar o pacote.
Vamos testar isso com uma aplicação de demonstração.
O objetivo desta aplicação é transformar uma determinação determinada em uma string de URL amigável - um slug . Isso é comumente usado para converter os títulos de página para caminhos de URL (Assim como a parte final da URL para este tutorial).
Vamos começar a criar um diretório para o nosso projeto. Vamos chamá-lo de slugify :
cd ~
mkdir slugify
cd slugify
Embora não seja necessário, você pode executar agora um comando composer init para criar um arquivo composer.json detalhado para seu projeto. Como o único objetivo do nosso projeto é demonstrar como instalar dependências com o Composer, usaremos um arquivo composer.json mais simples que será gerado automaticamente quando exigirmos nosso primeiro pacote.
Agora é hora de procurar no Packagist.org por um pacote que pode nos ajudar a gerar slugs. Se você procurar pelo termo “slug” no Packagist, receberá um resultado parecido com este:
Resultados da Pesquisa do Packagist para o termo "slug"
Você verá dois números no lado direito de cada pacote na lista. O número no topo representa quantas vezes o pacote foi instalado através do Composer, e o número em baixo mostra quantas vezes um pacote foi estrelado no GitHub. De um modo geral, os pacotes com mais instalações e mais estrelas tendem a ser mais estáveis, pois mais pessoas os utilizam. Também é importante verificar a descrição do pacote para relevância para garantir que ele é o que você precisa.
Precisamos de um conversor string-to-slug A partir dos resultados da pesquisa, o pacote cocur/slugify, que aparece como o primeiro resultado naquela página, parece ser um bom candidato, com uma quantidade razoável de instalações e estrelas.
Os pacotes no Packagist têm um nome de vendor e um nome de package. Cada pacote tem um identificador único (um namespace) no mesmo formato que o GitHub utiliza para seus repositórios: vendor/package. A biblioteca que queremos instalar utiliza o namespace cocur/slugify. Você precisa de um namespace do pacote para exigi-lo em seu projeto.
Agora que você sabe exatamente qual pacote deseja instalar, você pode executar o composer require para incluí-lo como uma dependência e gerar também o arquivo composer.json para seu projeto. Uma coisa importante é observar a exigência de pacotes. O Composer rastreia as dependências no nível da aplicação e do sistema. As dependências no nível do sistema são importantes para indicar de quais módulos PHP um pacote depende. No caso do pacote cocur/slugify, ele exige um módulo PHP que ainda não instalamos.
Quando um pacote necessário depende de uma biblioteca de sistema que não está atualmente instalada em seu servidor, você receberá um erro informando qual requisito está faltando:
composer require cocur/slugify
Output
Using version ^4.0 for cocur/slugify
./composer.json has been updated
Loading composer repositories with package information
Updating dependencies (including require-dev)
Your requirements could not be resolved to an installable set of packages.
  Problem 1
    - Installation request for cocur/slugify ^4.0 -> satisfiable by cocur/slugify[v4.0.0].
    - cocur/slugify v4.0.0 requires ext-mbstring * -> the requested PHP extension mbstring is missing from your system.
...
Para resolver o problema de dependência do sistema, podemos procurar pelo pacote que falta usando o apt search:
apt search mbstring
Output
Sorting... Done
Full Text Search... Done
php-mbstring/focal 2:7.4+75 all
  MBSTRING module for PHP [default]
php-patchwork-utf8/focal 1.3.1-1 all
  UTF-8 strings handling for PHP
php7.4-mbstring/focal 7.4.3-4ubuntu1 amd64
  MBSTRING module for PHP
Após localizar o nome do pacote correto, você pode utilizar o apt novamente para instalar a dependência de sistema:
sudo apt install php-mbstring
Assim que a instalação terminar, você pode executar novamente o comando composer require:
composer require cocur/slugify
Output
Using version ^4.0 for cocur/slugify
./composer.json has been created
Loading composer repositories with package information
Updating dependencies (including require-dev)
Package operations: 1 install, 0 updates, 0 removals
  - Installing cocur/slugify (v4.0.0): Downloading (100%)         
Writing lock file
Generating autoload files
Como você pode ver na saída, o Composer decidiu automaticamente qual versão do pacote utilizar. Se você verificar o diretório do seu projeto agora, ele irá conter dois arquivos novos: composer.json e composer.lock, e um diretório vendor:
ls -l
Output
total 12
-rw-rw-r-- 1 sammy sammy   59 May  4 13:56 composer.json
-rw-rw-r-- 1 sammy sammy 3229 May  4 13:56 composer.lock
drwxrwxr-x 4 sammy sammy 4096 May  4 13:56 vendor
O arquivo composer.lock é usado para armazenar informações sobre quais versões de cada pacote estão instaladas, e garantir que as mesmas versões sejam usadas se outra pessoa clonar seu projeto e instalar suas dependências. O diretório vendor é onde as dependências do projeto estão localizadas. Você não deve fazer commit da pasta vendor no controle de versão - você precisa apenas incluir os arquivos composer.json e composer.lock.
Ao instalar um projeto que já contém um arquivo composer.json, execute o composer install para baixar as dependências do projeto.
Vamos dar uma olhada rápida em restrições de versão. Se você verificar o conteúdo do seu arquivo composer.json, verá algo parecido com isto:
cat composer.json
Output
{
    "require": {
        "cocur/slugify": "^4.0"
    }
}
Note que há o caractere especial ^ antes do número da versão no composer.json. O Composer suporta várias restrições diferentes e formatos para definir a versão necessária do pacote, para fornecer flexibilidade enquanto também mantém seu projeto estável. O operador circunflexo (^) utilizado pelo arquivo composer.json criado automaticamente é o operador recomendado para a interoperabilidade máxima, seguindo o versionamento semântico. Neste caso, ele define 4.0 como a versão mínima compatível e permite atualizações para qualquer versão futura abaixo de 5.0.
De um modo geral, você não precisará alterar as restrições de versão em seu arquivo composer.json. No entanto, algumas situações podem exigir que você edite manualmente as restrições – por exemplo, quando uma nova versão principal da sua biblioteca requerida é liberada e você deseja atualizar, ou quando a biblioteca que você deseja usar não segue o versionamento semântico.
Aqui estão alguns exemplos para lhe dar um melhor entendimento sobre como as restrições de versão do Composer funcionam:
Restrição   Significado Exemplo de Versões Permitidas
^1.0    >= 1.0 < 2.0    1.0, 1.2.3, 1.9.9
^1.1.0  >= 1.1.0 < 2.0  1.1.0, 1.5.6, 1.9.9
~1.0    >= 1.0 < 2.0.0  1.0, 1.4.1, 1.9.9
~1.0.0  >= 1.0.0 < 1.1  1.0.0, 1.0.4, 1.0.9
1.2.1   1.2.1   1.2.1
1.* >= 1.0 < 2.0    1.0.0, 1.4.5, 1.9.9
1.2. *  >= 1.2 < 1.3    1.2.0, 1.2.3, 1.2.9
Para uma visualização mais detalhada das restrições de versão do Composer, consulte a documentação oficial.
A seguir, vamos ver como carregar dependências automaticamente com o Composer.
Passo 4 — Incluindo o Script Autoload
Como o PHP por si só não carrega classes automaticamente, o Composer fornece um script autoload que você pode incluir em seu projeto para obter o carregamento automático para ele. Este arquivo é gerado automaticamente pelo Composer quando você adiciona sua primeira dependência.
A única coisa que você precisa fazer é incluir o arquivo vendor/autoload.php em seus scripts PHP antes de qualquer instância de classe.
Vamos testar isso em nossa aplicação de demonstração. Abra um novo arquivo chamado test.php em seu editor de texto:
nano test.php
Adicione o código a seguir que vem no arquivo vendor/autoload.php, carrega a dependência cocur/slugify, e o utiliza para criar um slug:
test.php
<?php
require __DIR__ . '/vendor/autoload.php';
use Cocur\Slugify\Slugify;
$slugify = new Slugify();
echo $slugify->slugify('Hello World, this is a long sentence and I need to make a slug from it!');
Salve o arquivo e saia do seu editor.
Agora, execute o script.
php test.php
Isso produz a saída hello-world-this-is-a-long-sentence-and-i-need-to-make-a-slug-from-it.
As dependências precisam de atualizações quando novas versões são liberadas. Dessa forma, vamos ver como lidar com isso.
Passo 5 — Atualizando as Dependências do Projeto
Sempre que você quiser atualizar suas dependências do projeto para versões mais recentes, execute o comando update:
composer update
Isso irá verificar por versões mais recentes das bibliotecas que você requer em seu projeto. Se uma versão mais recente for encontrada e ela for compatível com a restrição de versão definida no arquivo composer.json, o Composer substituirá a versão anterior instalada. O arquivo composer.lock será atualizado para refletir essas alterações.
Você também pode atualizar uma ou mais bibliotecas específicas, especificando-as desta forma:
composer update vendor/package vendor2/package2
Certifique-se de verificar em seus arquivos composer.json e composer.lock dentro do seu sistema de controle de versão após atualizar suas dependências de modo que outros também possam instalar essas versões mais recentes.
 -->
exit
pwd
exit
curl
curl -s "https://laravel.build/example-app?with=mysql,redis" |bash
docker
curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -
docker
apt-cache policy docker-ce
docker
curl
curl --help
apt install docker
systemctl status docker
docker
exit
docker
ver
sudo apt-get update
sudo apt-get install ./docker-desktop-<version>-<arch>.deb
sudo apt-get install     ca-certificates     curl     gnupg     lsb-release
sudo mkdir -p /etc/apt/keyrings
curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg
echo   "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu \
  $(lsb_release -cs) stable" | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null
sudo apt-get update
sudo apt-get install docker-ce docker-ce-cli containerd.io docker-compose-plugin
sudo service docker start
sudo docker run hello-world
docker
exit
pwd
ls
cd Desktop
ls
mkdir ProjetosDocker
ls
cd ProjetosDocker/
ls
curl
curl -s "https://laravel.build/example-app?with=mysql,redir" | bash
docker
docker run
systemctl status docker
sudo systemctl status docker
wget -qO- https://get.docker.com/ | sh
curl -L https://github.com/docker/compose/releases/download/1.6.2/docker-compose-`uname -s`-`uname -m` > /usr/local/bin/docker-compose
chmod +x /usr/local/bin/docker-compose
docker-compose version
docker-machine version
docker
curl -s "https://laravel.build/example-app?with=mysql,redir" | bash
docker ls
docker --help
docker start
docker start --help
docker start -i
docker image list
cd ..
cd var
cd /var
cd run
ls
docker
docker run
docker run *
cd /
ls
pwd
cd rn
cd run
ls
docker
docker run
exit
docker
sytemctl status
sudo systemctl
cmd
docker
docker run
curl
curl --help
curl -V
docker -v
code .
cls
clear
docker
clear
docker ps
sudo sevice docker start
sudo service docker start
docker ps
sudo service docker start
docker ps
apt get install docker
apt install docker
docker ps
sudo service docker start
docker ps
sudo service docker start
sudo service docker-start
curl -s "https://laravel.build/example-app?wit..." | bash
docker
docker ps
exit
docker start
docker ps
docker start
docker ps
docker
docker ps
docker --version
docker run hello-world
docker image ls
Enable WSL 2 Windows features
Set-ExecutionPolicy -ExecutionPolicy RemoteSigned
lsb_release -a
dotnet --version
sudo wget https://packages.microsoft.com/config/ubuntu/20.04/packages-microsoft-prod.deb -O packages-microsoft-prod.deb
sudo dpkg -i packages-microsoft-prod.deb
sudo apt-get update
sudo apt-get install apt-transport-https
sudo apt-get update
sudo apt-get install dotnet-sdk-3.1
dotnet --version
code .
docker
sudo apt install gnome-terminal
docker
docker ps
docker start
sudo apt remove docker-desktop
sudo apt-get install ./docker-desktop-<version>-<arch>.deb
sudo apt-get update
sudo apt-get install ./docker-desktop-<version>-<arch>.deb
systemctl --user enable docker-desktop
systemctl --user stop docker-desktop
wsl.exe -l -v
wsl
apt install wsl
code .
curl -s https://laravel.build/example-app | bash
docker
apt get install docker
sudo su
clear
docker ps
y
pwd
ls
cd ProjetosDocker/
pwd
php -v
cls
clear
curl -s "https://laravel.build/example-app?with=mysql,redis,pgsql" |bash
sudo apt-get curl
curl
curl --manual
clear
docker ps
curl -s "https://laravel.build/example-app?with=mysql,redis,pgsql" |bash
docker ps
docker
docker ps
exit
ls
./vendor/bin/sail up
./vendor/bin/sail up -D
./vendor/bin/sail up -d
./vendor/bin/sail ps
./vendor/bin/sail composer require/breeze --dev
./vendor/bin/sail compose require/breeze --dev
./vendor/bin/sail composer require laravel/breeze --dev
sudo su
./vendor/bin/sail composer require laravel/breese --dev
docker ps
docker stop
docker ps
./vendor/bin/sail stop
./vendor/bin/sail composer require laravel/breese --dev
docker start
docker ps
./vendor/bin/sail up
./vendor/bin/sail up -d
docker ps
docker stop
./vendor/bin/sail stop
docker ps
docker ls
docker -ls
docker -l
docker ls
docker --help
docker rmi
docker rm
docker rm --help
docker rm -f
docker ls
list
docker ps
docker start
docker run
docker ps
curl -s "https://laravel.build/example-app?with=mysql,redis" | bash
docker ps
docker ls
ls
cd ProjetosDocker/
cd ..
cd example-app/
code .
docker run -d -p 80:80 docker/getting-started
docker up -d
clear
docker run -d -p 80:80 docker/getting-started
docker up 0094
docker run 7b0aed04f7c251a872242ec415f2d99551385af0c8ceb8409af2ffa9c3fedf6a -d
docker
docker ps
code .
docker
clear
clear ps
docker ps
sudo apt install curl 
exit
pwd
./vendor/bin/sail up -d
cls
clear
./vendor/bin/sail up -d
docker ps
clear
docker ps
./vendor/bin/sail up -d
docker kill
docker stop
doker ps
docker
exit
curl -s "https://laravel.build/laravel-curso?with=mysql,redis,mailhog" |bash
cd laravel-curso/
./vendeor/bin/sail up -d
./vendor/bin/sail up -d
docker ps
code .
./vendor/bin/sail up -d
curl "http://localhost/tutorial/"    -X GET    -H 'host: localhost'    -H 'connection: keep-alive'    -H 'sec-ch-ua: "Chromium";v="106", "Google Chrome";v="106", "Not;A=Brand";v="99"'    -H 'sec-ch-ua-mobile: ?0'    -H 'sec-ch-ua-platform: "Windows"'    -H 'upgrade-insecure-requests: 1'    -H 'user-agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/106.0.0.0 Safari/537.36'    -H 'accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9'    -H 'sec-fetch-site: same-origin'    -H 'sec-fetch-mode: navigate'    -H 'sec-fetch-dest: document'    -H 'referer: http://localhost/'    -H 'accept-encoding: gzip, deflate, br'    -H 'accept-language: pt-BR,pt;q=0.9,en-US;q=0.8,en;q=0.7,es;q=0.6'    -H 'cookie: _ga=GA1.1.171439518.1657383921; _ga_E7H41BFJ0Q=GS1.1.1657462355.2.1.1657462635.0; pma_lang=pt';
clear
./vendor/bin/sail up -d
pwd
ls
cd ProjetosDocker/
ls
cd example-app
ls
cd ..
cd example-app
ls
cd ..
rm -rf example-app
ls
rm-rf laravel-curso/
ls
rm -rf laravel-curso/
clear
ls
cd ProjetosDocker/
ls
curl -s "https://laravel.build/laravel-curso?with=mysql,redis,mailhog" |bash
cd laravel-curso && ./vendor/bin/sail up -d
code .
pwd
ls
cd ProjetosDocker/
ls
rm -rf laravel-curso/
ls
clear
curl -s "https://laravel.build/laravel-curso?with=mysql" |bash
pwd
ls
cd ProjetosDocker/
ls
rm -rf laravel-curso/
ls
cd ..
cd laravel-curso/
ls
exit
php -S localhost:8080
apt install php-cli
php -S localhost:8080
docker run -d -p 80:80 docker/getting-started
curl -s "https://laravel.build/laravel-curso?with=mysql" |bash
docker ps
docker ls
docker -l
docker l
docker ps
docker exec
docker exec -it docker/getting-started bash
docker ps
docker exec -it 6ec4e45db98a bash
docker exec -it 6ec4e45db98a 
docker exec --help
docker exec -it 6ec4e45db98a bash
clear
docker ps
code .
ls
cd laravel-curso/
ls
docker ps
cd ..
ls
pwd
cd socket/
ls
cd ..
cd ProjetosDocker/
ls
cd ..
rm -rf laravel-curso/
ls
cd ..
ls
clear
docker ps
docker exec -it docker/getting-started: bash
docker exec -it docker/getting-started bash
docker exec -it getting-started bash
docker exec -it 6ec4e45db98a bash
docker exec -it 6ec4e45db98a 
ls
cd socket/
ls
cd ..
cd snap
ls
cd ..
cd \
cd /
ls
cd var
ls
cd lib
ls
cd docker
ls
cd containers
ls
cd ..
cd image
ls
cd ..
sudo service docker status
status docker
sudo status docker
sudo service status docker
sudo service docker
sudo service docker status
docker start
cd ..
pwd
ls
cd usr
ls
ls -l
cd ..
docker ps
docker
docker ps
apt-get docker
apt-get install docker 
docker ps
apt-get uninstall docker 
pwd
ls
cd ..
ls
cd usr
ls
cd bin
ls
cd ..
cd lig
cd lib
ls
clear
ls
cd ..
ls
cd usr
ls
ls docker
cld
cd ..
ls
cd ProjetosDocker/
ls
sudo apt update
sudo apt install apt-transport-https ca-certificates curl software-properties-common
curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -
sudo add-apt-repository "deb [arch=amd64] https://download.docker.com/linux/ubuntu focal stable"
sudo apt update
apt-cache policy docker-ce
sudo apt install docker-ce
sudo systemctl status docker
wsl --set-version Ubuntu 2
sudo apt update
sudo apt install apt-transport-https ca-certificates curl software-properties-common
sudo apt install build-essential
curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add
sudo add-apt-repository "deb [arch=amd64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable"
sudo apt update
sudo apt install docker-ce
sudo docker run hello-world
início do docker de serviço sudo
sudo service docker start
sudo docker run hello-world
docker ps
sudo etc
cd etc
ls
cd ..
ls
cd etc
ls
vi init.d
cd ..
ls
sudo apt install docker-ce
sudo service docker status
sudo service docker start
docker ps
ls
cd var/run
ls
vi docker.sock
docker.sock
cd user
ls
cd ..
ls
cd run
ls
cd docker
ls
cd ..
sudo service docker start
docker ps
curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add
sudo add-apt-repository "deb [arch=amd64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable"
sudo docker run hello-world
docker ps
sudo service docker start
sudo service status
sudo service docker start
sudo curl -L "https://github.com/docker/compose/releases/download/1.24.0/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
sudo chmod +x /usr/local/bin/docker-compose
docker-compose --version
ls
cd ProjetosDocker/
code .
curl -s "https://laravel.build/laravel-9-course?with=mysql,redis,mailhog" | bash
docker start
docker ps
sudo apt install docker-ce
docker start
sudo service docker start
curl -s "https://laravel.build/laravel-9-course?with=mysql,redis,mailhog" | bash
docker ps
exit
docker ps
ls
docker ps
clear
docker ps
curl -s "https://laravel.build/laravel-9-course?with=mysql,redis,mailhog" | bash
cd laravel-9-course && ./vendor/bin/sail up -d
docker ps
clear
docker ps
docker ps -l
./vendor/bin/sail up -d
php artisan about
./vendor/bin/sail up -d
docker ps
docker-compose up -d
./vendor/bin/sail up -d
pwd
ls
cd laravel-9-course/
./vendor/bin/sail up -d
docker exec -it b6870e2dd73e bash
clear
ls
cd ..
clear
ls
cd laravel-9-course/
ls
php artisan serve
php artisan
clear
ls
code .
docker ps
docker ps -l
docker exec -it laravel-9-course-laravel.test-1 bash
ls
php artisan serve
vi
vi docker-compose.yml
code .
exit
php artisan serve
exit
php -v
mysql -v
mysql -u root
mysql -u root -p
docker ps
docker ps -l
exit
ls
rm -rf laravel-9-course/
ls
cd example-app/
ls
php -v
mysql -u root -p
apt install mysql-client-core-8.0
mysql -u root -p
jdflkjadsl
curl -s https://laravel.build/example-app | bash
cd example-app && ./vendor/bin/sail up -d
ls
php -S localhost:8000
php artisan serve
ls
cd public/
php -S localhost:8000
php artisan serve
clear
./vendor/bin/sail up -d
php artisan cache:clear
./vendor/bin/sail php artisan cache:clear
./vendor/bin/sail up -d
./vendor/bin/sail php artisan route:clear
./vendor/bin/sail down
./vendor/bin/sail php artisan route:clear
dir
cd public/
php -S localhost:80
cd ..
./vendor/bin/sail up -d
./vendor/bin/sail down
curl -s "https://laravel.build/olw?with=mysql,redis,mailhog,minio" | bash
LS
ls
cd ProjetosDocker/
ls
cd olw
ls
cd ..
cd olw
ls
sail artisan serve
sail php artisan serve
cls
clear
ls
code .
docker ps
clear
docker ps
alias sail='[ -f sail ] && sh sail || sh vendor/bin/sail'
sail up -d
code .
sail down
ls
cd ..
ls
version
ls
cd ..
ls
cd var
ls
cls
ls
cd www
cd /
ls
cd var
ls
cd www
cd ..
ls
cd home
ls
cd alber
ls
cd ..
laravel -v
laravel -V
composer -V
./vendor/bin/sail up -d
./vendor/bin/sail down
./vendor/bin/sail up -d
sail ps
sail down
clear
./vendor/bin/sail ps
./vendor/bin/sail down
./vendor/bin/sail up -d
php artisan --version
./vendor/bin/sail down
./vendor/bin/sail ps
docker up -d
docker run -d
docker ps
./vendor/bin/sail ps
./vendor/bin/sail up -d
docke ps
docker ps
docker exec -it ffc7fa4e28ed bash
docker ps
sail up -d
cd ..
./vendor/bin/sail up -d
docker ps
./vendor/bin/sail up -d
ls
cd home
ls
cd alber/
ls
cd ..
ls
cd ..
ls
cd home
ls
cd var
ls
cd ..
cd var
ls
cd ..
ls
docker ps
exit
wsl --set-version <Distro> 2, – wsl --set-default-version 2
wsl --importe visando WSL 2wsl --export
cls
clear
wsl
wsl2
wsl.exe -l -v
wsl.exe --set-default-version 2
docker ps
./vendor/bin/sail up -d
docker run
docker run olw-laravel.test-1
start-container
docker start-container
docker up start-container
docker run start-container
docker down
clear
docker ps
ls
cd olw
./vendor/bin/sail down
./vendor/bin/sail up -d
./vendor/bin/sail down
ls
cd ..
ls
rm -rf olw
ls
rm -rf ProjetosDocker/
rm -rf example-app/
ls
exit
curl.exe -L -o ubuntu-2004.appx https://aka.ms/wslubuntu2004
wsl --set-default-version 2
Error: 0x1bc
For information on key differences with WSL 2 please visit https://aka.ms/wsl2
[    0.363323] 9p: Installing v9fs 9p2000 file system support
[    0.363336] FS-Cache: Netfs '9p' registered for caching
[    0.398989] 9pnet: Installing 9P2000 support
wsl --update
apt-get upgrade
Get-WindowsOptionalFeature -Online -FeatureName Microsoft-Windows-Subsystem-Linux
sudo service ssh status
debug1: sshd version OpenSSH_7.2, OpenSSL 1.0.2g  1 Mar 2016
debug1: key_load_private: incorrect passphrase supplied to decrypt private key
debug1: key_load_public: No such file or directory
Could not load host key: /etc/ssh/ssh_host_rsa_key
debug1: key_load_private: No such file or directory
debug1: key_load_public: No such file or directory
Could not load host key: /etc/ssh/ssh_host_dsa_key
debug1: key_load_private: No such file or directory
debug1: key_load_public: No such file or directory
Could not load host key: /etc/ssh/ssh_host_ecdsa_key
debug1: key_load_private: No such file or directory
debug1: key_load_public: No such file or directory
Could not load host key: /etc/ssh/ssh_host_ed25519_key
sudo apt-get purge openssh-server
sudo apt-get install openssh-server
wsl --install
wsl --update
wsl --shutdown
exit
sudo apt update
sudo apt install gedit -y
sudo apt-get install     ca-certificates     curl     gnupg     lsb-release
sudo mkdir -p /etc/apt/keyrings
curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg
echo   "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu \
  $(lsb_release -cs) stable" | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null
sudo apt-get update
sudo apt-get install docker-ce docker-ce-cli containerd.io docker-compose-plugin
sudo service docker start
sudo docker run hello-world
sudo su docker run hello-world
docker ps
ps aux | grep docker
sudo service docker status
systemctl start docker
gpasswd -a $USER docker
systemctl start docker
sudo service docker start
docke ps
docker ps
sudo service docker start
sudo service --status-all
sudo service docker start
systemctl enable docker
systemctl restart docker
systemctl enable docker
sudo service docker start
/var/run/docker.sock
sudo nohup docker daemon -H tcp://0.0.0.0:2375 -H unix:///var/run/docker.sock
sudo usermod -aG docker $USER
reboot
docker ps
sudo /var/run/docker.sock
cd  /var/run/docker.sock
cd  /var/run/
ls
cd WSL
ls
cd ..
ls
cd ..
ls
curl -s "https://laravel.build/olw?with=mysql,redis,mailhog,minio" | bash
docker ps
docker start
service docker start
sudo service docker status
sudo service docker start
sudo service docker status
sudo service docker start
sudo service docker status
& $Env:ProgramFiles\Docker\Docker\DockerCli.exe -SwitchDaemon .
docker pull mcr.microsoft.com/windows/nanoserver:ltsc2022
dockerd --debug
docker -H tcp://0.0.0.0:2375 ps
sudo dockerd -H unix:///var/run/docker.sock -H tcp://192.168.59.106 -H tcp://10.10.10.2sudo dockerd -H unix:///var/run/docker.sock -H tcp://192.168.59.106 -H tcp://10.10.10.2
docker --tlsverify ps
docker ps
docker -H :5555 pull ubuntu
docker -H tcp://127.0.0.1:2375 pull ubuntu
docker 
docker ps
docker version
docker ps
systemclt start docker 
systemctl start docker 
docker 
docker -H
docker -H --host list
docker -H --host
docker -H --help
docker ps
curl -s "https://laravel.build/olw?with=mysql,redis,mailhog,minio" | bash
cd olw && ./vendor/bin/sail up
cd olw && ./vendor/bin/sail up -d
cd ..
cd olw
./vendor/bin/sail up -d
./vendor/bin/sail down
./vendor/bin/sail tinker
cls
clear
sail php --version
sail share
sudo chmod 777 storage/ -R
sudo chmod 0777 storage/ -R
./vendor/bin/sail up -d
./vendor/bin/sail down
ls
cd olw
./vendor/bin/sail up -d
sudo chmod 777 storage/ -R
./vendor/bin/sail up -d
code .
./vendor/bin/sail down
curl -s "https://laravel.build/example-app | bash
cd ..
curl -s "https://laravel.build/example-app | bash
ls
curl -s https://laravel.build/example-app | bash
cd example-app/
./vendor/bin/sail up -d
sudo chmod 777 storage/ -R
./vendor/bin/sail up -d
sail share
./vendor/bin/sail share
mysql 
myqsl -u root -p
alias sail='[ -f sail ] && sh sail || sh vendor/bin/sail'
ls
sail ps
./vendor/bin/sail ps
docker ps
cd example-app/
sail ps
sail down
composer global require beyondcode/expose
expose default-server sa-1
expose token 89e90595-06a7-4245-99c9-03536b633447
composer global require beyondcode/expose
ls
php artisan serve
cd public/
php -S localhost:8080
clear
cd..
cd ..
cd example-app/
clear
sail up -d
code .
ls
code .
sail down
cd ..
docker ps
clear
./vendor/bin/sail up -d
cd example-app/
./vendor/bin/sail up -d
code .
./vendor/bin/sail down
php artisan route:list
sail artisan route:list
sail
cls
clear
./vendor/bin/sail list
./vendor/bin/sail down
./vendor/bin/sail up -d
./vendor/bin/sail down
./vendor/bin/sail up -d
/ls
mysql -u root -p
mysql -u sail -p
mysql
docker ps
ls
cd example-app/
./vendor/bin/sail up -d
code .
cd ..
mysql
mysql --version
mysql -u sail -p
cd ..
ls
cd example-app/
clear
mysql -u root -p
cd..
ls
cd ..
sail down
./vendor/bin/sail down
docker ps
cd example-app/
sail down
./vendor/bin/sail down
ls
cd ..
ls
sail up -d
./vendor/bin/sail up -d
cd example-app/
./vendor/bin/sail up -d
docker ps
./vendor/bin/sail up -d
mysql -u root -p
mysql -u sail -p
exit
mysql -u sail -p
./vendor/bin/sail up -d
mysql -u sail -p
clear
./vendor/bin/sail down
mysql -u sail -p
exit
docker ps
docker ps -l
docker ps -a
clear
ls
cd ex
cd example-app/
ls
./vendor/bin/sail up -d
code .
mysql --version
mysql -u sail -p
mysql -u root -p
mysql -u sail -p
mysql --version
myql -u root -p
mysql -u root -p
ls
sudo
sudo chmod 777 storage/ -R
ls
cd ..
ls
cd ..
ls
sudo chmod 777 var/ -R
mysql -u root -p
ls
docker ps
cd example-app/
sail down
./vendor/bin/sail down
./vendor/bin/sail up -d
code .
ls
cd ..
ls
cd ..
ls
cd ..
ls
cd home
ls
cd ..
cd root
ls
cd example-app/
ls
cd ..
docker ps
docker exec -it example-app-mysql-1 bash
ls
cd example-app/
ping localhost:3306
ping 0.0.0.0:3306
clear
./vendor/bin/sail down
sail ps
./vendor/bin/sail ps
ls
cd ..
pwd
ls
cd olw
ls
cd ..
cd example-app/
sail ps
./vendor/bin/sail up -d
sail artisan migrate --seed
p
./vendor/bin/sail  artisan migrate --seed
./vendor/bin/sail artisan make:controller UserController
php artisan make:controller UserController
./vendor/bin/sail artisan make:controller UserController
php artisan make:controller UserController
clear
docker ps
./vendor/bin/sail  up -d
php -v
docker ps
docker run hello-world
exit
./vendor/bin/sail artisan serve
docker ps
clear
./vendor/bin/sail  up -d
mysql --v
mysql -v
mysql -u root -p
cd ..
mysql -u root -p
clear
mysql --version;
composer
clear
docker ps -l
docker ps
docker run hello-world
clear
docker ps -l
ls
cd example-app/
./vendor/bin/sail up -d
code .
./vendor/bin/sail down
./vendor/bin/sail up -d
./vendor/bin/sail down
./vendor/bin/sail up -d
./vendor/bin/sail down
./vendor/bin/sail up -d
./vendor/bin/sail down
./vendor/bin/sail up -d
code .
./vendor/bin/sail down
./vendor/bin/sail up -d
ping
ping 127.0.0.1:3307
ping 127.0.0.1:3306
ping 127.0.0.1
ping 127.0.0.1:80
ping 127.0.0.1:6379
ping 127.0.0.1:3306
ping 127.0.0.1:3307
./vendor/bin/sail down
./vendor/bin/sail up -d
code .
./vendor/bin/sail down
./vendor/bin/sail up -d
code .
./vendor/bin/sail down
./vendor/bin/sail up -d
code .
./vendor/bin/sail up -d
./vendor/bin/sail down
./vendor/bin/sail up -d
code .
./vendor/bin/sail up -d
./vendor/bin/sail down
./vendor/bin/sail up -d
code .
./vendor/bin/sail up -d
./vendor/bin/sail down
./vendor/bin/sail up -d
./vendor/bin/sail down
./vendor/bin/sail up -d
./vendor/bin/sail down
./vendor/bin/sail up -d
./vendor/bin/sail down
./vendor/bin/sail up -d
./vendor/bin/sail down
./vendor/bin/sail up -d
./vendor/bin/sail down
./vendor/bin/sail up -d
./vendor/bin/sail down
./vendor/bin/sail up -d
./vendor/bin/sail down
./vendor/bin/sail up -d
./vendor/bin/sail down
./vendor/bin/sail up -d
code .
./vendor/bin/sail up -d
./vendor/bin/sail down
./vendor/bin/sail up -d
./vendor/bin/sail down
./vendor/bin/sail up -d
clear
docker ps
docker exec -it example-app-mysql-1
docker exec -it example-app-mysql-1 bash
./vendor/bin/sail up -d
./vendor/bin/sail down
./vendor/bin/sail up -d
ls
cd example-app/
docker ps
ls
php artisan serve
clear
ls
cd vendor
cd bin
ls
vi sail
clear
code .
ls
cd sail
cd ..
cd vendor
cd bin
sail up -d
cd ..
./vendor/bin/sail up -d
ls
code .
./vendor/bin/sail ps
clear
./vendor/bin/sail down
docker ps -l
docker  -l
ls
cd olw
./vendor/bin/sail up -d
code .
docker ps
./vendor/bin/sail up -d
clear
./vendor/bin/sail up -d
./vendor/bin/sail composer require laravel/breeze --dev
./vendor/bin/sail up -d
./vendor/bin/sail composer require laravel/breeze --dev
cd ..
sudo chmod 777 olw/ -R
./vendor/bin/sail composer require laravel/breeze --dev
cd olw
./vendor/bin/sail composer require laravel/breeze --dev
./vendor/bin/sail art breeze:install vue
./vendor/bin/sail art migrate
CLEAR
clear
alias sail='bash vendor/bin/sail'
sail ps
git init
git add .
git commit -m "comit inicial"
git add .
git remote add origin https://github.com/albertogomesdasilva/laravel- sail-olw.git
git remote add origin -m https://github.com/albertogomesdasilva/laravel- sail-olw.git
git push
git push --set-upstream origin master
git remote add origin https://github.com/albertogomesdasilva/laravel-sail-olw.git
git push -u origin main
git remote add origin https://github.com/albertogomesdasilva/laravel-sail-olw.git
git push -u origin main
git login
git user.name albertogomesdasilva
echo "# laravel-sail-olw" >> README.md 
git init 
git add README.md 
git commit -m "first commit" 
git branch -M main 
git remote add origin https://github.com/albertogomesdasilva/laravel- sail-olw.git
echo "# laravel-sail-olw" >> README.md 
git init 
git add README.md 
git commit -m "first commit" 
git branch -M main 
git remote add origin https://github.com/albertogomesdasilva/laravel- sail-olw.git
echo "# laravel-sail-olw" >> README.md 
git init
git add README.md
git commit -m "first commit"
git config  user.name "Albertogomesdasilva"
git config  user.email "albertogomesdasilva@hotmail.com"
git branch -M main
git remote add origin https://github.com/albertogomesdasilva/laravel-sail-olw.git
git push -u origin main
ping www.google.com
clear
git remote add origin https://github.com/albertogomesdasilva/laravel-sail-olw.git
git push -u origin main
git remote add origin https://github.com/albertogomesdasilva/laravel-sail-olw
echo "# laravel-sail-olw" >> README.md
git init
git add README.md
git commit -m "first commit"
git branch -M main
git remote add origin https://github.com/albertogomesdasilva/laravel-sail-olw.git2
git push -u origin main
git remote add origin https://github.com/albertogomesdasilva/laravel-sail-olw.git
git remote add origin https://github.com/albertogomesdasilva/laravel-sail-olw.git2
git remote add origin https://github.com/albertogomesdasilva/laravel-sail-olw.git
clear
git remote add origin https://github.com/albertogomesdasilva/laravel-sail-olw
git config --global user.email  "albertogomesdasilva@hotmail.com"
git status
touch .gitignore
git add .
git commit -a -m "commit inicial"
git remote add origin https://github.com/albertogomesdasilva/laravel- sail-olw.git
git branch -M main 
git remote add origin https://github.com/albertogomesdasilva/laravel- sail-olw.git
clear
git status
git push --set-upstream origin master
git branch
git status
git init
git status
git add.
git add .
git status
git commit -a -m "commit inicial"
git status
git remote add origin https://github.com/albertogomesdasilva/laravel-sail-olw.git
git push
cd ..
git remote add origin https://github.com/albertogomesdasilva/laravel-sail-olw.git
cd owl
ls
cd olw
git remote add origin https://github.com/albertogomesdasilva/laravel-sail-olw
git push -u origin main
git init
clear
git reset
git status
git logout
git --help
git exit
clear
git add ANOTAÇÕES.md
git log
git commit "anotações"
clear
sail ps
clear
alias sail='bash vendor/bin/sail'
alias s='bash vendor/bin/sail'
s ps
clear
sail ps
s ps
clear
s down
s up -d
clear
s art make:controller BeerController
alias sail='bash vendor/bin/sail'
sail art migrate
sail npm run dev
npm run dev
sail npm run dev
npm run dev
sail npm run dev
sail art migrate
./vendor/bin/sail art migrate
./vendor/bin/sail artisan migrate
npm i
composer install
php --ini
php ini
php -i
ls
composer update
composer install
docker ps
ls
cd olw
s up -d
./vendor/bin/sail up -d
ls
cd public
ls
cd build
ls
cd assets/
ls
cd ..
ls
cd resources/
ls
cd views
ls
cd..
cd ..
code .
./vendor/bin/sail up -d
./vendor/bin/sail down
./vendor/bin/sail up -d
sail art migrate
./vendor/bin/sail up -d
./vendor/bin/sail donw
./vendor/bin/sail down
./vendor/bin/sail up -d
./vendor/bin/sail down
composer install
--ignore-platform-req=ext-simplexml --ignore-platform-req=ext-dom --ignore-platform-req=ext-xml --ignore-platform-req=ext-curl
composer install --ignore-platform-req=ext-simplexml --ignore-platform-req=ext-dom --ignore-platform-req=ext-xml --ignore-platform-req=ext-curl
sudo su composer update
sudo composer update
sudo su
sudo composer update
composer i
apt install composer
composer update
composer update --with-all-dependencies
php composer.phar install --no-plugins --no-scripts
cd olw
php composer.phar install --no-plugins --no-scripts
ls
cd olw
ls
apt update
composer update
./vendor/bin/sail up -d
./vendor/bin/sail down
./vendor/bin/sail up -d
composer update
composer update --with-all
ls
sudo su albert
sudo su alber
cd ow
cd olw
./vendor/bin/sail up -d
code .
./vendor/bin/sail up -d
php composer.phar update --no-plugins --no-scripts
ls
composer install
code .
php composer.phar install --no-plugins --no-scripts
cls
clear
./vendor/bin/sail up -d
./vendor/bin/sail down
php composer.phar install --no-plugins --no-scripts
composer update
cd ..
ls
cd ..
ls
chmod 777 usr/ -R
php --ini
php -ini
composer install
cd olw
pwd
ls
cd home
ls
cd ..
ls
cd root
ls
cd olw
composer install
npm i
cd public/
ls
cd buido
cd buid
cd build
ls
cd asstes
cd assets
ls
ls
chmod 777 olw/ -R
cd olw
sail up -d
./vendor/bin/sail up -d
./vendor/bin/sail composer dumpautoload
./vendor/bin/sail composer autoload
./vendor/bin/sail composer dump-autoload
composer install
composer --ignore-platform-req=ext-simplexml --ignore-platform-req=ext-dom --ignore-platform-req=ext-dom --ignore-platform-req=ext-xml --ignore-platform-req=ext-dom --ignore-platform-req=ext-dom --ignore-platform-req=ext-dom --ignore-platform-req=ext-curl --ignore-platform-req=ext-dom --ignore-platform-req=ext-simplexml
composer dumautoload --ignore-platform-req=ext-simplexml --ignore-platform-req=ext-dom --ignore-platform-req=ext-dom --ignore-platform-req=ext-xml --ignore-platform-req=ext-dom --ignore-platform-req=ext-dom --ignore-platform-req=ext-dom --ignore-platform-req=ext-curl --ignore-platform-req=ext-dom --ignore-platform-req=ext-simplexml
composer dumpautoload --ignore-platform-req=ext-simplexml --ignore-platform-req=ext-dom --ignore-platform-req=ext-dom --ignore-platform-req=ext-xml --ignore-platform-req=ext-dom --ignore-platform-req=ext-dom --ignore-platform-req=ext-dom --ignore-platform-req=ext-curl --ignore-platform-req=ext-dom --ignore-platform-req=ext-simplexml
./vendor/bin/sail up -d
code .
./vendor/bin/sail up -d
cd ..
ls
./vendor/bin/down
./vendor/bin/sail down
cd root
cd olw
./vendor/bin/sail down
cd olw
./vendor/bin/sail up -d
cd ..
rm -rf olw
ls
exit
docker ps
docker ps -la
docker ps -l
exit
nmp run dev
ls
cd example-app/
ls
sail 
./vendor/bin/sail up -d
code .
./vendor/bin/sail stop
cd ..
docker
docker ps
clear
cd ..
sudo chmod 777 olw/ -R
composer require laravel/breeze --dev
php -ini
php --ini
clear
./vendor/bin/sail composer require laravel/breeze --dev
cd olw
./vendor/bin/sail composer require laravel/breeze --dev
./vendor/bin/sail artisan breeze:install vue
./vendor/bin/sail art migrate
alias sail='[ -f sail ] && sh sail || sh vendor/bin/sail'
sail art make:controller BeerController
sail ps
sail artisan make:controller BeerController
sail artisan make:request BeerRequest
sail composer require psr/simple-cache:^2.0 maatwebsite/excel
./vendor/bin/sail composer require psr/simple-cache:^2.0 maatwebsite/excel
./vendor/bin/sail composer dump-autoload
./vendor/bin/sail artisan make:export BeerExport
./vendor/bin/sail art config:cache
./vendor/bin/sail art optimize:clear
./vendor/bin/sail composer require psr/simple-cache:^2.0 maatwebsite/excel
./vendor/bin/sail composer require -W league/flysystem-aws-s3-v3 "^3.0"
curl -s "https://laravel.build/olw?with=mysql,redis,mailhog,minio" | bash
ls
rm -rf example-app/
ls
rm -rf olw
clear
curl -s "https://laravel.build/olw?with=mysql,redis,mailhog,minio" | bash
docker scan
cd olw && ./vendor/bin/sail up -d
code .
cd olw && ./vendor/bin/sail up -d
./vendor/bin/sail up -d
code .
./vendor/bin/sail down
./vendor/bin/sail up -d
sail down
./vendor/bin/sail down
./vendor/bin/sail up -d
code .
./vendor/bin/sail up -d
code .
./vendor/bin/sail up -d
sail down
./vendor/bin/sail down
ls
cd olw
./vendor/bin/sail up -d
docker ps
ls
cd olx
ls
cd olw
./vendor/bin/sail up -d
docker ps
clear
code .
ls
cd ..
ls
docker ps
docker exec -it 51288723f17a bash
ls
./vendor/bin/sail up -d
cd olw
./vendor/bin/sail up -d
./vendor/bin/sail down
./vendor/bin/sail up -d
./vendor/bin/sail art migrate
php artisan migrate
clear
composer update
npm i
npm
composer install
php --ini
alias sail='[ -f sail ] && sh sail || sh vendor/bin/sail'
sail ps
s ps
sh ps
clear
sail art make:migration create_history_table
sail art make:model Export -mr
sail art make: Export -mr
sail art make:model Export -mr
sail art make:model Meal -mr
sail art make:factory MealFactory
sail art make:seed MealSeeder
sail composer require jzonta/faker-restaurant
sail composer dump-autoload
./vendor/bin/sail composer dump-autoload
clear
alias sail='[ -f sail ]
alias sail='[ -f sail ] && sh sail || sh vendor/bin/sail'
sail art migrate:fresh --seed
clear
sail art migrate:fresh --seed
sail art make:mail ExportEmail
sail up -d
sail down
sail up -d
docker ps
ols
olw
ls
cd olw
ls
sail ps
clear
./vendor/bin/sail up -d
code .
./vendor/bin/sail up -d
./vendor/bin/sail art server
./vendor/bin/sail art serve
sail art migrate:fresh --seed
alias sail='[ -f sail ] && sh sail || sh vendor/bin/sail'
sail composer dump-autoload
sail up -d
sail composer require jzonta/faker-restaurant
sail ps
sail composer install
composer install
php --ini
composer install
php -S localhost:8000
cd ..
chmod 777 olw/ -R
sail ps
./vendor/bin/sail up -d
cd olw
./vendor/bin/sail up -d
docker ps
./vendor/bin/sail up -d -->
"# notas" 
### FAKER
Falso#
Downloads do empacotador Status do fluxo de trabalho do GitHub
Faker é uma biblioteca PHP que gera dados falsos para você. Se você precisa inicializar seu banco de dados, criar documentos XML de boa aparência, preencher sua persistência para testá-lo ou anonimizar dados obtidos de um serviço de produção, o Faker é para você.
É fortemente inspirado por Perl's Data::Faker , e por Ruby's Faker .
Instalação#
Faker requer PHP >= 7.1.
composer require fakerphp/faker
Uso básico#
Carregamento automático#
Faker suporta tanto PSR-0como PSR-4autoloaders.
// when installed via composer
require_once 'vendor/autoload.php';
Você também pode carregar o autoloader FakersenviadoPSR-0
// load Faker autoloader
require_once '/path/to/Faker/src/autoload.php';
alternativamente, você pode usar qualquer outro autoloader compatível com PSR-4
Crie dados falsos#
Use Faker\Factory::create()para criar e inicializar um gerador faker, que pode gerar dados chamando métodos com o nome do tipo de dados desejado.
require_once 'vendor/autoload.php';
// use the factory to create a Faker\Generator instance
$faker = Faker\Factory::create();
// generate data by calling methods
echo $faker->name();
// 'Vince Sporer'
echo $faker->email();
// 'walter.sophia@hotmail.com'
echo $faker->text();
// 'Numquam ut mollitia at consequuntur inventore dolorem.'
Cada chamada para $faker->name()produz um resultado diferente (aleatório). Isso ocorre porque o Faker usa __call()magia e encaminha Faker\Generator->$method()chamadas para Faker\Generator->format($method, $attributes).
for ($i = 0; $i < 3; $i++) {
    echo $faker->name() . "\n";
}
// 'Cyrus Boyle'
// 'Alena Cummerata'
// 'Orlo Bergstrom'
Modificadores#
Faker fornece três provedores especiais, unique(), optional(), e valid(), para serem chamados antes de qualquer provedor.
// unique() forces providers to return unique values
$values = [];
for ($i = 0; $i < 10; $i++) {
    // get a random digit, but always a new one, to avoid duplicates
    $values []= $faker->unique()->randomDigit();
}
print_r($values); // [4, 1, 8, 5, 0, 2, 6, 9, 7, 3]
// providers with a limited range will throw an exception when no new unique value can be generated
$values = [];
try {
    for ($i = 0; $i < 10; $i++) {
        $values []= $faker->unique()->randomDigitNotNull();
    }
} catch (\OverflowException $e) {
    echo "There are only 9 unique digits not null, Faker can't generate 10 of them!";
}
// you can reset the unique modifier for all providers by passing true as first argument
$faker->unique($reset = true)->randomDigitNotNull(); // will not throw OverflowException since unique() was reset
// tip: unique() keeps one array of values per provider
// optional() sometimes bypasses the provider to return a default value instead (which defaults to NULL)
$values = [];
for ($i = 0; $i < 10; $i++) {
    // get a random digit, but also null sometimes
    $values []= $faker->optional()->randomDigit();
}
print_r($values); // [1, 4, null, 9, 5, null, null, 4, 6, null]
// optional() accepts a weight argument to specify the probability of receiving the default value.
// 0 will always return the default value; 1.0 will always return the provider. Default weight is 0.5 (50% chance).
// Please note that the weight can be provided as float (0 / 1.0) or int (0 / 100)
// As float
$faker->optional($weight = 0.1)->randomDigit(); // 90% chance of NULL
$faker->optional($weight = 0.9)->randomDigit(); // 10% chance of NULL
// As int
$faker->optional($weight = 10)->randomDigit; // 90% chance of NULL
$faker->optional($weight = 100)->randomDigit; // 0% chance of NULL
// optional() accepts a default argument to specify the default value to return.
// Defaults to NULL.
$faker->optional($weight = 0.5, $default = false)->randomDigit(); // 50% chance of FALSE
$faker->optional($weight = 0.9, $default = 'abc')->word(); // 10% chance of 'abc'
// valid() only accepts valid values according to the passed validator functions
$values = [];
$evenValidator = function($digit) {
    return $digit % 2 === 0;
};
for ($i = 0; $i < 10; $i++) {
    $values []= $faker->valid($evenValidator)->randomDigit();
}
print_r($values); // [0, 4, 8, 4, 2, 6, 0, 8, 8, 6]
// just like unique(), valid() throws an overflow exception when it can't generate a valid value
$values = [];
try {
    $faker->valid($evenValidator)->randomElement([1, 3, 5, 7, 9]);
} catch (\OverflowException $e) {
    echo "Can't pick an even number in that set!";
}
Se você quiser usar um modificador com um valor não gerado pelo Faker, use o passthrough()método. passthrough() simplesmente retorna qualquer valor que foi dado.
$faker->optional()->passthrough(mt_rand(5, 15));
Localização#
Faker\Factorypode receber uma localidade como argumento, para retornar dados localizados. Se nenhum provedor localizado for encontrado, a fábrica retornará à localidade padrão (en_US).
// create a French faker
$faker = Faker\Factory::create('fr_FR');
for ($i = 0; $i < 3; $i++) {
    echo $faker->name() . "\n";
}
// Luce du Coulon
// Auguste Dupont
// Roger Le Voisin
Você pode verificar as localidades do Faker disponíveis no código-fonte, no Providerdiretório . A localização do Faker é um processo contínuo, para o qual precisamos da sua ajuda. Não hesite em criar provedores localizados para sua própria localidade e enviar um PR!
Semeando o Gerador#
Você pode querer sempre obter os mesmos dados gerados - por exemplo, ao usar o Faker para fins de teste de unidade. O gerador oferece um seed()método que propaga o gerador de números aleatórios. Chamar o mesmo script duas vezes com a mesma semente produz os mesmos resultados.
$faker = Faker\Factory::create();
$faker->seed(1234);
echo $faker->name(); // 'Jess Mraz I';
Dica
Os formatadores DateTime não reproduzirão os mesmos dados falsos se você não corrigir o $maxvalor:
// even when seeded, this line will return different results because $max varies
$faker->dateTime(); // equivalent to $faker->dateTime($max = 'now')
// make sure you fix the $max parameter
$faker->dateTime('2014-02-25 08:37:17'); // will return always the same date when seeded
Dica
Os formatadores não reproduzirão os mesmos dados falsos se você usar a rand()função php. Use $fakerou mt_rand()em vez disso:
// bad
$faker->realText(rand(10, 20));
// good
$faker->realText($faker->numberBetween(10, 20));
Faker Internals: Entendendo os Provedores#
Um Faker\Generatorsozinho não pode fazer muita geração. Ele precisa Faker\Providerde objetos para delegar a geração de dados a eles. Faker\Factory::create()realmente cria um Faker\Generatorpacote com os provedores padrão. Aqui está o que acontece sob o capô:
$faker = new Faker\Generator();
$faker->addProvider(new Faker\Provider\en_US\Person($faker));
$faker->addProvider(new Faker\Provider\en_US\Address($faker));
$faker->addProvider(new Faker\Provider\en_US\PhoneNumber($faker));
$faker->addProvider(new Faker\Provider\en_US\Company($faker));
$faker->addProvider(new Faker\Provider\Lorem($faker));
$faker->addProvider(new Faker\Provider\Internet($faker));
Sempre que você tenta acessar uma propriedade do $fakerobjeto, o gerador procura um método com o mesmo nome em todos os provedores anexados a ele. Por exemplo, chamar $faker->nameaciona uma chamada para Faker\Provider\Person::name(). E como o Faker começa com o último provedor, você pode facilmente substituir os formatadores existentes: basta adicionar um provedor contendo métodos nomeados de acordo com os formatadores que você deseja substituir.
Isso significa que você pode adicionar facilmente seus próprios provedores a uma Faker\Generatorinstância. Um provedor geralmente é uma classe que estende o \Faker\Provider\Base. Essa classe pai permite que você use métodos como lexify()ou randomNumber(); também lhe dá acesso a formatadores de outros provedores, através da $generatorpropriedade protegida. Os novos formatadores são os métodos públicos da classe do provedor.
Aqui está um exemplo de provedor para preencher dados de livros:
namespace Faker\Provider;
class Book extends \Faker\Provider\Base
{
  public function title($nbWords = 5)
  {
    $sentence = $this->generator->sentence($nbWords);
    return substr($sentence, 0, strlen($sentence) - 1);
  }
  public function ISBN()
  {
    return $this->generator->ean13();
  }
}
Para registrar este provedor, basta adicionar uma nova instância de \Faker\Provider\Booka um gerador existente:
$faker->addProvider(new \Faker\Provider\Book($faker));
Agora você pode usar os dois novos formatadores como qualquer outro formatador Faker:
$book = new Book();
$book->setTitle($faker->title());
$book->setISBN($faker->ISBN());
$book->setSummary($faker->text());
$book->setPrice($faker->randomNumber(2));
Dica
Um provedor também pode ser um Plain Old PHP Object. Nesse caso, todos os métodos públicos do provedor ficam disponíveis para o gerador.
Formatadores específicos de idioma#
As localidades suportadas podem ser encontradas no cabeçalho "Locales" à esquerda.
Localidades com nomes errados#
Nome atual  Nome correto
at_AT   de_AT
zh_CN   zh_Hans_CN
zh_TW   zh_Hant_TW
Fonte: https://www.localeplanet.com/icu/
Licença#
Faker é lançado sob a licença MIT. Consulte o arquivo LICENSE incluído para obter detalhes.
Footer
© 2022 GitHub, Inc.
Footer navigation
Terms
Privacy
Security
Status
Docs
Contact GitHub
Pricing
API
Training
Blog
About
notas/NOTAS.md at main · albertogomesdasilva/notas

https://www.youtube.com/watch?v=bcjlZl9F0dU&t=696s


1 - Instalaçao do PHP
https://docs.microsoft.com/pt-br/sql/...

2 - Instalação MySQL
sudo apt install mysql-server

3 - Alterar senha de usuário root
a) sudo mysql -u root

b) ALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY '123456';

c) sudo service mysql restart

4 - Habilitar o mdo de reescrita do apache
a) sudo a2enmod rewrite
b) sudo service apache2 restart

5 - Alterar as Configurações no Arquivo apache2.conf
a) Altere as permissões pelo terminal dentro do diretório etc/.

b) sudo chmod 777 -R apache2/

Após alterar, reinicie o apache com o comando abaixo
c) sudo service apache2 restart

6 - Instalar o Composer
https://getcomposer.org/download/
Copie o código e cole no terminal. Após isso, digite o código de instalação abaixo:
sudo apt install composer

7 - Instalar o NodeJS
Link para saber a versão atual: https://nodejs.org/en/
a) curl -fsSL https://deb.nodesource.com/setup_16.x | sudo -E bash -

b) sudo apt install nodejs -y
c) sudo apt update

Por fim, instale o driver mysql
sudo apt install php8.1-pdo-mysql
sudo service mysql restart

sudo apt update

Detalhe IMPORTANTE!
Para criar o projeto em Laravel dentro do diretório html, é necessário dar permissão pelo terminal.
No diretório raiz digite: sudo chmod 777 -R /var/www/html/

### INICIAR O GIT LOGADO
git init
git remote add origin https://endereçodorepositoriocriado.git

git pull origin master

### CLONANDO O REPOSITÓRIO

git clone http://endereçodogit .    -> ponto no final pra ficar logo dentro da pasta

composer init



<!--  INÍCIO:

1 instalar o docker

2 abrir wsl2/Windows ou linux
 curl -s "https://laravel.build/olw?with=mysql,redis,mailhog,minio" | bash

3 cd olw
./vendor/bin/sail up -d
	ou
4 cd olw && ./vendor/bin/sail up -d

5 ATRIBUINDO PERMISSÃO PARA A PASTA
cd .. -> sai da pasta
sudo chmod 777 olw/ -R ou sem o 'sudo' chmod 777 olw/ -R

6 CRIANDO ALIAS PARA O COMANDO ANTERIOR
alias sail='[ -f sail ] && sh sail || sh vendor/bin/sail'
passa a usar assim: sail ps

7 CONFIGURAR PORTAS PARA A APLICAÇÃO NO NAVEGADOR E MYSQL
.env
APP_PORT=8000

*porta do myql
FORWARD_DB_PORT=3307

8 INSTALANDO DEPENDÊNCIA AO PROJETO
./vendor/bin/sail composer require laravel/breeze --dev 

e depois tem que 


9 DEIXAR TELA DE AUTENTICAÇÃO PRONTA, ROTA AUTENTICADA, TAWINDCSS INSTALADO E INERTIA INSTALADO
./vendor/bin/sail artisan breeze:install vue 
ou
./vendor/bin/sail art breeze:install vue




10 RODAR AS MIGRATES PADRÕES DO PROJETO AI JÁ PODE CADASTRAR USUÁRIOS PARA LOGIN:
./vendor/bin/sail art migrate

-->

 


/*******************************************/
2a AULA:

O PROJETO CONSISTE EM RECEBER DADOS DE UMA API (punkapi.com) DE INFORMAÇÕES SOBRE CERVEJAS, VAMOS CONSTRUIR AS ROTAS PARA CONSUMIR A API E CRIAR A ESTRUTURA PARA O RELATÓRIO QUE IREMOS GERAR EM EXCEL E ENVIAR PARA O STORAGE...
1 CRIAR ROTAS:
code .
olw/routes/web.php


sail up -d -> SOBE O CONTAINER localhost:8000 (nesse projeto)

Route::get('/beers', fn()=> 'Olw - testando a rota /beers');

**************************************************
obs:
- laravel.com/api -> acesso a documentação do código;
- in line paramets for vscode -> extensão para vscode para exibir o nome dos métodos na hora que codificar;
- fira code -> extensão para fonte no vscode

git Hub Copilot vs Tabnine -> (pesquisar sobre)
Link para extensões vscode:
https://github.com/icarojobs/vscode-useful-extensions
*************************************************


Route::get('/beers', fn()=> 'Olw - testando a rota /beers')
                             ->middleware(['auth']);

* FLUXO PADRÃO DO MVC-LARAVEL: 
life cicle: sai do usuário pelo navegador, insomnia ou postman -> passa pelo index.php(pasta public) -> passa pelos arquivos do bootstrap retornando uma instância da aplicação -> passa pelo kernel do http (carrega mais instâncias) -> Service provider -> despacha a requisição pro Router -> Cai no arquivo Web.php -> Middleware (se tiver, geralmente tem os globais) -> Controller (faz as regras de negócio e pode chamar outras classes como Serviços por exemplo)
-> Retorna uma view ou um json (No caso estamos usando inértia, ele não vai reinderizar a 'view.blade' padrão, ele vai reinderizar componente vue.js através do inértia.).


* EM VEZ DE USAR A FUNÇÃO AQUI NA ROTA CRIAMOS UM CONTROLLER:

obs.: ​dica: php artisan make:controller -r cria o Resource também.
dica: limpar o cache do container:
./vendor/bin/sail art config:cache 
./vendor/bin/sail art optimize:clear
ou
./vendor/bin/sail art config:cache && art optimize:clear

sail artisan make:controller BeerController
ou 
sail art make:controller BeerController -> CRIA O ARQUIVO BeerController.php na pasta app/Http/Controllers
->
<?php

namespace App\Http\Controllers;

use Illuminate\Http\Request;

class BeerController extends Controller
{
    public function index()
    {
    return 'Virgu & Beer & Code'
    }
}

* NO ARQUIVO DE ROTAS Web.php CHAMA O BeersController:

importante importar o Controller <nomeDoController>+<CTRL=ENTER:
use App\Http\Controllers\BeerController;

Route::get('/beers', [BeerController::class, 'index'])
                        ->middleware(['auth']);


* PRECISAMOS CRIAR UM MÉTODO PARA PEGAR A LISTA, LISTAR OS DADOS DA API (listar as bebidas de https://api.punkapi.com/v2 ->
VAMOS CRIAR UMA NOVA CLASSE de serviços em app/Sevices/PunkapiService.php

* O LARAVEL POSSUI UM RECURSO CHAMADO HTTPClient que abstrai o uso de uma ferramenta chama guzeo, esse guzeo é o client http mais comum para php, com ele fazemos requisições pra diversos serviços web dentro do php para outras url, ele é robusto, então o laravel simplifica importando o recurso que faz tudo por 'detrás dos panos':

PunkapiService.php

<?php

namespace App\Services;

use Illuminate\Support\Facades\Http;

class PunkapiService
{
    public function getBeers()
    {
        return Http::get('https://api.punkapi.com/v2/beers');
    }
}

E NO BeerController.php fica:
<?php

namespace App\Http\Controllers;

use App\Services\PunkapiService;
use Illuminate\Http\Request;

class BeerController extends Controller
{
    public function index()
    {
    //return 'Virgu & Beer & Code';
    $service = new PunkapiService;

    return $service->getBeers();
    }
}

* TRATE É CARACTERÍSTICA QUE A CLASSE ADQUIRE (pode ter mesmos métodos e atributos substituindo o recurso de um classe extender várias classes que não tem no php, a trate é uma forma de fazer isso. O service  é uma outra camada na maioria das vezes abstrair seviços que vc vai consumir, por exemplo API.

Estando logado, os dados da api já serão exibidos em localhost:8000/beers, se usar um aplicativo cliente tipo insomnia pode apresentar os dados também, melhor comentar a linha de de autenticação da rota:
Route::get('/beers', [BeerController::class, 'index']);
linha de autenticação da rota // ->middleware(['auth']);

* ESSA API PERMITE FAZER FILTROS VIA PARÂMETROS NA PRÓPRIA ROTA. PRIMEIRO VAMOS REFATORAR O CÓDIO, A CLASSE PunkapiService.php:

USO DE CONFIG E MACRO


Vamos alterar a url, primeiro acessando a pasta config da raiz do projeto e criar o arquivo punkapi.php. O que acontece é que o config(pasta config da raiz) carrega todos os arquivos da pasta e permite que sejam acessados via funções simples(HELPERS), isso é muito legal porque podemos acessar esses arquivos de configurações de qualquer lugar do projeto: 

<?php

return [
    'url' => env('PUNK_BASE_URL', 'https://api.punkapi.com/v2')
];

Usando o helper env significa dizer que, se não houver a constante PUNK_BASE_URL setada no arquivo .env do projeto, seu valor será o segundo parâmetro: http://api.punkapi.com/v2 e no arquivo PunkapiService.php da pasta app/Services fica:

<?php

namespace App\Services;

use Illuminate\Support\Facades\Http;

class PunkapiService
{
    public function getBeers()
    {
        return Http::get('/beers');
    }
}

MACRO é uma forma de criar funções customizadas:
 em app\Providers vamos acessar o arquivo AppServiceProvider.php que é uma classe que tem dois métodos register e boot. No método boot vamos chamar o método Http do laravel e chamar o método macro, no primeiro parâmetro será um nome atribuído à função e e o segundo uma clausure (uma função).
Neste arquivo é passado o arquivo de configuração da url (em 'config/punkapi.php') além de tokens, headers,...
 

use Illuminate\Support\Facades\Http; -> deve ser importado
E a função boot fica:

  public function boot()
    {
        Http::macro('punkapi', function(){
            return Http::acceptJson()
            ->baseUrl(config('punkapi.url'));
        });
    }

Então criamos uma macro(uma função customizada) chamada punkapi que já retorna o client com accept/Json no Header e com o baseUrl configurado lá do arquivo /config/punkapi.php e se estiver setado no .env pegará de lá.

/app/Services/PunkapiService.php fica:

<?php

namespace App\Services;

use Illuminate\Support\Facades\Http;

class PunkapiService
{
    public function getBeers()
    {
        return Http::punkapi()->get('/beers');
    }
}

*obs.: a baseUrl poderia ser setada no construtor, que pode setar token também.(uma outra abordagem para versão sem macros);

->Testamos o retorno Json em localhost:8000/beers.

Refatorando o arquivo PunkapiService.php: O client Http não lança exceção e podemos forçar o retorno em modo Json:
<?php

namespace App\Services;

use Illuminate\Support\Facades\Http;

class PunkapiService
{
    public function getBeers()
    {
       // return Http::punkapi()->get('/beers');
       return Http::punkapi()
            ->get('/beers')
            ->throw()  // Exceção em caso de erro
            ->json();   // Força o retorno em formato Json
    }
}

Podemos testar forçando um erro alterando a constante PUNKAPI_BASE_URL criada em /config/punkapi.php, vamos atribuir um valor diferente no arquivo .env:

PUNKAPI_BASE_URL="adfjklj878"

Podemos usar a função retry tem dois parâmetros, o número de tentativas pra buscar a requisição e o intervalo entre elas. Refatorando o código fica:
<?php

namespace App\Services;

use Illuminate\Support\Facades\Http;

class PunkapiService
{
    public function getBeers()
    {
       // return Http::punkapi()->get('/beers');
       return Http::punkapi()
            ->get('/beers')
            ->throw()  // Exceção em caso de erro
            ->json();   // Força o retorno em formato Json
    }
}

- Quando sai a exceção nao deveriamos retornar o erro em json por ser um api neste caso estamos usamos um app web e não uma api. E usaríamos o Route Api.

Refatorando o método boot de /app/Providers/AppServiceProvider.php, inserindo o retry():

     */
    public function boot()
    {
        Http::macro('punkapi', function(){
            return Http::acceptJson()
            ->baseUrl(config('punkapi.url'))
            ->retry(3,100);
        });
    }
}

comando de help

* ./vendor/bin/sail composer dump-autoload
* Verificar Nome do arquivo se bate com o nome das rotas(Classes criadas e importar o nome errado);
* inteliphense

Refatorando BeerController.php
<?php

namespace App\Http\Controllers;

use App\Services\PunkapiService;

class BeerController extends Controller
{
    public function index()
    {

    $service = new PunkapiService();

    return $service->getBeers();
    }
}

Em vez de instanciar o método PunkapiService() dentro de index, vamos passar por parâmetro de index() declarando seu Próprio nome (PunkapiService) como tipo. Fica assim:

<?php

namespace App\Http\Controllers;

use App\Services\PunkapiService;

class BeerController extends Controller
{
    public function index(PunkapiService $service)
    {
    return $service->getBeers();
    }
}

Assim usamos feactures do php(injeção de dependências) e ao mesmo tempo feactures do laravel. Em vez de criar uma instância dentro do método index, vamos injetar a classe como parâmetro para o método index(), ficando index($service) e a instância de dentro da função passa como parâmetro de 'tipo da variável'. Isso quebra a cadeia de dependência entre as classes.
Assim, o método index ganha independência não mais dependendo da instância de new PunkapiService e passamos a olhar a função index em si.
Assim, o Laravel tenta fazer um binding, um match, o laravel tenta encontrar alguma classe PunkapiService e cria uma instância dessa classe e usa ali como parâmetro. Se não fizer assim, lá em Rotas teria que ser passado como parâmetro o que fica desnecessário.
Não poderia ser feito se na classe PunkapiService existisse o construtor para atribuir valores automaticamente à classe. Assim podemos usar porque não precisamos passar nenhum valor.

ADICIONAR OS FILTROS:
Vamos filtrar o retorno api com os seguintes itens: beer_name, food, ibu_gt, malte:

var_dump($v)
die();
dd($variável)
benchmarck -> ?

/*****REFATORA PARA TESTE alterando BeerController.php e PunkapiService.php
BeerController.php
<?php

namespace App\Http\Controllers;

use App\Services\PunkapiService;

class BeerController extends Controller
{
    public function index(PunkapiService $service)
    {
    return $service->getBeers(
        'heineken',
        'cheese',
        'corn',
        45
    );
    }
}

PunkapiService.php
<?php

namespace App\Services;

use Illuminate\Support\Facades\Http;

class PunkapiService
{
    public function getBeers(
        string $beer_name,
        string $food,
        string $malt,
        string $ibu_gt
    )
    {
        $params = get_defined_vars();

        dd($params);

        return Http::punkapi()
            ->get('/beers', $params)
            ->throw()  // Exceção em caso de erro
            ->json();   // Força o retorno em formato Json
    }
}

Resultado do debug no insomnia ou no navegador:
array:4 [▼ // app/Services/PunkapiService.php:18
  "beer_name" => "heineken"
  "food" => "cheese"
  "malt" => "corn"
  "ibu_gt" => "45"
]
//* fim teste

Refatorando:

class PunkapiService
{
    public function getBeers(
        string $beer_name = null,
        string $food = null,
        string $malt = null,
        string $ibu_gt = null
    )
    {
        $params = get_defined_vars();

        dd($params);

        return Http::punkapi()
            ->get('/beers', $params)
            ->throw()  // Exceção em caso de erro
            ->json();   // Força o retorno em formato Json
    }
}

Assim quando não passar o valor para a chave ele exibirá a chave e o valor Null, vamos refatorar para não exibir nem a chave englobando get_defined_vers() com array_filter no arquivo PunkapiService.php:

$params = array_filter(get_defined_vars());

<?php

namespace App\Http\Controllers;

use App\Services\PunkapiService;

class BeerController extends Controller
{
    public function index(PunkapiService $service)
    {
    return $service->getBeers(
        'heineken',
        'cheese',
        'corn',
       // 45 -> Esse não é passado
    );
    }
}


array:3 [▼ // app/Services/PunkapiService.php:18
  "beer_name" => "heineken"
  "food" => "cheese"
  "malt" => "corn"
	Aqui não exibiu o valor 45
]


USANDO A FUNÇÃO NAMED_ARGS passamos só os parâmetros que precisamos retornar da api e o php com essa função saberá qual a posição dela no array de argumentos passados como parâmetro sem a necessidade de seguir a mesma sequência dos argumentos:
class BeerController extends Controller
{
    public function index(PunkapiService $service)
    {
    return $service->getBeers(food: 'cheese');
    }
}

REFATORANDO:
BeerController.php
<?php

namespace App\Http\Controllers;

use App\Services\PunkapiService;
use Illuminate\Http\Request;

class BeerController extends Controller
{
    public function index( Request $request, PunkapiService $service)
    {
    return $service->getBeers(...$request->all());
    }
}

PunkapiService.php
<?php

namespace App\Services;

use Illuminate\Support\Facades\Http;

class PunkapiService
{
    public function getBeers(
        string $beer_name = null,
        string $food = null,
        string $malt = null,
        string $ibu_gt = null
    )
    {
        $params = array_filter(get_defined_vars());

     //   dd($params);

        return Http::punkapi()
            ->get('/beers', $params)
            ->throw()  // Exceção em caso de erro
            ->json();   // Força o retorno em formato Json
    }
}

CRIANDO UMA REQUEST
sail artisan make:request BeerRequest
/app/Http/Requests/BeerRequest.php

* Funções anônimas, também conhecidas como closures , permitem a criação de funções que não tem o nome especificado. Elas são mais úteis como o valor de parâmetros callable, mas podem ter vários outros usos.. É uma função passada como parâmetro

CRIANDO NOVA ROTA PARA SALVAR COMO EXCEL
* https://docs.laravel-excel.com/3.1/getting-started/installation.html

Route::group([
    'prefix' => 'beers',
], function() {

    Route::get('/', [BeerController::class, 'index']); //-> Se houver necessidade de salvar dados por essa rota mudamos o método(verbo html) para post(os dados não serão expostos na url).
                          //  ->middleware(['auth']);
    Route::get('/export', [BeerController::class, 'export']);

});

Então passamos a ter duas rotas: localhost:8000/beers
localhost:8000/beers/export

No BeerController incluimos o método export():
class BeerController extends Controller
{
    public function index( BeerRequest $request, PunkapiService $service)
    {
    // return $service->getBeers(...$request->all());
    return $service->getBeers(...$request->validated());
    }

    public function export()
    {
        return 'Relatório criado.';
    }
}



INSTALANDO PACOTE LARAVEL-EXCEL PARA GERAR OS RELATÓRIO EM EXCEL FILTRADOS DA API:

* https://docs.laravel-excel.com/3.1/getting-started/installation.html

COMANDO PARA INSTALAR VIA COMPOSER:
./vendor/bin/sail composer require psr/simple-cache:^2.0 maatwebsite/excel

CRIAR A CLASSE DO EXCEL
./vendor/bin/sail artisan make:export BeerExport  --> Cria o arquivo em  /app/Exports/BeerExport.php

<?php

namespace App\Exports;

use Maatwebsite\Excel\Concerns\FromCollection;

class BeerExport implements FromCollection
{


    /**
    * @return \I¢lluminate\Support\Collection
    */
    public function collection()
    {
        //
    }
}

-> Dentro de colletion buscaremos as informações que serão salvas no arquivo do excel, um array de dados;

criamos um __construct() que vai ter uma propriedade privada do tipo array chamamos de $reportData.

O retorn será uma collection como informa o comentário:
 /**
    * @return \I¢lluminate\Support\Collection
    */

Na função colletion(), está recebendo um array return $this->reportData; 
Observe que não precisa mais declarar uma propriedade que vai se setada via construct(), basta defifinir o escopo junto do argumento e o php faz isso pra você. Como o retorno da função é um array usamos o helper collect para o $this->reportData:

BeerExport.php

<?php

namespace App\Exports;

use Maatwebsite\Excel\Concerns\FromCollection;

class BeerExport implements FromCollection
{

    public function __construct(
        private array $reportData
    ){}

    /**
    * @return \Illuminate\Support\Collection
    */
    public function collection()
    {
       return collect($this->reportData);
    }
}
 

Consultamos a documentação do Laravel-excel em 'Exporting collections':
em Excel Store passa o nome da classe e o nome do arquivo:

BeerController.php
<?php

namespace App\Http\Controllers;


use App\Exports\BeerExport;
use App\Http\Requests\BeerRequest;
use App\Services\PunkapiService;
use Maatwebsite\Excel\Facades\Excel;


class BeerController extends Controller
{
    public function index( BeerRequest $request, PunkapiService $service)
    {
    // return $service->getBeers(...$request->all());
    return $service->getBeers(...$request->validated());
    }

    public function export()
    {
      $params = [
        ['name' => 'Tom', 'age' => '30'],
        ['name' => 'Virgu', 'age' => '27']
       ];

       Excel::store(new BeerExport($params), 'olw-report.xlsx');
       return "Relatório criado";

    }


}

********************************************
* REFATORANDO E SALVANDO O ARQUIVO EXCEL EM /storage/app

BeerExport.php
<?php

namespace App\Exports;

use Maatwebsite\Excel\Concerns\FromCollection;

class BeerExport implements FromCollection
{

    public function __construct(
        private array $reportData
    ){}

    /**
    * @return \Illuminate\Support\Collection
    */
    public function collection()
    {
       return collect($this->reportData);
    }
}
*****************************

BeerController.php

<?php

namespace App\Http\Controllers;


use App\Exports\BeerExport;
use App\Http\Requests\BeerRequest;
use App\Services\PunkapiService;
use Maatwebsite\Excel\Facades\Excel;


class BeerController extends Controller
{
    public function index( BeerRequest $request, PunkapiService $service)
    {
        return $service->getBeers(...$request->all());

    }

    public function export(BeerRequest $request, PunkapiService $service)
    {
        $beers = $service->getBeers(...$request->validated());

        $filteredBeers = collect($beers)->map(function($value, $key){
        return collect($value)
                ->only(['name', 'tagline', 'first_brewed', 'description'])
                ->toArray();
    })->toArray();

    //dd($filteredBeers);

      $params = [
        ['name' => 'Tom', 'age' => '30'],
        ['name' => 'Virgu', 'age' => '27']
       ];

       Excel::store(new BeerExport($filteredBeers), 'olw-report.xlsx');

           return "Relatório criado";

    }


}

PARA SALVAR O ARQUIVO EXCEL EM UM STORAGE S3:
ALTERA BeerController.php

<?php

namespace App\Http\Controllers;


use App\Exports\BeerExport;
use App\Http\Requests\BeerRequest;
use App\Services\PunkapiService;
use Maatwebsite\Excel\Facades\Excel;


class BeerController extends Controller
{
    public function index( BeerRequest $request, PunkapiService $service)
    {
        return $service->getBeers(...$request->all());

    }

    public function export(BeerRequest $request, PunkapiService $service)
    {
        $beers = $service->getBeers(...$request->validated());

        $filteredBeers = collect($beers)->map(function($value, $key){
        return collect($value)
                ->only(['name', 'tagline', 'first_brewed', 'description'])
                ->toArray();
    })->toArray();


       Excel::store(
            new BeerExport($filteredBeers),
             'olw-report.xlsx',
             's3');

           return "Relatório criado";

    }


}

************
O REPOSITÓRIO DE ARQUIVOS minio:
NO DOCKER COMPOSER TEMOS O minio, um S3 que tem
MINIO_ROOT_USER: 'sail'
MINIO_ROOT_PASSWORD: 'password' e roda na porta 9000
localhost:9000
usuário: sail
senha: password

vamos criar um buncket(uma pasta)

e configurar o .env da raiz da aplicação:
originalmente é assim:
AWS_ACCESS_KEY_ID=
AWS_SECRET_ACCESS_KEY=
AWS_DEFAULT_REGION=us-east-1
AWS_BUCKET=
AWS_USE_PATH_STYLE_ENDPOINT=false

 e acrescentamos as informações para:


AWS_ACCESS_KEY_ID=sail
AWS_SECRET_ACCESS_KEY=password
AWS_DEFAULT_REGION=us-east-1
AWS_BUCKET=local
AWS_ENDPOINT=http://minio:9000
AWS_URL=http://minio:9000/local
AWS_USE_PATH_STYLE_ENDPOINT=true

altera tambem:

FILESYSTEM_DISK=local 
para:
FILESYSTEM_DISK=s3

INSTALAR UMA DEPENDÊNCIA (ADAPTER) PARA FAZER CORRESPONDÊNCIA COM A AWS:

Flysystem 3.x em laravel.com/docs/9.x/upgrade
./vendor/bin/sail composer require -W league/flysystem-aws-s3-v3 "^3.0"

em caso de erro:
 artisan vendor:publish --tag=laravel-assets --ansi --force

.env
APP_NAME=Laravel
APP_ENV=local
APP_KEY=base64:UbVvTP6Cu+LF5GamJdB4dsZZvW05ep4bZqcCEhmiDCg=
APP_DEBUG=true
APP_URL=http://localhost
APP_PORT=8000

# PUNKAPI_BASE_URL="httpadfjkljdsdfdfasf878"

LOG_CHANNEL=stack
LOG_DEPRECATIONS_CHANNEL=null
LOG_LEVEL=debug

DB_CONNECTION=mysql
FORWARD_DB_PORT=3307
DB_HOST=mysql
DB_PORT=3306
DB_DATABASE=olw
DB_USERNAME=sail
DB_PASSWORD=password

BROADCAST_DRIVER=log
CACHE_DRIVER=file
FILESYSTEM_DISK=s3
QUEUE_CONNECTION=sync
SESSION_DRIVER=file
SESSION_LIFETIME=120

MEMCACHED_HOST=memcached

REDIS_HOST=redis
REDIS_PASSWORD=null
REDIS_PORT=6379

MAIL_MAILER=smtp
MAIL_HOST=mailhog
MAIL_PORT=1025
MAIL_USERNAME=null
MAIL_PASSWORD=null
MAIL_ENCRYPTION=null
MAIL_FROM_ADDRESS="hello@example.com"
MAIL_FROM_NAME="${APP_NAME}"

AWS_ACCESS_KEY_ID=sail
AWS_SECRET_ACCESS_KEY=password
AWS_DEFAULT_REGION=us-east-1
AWS_BUCKET=local
AWS_ENDPOINT=http://minio:9000
AWS_URL=http://minio:9000/local
AWS_USE_PATH_STYLE_ENDPOINT=true

PUSHER_APP_ID=
PUSHER_APP_KEY=
PUSHER_APP_SECRET=
PUSHER_HOST=
PUSHER_PORT=443
PUSHER_SCHEME=https
PUSHER_APP_CLUSTER=mt1

VITE_PUSHER_APP_KEY="${PUSHER_APP_KEY}"
VITE_PUSHER_HOST="${PUSHER_HOST}"
VITE_PUSHER_PORT="${PUSHER_PORT}"
VITE_PUSHER_SCHEME="${PUSHER_SCHEME}"
VITE_PUSHER_APP_CLUSTER="${PUSHER_APP_CLUSTER}"

PRONTO. ENVIANDO PARA O MINIO.

/**** Criando as Migrations com Virgu e tabela de históricos

























 







/***********************************************************
QUINTA FEIRA: 20/10/22

Open Laravel Week | Deploy com Terraform, EC2 e RDS | Fermentação

****
https://portal.aws.amazon.com/billing/signup?nc2=h_ct&src=header_signup&redirect_url=https%3A%2F%2Faws.amazon.com%2Fregistration-confirmation&language=pt_br#/start/email

Com terraform pode mudar de infra e configurar no git.

PROGRMAR A CONFIGURAÇÃO DO SERVIDOR: É basicamente construir uma nova aplicação para fazer isso, mais fácil de entender.
Terraform serve para (linguagem HCL -> linguagem própria - linguagem descritiva, descreve o resultado e não como irá ser feito), ou seja, descrever o que queremos.
Terraspace é o framework pra terraform.
Quando criamos o Terraform, ele pode variar conforme a infra cloud (aws, azure, google cloud). sua estrutura é a mesma para todos. mas cada provider tem a sua forma de usar, não consegue usar o mesmo código para mais de uma cloud.
Vamos rodar Terraform via container:

1. clonar do git: git clone 
Criar uma pasta para a infraestrutura

sail   (script que vamos usar)
#!/usr/bin/env bash

docker run -rm -it
	-u $(id -u):$(id -g) \
	-v $PWD:/workspace \
	-w /workspace
	hashicorp/terraform:light "%@"


	<no terminal

Logar em: aws.amazon.com
busca: iam
iam dashboard -> mysecurity credencials (root user) -> Acces keys ->clicar em create access keys -> salva o access key e secret access key
e coloca no arquivo credencials na maquina local.. .aws/credencials
















































//////////////////////////////////////////////////////////////////////////////////////////////////////
CONTEÚDO QUE FALTA ORGANIZAR:



/**************************************/

sail share

sail artisan sail:publish ->coloca em uma pasta na raiz chamada docker

sail --help

sail artisan optimizer:clear

sail ps

sail build --no-cache -> faz o bild da aplicação. (dá um sail down  por precaução antes.)










/*********************************

root@DELLAGS:~# curl -s "https://laravel.build/laravel-9-course?with=mysql,redis,mailhog" | bash

Dockerfile

root@DELLAGS:~/example-app# docker exec -it example-app-mysql-1 bash


FROM wyveo/nginx-php-fpm:latest
WORKDIR /usr/share/nginx
RUN rm -rf /usr/share/nginx/html
COPY . /usr/share/nginx
RUN chmod -R 755 /usr/share/nginx/storage/*
RUN ln -s public html

.env (do composer)

DB_CONNECTION=mysql
DB_HOST=mysql-app (serviço do mysql no docker-compose.yaml)
DB_PORT=3306
DB_DATABASE=laraveldockerdb
DB_USERNAME=root
DB_PASSWORD=123456



docker-compose.yaml

version: '3'

services:
  laraveldocker-app:
    build: .
    ports:
      - "3003:80"
    volumes:
      - ./:/usr/share/nginx
      - .docker/nginx:/etc/nginx/conf.d/
    networks:
      - app-network
  mysql-app:
    image: mysql:5.7.22
    ports:
      - "3306:3306"
    volumes:
      - .docker/dbdata:/var/lib/mysql
    environment:
      MYSQL_DATABASE: laraveldocker
      MYSQL_ROOT_PASSWORD: 123456
    networks:
      - app-network
networks:
  app-network:
    driver: bridge
    
https://calculator.aws/#/addService
################



/*************************************************
#criando um serviço com um nome qualquer
version: '3'

services:
  laravel-app:                    #criando um serviço com um nome qualquer
    build: . ou image: wyveo/nginx-php-fpm:latest -> neste caso sem Dockerfile.                    # endereço da imagem ou local do Dockerfile (neste caso o ponto siginifica a raiz do projeto)
    ports:
      - "8080:80"                 # 8080 porta do meu host: 80 é a porta do docker nginx
    volumes:                      # docker-compose up -d -> sobe a imagem e libera o terminal  
      - ./:/usr/share/nginx       # TUDO QUE ESTIVE NA RAIZ (na rais tem o meu projeto laravel) './' IRÁ SER REFLETIDO NA PASTA /usr/share/nginx (pasta de acesso da página html)
                                  # C:\Laravel-docker\laravel-docker>docker compose up -d --build atualiza a minha imagem

  mysql-app:
      image: mysql:5.7
      ports:
        - "3306:3306"
      volumes:
        - .docker/dbdata:/var/lib/mysql          # qualqer nome (para persistir -guardar os dados do banco de dados)


      environment:
        MYSQL_DATABASE: laravel
        MYSQL_ROOT_PASSWORD: laravel
    
      

      /***************************///


  
C:\Laravel-docker\laravel-docker>docker compose up -d --build

                                
                               

    

/******************************** Dockerfile
FROM wyveo/nginx-php-fpm:latest

/***************************///
  COMANDOS

docker compose down -> para todos os containers
C:\Laravel-docker\laravel-docker>docker exec -it laravel-docker-laravel-app-1 bash 
root@612ea0ea3340:/# cd /usr/share/nginx/
root@612ea0ea3340:/usr/share/nginx# php artisan migrate
root@612ea0ea3340:/usr/share/nginx# php artisan serve

		
/***********/
PS C:\Users\alber> docker run -e MYSQL_ROOT_PASSWORD=root --name meu-mysql -d mysql:5.7

docker inspect meu-mysql ou | grep IPAddress

PS C:\Users\alber> docker run -e MYSQL_ROOT_PASSWORD=root --name meu-mysql -d -p 3306:3306 mysql:5.7

docker ps
docker ps -l
docker ps -a
docker rm -f nome


/*** LARAVEL */
### CRIANDO UM PROJETO NO LARAVEL 
laravel new projeto_laravel_via_installer (ESTA É UM AOPÇÃO)
composer create-project --prefer-dist laravel/laravel app_controle_tarefas "8.5.9"
cd app_controle_tarefas
cd public
php -S localhost:8000

ou 
da raiz do projeto:
php artisan serve 
ou
php artisan serve --port=3000

### PARA ABRIR PORTA EM OUTRO SERVIDOR
php artisan serve --host test.com --port 8080

 **********************************************************************
cd app_controle_tarefas
cd public
php artisan serve
- acessa o navegador http://localhost:8000

### DENTRO DO PROJETO CRIADO INSTALAR O LARAVEL/UI:^3.2 - versão 3.2
composer require laravel/ui:^3.2

### SE OCORRER ERRO AUMENTAR A MEMÓRIA DISPONIVEL PARA O php

-php --ini -> localiza o arquivo de configuração do php
LOCALIZA memory_limit = 1000 e altera para 
         memory_limit  = -1 e Salva

### LISTA A RELAÇÃO DE COMANDOS 
php artisan list 

DEVERA SURGIR AS OPÇÕES ABAIXO:

 ui
  ui:auth               Scaffold basic login and registration views and routes
  ui:controllers        Scaffold the authentication controllers
 vendor

### ENTENDENDO O PACOTE UI E INICIANDO A AUTENTICAÇÃO WEB NATIVA DO LARAVEL

COMANDO PARA LISTAR ROUTES: 
php artisan route:list

### php artisan ui bootstrap --auth (bootstrap ou react ou vue)
aplicando o bootstrap incluindo os recursos de autenticação;
poderia ser aplicado o bootstrap sem os recursos de autenticação;

### php artisan route:list -> mostra as rotas - ver que aumentaram as rotas

### APÓS ESSE PROCESSO O SISTEMA PEDE PARA RODAR
npm install -> instala as dependências do package.json (inclusive o bootstrap)
npm run dev -> gera os assets da aplicação de acordo com a tecnologia selecionada (bootstrap, react ou vue) -> Geralmente roda mais de uma vez para compilar tudo.

### CRIA O BANCO DE DADOS NORMALMENTE

### EXECUTA AS MIGRATIONS PADRÕES CRIADAS PARA O SISTEMA DE login
php artisan migrate -> CRIA AS TABELAS NO BANCO DE DADOS


************************************** 
INSTALANDO O COMPOSER NO UBUNTU
**************************************
sudo apt update
sudo apt install php-cli unzip

cd ~

curl -sS https://getcomposer.org/installer -o composer-setup.php

HASH=`curl -sS https://composer.github.io/installer.sig`

echo $HASH ->saída: Output
e0012edf3e80b6978849f5eff0d4b4e4c79ff1609dd1e613307e16318854d24ae64f26d17af3ef0bf7cfb710ca74



php -r "if (hash_file('SHA384', 'composer-setup.php') === '$HASH') { echo 'Installer verified'; } else { echo 'Installer corrupt'; unlink('composer-setup.php'); } echo PHP_EOL;"

sudo php composer-setup.php --install-dir=/usr/local/bin --filename=composer





***********************

DigitalOcean Kubernetes: novo plano de controle é mais rápido e gratuito, habilita HA para SLA de 99,95% de tempo de atividade
Produtos
Preços

Documentos
divisa suspensa

Entrar
divisa suspensa

// Tutorial //
Como Instalar e Utilizar o Composer no Ubuntu 20.04
Publicado em 21 de maio de 2020
Ubuntu
PHP
Ubuntu 20.04
Avatar padrão
Por Erika Heidi
Advogado Desenvolvedor
Português
Como Instalar e Utilizar o Composer no Ubuntu 20.04
Introdução
O Composer é uma ferramenta popular de gerenciamento de dependências para o PHP, criado para facilitar a instalação e a atualização das dependências principalmente do projeto. Ele controla quais outros pacotes de projeto específico dependem e são instalados para você, usando as opções apropriadas de acordo com os requisitos do projeto. O Composer também é comumente utilizado para inicializar novos projetos em frameworks PHP populares, como o Symfon e o Laravel .

Neste tutorial, você instalará e começará a usar o Composer em um sistema Ubuntu 20.04.

Pré-requisitos
Para seguir este guia, você pode acessar um servidor como usuário Ubuntu20.04 como usuário sudonão-root um firewall habilitado em seu servidor Para configurar isto, siga nosso guia Configuração do servidor inicial para o Ubuntu 20.04

Passo 1 — Instalando o PHP e as Dependências Adicionais
Além das dependências que já devem estar incluídas em seu sistema Ubuntu 20.04, como o , o Composer exige ou gitexecuta scripts PHP na linha de comando e para extrair arquivos zipados. Vamos instalar essas dependências agora.curlphp-cliunzip

primeiro, atual, gerenciador de pacotes de soluções: o cache do gerenciador de pacotes

sudo apt update
Em seguida, o seguinte comando para instalar os pacotes, execute:

sudo apt install php-cli unzip
Você será solicitado a confirmar a instalação digitando Ye, depois, ENTER.

Assim que os pré-requisitos para instalação do Composer forem instalados, você poderá seguir.

Passo 2 — Baixando e Instalando o Compositor
O Composer fornece um instalador de script escrito em PHP. Vamos baixá-lo, verificar se ele não está danificado e, em seguida, o usaremos para instalar o Composer.

Certifique-se de estar em sua pasta home. Em seguida, baixe o instalador usando o curl:

cd ~
curl -sS https://getcomposer.org/installer -o composer-setup.php
Em seguida, vamos verificar se o instalador baixado corresponde ao hash SHA-384 para o instalador mais recente encontrado na página Composer Public Keys / Signatures . Para facilitar o passo de seleção, você pode usar o seguinte comando para obter programaticamente o hash mais recente da página do Composer e armazená-lo em uma variável do shell:

HASH=`curl -sS https://composer.github.io/installer.sig`
Se você quiser verificar o valor realizado, execute:

echo $HASH
Output
e0012edf3e80b6978849f5eff0d4b4e4c79ff1609dd1e613307e16318854d24ae64f26d17af3ef0bf7cfb710ca74755a
Agora o código PHP a seguir, execute conforme a página de download do Composer, para verificar se o script de instalação está seguro para ser executado:

php -r "if (hash_file('SHA384', 'composer-setup.php') === '$HASH') { echo 'Installer verified'; } else { echo 'Installer corrupt'; unlink('composer-setup.php'); } echo PHP_EOL;"
Você verá o seguinte resultado:

Resultado
Installer verified
Se Installer corruptvocê estiver usando o hash correto, verifique se você está usando o hash correto. Em seguida, repita o processo de verificação. Quando você tiver um instalador selecionado, você pode continuar.

Para instalar o composerglobalmente, use o seguinte comando que baixará e instalará o Composer como um comando disponível em todo o sistema chamado composer, sob /usr/local/bin:

sudo php composer-setup.php --install-dir=/usr/local/bin --filename=composer
Você verá um resultado semelhante com este:

Output
All settings correct for using Composer
Downloading...

Composer (version 1.10.5) successfully installed to: /usr/local/bin/composer
Use it: php /usr/local/bin/composer
Para testar sua instalação, execute:

composer
Output
   ______
  / ____/___  ____ ___  ____  ____  ________  _____
 / /   / __ \/ __ `__ \/ __ \/ __ \/ ___/ _ \/ ___/
/ /___/ /_/ / / / / / / /_/ / /_/ (__  )  __/ /
\____/\____/_/ /_/ /_/ .___/\____/____/\___/_/
                    /_/
Composer version 1.10.5 2020-04-10 11:44:22

Usage:
  command [options] [arguments]

Options:
  -h, --help                     Display this help message
  -q, --quiet                    Do not output any message
  -V, --version                  Display this application version
      --ansi                     Force ANSI output
      --no-ansi                  Disable ANSI output
  -n, --no-interaction           Do not ask any interactive question
      --profile                  Display timing and memory usage information
      --no-plugins               Whether to disable plugins.
  -d, --working-dir=WORKING-DIR  If specified, use the given directory as working directory.
      --no-cache                 Prevent use of the cache
  -v|vv|vvv, --verbose           Increase the verbosity of messages: 1 for normal output, 2 for more verbose output and 3 for debug
...
Isso verifica que o Composer foi instalado com sucesso em seu sistema e está disponível em todo o sistema.

Nota: se você preferirá ter-lhe-ão separados separados do Composer para projeto hospedado neste servidor, você pode instalar localmente, em uma base por projeto. Este método também é útil quando o usuário do sistema não possui permissão para instalar o software disponível em todo o sistema.

Para fazer isso, use o comando php composer-setup.php. Isso irá gerar um arquivo composer.pharem seu diretório atual, que pode ser executado com o seu atual php composer.phar.

Agora podemos dar uma dependência em como usar o Compose como gerenciar.

Passo 3 — Usando o Compositor em um Projeto PHP
Os projetos PHP geralmente dependentes de bibliotecas externas, e o gerenciamento de dependências e suas versões podem ser complicados. O Composer resolve esse problema de manter um controle de projeto de extensões e dependências, também facilita o processo de descoberta, instalação e atualização de pacotes que são definidos por enquanto.

Para usar o seu projeto, você pode compor um arquivo composer.json. O arquivo composer.jsonComposer quais dependências precisa para baixar seu projeto quais serão as versões de cada pacote tem permissão para instalações e instalações. Isso é muito importante para manter seu projeto consistente e evitar a instalação de versões instáveis ​​que podem causar problemas de compatibilidade retroativa.

Você não precisa criar este arquivo manualmente - é comum ocorrer erros de sintaxe quando fizer isso. O Composer oferece uma maneira de criar um novo arquivo composer.jsoncom base na entrada do usuário, o que é uma boa escolha se você planeja compartilhar seu projeto mais tarde como um pacote público no Packagist . O Composer gera automaticamente um arquivo básico composer.jsonquando você executa um comando composer requirepara incluir uma dependência em um projeto recém-criado.

O processo de uso do Composer para instalar um pacote como uma dependência em um projeto envolve os passos a seguir:

Identifique o tipo de biblioteca que o aplicativo precisa.
uma biblioteca de código aberto adequada no agist.org , o responsável oficial de pacotes para o Compose.
Escolha o pacote de dependência.
Execute composer requirepara incluir a dependência no arquivo composer.jsone instalar o pacote.
Vamos testar isso com uma aplicação de demonstração.

O objetivo desta aplicação é transformar uma determinação determinada em uma string de URL amigável - um slug . Isso é comumente usado para converter os títulos de página para caminhos de URL (Assim como a parte final da URL para este tutorial).

Vamos começar a criar um diretório para o nosso projeto. Vamos chamá-lo de slugify :

cd ~
mkdir slugify
cd slugify
Embora não seja necessário, você pode executar agora um comando composer init para criar um arquivo composer.json detalhado para seu projeto. Como o único objetivo do nosso projeto é demonstrar como instalar dependências com o Composer, usaremos um arquivo composer.json mais simples que será gerado automaticamente quando exigirmos nosso primeiro pacote.

Agora é hora de procurar no Packagist.org por um pacote que pode nos ajudar a gerar slugs. Se você procurar pelo termo “slug” no Packagist, receberá um resultado parecido com este:

Resultados da Pesquisa do Packagist para o termo "slug"

Você verá dois números no lado direito de cada pacote na lista. O número no topo representa quantas vezes o pacote foi instalado através do Composer, e o número em baixo mostra quantas vezes um pacote foi estrelado no GitHub. De um modo geral, os pacotes com mais instalações e mais estrelas tendem a ser mais estáveis, pois mais pessoas os utilizam. Também é importante verificar a descrição do pacote para relevância para garantir que ele é o que você precisa.

Precisamos de um conversor string-to-slug A partir dos resultados da pesquisa, o pacote cocur/slugify, que aparece como o primeiro resultado naquela página, parece ser um bom candidato, com uma quantidade razoável de instalações e estrelas.

Os pacotes no Packagist têm um nome de vendor e um nome de package. Cada pacote tem um identificador único (um namespace) no mesmo formato que o GitHub utiliza para seus repositórios: vendor/package. A biblioteca que queremos instalar utiliza o namespace cocur/slugify. Você precisa de um namespace do pacote para exigi-lo em seu projeto.

Agora que você sabe exatamente qual pacote deseja instalar, você pode executar o composer require para incluí-lo como uma dependência e gerar também o arquivo composer.json para seu projeto. Uma coisa importante é observar a exigência de pacotes. O Composer rastreia as dependências no nível da aplicação e do sistema. As dependências no nível do sistema são importantes para indicar de quais módulos PHP um pacote depende. No caso do pacote cocur/slugify, ele exige um módulo PHP que ainda não instalamos.

Quando um pacote necessário depende de uma biblioteca de sistema que não está atualmente instalada em seu servidor, você receberá um erro informando qual requisito está faltando:

composer require cocur/slugify
Output
Using version ^4.0 for cocur/slugify
./composer.json has been updated
Loading composer repositories with package information
Updating dependencies (including require-dev)
Your requirements could not be resolved to an installable set of packages.

  Problem 1
    - Installation request for cocur/slugify ^4.0 -> satisfiable by cocur/slugify[v4.0.0].
    - cocur/slugify v4.0.0 requires ext-mbstring * -> the requested PHP extension mbstring is missing from your system.
...
Para resolver o problema de dependência do sistema, podemos procurar pelo pacote que falta usando o apt search:

apt search mbstring
Output
Sorting... Done
Full Text Search... Done
php-mbstring/focal 2:7.4+75 all
  MBSTRING module for PHP [default]

php-patchwork-utf8/focal 1.3.1-1 all
  UTF-8 strings handling for PHP

php7.4-mbstring/focal 7.4.3-4ubuntu1 amd64
  MBSTRING module for PHP
Após localizar o nome do pacote correto, você pode utilizar o apt novamente para instalar a dependência de sistema:

sudo apt install php-mbstring
Assim que a instalação terminar, você pode executar novamente o comando composer require:

composer require cocur/slugify
Output
Using version ^4.0 for cocur/slugify
./composer.json has been created
Loading composer repositories with package information
Updating dependencies (including require-dev)
Package operations: 1 install, 0 updates, 0 removals
  - Installing cocur/slugify (v4.0.0): Downloading (100%)         
Writing lock file
Generating autoload files
Como você pode ver na saída, o Composer decidiu automaticamente qual versão do pacote utilizar. Se você verificar o diretório do seu projeto agora, ele irá conter dois arquivos novos: composer.json e composer.lock, e um diretório vendor:

ls -l
Output
total 12
-rw-rw-r-- 1 sammy sammy   59 May  4 13:56 composer.json
-rw-rw-r-- 1 sammy sammy 3229 May  4 13:56 composer.lock
drwxrwxr-x 4 sammy sammy 4096 May  4 13:56 vendor
O arquivo composer.lock é usado para armazenar informações sobre quais versões de cada pacote estão instaladas, e garantir que as mesmas versões sejam usadas se outra pessoa clonar seu projeto e instalar suas dependências. O diretório vendor é onde as dependências do projeto estão localizadas. Você não deve fazer commit da pasta vendor no controle de versão - você precisa apenas incluir os arquivos composer.json e composer.lock.

Ao instalar um projeto que já contém um arquivo composer.json, execute o composer install para baixar as dependências do projeto.

Vamos dar uma olhada rápida em restrições de versão. Se você verificar o conteúdo do seu arquivo composer.json, verá algo parecido com isto:

cat composer.json
Output
{
    "require": {
        "cocur/slugify": "^4.0"
    }
}
Note que há o caractere especial ^ antes do número da versão no composer.json. O Composer suporta várias restrições diferentes e formatos para definir a versão necessária do pacote, para fornecer flexibilidade enquanto também mantém seu projeto estável. O operador circunflexo (^) utilizado pelo arquivo composer.json criado automaticamente é o operador recomendado para a interoperabilidade máxima, seguindo o versionamento semântico. Neste caso, ele define 4.0 como a versão mínima compatível e permite atualizações para qualquer versão futura abaixo de 5.0.

De um modo geral, você não precisará alterar as restrições de versão em seu arquivo composer.json. No entanto, algumas situações podem exigir que você edite manualmente as restrições – por exemplo, quando uma nova versão principal da sua biblioteca requerida é liberada e você deseja atualizar, ou quando a biblioteca que você deseja usar não segue o versionamento semântico.

Aqui estão alguns exemplos para lhe dar um melhor entendimento sobre como as restrições de versão do Composer funcionam:

Restrição	Significado	Exemplo de Versões Permitidas
^1.0	>= 1.0 < 2.0	1.0, 1.2.3, 1.9.9
^1.1.0	>= 1.1.0 < 2.0	1.1.0, 1.5.6, 1.9.9
~1.0	>= 1.0 < 2.0.0	1.0, 1.4.1, 1.9.9
~1.0.0	>= 1.0.0 < 1.1	1.0.0, 1.0.4, 1.0.9
1.2.1	1.2.1	1.2.1
1.*	>= 1.0 < 2.0	1.0.0, 1.4.5, 1.9.9
1.2. *	>= 1.2 < 1.3	1.2.0, 1.2.3, 1.2.9
Para uma visualização mais detalhada das restrições de versão do Composer, consulte a documentação oficial.

A seguir, vamos ver como carregar dependências automaticamente com o Composer.

Passo 4 — Incluindo o Script Autoload
Como o PHP por si só não carrega classes automaticamente, o Composer fornece um script autoload que você pode incluir em seu projeto para obter o carregamento automático para ele. Este arquivo é gerado automaticamente pelo Composer quando você adiciona sua primeira dependência.

A única coisa que você precisa fazer é incluir o arquivo vendor/autoload.php em seus scripts PHP antes de qualquer instância de classe.

Vamos testar isso em nossa aplicação de demonstração. Abra um novo arquivo chamado test.php em seu editor de texto:

nano test.php
Adicione o código a seguir que vem no arquivo vendor/autoload.php, carrega a dependência cocur/slugify, e o utiliza para criar um slug:

test.php
<?php
require __DIR__ . '/vendor/autoload.php';

use Cocur\Slugify\Slugify;

$slugify = new Slugify();

echo $slugify->slugify('Hello World, this is a long sentence and I need to make a slug from it!');
Salve o arquivo e saia do seu editor.

Agora, execute o script.

php test.php
Isso produz a saída hello-world-this-is-a-long-sentence-and-i-need-to-make-a-slug-from-it.

As dependências precisam de atualizações quando novas versões são liberadas. Dessa forma, vamos ver como lidar com isso.

Passo 5 — Atualizando as Dependências do Projeto
Sempre que você quiser atualizar suas dependências do projeto para versões mais recentes, execute o comando update:

composer update
Isso irá verificar por versões mais recentes das bibliotecas que você requer em seu projeto. Se uma versão mais recente for encontrada e ela for compatível com a restrição de versão definida no arquivo composer.json, o Composer substituirá a versão anterior instalada. O arquivo composer.lock será atualizado para refletir essas alterações.

Você também pode atualizar uma ou mais bibliotecas específicas, especificando-as desta forma:

composer update vendor/package vendor2/package2
Certifique-se de verificar em seus arquivos composer.json e composer.lock dentro do seu sistema de controle de versão após atualizar suas dependências de modo que outros também possam instalar essas versões mais recentes.

Conclusão





***********
Algoritmo "CalculoMedia2"
// Disciplina: Lógica de programação
// Professor : Antonio Carlos Nicolodi
// Descrição : calculo da média aritimética
// Autor     : Professor Antonio
// Data atual: 01/04/2015
var
// Seção de Declarações
   v1, v2, total: Real
   sinal : Caracter
Inicio
// Seção dos Comandos
   Escreva ("Digite o primeiro valor: ")
   Leia (v1)
   Escreva ("Digite a operação + - * / : ")
   Leia (sinal)
   Escreva ("Digite o segundo valor: ")
   Leia (v2)

   Se sinal = "+" entao
   total <- v1 + v2
   Escreva("O Resultado é: ", total)
   Senao
   Se sinal = "-" entao
   total <- v1 - v2
   Escreva("O Resultado é: ", total)
   Senao
   Se sinal = "*" entao
   total <- v1 * v2
   Escreva("O Resultado é: ", total)


   Senao
     Escreva("OPERAÇÃO INVÁLIDA! ")



      Escreval("total")
   fimse
Fimalgoritmo

****
COMANDOS DOCKER
root@DELLAGS:~# curl -s "https://laravel.build/laravel-9-course?with=mysql,redis,mailhog" | bash

root@DELLAGS:~/example-app# ./vendor/bin/sail  artisan migrate --seed -> criar o banco de dados e copular dados;

Dockerfile

root@DELLAGS:~/example-app# docker exec -it example-app-mysql-1 bash


FROM wyveo/nginx-php-fpm:latest
WORKDIR /usr/share/nginx
RUN rm -rf /usr/share/nginx/html
COPY . /usr/share/nginx
RUN chmod -R 755 /usr/share/nginx/storage/*
RUN ln -s public html

.env (do composer)

DB_CONNECTION=mysql
DB_HOST=mysql-app (serviço do mysql no docker-compose.yaml)
DB_PORT=3306
DB_DATABASE=laraveldockerdb
DB_USERNAME=root
DB_PASSWORD=123456



docker-compose.yaml

version: '3'

services:
  laraveldocker-app:
    build: .
    ports:
      - "3003:80"
    volumes:
      - ./:/usr/share/nginx
      - .docker/nginx:/etc/nginx/conf.d/
    networks:
      - app-network
  mysql-app:
    image: mysql:5.7.22
    ports:
      - "3306:3306"
    volumes:
      - .docker/dbdata:/var/lib/mysql
    environment:
      MYSQL_DATABASE: laraveldocker
      MYSQL_ROOT_PASSWORD: 123456
    networks:
      - app-network
networks:
  app-network:
    driver: bridge
    



/*************************************************
#criando um serviço com um nome qualquer
version: '3'

services:
  laravel-app:                    #criando um serviço com um nome qualquer
    build: . ou image: wyveo/nginx-php-fpm:latest -> neste caso sem Dockerfile.                    # endereço da imagem ou local do Dockerfile (neste caso o ponto siginifica a raiz do projeto)
    ports:
      - "8080:80"                 # 8080 porta do meu host: 80 é a porta do docker nginx
    volumes:                      # docker-compose up -d -> sobe a imagem e libera o terminal  
      - ./:/usr/share/nginx       # TUDO QUE ESTIVE NA RAIZ (na rais tem o meu projeto laravel) './' IRÁ SER REFLETIDO NA PASTA /usr/share/nginx (pasta de acesso da página html)
                                  # C:\Laravel-docker\laravel-docker>docker compose up -d --build atualiza a minha imagem

  mysql-app:
      image: mysql:5.7
      ports:
        - "3306:3306"
      volumes:
        - .docker/dbdata:/var/lib/mysql          # qualqer nome (para persistir -guardar os dados do banco de dados)


      environment:
        MYSQL_DATABASE: laravel
        MYSQL_ROOT_PASSWORD: laravel
    
      

      /***************************///


  
C:\Laravel-docker\laravel-docker>docker compose up -d --build

                                
                               

    

/******************************** Dockerfile
FROM wyveo/nginx-php-fpm:latest

/***************************///
  COMANDOS

docker compose down -> para todos os containers
C:\Laravel-docker\laravel-docker>docker exec -it laravel-docker-laravel-app-1 bash 
root@612ea0ea3340:/# cd /usr/share/nginx/
root@612ea0ea3340:/usr/share/nginx# php artisan migrate
root@612ea0ea3340:/usr/share/nginx# php artisan serve

		
/***********/
PS C:\Users\alber> docker run -e MYSQL_ROOT_PASSWORD=root --name meu-mysql -d mysql:5.7

docker inspect meu-mysql ou | grep IPAddress

PS C:\Users\alber> docker run -e MYSQL_ROOT_PASSWORD=root --name meu-mysql -d -p 3306:3306 mysql:5.7

docker ps
docker ps -l
docker ps -a
docker rm -f nome


/*** LARAVEL */
### CRIANDO UM PROJETO NO LARAVEL 
laravel new projeto_laravel_via_installer (ESTA É UM AOPÇÃO)
composer create-project --prefer-dist laravel/laravel app_controle_tarefas "8.5.9"
cd app_controle_tarefas
cd public
php -S localhost:8000

ou 
da raiz do projeto:
php artisan serve 
ou
php artisan serve --port=3000

### PARA ABRIR PORTA EM OUTRO SERVIDOR
php artisan serve --host test.com --port 8080

 **********************************************************************
cd app_controle_tarefas
cd public
php artisan serve
- acessa o navegador http://localhost:8000

### DENTRO DO PROJETO CRIADO INSTALAR O LARAVEL/UI:^3.2 - versão 3.2
composer require laravel/ui:^3.2

### SE OCORRER ERRO AUMENTAR A MEMÓRIA DISPONIVEL PARA O php

-php --ini -> localiza o arquivo de configuração do php
LOCALIZA memory_limit = 1000 e altera para 
         memory_limit  = -1 e Salva

### LISTA A RELAÇÃO DE COMANDOS 
php artisan list 

DEVERA SURGIR AS OPÇÕES ABAIXO:

 ui
  ui:auth               Scaffold basic login and registration views and routes
  ui:controllers        Scaffold the authentication controllers
 vendor

### ENTENDENDO O PACOTE UI E INICIANDO A AUTENTICAÇÃO WEB NATIVA DO LARAVEL

COMANDO PARA LISTAR ROUTES: 
php artisan route:list

### php artisan ui bootstrap --auth (bootstrap ou react ou vue)
aplicando o bootstrap incluindo os recursos de autenticação;
poderia ser aplicado o bootstrap sem os recursos de autenticação;

### php artisan route:list -> mostra as rotas - ver que aumentaram as rotas

### APÓS ESSE PROCESSO O SISTEMA PEDE PARA RODAR
npm install -> instala as dependências do package.json (inclusive o bootstrap)
npm run dev -> gera os assets da aplicação de acordo com a tecnologia selecionada (bootstrap, react ou vue) -> Geralmente roda mais de uma vez para compilar tudo.

### CRIA O BANCO DE DADOS NORMALMENTE

### EXECUTA AS MIGRATIONS PADRÕES CRIADAS PARA O SISTEMA DE login
php artisan migrate -> CRIA AS TABELAS NO BANCO DE DADOS


************************************** 
INSTALANDO O COMPOSER NO UBUNTU
**************************************
sudo apt update
sudo apt install php-cli unzip

cd ~

curl -sS https://getcomposer.org/installer -o composer-setup.php

HASH=`curl -sS https://composer.github.io/installer.sig`

echo $HASH ->saída: Output
e0012edf3e80b6978849f5eff0d4b4e4c79ff1609dd1e613307e16318854d24ae64f26d17af3ef0bf7cfb710ca74



php -r "if (hash_file('SHA384', 'composer-setup.php') === '$HASH') { echo 'Installer verified'; } else { echo 'Installer corrupt'; unlink('composer-setup.php'); } echo PHP_EOL;"

sudo php composer-setup.php --install-dir=/usr/local/bin --filename=composer





***********************

DigitalOcean Kubernetes: novo plano de controle é mais rápido e gratuito, habilita HA para SLA de 99,95% de tempo de atividade
Produtos
Preços

Documentos
divisa suspensa

Entrar
divisa suspensa

// Tutorial //
Como Instalar e Utilizar o Composer no Ubuntu 20.04
Publicado em 21 de maio de 2020
Ubuntu
PHP
Ubuntu 20.04
Avatar padrão
Por Erika Heidi
Advogado Desenvolvedor
Português
Como Instalar e Utilizar o Composer no Ubuntu 20.04
Introdução
O Composer é uma ferramenta popular de gerenciamento de dependências para o PHP, criado para facilitar a instalação e a atualização das dependências principalmente do projeto. Ele controla quais outros pacotes de projeto específico dependem e são instalados para você, usando as opções apropriadas de acordo com os requisitos do projeto. O Composer também é comumente utilizado para inicializar novos projetos em frameworks PHP populares, como o Symfon e o Laravel .

Neste tutorial, você instalará e começará a usar o Composer em um sistema Ubuntu 20.04.

Pré-requisitos
Para seguir este guia, você pode acessar um servidor como usuário Ubuntu20.04 como usuário sudonão-root um firewall habilitado em seu servidor Para configurar isto, siga nosso guia Configuração do servidor inicial para o Ubuntu 20.04

Passo 1 — Instalando o PHP e as Dependências Adicionais
Além das dependências que já devem estar incluídas em seu sistema Ubuntu 20.04, como o , o Composer exige ou gitexecuta scripts PHP na linha de comando e para extrair arquivos zipados. Vamos instalar essas dependências agora.curlphp-cliunzip

primeiro, atual, gerenciador de pacotes de soluções: o cache do gerenciador de pacotes

sudo apt update
Em seguida, o seguinte comando para instalar os pacotes, execute:

sudo apt install php-cli unzip
Você será solicitado a confirmar a instalação digitando Ye, depois, ENTER.

Assim que os pré-requisitos para instalação do Composer forem instalados, você poderá seguir.

Passo 2 — Baixando e Instalando o Compositor
O Composer fornece um instalador de script escrito em PHP. Vamos baixá-lo, verificar se ele não está danificado e, em seguida, o usaremos para instalar o Composer.

Certifique-se de estar em sua pasta home. Em seguida, baixe o instalador usando o curl:

cd ~
curl -sS https://getcomposer.org/installer -o composer-setup.php
Em seguida, vamos verificar se o instalador baixado corresponde ao hash SHA-384 para o instalador mais recente encontrado na página Composer Public Keys / Signatures . Para facilitar o passo de seleção, você pode usar o seguinte comando para obter programaticamente o hash mais recente da página do Composer e armazená-lo em uma variável do shell:

HASH=`curl -sS https://composer.github.io/installer.sig`
Se você quiser verificar o valor realizado, execute:

echo $HASH
Output
e0012edf3e80b6978849f5eff0d4b4e4c79ff1609dd1e613307e16318854d24ae64f26d17af3ef0bf7cfb710ca74755a
Agora o código PHP a seguir, execute conforme a página de download do Composer, para verificar se o script de instalação está seguro para ser executado:

php -r "if (hash_file('SHA384', 'composer-setup.php') === '$HASH') { echo 'Installer verified'; } else { echo 'Installer corrupt'; unlink('composer-setup.php'); } echo PHP_EOL;"
Você verá o seguinte resultado:

Resultado
Installer verified
Se Installer corruptvocê estiver usando o hash correto, verifique se você está usando o hash correto. Em seguida, repita o processo de verificação. Quando você tiver um instalador selecionado, você pode continuar.

Para instalar o composerglobalmente, use o seguinte comando que baixará e instalará o Composer como um comando disponível em todo o sistema chamado composer, sob /usr/local/bin:

sudo php composer-setup.php --install-dir=/usr/local/bin --filename=composer
Você verá um resultado semelhante com este:

Output
All settings correct for using Composer
Downloading...

Composer (version 1.10.5) successfully installed to: /usr/local/bin/composer
Use it: php /usr/local/bin/composer
Para testar sua instalação, execute:

composer
Output
   ______
  / ____/___  ____ ___  ____  ____  ________  _____
 / /   / __ \/ __ `__ \/ __ \/ __ \/ ___/ _ \/ ___/
/ /___/ /_/ / / / / / / /_/ / /_/ (__  )  __/ /
\____/\____/_/ /_/ /_/ .___/\____/____/\___/_/
                    /_/
Composer version 1.10.5 2020-04-10 11:44:22

Usage:
  command [options] [arguments]

Options:
  -h, --help                     Display this help message
  -q, --quiet                    Do not output any message
  -V, --version                  Display this application version
      --ansi                     Force ANSI output
      --no-ansi                  Disable ANSI output
  -n, --no-interaction           Do not ask any interactive question
      --profile                  Display timing and memory usage information
      --no-plugins               Whether to disable plugins.
  -d, --working-dir=WORKING-DIR  If specified, use the given directory as working directory.
      --no-cache                 Prevent use of the cache
  -v|vv|vvv, --verbose           Increase the verbosity of messages: 1 for normal output, 2 for more verbose output and 3 for debug
...
Isso verifica que o Composer foi instalado com sucesso em seu sistema e está disponível em todo o sistema.

Nota: se você preferirá ter-lhe-ão separados separados do Composer para projeto hospedado neste servidor, você pode instalar localmente, em uma base por projeto. Este método também é útil quando o usuário do sistema não possui permissão para instalar o software disponível em todo o sistema.

Para fazer isso, use o comando php composer-setup.php. Isso irá gerar um arquivo composer.pharem seu diretório atual, que pode ser executado com o seu atual php composer.phar.

Agora podemos dar uma dependência em como usar o Compose como gerenciar.

Passo 3 — Usando o Compositor em um Projeto PHP
Os projetos PHP geralmente dependentes de bibliotecas externas, e o gerenciamento de dependências e suas versões podem ser complicados. O Composer resolve esse problema de manter um controle de projeto de extensões e dependências, também facilita o processo de descoberta, instalação e atualização de pacotes que são definidos por enquanto.

Para usar o seu projeto, você pode compor um arquivo composer.json. O arquivo composer.jsonComposer quais dependências precisa para baixar seu projeto quais serão as versões de cada pacote tem permissão para instalações e instalações. Isso é muito importante para manter seu projeto consistente e evitar a instalação de versões instáveis ​​que podem causar problemas de compatibilidade retroativa.

Você não precisa criar este arquivo manualmente - é comum ocorrer erros de sintaxe quando fizer isso. O Composer oferece uma maneira de criar um novo arquivo composer.jsoncom base na entrada do usuário, o que é uma boa escolha se você planeja compartilhar seu projeto mais tarde como um pacote público no Packagist . O Composer gera automaticamente um arquivo básico composer.jsonquando você executa um comando composer requirepara incluir uma dependência em um projeto recém-criado.

O processo de uso do Composer para instalar um pacote como uma dependência em um projeto envolve os passos a seguir:

Identifique o tipo de biblioteca que o aplicativo precisa.
uma biblioteca de código aberto adequada no agist.org , o responsável oficial de pacotes para o Compose.
Escolha o pacote de dependência.
Execute composer requirepara incluir a dependência no arquivo composer.jsone instalar o pacote.
Vamos testar isso com uma aplicação de demonstração.

O objetivo desta aplicação é transformar uma determinação determinada em uma string de URL amigável - um slug . Isso é comumente usado para converter os títulos de página para caminhos de URL (Assim como a parte final da URL para este tutorial).

Vamos começar a criar um diretório para o nosso projeto. Vamos chamá-lo de slugify :

cd ~
mkdir slugify
cd slugify
Embora não seja necessário, você pode executar agora um comando composer init para criar um arquivo composer.json detalhado para seu projeto. Como o único objetivo do nosso projeto é demonstrar como instalar dependências com o Composer, usaremos um arquivo composer.json mais simples que será gerado automaticamente quando exigirmos nosso primeiro pacote.

Agora é hora de procurar no Packagist.org por um pacote que pode nos ajudar a gerar slugs. Se você procurar pelo termo “slug” no Packagist, receberá um resultado parecido com este:

Resultados da Pesquisa do Packagist para o termo "slug"

Você verá dois números no lado direito de cada pacote na lista. O número no topo representa quantas vezes o pacote foi instalado através do Composer, e o número em baixo mostra quantas vezes um pacote foi estrelado no GitHub. De um modo geral, os pacotes com mais instalações e mais estrelas tendem a ser mais estáveis, pois mais pessoas os utilizam. Também é importante verificar a descrição do pacote para relevância para garantir que ele é o que você precisa.

Precisamos de um conversor string-to-slug A partir dos resultados da pesquisa, o pacote cocur/slugify, que aparece como o primeiro resultado naquela página, parece ser um bom candidato, com uma quantidade razoável de instalações e estrelas.

Os pacotes no Packagist têm um nome de vendor e um nome de package. Cada pacote tem um identificador único (um namespace) no mesmo formato que o GitHub utiliza para seus repositórios: vendor/package. A biblioteca que queremos instalar utiliza o namespace cocur/slugify. Você precisa de um namespace do pacote para exigi-lo em seu projeto.

Agora que você sabe exatamente qual pacote deseja instalar, você pode executar o composer require para incluí-lo como uma dependência e gerar também o arquivo composer.json para seu projeto. Uma coisa importante é observar a exigência de pacotes. O Composer rastreia as dependências no nível da aplicação e do sistema. As dependências no nível do sistema são importantes para indicar de quais módulos PHP um pacote depende. No caso do pacote cocur/slugify, ele exige um módulo PHP que ainda não instalamos.

Quando um pacote necessário depende de uma biblioteca de sistema que não está atualmente instalada em seu servidor, você receberá um erro informando qual requisito está faltando:

composer require cocur/slugify
Output
Using version ^4.0 for cocur/slugify
./composer.json has been updated
Loading composer repositories with package information
Updating dependencies (including require-dev)
Your requirements could not be resolved to an installable set of packages.

  Problem 1
    - Installation request for cocur/slugify ^4.0 -> satisfiable by cocur/slugify[v4.0.0].
    - cocur/slugify v4.0.0 requires ext-mbstring * -> the requested PHP extension mbstring is missing from your system.
...
Para resolver o problema de dependência do sistema, podemos procurar pelo pacote que falta usando o apt search:

apt search mbstring
Output
Sorting... Done
Full Text Search... Done
php-mbstring/focal 2:7.4+75 all
  MBSTRING module for PHP [default]

php-patchwork-utf8/focal 1.3.1-1 all
  UTF-8 strings handling for PHP

php7.4-mbstring/focal 7.4.3-4ubuntu1 amd64
  MBSTRING module for PHP
Após localizar o nome do pacote correto, você pode utilizar o apt novamente para instalar a dependência de sistema:

sudo apt install php-mbstring
Assim que a instalação terminar, você pode executar novamente o comando composer require:

composer require cocur/slugify
Output
Using version ^4.0 for cocur/slugify
./composer.json has been created
Loading composer repositories with package information
Updating dependencies (including require-dev)
Package operations: 1 install, 0 updates, 0 removals
  - Installing cocur/slugify (v4.0.0): Downloading (100%)         
Writing lock file
Generating autoload files
Como você pode ver na saída, o Composer decidiu automaticamente qual versão do pacote utilizar. Se você verificar o diretório do seu projeto agora, ele irá conter dois arquivos novos: composer.json e composer.lock, e um diretório vendor:

ls -l
Output
total 12
-rw-rw-r-- 1 sammy sammy   59 May  4 13:56 composer.json
-rw-rw-r-- 1 sammy sammy 3229 May  4 13:56 composer.lock
drwxrwxr-x 4 sammy sammy 4096 May  4 13:56 vendor
O arquivo composer.lock é usado para armazenar informações sobre quais versões de cada pacote estão instaladas, e garantir que as mesmas versões sejam usadas se outra pessoa clonar seu projeto e instalar suas dependências. O diretório vendor é onde as dependências do projeto estão localizadas. Você não deve fazer commit da pasta vendor no controle de versão - você precisa apenas incluir os arquivos composer.json e composer.lock.

Ao instalar um projeto que já contém um arquivo composer.json, execute o composer install para baixar as dependências do projeto.

Vamos dar uma olhada rápida em restrições de versão. Se você verificar o conteúdo do seu arquivo composer.json, verá algo parecido com isto:

cat composer.json
Output
{
    "require": {
        "cocur/slugify": "^4.0"
    }
}
Note que há o caractere especial ^ antes do número da versão no composer.json. O Composer suporta várias restrições diferentes e formatos para definir a versão necessária do pacote, para fornecer flexibilidade enquanto também mantém seu projeto estável. O operador circunflexo (^) utilizado pelo arquivo composer.json criado automaticamente é o operador recomendado para a interoperabilidade máxima, seguindo o versionamento semântico. Neste caso, ele define 4.0 como a versão mínima compatível e permite atualizações para qualquer versão futura abaixo de 5.0.

De um modo geral, você não precisará alterar as restrições de versão em seu arquivo composer.json. No entanto, algumas situações podem exigir que você edite manualmente as restrições – por exemplo, quando uma nova versão principal da sua biblioteca requerida é liberada e você deseja atualizar, ou quando a biblioteca que você deseja usar não segue o versionamento semântico.

Aqui estão alguns exemplos para lhe dar um melhor entendimento sobre como as restrições de versão do Composer funcionam:

Restrição	Significado	Exemplo de Versões Permitidas
^1.0	>= 1.0 < 2.0	1.0, 1.2.3, 1.9.9
^1.1.0	>= 1.1.0 < 2.0	1.1.0, 1.5.6, 1.9.9
~1.0	>= 1.0 < 2.0.0	1.0, 1.4.1, 1.9.9
~1.0.0	>= 1.0.0 < 1.1	1.0.0, 1.0.4, 1.0.9
1.2.1	1.2.1	1.2.1
1.*	>= 1.0 < 2.0	1.0.0, 1.4.5, 1.9.9
1.2. *	>= 1.2 < 1.3	1.2.0, 1.2.3, 1.2.9
Para uma visualização mais detalhada das restrições de versão do Composer, consulte a documentação oficial.

A seguir, vamos ver como carregar dependências automaticamente com o Composer.

Passo 4 — Incluindo o Script Autoload
Como o PHP por si só não carrega classes automaticamente, o Composer fornece um script autoload que você pode incluir em seu projeto para obter o carregamento automático para ele. Este arquivo é gerado automaticamente pelo Composer quando você adiciona sua primeira dependência.

A única coisa que você precisa fazer é incluir o arquivo vendor/autoload.php em seus scripts PHP antes de qualquer instância de classe.

Vamos testar isso em nossa aplicação de demonstração. Abra um novo arquivo chamado test.php em seu editor de texto:

nano test.php
Adicione o código a seguir que vem no arquivo vendor/autoload.php, carrega a dependência cocur/slugify, e o utiliza para criar um slug:

test.php
<?php
require __DIR__ . '/vendor/autoload.php';

use Cocur\Slugify\Slugify;

$slugify = new Slugify();

echo $slugify->slugify('Hello World, this is a long sentence and I need to make a slug from it!');
Salve o arquivo e saia do seu editor.

Agora, execute o script.

php test.php
Isso produz a saída hello-world-this-is-a-long-sentence-and-i-need-to-make-a-slug-from-it.

As dependências precisam de atualizações quando novas versões são liberadas. Dessa forma, vamos ver como lidar com isso.

Passo 5 — Atualizando as Dependências do Projeto
Sempre que você quiser atualizar suas dependências do projeto para versões mais recentes, execute o comando update:

composer update
Isso irá verificar por versões mais recentes das bibliotecas que você requer em seu projeto. Se uma versão mais recente for encontrada e ela for compatível com a restrição de versão definida no arquivo composer.json, o Composer substituirá a versão anterior instalada. O arquivo composer.lock será atualizado para refletir essas alterações.

Você também pode atualizar uma ou mais bibliotecas específicas, especificando-as desta forma:

composer update vendor/package vendor2/package2
Certifique-se de verificar em seus arquivos composer.json e composer.lock dentro do seu sistema de controle de versão após atualizar suas dependências de modo que outros também possam instalar essas versões mais recentes.








INÍCIO:

1 instalar o docker

2 abrir wsl2/Windows ou linux
 curl -s "https://laravel.build/olw?with=mysql,redis,mailhog,minio" | bash

3 cd olw
./vendor/bin/sail up -d
	ou
4 cd olw && ./vendor/bin/sail up -d

5 ATRIBUINDO PERMISSÃO PARA A PASTA
cd .. -> sai da pasta
sudo chmod 777 olw/ -R ou sem o 'sudo' chmod 777 olw/ -R

6 CRIANDO ALIAS PARA O COMANDO ANTERIOR
alias sail='[ -f sail ] && sh sail || sh vendor/bin/sail'
passa a usar assim: sail ps

7 CONFIGURAR PORTAS PARA A APLICAÇÃO NO NAVEGADOR E MYSQL
.env
APP_PORT=8000

*porta do myql
FORWARD_DB_PORT=3307

8 INSTALANDO DEPENDÊNCIA AO PROJETO
./vendor/bin/sail composer require laravel/breeze --dev

9 DEIXAR TELA DE AUTENTICAÇÃO PRONTA, ROTA AUTENTICADA, TAWINDCSS INSTALADO E INERTIA INSTALADO
./vendor/bin/sail artisan breeze:install vue 
ou
./vendor/bin/sail art breeze:install vue


10 RODAR AS MIGRATES PADRÕES DO PROJETO AI JÁ PODE CADASTRAR USUÁRIOS PARA LOGIN:
./vendor/bin/sail art migrate

11 


/*******************************************/
2a AULA:

O PROJETO CONSISTE EM RECEBER DADOS DE UMA API (punkapi.com) DE INFORMAÇÕES SOBRE CERVEJAS, VAMOS CONSTRUIR AS ROTAS PARA CONSUMIR A API E CRIAR A ESTRUTURA PARA O RELATÓRIO QUE IREMOS GERAR EM EXCEL E ENVIAR PARA O STORAGE...
1 CRIAR ROTAS:
code .
olw/routes/web.php


sail up -d -> SOBE O CONTAINER localhost:8000 (nesse projeto)

Route::get('/beers', fn()=> 'Olw - testando a rota /beers');

**************************************************
obs:
- laravel.com/api -> acesso a documentação do código;
- in line paramets for vscode -> extensão para vscode para exibir o nome dos métodos na hora que codificar;
- fira code -> extensão para fonte no vscode

git Hub Copilot vs Tabnine -> (pesquisar sobre)
Link para extensões vscode:
https://github.com/icarojobs/vscode-useful-extensions
*************************************************


Route::get('/beers', fn()=> 'Olw - testando a rota /beers')
                             ->middleware(['auth']);

* FLUXO PADRÃO DO MVC-LARAVEL: 
life cicle: sai do usuário pelo navegador, insomnia ou postman -> passa pelo index.php(pasta public) -> passa pelos arquivos do bootstrap retornando uma instância da aplicação -> passa pelo kernel do http (carrega mais instâncias) -> Service provider -> despacha a requisição pro Router -> Cai no arquivo Web.php -> Middleware (se tiver, geralmente tem os globais) -> Controller (faz as regras de negócio e pode chamar outras classes como Serviços por exemplo)
-> Retorna uma view ou um json (No caso estamos usando inértia, ele não vai reinderizar a 'view.blade' padrão, ele vai reinderizar componente vue.js através do inértia.).


* EM VEZ DE USAR A FUNÇÃO AQUI NA ROTA CRIAMOS UM CONTROLLER:

obs.: ​dica: php artisan make:controller -r cria o Resource também.
dica: limpar o cache do container:
./vendor/bin/sail art config:cache
./vendor/bin/sail art optimize:clear


sail artisan make:controller BeerController
ou 
sail art make:controller BeerController -> CRIA O ARQUIVO BeerController.php na pasta app/Http/Controllers
->
<?php

namespace App\Http\Controllers;

use Illuminate\Http\Request;

class BeerController extends Controller
{
    public function index()
    {
    return 'Virgu & Beer & Code'
    }
}

* NO ARQUIVO DE ROTAS Web.php CHAMA O BeersController:

importante importar o Controller <nomeDoController>+<CTRL=ENTER:
use App\Http\Controllers\BeerController;

Route::get('/beers', [BeerController::class, 'index'])
                        ->middleware(['auth']);


* PRECISAMOS CRIAR UM MÉTODO PARA PEGAR A LISTA, LISTAR OS DADOS DA API (listar as bebidas de https://api.punkapi.com/v2 ->
VAMOS CRIAR UMA NOVA CLASSE de serviços em app/Sevices/PunkapiService.php

* O LARAVEL POSSUI UM RECURSO CHAMADO HTTPClient que abstrai o uso de uma ferramenta chama guzeo, esse guzeo é o client http mais comum para php, com ele fazemos requisições pra diversos serviços web dentro do php para outras url, ele é robusto, então o laravel simplifica importando o recurso que faz tudo por 'detrás dos panos':

PunkapiService.php

<?php

namespace App\Services;

use Illuminate\Support\Facades\Http;

class PunkapiService
{
    public function getBeers()
    {
        return Http::get('https://api.punkapi.com/v2/beers');
    }
}

E NO BeerController.php fica:
<?php

namespace App\Http\Controllers;

use App\Services\PunkapiService;
use Illuminate\Http\Request;

class BeerController extends Controller
{
    public function index()
    {
    //return 'Virgu & Beer & Code';
    $service = new PunkapiService;

    return $service->getBeers();
    }
}

* TRATE É CARACTERÍSTICA QUE A CLASSE ADQUIRE (pode ter mesmos métodos e atributos substituindo o recurso de um classe extender várias classes que não tem no php, a trate é uma forma de fazer isso. O service  é uma outra camada na maioria das vezes abstrair seviços que vc vai consumir, por exemplo API.

Estando logado, os dados da api já serão exibidos em localhost:8000/beers, se usar um aplicativo cliente tipo insomnia pode apresentar os dados também, melhor comentar a linha de de autenticação da rota:
Route::get('/beers', [BeerController::class, 'index']);
linha de autenticação da rota // ->middleware(['auth']);

* ESSA API PERMITE FAZER FILTROS VIA PARÂMETROS NA PRÓPRIA ROTA. PRIMEIRO VAMOS REFATORAR O CÓDIO, A CLASSE PunkapiService.php:

USO DE CONFIG E MACRO


Vamos alterar a url, primeiro acessando a pasta config da raiz do projeto e criar o arquivo punkapi.php. O que acontece é que o config(pasta config da raiz) carrega todos os arquivos da pasta e permite que sejam acessados via funções simples(HELPERS), isso é muito legal porque podemos acessar esses arquivos de configurações de qualquer lugar do projeto: 

<?php

return [
    'url' => env('PUNK_BASE_URL', 'https://api.punkapi.com/v2')
];

Usando o helper env significa dizer que, se não houver a constante PUNK_BASE_URL setada no arquivo .env do projeto, seu valor será o segundo parâmetro: http://api.punkapi.com/v2 e no arquivo PunkapiService.php da pasta app/Services fica:

<?php

namespace App\Services;

use Illuminate\Support\Facades\Http;

class PunkapiService
{
    public function getBeers()
    {
        return Http::get('/beers');
    }
}

MACRO é uma forma de criar funções customizadas:
 em app\Providers vamos acessar o arquivo AppServiceProvider.php que é uma classe que tem dois métodos register e boot. No método boot vamos chamar o método Http do laravel e chamar o método macro, no primeiro parâmetro será um nome atribuído à função e e o segundo uma clausure (uma função).
Neste arquivo é passado o arquivo de configuração da url (em 'config/punkapi.php') além de tokens, headers,...
 

use Illuminate\Support\Facades\Http; -> deve ser importado
E a função boot fica:

  public function boot()
    {
        Http::macro('punkapi', function(){
            return Http::acceptJson()
            ->baseUrl(config('punkapi.url'));
        });
    }

Então criamos uma macro(uma função customizada) chamada punkapi que já retorna o client com accept/Json no Header e com o baseUrl configurado lá do arquivo /config/punkapi.php e se estiver setado no .env pegará de lá.

/app/Services/PunkapiService.php fica:

<?php

namespace App\Services;

use Illuminate\Support\Facades\Http;

class PunkapiService
{
    public function getBeers()
    {
        return Http::punkapi()->get('/beers');
    }
}

*obs.: a baseUrl poderia ser setada no construtor, que pode setar token também.(uma outra abordagem para versão sem macros);

->Testamos o retorno Json em localhost:8000/beers.

Refatorando o arquivo PunkapiService.php: O client Http não lança exceção e podemos forçar o retorno em modo Json:
<?php

namespace App\Services;

use Illuminate\Support\Facades\Http;

class PunkapiService
{
    public function getBeers()
    {
       // return Http::punkapi()->get('/beers');
       return Http::punkapi()
            ->get('/beers')
            ->throw()  // Exceção em caso de erro
            ->json();   // Força o retorno em formato Json
    }
}

Podemos testar forçando um erro alterando a constante PUNKAPI_BASE_URL criada em /config/punkapi.php, vamos atribuir um valor diferente no arquivo .env:

PUNKAPI_BASE_URL="adfjklj878"

Podemos usar a função retry tem dois parâmetros, o número de tentativas pra buscar a requisição e o intervalo entre elas. Refatorando o código fica:
<?php

namespace App\Services;

use Illuminate\Support\Facades\Http;

class PunkapiService
{
    public function getBeers()
    {
       // return Http::punkapi()->get('/beers');
       return Http::punkapi()
            ->get('/beers')
            ->throw()  // Exceção em caso de erro
            ->json();   // Força o retorno em formato Json
    }
}

- Quando sai a exceção nao deveriamos retornar o erro em json por ser um api neste caso estamos usamos um app web e não uma api. E usaríamos o Route Api.

Refatorando o método boot de /app/Providers/AppServiceProvider.php, inserindo o retry():

     */
    public function boot()
    {
        Http::macro('punkapi', function(){
            return Http::acceptJson()
            ->baseUrl(config('punkapi.url'))
            ->retry(3,100);
        });
    }
}

comando de help

* ./vendor/bin/sail composer dump-autoload
* Verificar Nome do arquivo se bate com o nome das rotas(Classes criadas e importar o nome errado);
* inteliphense

Refatorando BeerController.php
<?php

namespace App\Http\Controllers;

use App\Services\PunkapiService;

class BeerController extends Controller
{
    public function index()
    {

    $service = new PunkapiService();

    return $service->getBeers();
    }
}

Em vez de instanciar o método PunkapiService() dentro de index, vamos passar por parâmetro de index() declarando seu Próprio nome (PunkapiService) como tipo. Fica assim:

<?php

namespace App\Http\Controllers;

use App\Services\PunkapiService;

class BeerController extends Controller
{
    public function index(PunkapiService $service)
    {
    return $service->getBeers();
    }
}

Assim usamos feactures do php(injeção de dependências) e ao mesmo tempo feactures do laravel. Em vez de criar uma instância dentro do método index, vamos injetar a classe como parâmetro para o método index(), ficando index($service) e a instância de dentro da função passa como parâmetro de 'tipo da variável'. Isso quebra a cadeia de dependência entre as classes.
Assim, o método index ganha independência não mais dependendo da instância de new PunkapiService e passamos a olhar a função index em si.
Assim, o Laravel tenta fazer um binding, um match, o laravel tenta encontrar alguma classe PunkapiService e cria uma instância dessa classe e usa ali como parâmetro. Se não fizer assim, lá em Rotas teria que ser passado como parâmetro o que fica desnecessário.
Não poderia ser feito se na classe PunkapiService existisse o construtor para atribuir valores automaticamente à classe. Assim podemos usar porque não precisamos passar nenhum valor.

ADICIONAR OS FILTROS:
Vamos filtrar o retorno api com os seguintes itens: beer_name, food, ibu_gt, malte:

var_dump($v)
die();
dd($variável)
benchmarck -> ?

/*****REFATORA PARA TESTE alterando BeerController.php e PunkapiService.php
BeerController.php
<?php

namespace App\Http\Controllers;

use App\Services\PunkapiService;

class BeerController extends Controller
{
    public function index(PunkapiService $service)
    {
    return $service->getBeers(
        'heineken',
        'cheese',
        'corn',
        45
    );
    }
}

PunkapiService.php
<?php

namespace App\Services;

use Illuminate\Support\Facades\Http;

class PunkapiService
{
    public function getBeers(
        string $beer_name,
        string $food,
        string $malt,
        string $ibu_gt
    )
    {
        $params = get_defined_vars();

        dd($params);

        return Http::punkapi()
            ->get('/beers', $params)
            ->throw()  // Exceção em caso de erro
            ->json();   // Força o retorno em formato Json
    }
}

Resultado do debug no insomnia ou no navegador:
array:4 [▼ // app/Services/PunkapiService.php:18
  "beer_name" => "heineken"
  "food" => "cheese"
  "malt" => "corn"
  "ibu_gt" => "45"
]
//* fim teste

Refatorando:

class PunkapiService
{
    public function getBeers(
        string $beer_name = null,
        string $food = null,
        string $malt = null,
        string $ibu_gt = null
    )
    {
        $params = get_defined_vars();

        dd($params);

        return Http::punkapi()
            ->get('/beers', $params)
            ->throw()  // Exceção em caso de erro
            ->json();   // Força o retorno em formato Json
    }
}

Assim quando não passar o valor para a chave ele exibirá a chave e o valor Null, vamos refatorar para não exibir nem a chave englobando get_defined_vers() com array_filter no arquivo PunkapiService.php:

$params = array_filter(get_defined_vars());

<?php

namespace App\Http\Controllers;

use App\Services\PunkapiService;

class BeerController extends Controller
{
    public function index(PunkapiService $service)
    {
    return $service->getBeers(
        'heineken',
        'cheese',
        'corn',
       // 45 -> Esse não é passado
    );
    }
}


array:3 [▼ // app/Services/PunkapiService.php:18
  "beer_name" => "heineken"
  "food" => "cheese"
  "malt" => "corn"
	Aqui não exibiu o valor 45
]


USANDO A FUNÇÃO NAMED_ARGS passamos só os parâmetros que precisamos retornar da api e o php com essa função saberá qual a posição dela no array de argumentos passados como parâmetro sem a necessidade de seguir a mesma sequência dos argumentos:
class BeerController extends Controller
{
    public function index(PunkapiService $service)
    {
    return $service->getBeers(food: 'cheese');
    }
}

REFATORANDO:
BeerController.php
<?php

namespace App\Http\Controllers;

use App\Services\PunkapiService;
use Illuminate\Http\Request;

class BeerController extends Controller
{
    public function index( Request $request, PunkapiService $service)
    {
    return $service->getBeers(...$request->all());
    }
}

PunkapiService.php
<?php

namespace App\Services;

use Illuminate\Support\Facades\Http;

class PunkapiService
{
    public function getBeers(
        string $beer_name = null,
        string $food = null,
        string $malt = null,
        string $ibu_gt = null
    )
    {
        $params = array_filter(get_defined_vars());

     //   dd($params);

        return Http::punkapi()
            ->get('/beers', $params)
            ->throw()  // Exceção em caso de erro
            ->json();   // Força o retorno em formato Json
    }
}

CRIANDO UMA REQUEST
sail artisan make:request BeerRequest
/app/Http/Requests/BeerRequest.php

* Funções anônimas, também conhecidas como closures , permitem a criação de funções que não tem o nome especificado. Elas são mais úteis como o valor de parâmetros callable, mas podem ter vários outros usos.. É uma função passada como parâmetro

CRIANDO NOVA ROTA PARA SALVAR COMO EXCEL
* https://docs.laravel-excel.com/3.1/getting-started/installation.html

Route::group([
    'prefix' => 'beers',
], function() {

    Route::get('/', [BeerController::class, 'index']); //-> Se houver necessidade de salvar dados por essa rota mudamos o método(verbo html) para post(os dados não serão expostos na url).
                          //  ->middleware(['auth']);
    Route::get('/export', [BeerController::class, 'export']);

});

Então passamos a ter duas rotas: localhost:8000/beers
localhost:8000/beers/export

No BeerController incluimos o método export():
class BeerController extends Controller
{
    public function index( BeerRequest $request, PunkapiService $service)
    {
    // return $service->getBeers(...$request->all());
    return $service->getBeers(...$request->validated());
    }

    public function export()
    {
        return 'Relatório criado.';
    }
}



INSTALANDO PACOTE LARAVEL-EXCEL PARA GERAR OS RELATÓRIO EM EXCEL FILTRADOS DA API:

* https://docs.laravel-excel.com/3.1/getting-started/installation.html

COMANDO PARA INSTALAR VIA COMPOSER:
./vendor/bin/sail composer require psr/simple-cache:^2.0 maatwebsite/excel

CRIAR A CLASSE DO EXCEL
./vendor/bin/sail artisan make:export BeerExport  --> Cria o arquivo em  /app/Exports/BeerExport.php

<?php

namespace App\Exports;

use Maatwebsite\Excel\Concerns\FromCollection;

class BeerExport implements FromCollection
{


    /**
    * @return \I¢lluminate\Support\Collection
    */
    public function collection()
    {
        //
    }
}

-> Dentro de colletion buscaremos as informações que serão salvas no arquivo do excel, um array de dados;

criamos um __construct() que vai ter uma propriedade privada do tipo array chamamos de $reportData.

O retorn será uma collection como informa o comentário:
 /**
    * @return \I¢lluminate\Support\Collection
    */

Na função colletion(), está recebendo um array return $this->reportData; 
Observe que não precisa mais declarar uma propriedade que vai se setada via construct(), basta defifinir o escopo junto do argumento e o php faz isso pra você. Como o retorno da função é um array usamos o helper collect para o $this->reportData:

BeerExport.php

<?php

namespace App\Exports;

use Maatwebsite\Excel\Concerns\FromCollection;

class BeerExport implements FromCollection
{

    public function __construct(
        private array $reportData
    ){}

    /**
    * @return \Illuminate\Support\Collection
    */
    public function collection()
    {
       return collect($this->reportData);
    }
}
 

Consultamos a documentação do Laravel-excel em 'Exporting collections':
em Excel Store passa o nome da classe e o nome do arquivo:

BeerController.php
<?php

namespace App\Http\Controllers;


use App\Exports\BeerExport;
use App\Http\Requests\BeerRequest;
use App\Services\PunkapiService;
use Maatwebsite\Excel\Facades\Excel;


class BeerController extends Controller
{
    public function index( BeerRequest $request, PunkapiService $service)
    {
    // return $service->getBeers(...$request->all());
    return $service->getBeers(...$request->validated());
    }

    public function export()
    {
      $params = [
        ['name' => 'Tom', 'age' => '30'],
        ['name' => 'Virgu', 'age' => '27']
       ];

       Excel::store(new BeerExport($params), 'olw-report.xlsx');
       return "Relatório criado";

    }


}

********************************************
* REFATORANDO E SALVANDO O ARQUIVO EXCEL EM /storage/app

BeerExport.php
<?php

namespace App\Exports;

use Maatwebsite\Excel\Concerns\FromCollection;

class BeerExport implements FromCollection
{

    public function __construct(
        private array $reportData
    ){}

    /**
    * @return \Illuminate\Support\Collection
    */
    public function collection()
    {
       return collect($this->reportData);
    }
}
*****************************

BeerController.php

<?php

namespace App\Http\Controllers;


use App\Exports\BeerExport;
use App\Http\Requests\BeerRequest;
use App\Services\PunkapiService;
use Maatwebsite\Excel\Facades\Excel;


class BeerController extends Controller
{
    public function index( BeerRequest $request, PunkapiService $service)
    {
        return $service->getBeers(...$request->all());

    }

    public function export(BeerRequest $request, PunkapiService $service)
    {
        $beers = $service->getBeers(...$request->validated());

        $filteredBeers = collect($beers)->map(function($value, $key){
        return collect($value)
                ->only(['name', 'tagline', 'first_brewed', 'description'])
                ->toArray();
    })->toArray();

    //dd($filteredBeers);

      $params = [
        ['name' => 'Tom', 'age' => '30'],
        ['name' => 'Virgu', 'age' => '27']
       ];

       Excel::store(new BeerExport($filteredBeers), 'olw-report.xlsx');

           return "Relatório criado";

    }


}

PARA SALVAR O ARQUIVO EXCEL EM UM STORAGE S3:
ALTERA BeerController.php

<?php

namespace App\Http\Controllers;


use App\Exports\BeerExport;
use App\Http\Requests\BeerRequest;
use App\Services\PunkapiService;
use Maatwebsite\Excel\Facades\Excel;


class BeerController extends Controller
{
    public function index( BeerRequest $request, PunkapiService $service)
    {
        return $service->getBeers(...$request->all());

    }

    public function export(BeerRequest $request, PunkapiService $service)
    {
        $beers = $service->getBeers(...$request->validated());

        $filteredBeers = collect($beers)->map(function($value, $key){
        return collect($value)
                ->only(['name', 'tagline', 'first_brewed', 'description'])
                ->toArray();
    })->toArray();


       Excel::store(
            new BeerExport($filteredBeers),
             'olw-report.xlsx',
             's3');

           return "Relatório criado";

    }


}

************
O REPOSITÓRIO DE ARQUIVOS minio:
NO DOCKER COMPOSER TEMOS O minio, um S3 que tem
MINIO_ROOT_USER: 'sail'
MINIO_ROOT_PASSWORD: 'password' e roda na porta 9000
localhost:9000
usuário: sail
senha: password

vamos criar um buncket(uma pasta)

e configurar o .env da raiz da aplicação:
originalmente é assim:
AWS_ACCESS_KEY_ID=
AWS_SECRET_ACCESS_KEY=
AWS_DEFAULT_REGION=us-east-1
AWS_BUCKET=
AWS_USE_PATH_STYLE_ENDPOINT=false

 e acrescentamos as informações para:


AWS_ACCESS_KEY_ID=sail
AWS_SECRET_ACCESS_KEY=password
AWS_DEFAULT_REGION=us-east-1
AWS_BUCKET=local
AWS_ENDPOINT=http://minio:9000
AWS_URL=http://minio:9000/local
AWS_USE_PATH_STYLE_ENDPOINT=true

altera tambem:

FILESYSTEM_DISK=local 
para:
FILESYSTEM_DISK=s3

INSTALAR UMA DEPENDÊNCIA (ADAPTER) PARA FAZER CORRESPONDÊNCIA COM A AWS:

Flysystem 3.x em laravel.com/docs/9.x/upgrade
./vendor/bin/sail composer require -W league/flysystem-aws-s3-v3 "^3.0"

em caso de erro:
 artisan vendor:publish --tag=laravel-assets --ansi --force

.env
APP_NAME=Laravel
APP_ENV=local
APP_KEY=base64:UbVvTP6Cu+LF5GamJdB4dsZZvW05ep4bZqcCEhmiDCg=
APP_DEBUG=true
APP_URL=http://localhost
APP_PORT=8000

# PUNKAPI_BASE_URL="httpadfjkljdsdfdfasf878"

LOG_CHANNEL=stack
LOG_DEPRECATIONS_CHANNEL=null
LOG_LEVEL=debug

DB_CONNECTION=mysql
FORWARD_DB_PORT=3307
DB_HOST=mysql
DB_PORT=3306
DB_DATABASE=olw
DB_USERNAME=sail
DB_PASSWORD=password

BROADCAST_DRIVER=log
CACHE_DRIVER=file
FILESYSTEM_DISK=s3
QUEUE_CONNECTION=sync
SESSION_DRIVER=file
SESSION_LIFETIME=120

MEMCACHED_HOST=memcached

REDIS_HOST=redis
REDIS_PASSWORD=null
REDIS_PORT=6379

MAIL_MAILER=smtp
MAIL_HOST=mailhog
MAIL_PORT=1025
MAIL_USERNAME=null
MAIL_PASSWORD=null
MAIL_ENCRYPTION=null
MAIL_FROM_ADDRESS="hello@example.com"
MAIL_FROM_NAME="${APP_NAME}"

AWS_ACCESS_KEY_ID=sail
AWS_SECRET_ACCESS_KEY=password
AWS_DEFAULT_REGION=us-east-1
AWS_BUCKET=local
AWS_ENDPOINT=http://minio:9000
AWS_URL=http://minio:9000/local
AWS_USE_PATH_STYLE_ENDPOINT=true

PUSHER_APP_ID=
PUSHER_APP_KEY=
PUSHER_APP_SECRET=
PUSHER_HOST=
PUSHER_PORT=443
PUSHER_SCHEME=https
PUSHER_APP_CLUSTER=mt1

VITE_PUSHER_APP_KEY="${PUSHER_APP_KEY}"
VITE_PUSHER_HOST="${PUSHER_HOST}"
VITE_PUSHER_PORT="${PUSHER_PORT}"
VITE_PUSHER_SCHEME="${PUSHER_SCHEME}"
VITE_PUSHER_APP_CLUSTER="${PUSHER_APP_CLUSTER}"

PRONTO. ENVIANDO PARA O MINIO.


### /**** ABAIXO AULA DE FRONT END -> FALTA
virgu 3a. aula seed model factory

olw# sail art make:migration create_history_table
/olw# sail art make:model Export -mr

/olw# sail art migrate:fresh --seed ->


























 







/***********************************************************
QUINTA FEIRA: 20/10/22

Open Laravel Week | Deploy com Terraform, EC2 e RDS | Fermentação

****
https://portal.aws.amazon.com/billing/signup?nc2=h_ct&src=header_signup&redirect_url=https%3A%2F%2Faws.amazon.com%2Fregistration-confirmation&language=pt_br#/start/email

Com terraform pode mudar de infra e configurar no git.

PROGRMAR A CONFIGURAÇÃO DO SERVIDOR: É basicamente construir uma nova aplicação para fazer isso, mais fácil de entender.
Terraform serve para (linguagem HCL -> linguagem própria - linguagem descritiva, descreve o resultado e não como irá ser feito), ou seja, descrever o que queremos.
Terraspace é o framework pra terraform.
Quando criamos o Terraform, ele pode variar conforme a infra cloud (aws, azure, google cloud). sua estrutura é a mesma para todos. mas cada provider tem a sua forma de usar, não consegue usar o mesmo código para mais de uma cloud.
Vamos rodar Terraform via container:

1. clonar do git: git clone 
Criar uma pasta para a infraestrutura

sail   (script que vamos usar)
#!/usr/bin/env bash

docker run -rm -it
	-u $(id -u):$(id -g) \
	-v $PWD:/workspace \
	-w /workspace
	hashicorp/terraform:light "%@"


	<no terminal

Logar em: aws.amazon.com
busca: iam
iam dashboard -> mysecurity credencials (root user) -> Acces keys ->clicar em create access keys -> salva o access key e secret access key
e coloca no arquivo credencials na maquina local.. .aws/credencials
















































//////////////////////////////////////////////////////////////////////////////////////////////////////
CONTEÚDO QUE FALTA ORGANIZAR:



/**************************************/

sail share

sail artisan sail:publish ->coloca em uma pasta na raiz chamada docker

sail --help

sail artisan optimizer:clear

sail ps

sail build --no-cache -> faz o bild da aplicação. (dá um sail down  por precaução antes.)










/*********************************

root@DELLAGS:~# curl -s "https://laravel.build/laravel-9-course?with=mysql,redis,mailhog" | bash

Dockerfile

root@DELLAGS:~/example-app# docker exec -it example-app-mysql-1 bash


FROM wyveo/nginx-php-fpm:latest
WORKDIR /usr/share/nginx
RUN rm -rf /usr/share/nginx/html
COPY . /usr/share/nginx
RUN chmod -R 755 /usr/share/nginx/storage/*
RUN ln -s public html

.env (do composer)

DB_CONNECTION=mysql
DB_HOST=mysql-app (serviço do mysql no docker-compose.yaml)
DB_PORT=3306
DB_DATABASE=laraveldockerdb
DB_USERNAME=root
DB_PASSWORD=123456



docker-compose.yaml

version: '3'

services:
  laraveldocker-app:
    build: .
    ports:
      - "3003:80"
    volumes:
      - ./:/usr/share/nginx
      - .docker/nginx:/etc/nginx/conf.d/
    networks:
      - app-network
  mysql-app:
    image: mysql:5.7.22
    ports:
      - "3306:3306"
    volumes:
      - .docker/dbdata:/var/lib/mysql
    environment:
      MYSQL_DATABASE: laraveldocker
      MYSQL_ROOT_PASSWORD: 123456
    networks:
      - app-network
networks:
  app-network:
    driver: bridge
    



/*************************************************
#criando um serviço com um nome qualquer
version: '3'

services:
  laravel-app:                    #criando um serviço com um nome qualquer
    build: . ou image: wyveo/nginx-php-fpm:latest -> neste caso sem Dockerfile.                    # endereço da imagem ou local do Dockerfile (neste caso o ponto siginifica a raiz do projeto)
    ports:
      - "8080:80"                 # 8080 porta do meu host: 80 é a porta do docker nginx
    volumes:                      # docker-compose up -d -> sobe a imagem e libera o terminal  
      - ./:/usr/share/nginx       # TUDO QUE ESTIVE NA RAIZ (na rais tem o meu projeto laravel) './' IRÁ SER REFLETIDO NA PASTA /usr/share/nginx (pasta de acesso da página html)
                                  # C:\Laravel-docker\laravel-docker>docker compose up -d --build atualiza a minha imagem

  mysql-app:
      image: mysql:5.7
      ports:
        - "3306:3306"
      volumes:
        - .docker/dbdata:/var/lib/mysql          # qualqer nome (para persistir -guardar os dados do banco de dados)


      environment:
        MYSQL_DATABASE: laravel
        MYSQL_ROOT_PASSWORD: laravel
    
      

      /***************************///


  
C:\Laravel-docker\laravel-docker>docker compose up -d --build

                                
                               

    

/******************************** Dockerfile
FROM wyveo/nginx-php-fpm:latest

/***************************///
  COMANDOS

docker compose down -> para todos os containers
C:\Laravel-docker\laravel-docker>docker exec -it laravel-docker-laravel-app-1 bash 
root@612ea0ea3340:/# cd /usr/share/nginx/
root@612ea0ea3340:/usr/share/nginx# php artisan migrate
root@612ea0ea3340:/usr/share/nginx# php artisan serve

		
/***********/
PS C:\Users\alber> docker run -e MYSQL_ROOT_PASSWORD=root --name meu-mysql -d mysql:5.7

docker inspect meu-mysql ou | grep IPAddress

PS C:\Users\alber> docker run -e MYSQL_ROOT_PASSWORD=root --name meu-mysql -d -p 3306:3306 mysql:5.7

docker ps
docker ps -l
docker ps -a
docker rm -f nome


/*** LARAVEL */
### CRIANDO UM PROJETO NO LARAVEL 
laravel new projeto_laravel_via_installer (ESTA É UM AOPÇÃO)
composer create-project --prefer-dist laravel/laravel app_controle_tarefas "8.5.9"
cd app_controle_tarefas
cd public
php -S localhost:8000

ou 
da raiz do projeto:
php artisan serve 
ou
php artisan serve --port=3000

### PARA ABRIR PORTA EM OUTRO SERVIDOR
php artisan serve --host test.com --port 8080

 **********************************************************************
cd app_controle_tarefas
cd public
php artisan serve
- acessa o navegador http://localhost:8000

### DENTRO DO PROJETO CRIADO INSTALAR O LARAVEL/UI:^3.2 - versão 3.2
composer require laravel/ui:^3.2

### SE OCORRER ERRO AUMENTAR A MEMÓRIA DISPONIVEL PARA O php

-php --ini -> localiza o arquivo de configuração do php
LOCALIZA memory_limit = 1000 e altera para 
         memory_limit  = -1 e Salva

### LISTA A RELAÇÃO DE COMANDOS 
php artisan list 

DEVERA SURGIR AS OPÇÕES ABAIXO:

 ui
  ui:auth               Scaffold basic login and registration views and routes
  ui:controllers        Scaffold the authentication controllers
 vendor

### ENTENDENDO O PACOTE UI E INICIANDO A AUTENTICAÇÃO WEB NATIVA DO LARAVEL

COMANDO PARA LISTAR ROUTES: 
php artisan route:list

### php artisan ui bootstrap --auth (bootstrap ou react ou vue)
aplicando o bootstrap incluindo os recursos de autenticação;
poderia ser aplicado o bootstrap sem os recursos de autenticação;

### php artisan route:list -> mostra as rotas - ver que aumentaram as rotas

### APÓS ESSE PROCESSO O SISTEMA PEDE PARA RODAR
npm install -> instala as dependências do package.json (inclusive o bootstrap)
npm run dev -> gera os assets da aplicação de acordo com a tecnologia selecionada (bootstrap, react ou vue) -> Geralmente roda mais de uma vez para compilar tudo.

### CRIA O BANCO DE DADOS NORMALMENTE

### EXECUTA AS MIGRATIONS PADRÕES CRIADAS PARA O SISTEMA DE login
php artisan migrate -> CRIA AS TABELAS NO BANCO DE DADOS


************************************** 
INSTALANDO O COMPOSER NO UBUNTU
**************************************
sudo apt update
sudo apt install php-cli unzip

cd ~

curl -sS https://getcomposer.org/installer -o composer-setup.php

HASH=`curl -sS https://composer.github.io/installer.sig`

echo $HASH ->saída: Output
e0012edf3e80b6978849f5eff0d4b4e4c79ff1609dd1e613307e16318854d24ae64f26d17af3ef0bf7cfb710ca74



php -r "if (hash_file('SHA384', 'composer-setup.php') === '$HASH') { echo 'Installer verified'; } else { echo 'Installer corrupt'; unlink('composer-setup.php'); } echo PHP_EOL;"

sudo php composer-setup.php --install-dir=/usr/local/bin --filename=composer





***********************

DigitalOcean Kubernetes: novo plano de controle é mais rápido e gratuito, habilita HA para SLA de 99,95% de tempo de atividade
Produtos
Preços

Documentos
divisa suspensa

Entrar
divisa suspensa

// Tutorial //
Como Instalar e Utilizar o Composer no Ubuntu 20.04
Publicado em 21 de maio de 2020
Ubuntu
PHP
Ubuntu 20.04
Avatar padrão
Por Erika Heidi
Advogado Desenvolvedor
Português
Como Instalar e Utilizar o Composer no Ubuntu 20.04
Introdução
O Composer é uma ferramenta popular de gerenciamento de dependências para o PHP, criado para facilitar a instalação e a atualização das dependências principalmente do projeto. Ele controla quais outros pacotes de projeto específico dependem e são instalados para você, usando as opções apropriadas de acordo com os requisitos do projeto. O Composer também é comumente utilizado para inicializar novos projetos em frameworks PHP populares, como o Symfon e o Laravel .

Neste tutorial, você instalará e começará a usar o Composer em um sistema Ubuntu 20.04.

Pré-requisitos
Para seguir este guia, você pode acessar um servidor como usuário Ubuntu20.04 como usuário sudonão-root um firewall habilitado em seu servidor Para configurar isto, siga nosso guia Configuração do servidor inicial para o Ubuntu 20.04

Passo 1 — Instalando o PHP e as Dependências Adicionais
Além das dependências que já devem estar incluídas em seu sistema Ubuntu 20.04, como o , o Composer exige ou gitexecuta scripts PHP na linha de comando e para extrair arquivos zipados. Vamos instalar essas dependências agora.curlphp-cliunzip

primeiro, atual, gerenciador de pacotes de soluções: o cache do gerenciador de pacotes

sudo apt update
Em seguida, o seguinte comando para instalar os pacotes, execute:

sudo apt install php-cli unzip
Você será solicitado a confirmar a instalação digitando Ye, depois, ENTER.

Assim que os pré-requisitos para instalação do Composer forem instalados, você poderá seguir.

Passo 2 — Baixando e Instalando o Compositor
O Composer fornece um instalador de script escrito em PHP. Vamos baixá-lo, verificar se ele não está danificado e, em seguida, o usaremos para instalar o Composer.

Certifique-se de estar em sua pasta home. Em seguida, baixe o instalador usando o curl:

cd ~
curl -sS https://getcomposer.org/installer -o composer-setup.php
Em seguida, vamos verificar se o instalador baixado corresponde ao hash SHA-384 para o instalador mais recente encontrado na página Composer Public Keys / Signatures . Para facilitar o passo de seleção, você pode usar o seguinte comando para obter programaticamente o hash mais recente da página do Composer e armazená-lo em uma variável do shell:

HASH=`curl -sS https://composer.github.io/installer.sig`
Se você quiser verificar o valor realizado, execute:

echo $HASH
Output
e0012edf3e80b6978849f5eff0d4b4e4c79ff1609dd1e613307e16318854d24ae64f26d17af3ef0bf7cfb710ca74755a
Agora o código PHP a seguir, execute conforme a página de download do Composer, para verificar se o script de instalação está seguro para ser executado:

php -r "if (hash_file('SHA384', 'composer-setup.php') === '$HASH') { echo 'Installer verified'; } else { echo 'Installer corrupt'; unlink('composer-setup.php'); } echo PHP_EOL;"
Você verá o seguinte resultado:

Resultado
Installer verified
Se Installer corruptvocê estiver usando o hash correto, verifique se você está usando o hash correto. Em seguida, repita o processo de verificação. Quando você tiver um instalador selecionado, você pode continuar.

Para instalar o composerglobalmente, use o seguinte comando que baixará e instalará o Composer como um comando disponível em todo o sistema chamado composer, sob /usr/local/bin:

sudo php composer-setup.php --install-dir=/usr/local/bin --filename=composer
Você verá um resultado semelhante com este:

Output
All settings correct for using Composer
Downloading...

Composer (version 1.10.5) successfully installed to: /usr/local/bin/composer
Use it: php /usr/local/bin/composer
Para testar sua instalação, execute:

composer
Output
   ______
  / ____/___  ____ ___  ____  ____  ________  _____
 / /   / __ \/ __ `__ \/ __ \/ __ \/ ___/ _ \/ ___/
/ /___/ /_/ / / / / / / /_/ / /_/ (__  )  __/ /
\____/\____/_/ /_/ /_/ .___/\____/____/\___/_/
                    /_/
Composer version 1.10.5 2020-04-10 11:44:22

Usage:
  command [options] [arguments]

Options:
  -h, --help                     Display this help message
  -q, --quiet                    Do not output any message
  -V, --version                  Display this application version
      --ansi                     Force ANSI output
      --no-ansi                  Disable ANSI output
  -n, --no-interaction           Do not ask any interactive question
      --profile                  Display timing and memory usage information
      --no-plugins               Whether to disable plugins.
  -d, --working-dir=WORKING-DIR  If specified, use the given directory as working directory.
      --no-cache                 Prevent use of the cache
  -v|vv|vvv, --verbose           Increase the verbosity of messages: 1 for normal output, 2 for more verbose output and 3 for debug
...
Isso verifica que o Composer foi instalado com sucesso em seu sistema e está disponível em todo o sistema.

Nota: se você preferirá ter-lhe-ão separados separados do Composer para projeto hospedado neste servidor, você pode instalar localmente, em uma base por projeto. Este método também é útil quando o usuário do sistema não possui permissão para instalar o software disponível em todo o sistema.

Para fazer isso, use o comando php composer-setup.php. Isso irá gerar um arquivo composer.pharem seu diretório atual, que pode ser executado com o seu atual php composer.phar.

Agora podemos dar uma dependência em como usar o Compose como gerenciar.

Passo 3 — Usando o Compositor em um Projeto PHP
Os projetos PHP geralmente dependentes de bibliotecas externas, e o gerenciamento de dependências e suas versões podem ser complicados. O Composer resolve esse problema de manter um controle de projeto de extensões e dependências, também facilita o processo de descoberta, instalação e atualização de pacotes que são definidos por enquanto.

Para usar o seu projeto, você pode compor um arquivo composer.json. O arquivo composer.jsonComposer quais dependências precisa para baixar seu projeto quais serão as versões de cada pacote tem permissão para instalações e instalações. Isso é muito importante para manter seu projeto consistente e evitar a instalação de versões instáveis ​​que podem causar problemas de compatibilidade retroativa.

Você não precisa criar este arquivo manualmente - é comum ocorrer erros de sintaxe quando fizer isso. O Composer oferece uma maneira de criar um novo arquivo composer.jsoncom base na entrada do usuário, o que é uma boa escolha se você planeja compartilhar seu projeto mais tarde como um pacote público no Packagist . O Composer gera automaticamente um arquivo básico composer.jsonquando você executa um comando composer requirepara incluir uma dependência em um projeto recém-criado.

O processo de uso do Composer para instalar um pacote como uma dependência em um projeto envolve os passos a seguir:

Identifique o tipo de biblioteca que o aplicativo precisa.
uma biblioteca de código aberto adequada no agist.org , o responsável oficial de pacotes para o Compose.
Escolha o pacote de dependência.
Execute composer requirepara incluir a dependência no arquivo composer.jsone instalar o pacote.
Vamos testar isso com uma aplicação de demonstração.

O objetivo desta aplicação é transformar uma determinação determinada em uma string de URL amigável - um slug . Isso é comumente usado para converter os títulos de página para caminhos de URL (Assim como a parte final da URL para este tutorial).

Vamos começar a criar um diretório para o nosso projeto. Vamos chamá-lo de slugify :

cd ~
mkdir slugify
cd slugify
Embora não seja necessário, você pode executar agora um comando composer init para criar um arquivo composer.json detalhado para seu projeto. Como o único objetivo do nosso projeto é demonstrar como instalar dependências com o Composer, usaremos um arquivo composer.json mais simples que será gerado automaticamente quando exigirmos nosso primeiro pacote.

Agora é hora de procurar no Packagist.org por um pacote que pode nos ajudar a gerar slugs. Se você procurar pelo termo “slug” no Packagist, receberá um resultado parecido com este:

Resultados da Pesquisa do Packagist para o termo "slug"

Você verá dois números no lado direito de cada pacote na lista. O número no topo representa quantas vezes o pacote foi instalado através do Composer, e o número em baixo mostra quantas vezes um pacote foi estrelado no GitHub. De um modo geral, os pacotes com mais instalações e mais estrelas tendem a ser mais estáveis, pois mais pessoas os utilizam. Também é importante verificar a descrição do pacote para relevância para garantir que ele é o que você precisa.

Precisamos de um conversor string-to-slug A partir dos resultados da pesquisa, o pacote cocur/slugify, que aparece como o primeiro resultado naquela página, parece ser um bom candidato, com uma quantidade razoável de instalações e estrelas.

Os pacotes no Packagist têm um nome de vendor e um nome de package. Cada pacote tem um identificador único (um namespace) no mesmo formato que o GitHub utiliza para seus repositórios: vendor/package. A biblioteca que queremos instalar utiliza o namespace cocur/slugify. Você precisa de um namespace do pacote para exigi-lo em seu projeto.

Agora que você sabe exatamente qual pacote deseja instalar, você pode executar o composer require para incluí-lo como uma dependência e gerar também o arquivo composer.json para seu projeto. Uma coisa importante é observar a exigência de pacotes. O Composer rastreia as dependências no nível da aplicação e do sistema. As dependências no nível do sistema são importantes para indicar de quais módulos PHP um pacote depende. No caso do pacote cocur/slugify, ele exige um módulo PHP que ainda não instalamos.

Quando um pacote necessário depende de uma biblioteca de sistema que não está atualmente instalada em seu servidor, você receberá um erro informando qual requisito está faltando:

composer require cocur/slugify
Output
Using version ^4.0 for cocur/slugify
./composer.json has been updated
Loading composer repositories with package information
Updating dependencies (including require-dev)
Your requirements could not be resolved to an installable set of packages.

  Problem 1
    - Installation request for cocur/slugify ^4.0 -> satisfiable by cocur/slugify[v4.0.0].
    - cocur/slugify v4.0.0 requires ext-mbstring * -> the requested PHP extension mbstring is missing from your system.
...
Para resolver o problema de dependência do sistema, podemos procurar pelo pacote que falta usando o apt search:

apt search mbstring
Output
Sorting... Done
Full Text Search... Done
php-mbstring/focal 2:7.4+75 all
  MBSTRING module for PHP [default]

php-patchwork-utf8/focal 1.3.1-1 all
  UTF-8 strings handling for PHP

php7.4-mbstring/focal 7.4.3-4ubuntu1 amd64
  MBSTRING module for PHP
Após localizar o nome do pacote correto, você pode utilizar o apt novamente para instalar a dependência de sistema:

sudo apt install php-mbstring
Assim que a instalação terminar, você pode executar novamente o comando composer require:

composer require cocur/slugify
Output
Using version ^4.0 for cocur/slugify
./composer.json has been created
Loading composer repositories with package information
Updating dependencies (including require-dev)
Package operations: 1 install, 0 updates, 0 removals
  - Installing cocur/slugify (v4.0.0): Downloading (100%)         
Writing lock file
Generating autoload files
Como você pode ver na saída, o Composer decidiu automaticamente qual versão do pacote utilizar. Se você verificar o diretório do seu projeto agora, ele irá conter dois arquivos novos: composer.json e composer.lock, e um diretório vendor:

ls -l
Output
total 12
-rw-rw-r-- 1 sammy sammy   59 May  4 13:56 composer.json
-rw-rw-r-- 1 sammy sammy 3229 May  4 13:56 composer.lock
drwxrwxr-x 4 sammy sammy 4096 May  4 13:56 vendor
O arquivo composer.lock é usado para armazenar informações sobre quais versões de cada pacote estão instaladas, e garantir que as mesmas versões sejam usadas se outra pessoa clonar seu projeto e instalar suas dependências. O diretório vendor é onde as dependências do projeto estão localizadas. Você não deve fazer commit da pasta vendor no controle de versão - você precisa apenas incluir os arquivos composer.json e composer.lock.

Ao instalar um projeto que já contém um arquivo composer.json, execute o composer install para baixar as dependências do projeto.

Vamos dar uma olhada rápida em restrições de versão. Se você verificar o conteúdo do seu arquivo composer.json, verá algo parecido com isto:

cat composer.json
Output
{
    "require": {
        "cocur/slugify": "^4.0"
    }
}
Note que há o caractere especial ^ antes do número da versão no composer.json. O Composer suporta várias restrições diferentes e formatos para definir a versão necessária do pacote, para fornecer flexibilidade enquanto também mantém seu projeto estável. O operador circunflexo (^) utilizado pelo arquivo composer.json criado automaticamente é o operador recomendado para a interoperabilidade máxima, seguindo o versionamento semântico. Neste caso, ele define 4.0 como a versão mínima compatível e permite atualizações para qualquer versão futura abaixo de 5.0.

De um modo geral, você não precisará alterar as restrições de versão em seu arquivo composer.json. No entanto, algumas situações podem exigir que você edite manualmente as restrições – por exemplo, quando uma nova versão principal da sua biblioteca requerida é liberada e você deseja atualizar, ou quando a biblioteca que você deseja usar não segue o versionamento semântico.

Aqui estão alguns exemplos para lhe dar um melhor entendimento sobre como as restrições de versão do Composer funcionam:

Restrição	Significado	Exemplo de Versões Permitidas
^1.0	>= 1.0 < 2.0	1.0, 1.2.3, 1.9.9
^1.1.0	>= 1.1.0 < 2.0	1.1.0, 1.5.6, 1.9.9
~1.0	>= 1.0 < 2.0.0	1.0, 1.4.1, 1.9.9
~1.0.0	>= 1.0.0 < 1.1	1.0.0, 1.0.4, 1.0.9
1.2.1	1.2.1	1.2.1
1.*	>= 1.0 < 2.0	1.0.0, 1.4.5, 1.9.9
1.2. *	>= 1.2 < 1.3	1.2.0, 1.2.3, 1.2.9
Para uma visualização mais detalhada das restrições de versão do Composer, consulte a documentação oficial.

A seguir, vamos ver como carregar dependências automaticamente com o Composer.

Passo 4 — Incluindo o Script Autoload
Como o PHP por si só não carrega classes automaticamente, o Composer fornece um script autoload que você pode incluir em seu projeto para obter o carregamento automático para ele. Este arquivo é gerado automaticamente pelo Composer quando você adiciona sua primeira dependência.

A única coisa que você precisa fazer é incluir o arquivo vendor/autoload.php em seus scripts PHP antes de qualquer instância de classe.

Vamos testar isso em nossa aplicação de demonstração. Abra um novo arquivo chamado test.php em seu editor de texto:

nano test.php
Adicione o código a seguir que vem no arquivo vendor/autoload.php, carrega a dependência cocur/slugify, e o utiliza para criar um slug:

test.php
<?php
require __DIR__ . '/vendor/autoload.php';

use Cocur\Slugify\Slugify;

$slugify = new Slugify();

echo $slugify->slugify('Hello World, this is a long sentence and I need to make a slug from it!');
Salve o arquivo e saia do seu editor.

Agora, execute o script.

php test.php
Isso produz a saída hello-world-this-is-a-long-sentence-and-i-need-to-make-a-slug-from-it.

As dependências precisam de atualizações quando novas versões são liberadas. Dessa forma, vamos ver como lidar com isso.

Passo 5 — Atualizando as Dependências do Projeto
Sempre que você quiser atualizar suas dependências do projeto para versões mais recentes, execute o comando update:

composer update
Isso irá verificar por versões mais recentes das bibliotecas que você requer em seu projeto. Se uma versão mais recente for encontrada e ela for compatível com a restrição de versão definida no arquivo composer.json, o Composer substituirá a versão anterior instalada. O arquivo composer.lock será atualizado para refletir essas alterações.

Você também pode atualizar uma ou mais bibliotecas específicas, especificando-as desta forma:

composer update vendor/package vendor2/package2
Certifique-se de verificar em seus arquivos composer.json e composer.lock dentro do seu sistema de controle de versão após atualizar suas dependências de modo que outros também possam instalar essas versões mais recentes.

Conclusão





***********
Algoritmo "CalculoMedia2"
// Disciplina: Lógica de programação
// Professor : Antonio Carlos Nicolodi
// Descrição : calculo da média aritimética
// Autor     : Professor Antonio
// Data atual: 01/04/2015
var
// Seção de Declarações
   v1, v2, total: Real
   sinal : Caracter
Inicio
// Seção dos Comandos
   Escreva ("Digite o primeiro valor: ")
   Leia (v1)
   Escreva ("Digite a operação + - * / : ")
   Leia (sinal)
   Escreva ("Digite o segundo valor: ")
   Leia (v2)

   Se sinal = "+" entao
   total <- v1 + v2
   Escreva("O Resultado é: ", total)
   Senao
   Se sinal = "-" entao
   total <- v1 - v2
   Escreva("O Resultado é: ", total)
   Senao
   Se sinal = "*" entao
   total <- v1 * v2
   Escreva("O Resultado é: ", total)


   Senao
     Escreva("OPERAÇÃO INVÁLIDA! ")



      Escreval("total")
   fimse
Fimalgoritmo

****
COMANDOS DOCKER
root@DELLAGS:~# curl -s "https://laravel.build/laravel-9-course?with=mysql,redis,mailhog" | bash

root@DELLAGS:~/example-app# ./vendor/bin/sail  artisan migrate --seed -> criar o banco de dados e copular dados;

Dockerfile

root@DELLAGS:~/example-app# docker exec -it example-app-mysql-1 bash


FROM wyveo/nginx-php-fpm:latest
WORKDIR /usr/share/nginx
RUN rm -rf /usr/share/nginx/html
COPY . /usr/share/nginx
RUN chmod -R 755 /usr/share/nginx/storage/*
RUN ln -s public html

.env (do composer)

DB_CONNECTION=mysql
DB_HOST=mysql-app (serviço do mysql no docker-compose.yaml)
DB_PORT=3306
DB_DATABASE=laraveldockerdb
DB_USERNAME=root
DB_PASSWORD=123456



docker-compose.yaml

version: '3'

services:
  laraveldocker-app:
    build: .
    ports:
      - "3003:80"
    volumes:
      - ./:/usr/share/nginx
      - .docker/nginx:/etc/nginx/conf.d/
    networks:
      - app-network
  mysql-app:
    image: mysql:5.7.22
    ports:
      - "3306:3306"
    volumes:
      - .docker/dbdata:/var/lib/mysql
    environment:
      MYSQL_DATABASE: laraveldocker
      MYSQL_ROOT_PASSWORD: 123456
    networks:
      - app-network
networks:
  app-network:
    driver: bridge
    



/*************************************************
#criando um serviço com um nome qualquer
version: '3'

services:
  laravel-app:                    #criando um serviço com um nome qualquer
    build: . ou image: wyveo/nginx-php-fpm:latest -> neste caso sem Dockerfile.                    # endereço da imagem ou local do Dockerfile (neste caso o ponto siginifica a raiz do projeto)
    ports:
      - "8080:80"                 # 8080 porta do meu host: 80 é a porta do docker nginx
    volumes:                      # docker-compose up -d -> sobe a imagem e libera o terminal  
      - ./:/usr/share/nginx       # TUDO QUE ESTIVE NA RAIZ (na rais tem o meu projeto laravel) './' IRÁ SER REFLETIDO NA PASTA /usr/share/nginx (pasta de acesso da página html)
                                  # C:\Laravel-docker\laravel-docker>docker compose up -d --build atualiza a minha imagem

  mysql-app:
      image: mysql:5.7
      ports:
        - "3306:3306"
      volumes:
        - .docker/dbdata:/var/lib/mysql          # qualqer nome (para persistir -guardar os dados do banco de dados)


      environment:
        MYSQL_DATABASE: laravel
        MYSQL_ROOT_PASSWORD: laravel
    
      

      /***************************///


  
C:\Laravel-docker\laravel-docker>docker compose up -d --build

                                
                               

    

/******************************** Dockerfile
FROM wyveo/nginx-php-fpm:latest

/***************************///
  COMANDOS

docker compose down -> para todos os containers
C:\Laravel-docker\laravel-docker>docker exec -it laravel-docker-laravel-app-1 bash 
root@612ea0ea3340:/# cd /usr/share/nginx/
root@612ea0ea3340:/usr/share/nginx# php artisan migrate
root@612ea0ea3340:/usr/share/nginx# php artisan serve

		
/***********/
PS C:\Users\alber> docker run -e MYSQL_ROOT_PASSWORD=root --name meu-mysql -d mysql:5.7

docker inspect meu-mysql ou | grep IPAddress

PS C:\Users\alber> docker run -e MYSQL_ROOT_PASSWORD=root --name meu-mysql -d -p 3306:3306 mysql:5.7

docker ps
docker ps -l
docker ps -a
docker rm -f nome


/*** LARAVEL */
### CRIANDO UM PROJETO NO LARAVEL 
laravel new projeto_laravel_via_installer (ESTA É UM AOPÇÃO)
composer create-project --prefer-dist laravel/laravel app_controle_tarefas "8.5.9"
cd app_controle_tarefas
cd public
php -S localhost:8000

ou 
da raiz do projeto:
php artisan serve 
ou
php artisan serve --port=3000

### PARA ABRIR PORTA EM OUTRO SERVIDOR
php artisan serve --host test.com --port 8080

 **********************************************************************
cd app_controle_tarefas
cd public
php artisan serve
- acessa o navegador http://localhost:8000

### DENTRO DO PROJETO CRIADO INSTALAR O LARAVEL/UI:^3.2 - versão 3.2
composer require laravel/ui:^3.2

### SE OCORRER ERRO AUMENTAR A MEMÓRIA DISPONIVEL PARA O php

-php --ini -> localiza o arquivo de configuração do php
LOCALIZA memory_limit = 1000 e altera para 
         memory_limit  = -1 e Salva

### LISTA A RELAÇÃO DE COMANDOS 
php artisan list 

DEVERA SURGIR AS OPÇÕES ABAIXO:

 ui
  ui:auth               Scaffold basic login and registration views and routes
  ui:controllers        Scaffold the authentication controllers
 vendor

### ENTENDENDO O PACOTE UI E INICIANDO A AUTENTICAÇÃO WEB NATIVA DO LARAVEL

COMANDO PARA LISTAR ROUTES: 
php artisan route:list

### php artisan ui bootstrap --auth (bootstrap ou react ou vue)
aplicando o bootstrap incluindo os recursos de autenticação;
poderia ser aplicado o bootstrap sem os recursos de autenticação;

### php artisan route:list -> mostra as rotas - ver que aumentaram as rotas

### APÓS ESSE PROCESSO O SISTEMA PEDE PARA RODAR
npm install -> instala as dependências do package.json (inclusive o bootstrap)
npm run dev -> gera os assets da aplicação de acordo com a tecnologia selecionada (bootstrap, react ou vue) -> Geralmente roda mais de uma vez para compilar tudo.

### CRIA O BANCO DE DADOS NORMALMENTE

### EXECUTA AS MIGRATIONS PADRÕES CRIADAS PARA O SISTEMA DE login
php artisan migrate -> CRIA AS TABELAS NO BANCO DE DADOS


************************************** 
INSTALANDO O COMPOSER NO UBUNTU
**************************************
sudo apt update
sudo apt install php-cli unzip

cd ~

curl -sS https://getcomposer.org/installer -o composer-setup.php

HASH=`curl -sS https://composer.github.io/installer.sig`

echo $HASH ->saída: Output
e0012edf3e80b6978849f5eff0d4b4e4c79ff1609dd1e613307e16318854d24ae64f26d17af3ef0bf7cfb710ca74



php -r "if (hash_file('SHA384', 'composer-setup.php') === '$HASH') { echo 'Installer verified'; } else { echo 'Installer corrupt'; unlink('composer-setup.php'); } echo PHP_EOL;"

sudo php composer-setup.php --install-dir=/usr/local/bin --filename=composer





***********************

DigitalOcean Kubernetes: novo plano de controle é mais rápido e gratuito, habilita HA para SLA de 99,95% de tempo de atividade
Produtos
Preços

Documentos
divisa suspensa

Entrar
divisa suspensa

// Tutorial //
Como Instalar e Utilizar o Composer no Ubuntu 20.04
Publicado em 21 de maio de 2020
Ubuntu
PHP
Ubuntu 20.04
Avatar padrão
Por Erika Heidi
Advogado Desenvolvedor
Português
Como Instalar e Utilizar o Composer no Ubuntu 20.04
Introdução
O Composer é uma ferramenta popular de gerenciamento de dependências para o PHP, criado para facilitar a instalação e a atualização das dependências principalmente do projeto. Ele controla quais outros pacotes de projeto específico dependem e são instalados para você, usando as opções apropriadas de acordo com os requisitos do projeto. O Composer também é comumente utilizado para inicializar novos projetos em frameworks PHP populares, como o Symfon e o Laravel .

Neste tutorial, você instalará e começará a usar o Composer em um sistema Ubuntu 20.04.

Pré-requisitos
Para seguir este guia, você pode acessar um servidor como usuário Ubuntu20.04 como usuário sudonão-root um firewall habilitado em seu servidor Para configurar isto, siga nosso guia Configuração do servidor inicial para o Ubuntu 20.04

Passo 1 — Instalando o PHP e as Dependências Adicionais
Além das dependências que já devem estar incluídas em seu sistema Ubuntu 20.04, como o , o Composer exige ou gitexecuta scripts PHP na linha de comando e para extrair arquivos zipados. Vamos instalar essas dependências agora.curlphp-cliunzip

primeiro, atual, gerenciador de pacotes de soluções: o cache do gerenciador de pacotes

sudo apt update
Em seguida, o seguinte comando para instalar os pacotes, execute:

sudo apt install php-cli unzip
Você será solicitado a confirmar a instalação digitando Ye, depois, ENTER.

Assim que os pré-requisitos para instalação do Composer forem instalados, você poderá seguir.

Passo 2 — Baixando e Instalando o Compositor
O Composer fornece um instalador de script escrito em PHP. Vamos baixá-lo, verificar se ele não está danificado e, em seguida, o usaremos para instalar o Composer.

Certifique-se de estar em sua pasta home. Em seguida, baixe o instalador usando o curl:

cd ~
curl -sS https://getcomposer.org/installer -o composer-setup.php
Em seguida, vamos verificar se o instalador baixado corresponde ao hash SHA-384 para o instalador mais recente encontrado na página Composer Public Keys / Signatures . Para facilitar o passo de seleção, você pode usar o seguinte comando para obter programaticamente o hash mais recente da página do Composer e armazená-lo em uma variável do shell:

HASH=`curl -sS https://composer.github.io/installer.sig`
Se você quiser verificar o valor realizado, execute:

echo $HASH
Output
e0012edf3e80b6978849f5eff0d4b4e4c79ff1609dd1e613307e16318854d24ae64f26d17af3ef0bf7cfb710ca74755a
Agora o código PHP a seguir, execute conforme a página de download do Composer, para verificar se o script de instalação está seguro para ser executado:

php -r "if (hash_file('SHA384', 'composer-setup.php') === '$HASH') { echo 'Installer verified'; } else { echo 'Installer corrupt'; unlink('composer-setup.php'); } echo PHP_EOL;"
Você verá o seguinte resultado:

Resultado
Installer verified
Se Installer corruptvocê estiver usando o hash correto, verifique se você está usando o hash correto. Em seguida, repita o processo de verificação. Quando você tiver um instalador selecionado, você pode continuar.

Para instalar o composerglobalmente, use o seguinte comando que baixará e instalará o Composer como um comando disponível em todo o sistema chamado composer, sob /usr/local/bin:

sudo php composer-setup.php --install-dir=/usr/local/bin --filename=composer
Você verá um resultado semelhante com este:

Output
All settings correct for using Composer
Downloading...

Composer (version 1.10.5) successfully installed to: /usr/local/bin/composer
Use it: php /usr/local/bin/composer
Para testar sua instalação, execute:

composer
Output
   ______
  / ____/___  ____ ___  ____  ____  ________  _____
 / /   / __ \/ __ `__ \/ __ \/ __ \/ ___/ _ \/ ___/
/ /___/ /_/ / / / / / / /_/ / /_/ (__  )  __/ /
\____/\____/_/ /_/ /_/ .___/\____/____/\___/_/
                    /_/
Composer version 1.10.5 2020-04-10 11:44:22

Usage:
  command [options] [arguments]

Options:
  -h, --help                     Display this help message
  -q, --quiet                    Do not output any message
  -V, --version                  Display this application version
      --ansi                     Force ANSI output
      --no-ansi                  Disable ANSI output
  -n, --no-interaction           Do not ask any interactive question
      --profile                  Display timing and memory usage information
      --no-plugins               Whether to disable plugins.
  -d, --working-dir=WORKING-DIR  If specified, use the given directory as working directory.
      --no-cache                 Prevent use of the cache
  -v|vv|vvv, --verbose           Increase the verbosity of messages: 1 for normal output, 2 for more verbose output and 3 for debug
...
Isso verifica que o Composer foi instalado com sucesso em seu sistema e está disponível em todo o sistema.

Nota: se você preferirá ter-lhe-ão separados separados do Composer para projeto hospedado neste servidor, você pode instalar localmente, em uma base por projeto. Este método também é útil quando o usuário do sistema não possui permissão para instalar o software disponível em todo o sistema.

Para fazer isso, use o comando php composer-setup.php. Isso irá gerar um arquivo composer.pharem seu diretório atual, que pode ser executado com o seu atual php composer.phar.

Agora podemos dar uma dependência em como usar o Compose como gerenciar.

Passo 3 — Usando o Compositor em um Projeto PHP
Os projetos PHP geralmente dependentes de bibliotecas externas, e o gerenciamento de dependências e suas versões podem ser complicados. O Composer resolve esse problema de manter um controle de projeto de extensões e dependências, também facilita o processo de descoberta, instalação e atualização de pacotes que são definidos por enquanto.

Para usar o seu projeto, você pode compor um arquivo composer.json. O arquivo composer.jsonComposer quais dependências precisa para baixar seu projeto quais serão as versões de cada pacote tem permissão para instalações e instalações. Isso é muito importante para manter seu projeto consistente e evitar a instalação de versões instáveis ​​que podem causar problemas de compatibilidade retroativa.

Você não precisa criar este arquivo manualmente - é comum ocorrer erros de sintaxe quando fizer isso. O Composer oferece uma maneira de criar um novo arquivo composer.jsoncom base na entrada do usuário, o que é uma boa escolha se você planeja compartilhar seu projeto mais tarde como um pacote público no Packagist . O Composer gera automaticamente um arquivo básico composer.jsonquando você executa um comando composer requirepara incluir uma dependência em um projeto recém-criado.

O processo de uso do Composer para instalar um pacote como uma dependência em um projeto envolve os passos a seguir:

Identifique o tipo de biblioteca que o aplicativo precisa.
uma biblioteca de código aberto adequada no agist.org , o responsável oficial de pacotes para o Compose.
Escolha o pacote de dependência.
Execute composer requirepara incluir a dependência no arquivo composer.jsone instalar o pacote.
Vamos testar isso com uma aplicação de demonstração.

O objetivo desta aplicação é transformar uma determinação determinada em uma string de URL amigável - um slug . Isso é comumente usado para converter os títulos de página para caminhos de URL (Assim como a parte final da URL para este tutorial).

Vamos começar a criar um diretório para o nosso projeto. Vamos chamá-lo de slugify :

cd ~
mkdir slugify
cd slugify
Embora não seja necessário, você pode executar agora um comando composer init para criar um arquivo composer.json detalhado para seu projeto. Como o único objetivo do nosso projeto é demonstrar como instalar dependências com o Composer, usaremos um arquivo composer.json mais simples que será gerado automaticamente quando exigirmos nosso primeiro pacote.

Agora é hora de procurar no Packagist.org por um pacote que pode nos ajudar a gerar slugs. Se você procurar pelo termo “slug” no Packagist, receberá um resultado parecido com este:

Resultados da Pesquisa do Packagist para o termo "slug"

Você verá dois números no lado direito de cada pacote na lista. O número no topo representa quantas vezes o pacote foi instalado através do Composer, e o número em baixo mostra quantas vezes um pacote foi estrelado no GitHub. De um modo geral, os pacotes com mais instalações e mais estrelas tendem a ser mais estáveis, pois mais pessoas os utilizam. Também é importante verificar a descrição do pacote para relevância para garantir que ele é o que você precisa.

Precisamos de um conversor string-to-slug A partir dos resultados da pesquisa, o pacote cocur/slugify, que aparece como o primeiro resultado naquela página, parece ser um bom candidato, com uma quantidade razoável de instalações e estrelas.

Os pacotes no Packagist têm um nome de vendor e um nome de package. Cada pacote tem um identificador único (um namespace) no mesmo formato que o GitHub utiliza para seus repositórios: vendor/package. A biblioteca que queremos instalar utiliza o namespace cocur/slugify. Você precisa de um namespace do pacote para exigi-lo em seu projeto.

Agora que você sabe exatamente qual pacote deseja instalar, você pode executar o composer require para incluí-lo como uma dependência e gerar também o arquivo composer.json para seu projeto. Uma coisa importante é observar a exigência de pacotes. O Composer rastreia as dependências no nível da aplicação e do sistema. As dependências no nível do sistema são importantes para indicar de quais módulos PHP um pacote depende. No caso do pacote cocur/slugify, ele exige um módulo PHP que ainda não instalamos.

Quando um pacote necessário depende de uma biblioteca de sistema que não está atualmente instalada em seu servidor, você receberá um erro informando qual requisito está faltando:

composer require cocur/slugify
Output
Using version ^4.0 for cocur/slugify
./composer.json has been updated
Loading composer repositories with package information
Updating dependencies (including require-dev)
Your requirements could not be resolved to an installable set of packages.

  Problem 1
    - Installation request for cocur/slugify ^4.0 -> satisfiable by cocur/slugify[v4.0.0].
    - cocur/slugify v4.0.0 requires ext-mbstring * -> the requested PHP extension mbstring is missing from your system.
...
Para resolver o problema de dependência do sistema, podemos procurar pelo pacote que falta usando o apt search:

apt search mbstring
Output
Sorting... Done
Full Text Search... Done
php-mbstring/focal 2:7.4+75 all
  MBSTRING module for PHP [default]

php-patchwork-utf8/focal 1.3.1-1 all
  UTF-8 strings handling for PHP

php7.4-mbstring/focal 7.4.3-4ubuntu1 amd64
  MBSTRING module for PHP
Após localizar o nome do pacote correto, você pode utilizar o apt novamente para instalar a dependência de sistema:

sudo apt install php-mbstring
Assim que a instalação terminar, você pode executar novamente o comando composer require:

composer require cocur/slugify
Output
Using version ^4.0 for cocur/slugify
./composer.json has been created
Loading composer repositories with package information
Updating dependencies (including require-dev)
Package operations: 1 install, 0 updates, 0 removals
  - Installing cocur/slugify (v4.0.0): Downloading (100%)         
Writing lock file
Generating autoload files
Como você pode ver na saída, o Composer decidiu automaticamente qual versão do pacote utilizar. Se você verificar o diretório do seu projeto agora, ele irá conter dois arquivos novos: composer.json e composer.lock, e um diretório vendor:

ls -l
Output
total 12
-rw-rw-r-- 1 sammy sammy   59 May  4 13:56 composer.json
-rw-rw-r-- 1 sammy sammy 3229 May  4 13:56 composer.lock
drwxrwxr-x 4 sammy sammy 4096 May  4 13:56 vendor
O arquivo composer.lock é usado para armazenar informações sobre quais versões de cada pacote estão instaladas, e garantir que as mesmas versões sejam usadas se outra pessoa clonar seu projeto e instalar suas dependências. O diretório vendor é onde as dependências do projeto estão localizadas. Você não deve fazer commit da pasta vendor no controle de versão - você precisa apenas incluir os arquivos composer.json e composer.lock.

Ao instalar um projeto que já contém um arquivo composer.json, execute o composer install para baixar as dependências do projeto.

Vamos dar uma olhada rápida em restrições de versão. Se você verificar o conteúdo do seu arquivo composer.json, verá algo parecido com isto:

cat composer.json
Output
{
    "require": {
        "cocur/slugify": "^4.0"
    }
}
Note que há o caractere especial ^ antes do número da versão no composer.json. O Composer suporta várias restrições diferentes e formatos para definir a versão necessária do pacote, para fornecer flexibilidade enquanto também mantém seu projeto estável. O operador circunflexo (^) utilizado pelo arquivo composer.json criado automaticamente é o operador recomendado para a interoperabilidade máxima, seguindo o versionamento semântico. Neste caso, ele define 4.0 como a versão mínima compatível e permite atualizações para qualquer versão futura abaixo de 5.0.

De um modo geral, você não precisará alterar as restrições de versão em seu arquivo composer.json. No entanto, algumas situações podem exigir que você edite manualmente as restrições – por exemplo, quando uma nova versão principal da sua biblioteca requerida é liberada e você deseja atualizar, ou quando a biblioteca que você deseja usar não segue o versionamento semântico.

Aqui estão alguns exemplos para lhe dar um melhor entendimento sobre como as restrições de versão do Composer funcionam:

Restrição	Significado	Exemplo de Versões Permitidas
^1.0	>= 1.0 < 2.0	1.0, 1.2.3, 1.9.9
^1.1.0	>= 1.1.0 < 2.0	1.1.0, 1.5.6, 1.9.9
~1.0	>= 1.0 < 2.0.0	1.0, 1.4.1, 1.9.9
~1.0.0	>= 1.0.0 < 1.1	1.0.0, 1.0.4, 1.0.9
1.2.1	1.2.1	1.2.1
1.*	>= 1.0 < 2.0	1.0.0, 1.4.5, 1.9.9
1.2. *	>= 1.2 < 1.3	1.2.0, 1.2.3, 1.2.9
Para uma visualização mais detalhada das restrições de versão do Composer, consulte a documentação oficial.

A seguir, vamos ver como carregar dependências automaticamente com o Composer.

Passo 4 — Incluindo o Script Autoload
Como o PHP por si só não carrega classes automaticamente, o Composer fornece um script autoload que você pode incluir em seu projeto para obter o carregamento automático para ele. Este arquivo é gerado automaticamente pelo Composer quando você adiciona sua primeira dependência.

A única coisa que você precisa fazer é incluir o arquivo vendor/autoload.php em seus scripts PHP antes de qualquer instância de classe.

Vamos testar isso em nossa aplicação de demonstração. Abra um novo arquivo chamado test.php em seu editor de texto:

nano test.php
Adicione o código a seguir que vem no arquivo vendor/autoload.php, carrega a dependência cocur/slugify, e o utiliza para criar um slug:

test.php
<?php
require __DIR__ . '/vendor/autoload.php';

use Cocur\Slugify\Slugify;

$slugify = new Slugify();

echo $slugify->slugify('Hello World, this is a long sentence and I need to make a slug from it!');
Salve o arquivo e saia do seu editor.

Agora, execute o script.

php test.php
Isso produz a saída hello-world-this-is-a-long-sentence-and-i-need-to-make-a-slug-from-it.

As dependências precisam de atualizações quando novas versões são liberadas. Dessa forma, vamos ver como lidar com isso.

Passo 5 — Atualizando as Dependências do Projeto
Sempre que você quiser atualizar suas dependências do projeto para versões mais recentes, execute o comando update:

composer update
Isso irá verificar por versões mais recentes das bibliotecas que você requer em seu projeto. Se uma versão mais recente for encontrada e ela for compatível com a restrição de versão definida no arquivo composer.json, o Composer substituirá a versão anterior instalada. O arquivo composer.lock será atualizado para refletir essas alterações.

Você também pode atualizar uma ou mais bibliotecas específicas, especificando-as desta forma:

composer update vendor/package vendor2/package2
Certifique-se de verificar em seus arquivos composer.json e composer.lock dentro do seu sistema de controle de versão após atualizar suas dependências de modo que outros também possam instalar essas versões mais recentes.








INÍCIO:

1 instalar o docker

2 abrir wsl2/Windows ou linux
 curl -s "https://laravel.build/olw?with=mysql,redis,mailhog,minio" | bash

3 cd olw
./vendor/bin/sail up -d
	ou
4 cd olw && ./vendor/bin/sail up -d

5 ATRIBUINDO PERMISSÃO PARA A PASTA
cd .. -> sai da pasta
sudo chmod 777 olw/ -R ou sem o 'sudo' chmod 777 olw/ -R

6 CRIANDO ALIAS PARA O COMANDO ANTERIOR
alias sail='[ -f sail ] && sh sail || sh vendor/bin/sail'
passa a usar assim: sail ps

7 CONFIGURAR PORTAS PARA A APLICAÇÃO NO NAVEGADOR E MYSQL
.env
APP_PORT=8000

*porta do myql
FORWARD_DB_PORT=3307

8 INSTALANDO DEPENDÊNCIA AO PROJETO
./vendor/bin/sail composer require laravel/breeze --dev

9 DEIXAR TELA DE AUTENTICAÇÃO PRONTA, ROTA AUTENTICADA, TAWINDCSS INSTALADO E INERTIA INSTALADO
./vendor/bin/sail artisan breeze:install vue 
ou
./vendor/bin/sail art breeze:install vue


10 RODAR AS MIGRATES PADRÕES DO PROJETO AI JÁ PODE CADASTRAR USUÁRIOS PARA LOGIN:
./vendor/bin/sail art migrate

11 


/*******************************************/
2a AULA:

O PROJETO CONSISTE EM RECEBER DADOS DE UMA API (punkapi.com) DE INFORMAÇÕES SOBRE CERVEJAS, VAMOS CONSTRUIR AS ROTAS PARA CONSUMIR A API E CRIAR A ESTRUTURA PARA O RELATÓRIO QUE IREMOS GERAR EM EXCEL E ENVIAR PARA O STORAGE...
1 CRIAR ROTAS:
code .
olw/routes/web.php


sail up -d -> SOBE O CONTAINER localhost:8000 (nesse projeto)

Route::get('/beers', fn()=> 'Olw - testando a rota /beers');

**************************************************
obs:
- laravel.com/api -> acesso a documentação do código;
- Inline Parameters for VSCode-> extensão para vscode para exibir o nome dos métodos na hora que codificar;
- fira code -> extensão para fonte no vscode

git Hub Copilot vs Tabnine -> (pesquisar sobre)
Link para extensões vscode:
https://github.com/icarojobs/vscode-useful-extensions
*************************************************


Route::get('/beers', fn()=> 'Olw - testando a rota /beers')
                             ->middleware(['auth']);

* FLUXO PADRÃO DO MVC-LARAVEL: 
life cicle: sai do usuário pelo navegador, insomnia ou postman -> passa pelo index.php(pasta public) -> passa pelos arquivos do bootstrap retornando uma instância da aplicação -> passa pelo kernel do http (carrega mais instâncias) -> Service provider -> despacha a requisição pro Router -> Cai no arquivo Web.php -> Middleware (se tiver, geralmente tem os globais) -> Controller (faz as regras de negócio e pode chamar outras classes como Serviços por exemplo)
-> Retorna uma view ou um json (No caso estamos usando inértia, ele não vai reinderizar a 'view.blade' padrão, ele vai reinderizar componente vue.js através do inértia.).


* EM VEZ DE USAR A FUNÇÃO AQUI NA ROTA CRIAMOS UM CONTROLLER:

obs.: ​dica: php artisan make:controller -r cria o Resource também.
dica: limpar o cache do container:
./vendor/bin/sail art config:cache
./vendor/bin/sail art optimize:clear


sail artisan make:controller BeerController
ou 
sail art make:controller BeerController -> CRIA O ARQUIVO BeerController.php na pasta app/Http/Controllers
->
<?php

namespace App\Http\Controllers;

use Illuminate\Http\Request;

class BeerController extends Controller
{
    public function index()
    {
    return 'Virgu & Beer & Code'
    }
}

* NO ARQUIVO DE ROTAS Web.php CHAMA O BeersController:

importante importar o Controller <nomeDoController>+<CTRL=ENTER:
use App\Http\Controllers\BeerController;

Route::get('/beers', [BeerController::class, 'index'])
                        ->middleware(['auth']);


* PRECISAMOS CRIAR UM MÉTODO PARA PEGAR A LISTA, LISTAR OS DADOS DA API (listar as bebidas de https://api.punkapi.com/v2 ->
VAMOS CRIAR UMA NOVA CLASSE de serviços em app/Sevices/PunkapiService.php

* O LARAVEL POSSUI UM RECURSO CHAMADO HTTPClient que abstrai o uso de uma ferramenta chama guzeo, esse guzeo é o client http mais comum para php, com ele fazemos requisições pra diversos serviços web dentro do php para outras url, ele é robusto, então o laravel simplifica importando o recurso que faz tudo por 'detrás dos panos':

PunkapiService.php

<?php

namespace App\Services;

use Illuminate\Support\Facades\Http;

class PunkapiService
{
    public function getBeers()
    {
        return Http::get('https://api.punkapi.com/v2/beers');
    }
}

E NO BeerController.php fica:
<?php

namespace App\Http\Controllers;

use App\Services\PunkapiService;
use Illuminate\Http\Request;

class BeerController extends Controller
{
    public function index()
    {
    //return 'Virgu & Beer & Code';
    $service = new PunkapiService;

    return $service->getBeers();
    }
}

* TRATE É CARACTERÍSTICA QUE A CLASSE ADQUIRE (pode ter mesmos métodos e atributos substituindo o recurso de um classe extender várias classes que não tem no php, a trate é uma forma de fazer isso. O service  é uma outra camada na maioria das vezes abstrair seviços que vc vai consumir, por exemplo API.

Estando logado, os dados da api já serão exibidos em localhost:8000/beers, se usar um aplicativo cliente tipo insomnia pode apresentar os dados também, melhor comentar a linha de de autenticação da rota:
Route::get('/beers', [BeerController::class, 'index']);
linha de autenticação da rota // ->middleware(['auth']);

* ESSA API PERMITE FAZER FILTROS VIA PARÂMETROS NA PRÓPRIA ROTA. PRIMEIRO VAMOS REFATORAR O CÓDIO, A CLASSE PunkapiService.php:

USO DE CONFIG E MACRO


Vamos alterar a url, primeiro acessando a pasta config da raiz do projeto e criar o arquivo punkapi.php. O que acontece é que o config(pasta config da raiz) carrega todos os arquivos da pasta e permite que sejam acessados via funções simples(HELPERS), isso é muito legal porque podemos acessar esses arquivos de configurações de qualquer lugar do projeto: 

<?php

return [
    'url' => env('PUNK_BASE_URL', 'https://api.punkapi.com/v2')
];

Usando o helper env significa dizer que, se não houver a constante PUNK_BASE_URL setada no arquivo .env do projeto, seu valor será o segundo parâmetro: http://api.punkapi.com/v2 e no arquivo PunkapiService.php da pasta app/Services fica:

<?php

namespace App\Services;

use Illuminate\Support\Facades\Http;

class PunkapiService
{
    public function getBeers()
    {
        return Http::get('/beers');
    }
}

MACRO é uma forma de criar funções customizadas:
 em app\Providers vamos acessar o arquivo AppServiceProvider.php que é uma classe que tem dois métodos register e boot. No método boot vamos chamar o método Http do laravel e chamar o método macro, no primeiro parâmetro será um nome atribuído à função e e o segundo uma clausure (uma função).
Neste arquivo é passado o arquivo de configuração da url (em 'config/punkapi.php') além de tokens, headers,...
 

use Illuminate\Support\Facades\Http; -> deve ser importado
E a função boot fica:

  public function boot()
    {
        Http::macro('punkapi', function(){
            return Http::acceptJson()
            ->baseUrl(config('punkapi.url'));
        });
    }

Então criamos uma macro(uma função customizada) chamada punkapi que já retorna o client com accept/Json no Header e com o baseUrl configurado lá do arquivo /config/punkapi.php e se estiver setado no .env pegará de lá.

/app/Services/PunkapiService.php fica:

<?php

namespace App\Services;

use Illuminate\Support\Facades\Http;

class PunkapiService
{
    public function getBeers()
    {
        return Http::punkapi()->get('/beers');
    }
}

*obs.: a baseUrl poderia ser setada no construtor, que pode setar token também.(uma outra abordagem para versão sem macros);

->Testamos o retorno Json em localhost:8000/beers.

Refatorando o arquivo PunkapiService.php: O client Http não lança exceção e podemos forçar o retorno em modo Json:
<?php

namespace App\Services;

use Illuminate\Support\Facades\Http;

class PunkapiService
{
    public function getBeers()
    {
       // return Http::punkapi()->get('/beers');
       return Http::punkapi()
            ->get('/beers')
            ->throw()  // Exceção em caso de erro
            ->json();   // Força o retorno em formato Json
    }
}

Podemos testar forçando um erro alterando a constante PUNKAPI_BASE_URL criada em /config/punkapi.php, vamos atribuir um valor diferente no arquivo .env:

PUNKAPI_BASE_URL="adfjklj878"

Podemos usar a função retry tem dois parâmetros, o número de tentativas pra buscar a requisição e o intervalo entre elas. Refatorando o código fica:
<?php

namespace App\Services;

use Illuminate\Support\Facades\Http;

class PunkapiService
{
    public function getBeers()
    {
       // return Http::punkapi()->get('/beers');
       return Http::punkapi()
            ->get('/beers')
            ->throw()  // Exceção em caso de erro
            ->json();   // Força o retorno em formato Json
    }
}

- Quando sai a exceção nao deveriamos retornar o erro em json por ser um api neste caso estamos usamos um app web e não uma api. E usaríamos o Route Api.

Refatorando o método boot de /app/Providers/AppServiceProvider.php, inserindo o retry():

     */
    public function boot()
    {
        Http::macro('punkapi', function(){
            return Http::acceptJson()
            ->baseUrl(config('punkapi.url'))
            ->retry(3,100);
        });
    }
}

comando de help

* ./vendor/bin/sail composer dump-autoload
* Verificar Nome do arquivo se bate com o nome das rotas(Classes criadas e importar o nome errado);
* inteliphense

Refatorando BeerController.php
<?php

namespace App\Http\Controllers;

use App\Services\PunkapiService;

class BeerController extends Controller
{
    public function index()
    {

    $service = new PunkapiService();

    return $service->getBeers();
    }
}

Em vez de instanciar o método PunkapiService() dentro de index, vamos passar por parâmetro de index() declarando seu Próprio nome (PunkapiService) como tipo. Fica assim:

<?php

namespace App\Http\Controllers;

use App\Services\PunkapiService;

class BeerController extends Controller
{
    public function index(PunkapiService $service)
    {
    return $service->getBeers();
    }
}

Assim usamos feactures do php(injeção de dependências) e ao mesmo tempo feactures do laravel. Em vez de criar uma instância dentro do método index, vamos injetar a classe como parâmetro para o método index(), ficando index($service) e a instância de dentro da função passa como parâmetro de 'tipo da variável'. Isso quebra a cadeia de dependência entre as classes.
Assim, o método index ganha independência não mais dependendo da instância de new PunkapiService e passamos a olhar a função index em si.
Assim, o Laravel tenta fazer um binding, um match, o laravel tenta encontrar alguma classe PunkapiService e cria uma instância dessa classe e usa ali como parâmetro. Se não fizer assim, lá em Rotas teria que ser passado como parâmetro o que fica desnecessário.
Não poderia ser feito se na classe PunkapiService existisse o construtor para atribuir valores automaticamente à classe. Assim podemos usar porque não precisamos passar nenhum valor.

ADICIONAR OS FILTROS:
Vamos filtrar o retorno api com os seguintes itens: beer_name, food, ibu_gt, malte:

var_dump($v)
die();
dd($variável)
benchmarck -> ?

/*****REFATORA PARA TESTE alterando BeerController.php e PunkapiService.php
BeerController.php
<?php

namespace App\Http\Controllers;

use App\Services\PunkapiService;

class BeerController extends Controller
{
    public function index(PunkapiService $service)
    {
    return $service->getBeers(
        'heineken',
        'cheese',
        'corn',
        45
    );
    }
}

PunkapiService.php
<?php

namespace App\Services;

use Illuminate\Support\Facades\Http;

class PunkapiService
{
    public function getBeers(
        string $beer_name,
        string $food,
        string $malt,
        string $ibu_gt
    )
    {
        $params = get_defined_vars();

        dd($params);

        return Http::punkapi()
            ->get('/beers', $params)
            ->throw()  // Exceção em caso de erro
            ->json();   // Força o retorno em formato Json
    }
}

Resultado do debug no insomnia ou no navegador:
array:4 [▼ // app/Services/PunkapiService.php:18
  "beer_name" => "heineken"
  "food" => "cheese"
  "malt" => "corn"
  "ibu_gt" => "45"
]
//* fim teste

Refatorando:

class PunkapiService
{
    public function getBeers(
        string $beer_name = null,
        string $food = null,
        string $malt = null,
        string $ibu_gt = null
    )
    {
        $params = get_defined_vars();

        dd($params);

        return Http::punkapi()
            ->get('/beers', $params)
            ->throw()  // Exceção em caso de erro
            ->json();   // Força o retorno em formato Json
    }
}

Assim quando não passar o valor para a chave ele exibirá a chave e o valor Null, vamos refatorar para não exibir nem a chave englobando get_defined_vers() com array_filter no arquivo PunkapiService.php:

$params = array_filter(get_defined_vars());

<?php

namespace App\Http\Controllers;

use App\Services\PunkapiService;

class BeerController extends Controller
{
    public function index(PunkapiService $service)
    {
    return $service->getBeers(
        'heineken',
        'cheese',
        'corn',
       // 45 -> Esse não é passado
    );
    }
}


array:3 [▼ // app/Services/PunkapiService.php:18
  "beer_name" => "heineken"
  "food" => "cheese"
  "malt" => "corn"
	Aqui não exibiu o valor 45
]


USANDO A FUNÇÃO NAMED_ARGS passamos só os parâmetros que precisamos retornar da api e o php com essa função saberá qual a posição dela no array de argumentos passados como parâmetro sem a necessidade de seguir a mesma sequência dos argumentos:
class BeerController extends Controller
{
    public function index(PunkapiService $service)
    {
    return $service->getBeers(food: 'cheese');
    }
}

REFATORANDO:
BeerController.php
<?php

namespace App\Http\Controllers;

use App\Services\PunkapiService;
use Illuminate\Http\Request;

class BeerController extends Controller
{
    public function index( Request $request, PunkapiService $service)
    {
    return $service->getBeers(...$request->all());
    }
}

PunkapiService.php
<?php

namespace App\Services;

use Illuminate\Support\Facades\Http;

class PunkapiService
{
    public function getBeers(
        string $beer_name = null,
        string $food = null,
        string $malt = null,
        string $ibu_gt = null
    )
    {
        $params = array_filter(get_defined_vars());

     //   dd($params);

        return Http::punkapi()
            ->get('/beers', $params)
            ->throw()  // Exceção em caso de erro
            ->json();   // Força o retorno em formato Json
    }
}

CRIANDO UMA REQUEST
sail artisan make:request BeerRequest
/app/Http/Requests/BeerRequest.php

* Funções anônimas, também conhecidas como closures , permitem a criação de funções que não tem o nome especificado. Elas são mais úteis como o valor de parâmetros callable, mas podem ter vários outros usos.. É uma função passada como parâmetro

CRIANDO NOVA ROTA PARA SALVAR COMO EXCEL
* https://docs.laravel-excel.com/3.1/getting-started/installation.html

Route::group([
    'prefix' => 'beers',
], function() {

    Route::get('/', [BeerController::class, 'index']); //-> Se houver necessidade de salvar dados por essa rota mudamos o método(verbo html) para post(os dados não serão expostos na url).
                          //  ->middleware(['auth']);
    Route::get('/export', [BeerController::class, 'export']);

});

Então passamos a ter duas rotas: localhost:8000/beers
localhost:8000/beers/export

No BeerController incluimos o método export():
class BeerController extends Controller
{
    public function index( BeerRequest $request, PunkapiService $service)
    {
    // return $service->getBeers(...$request->all());
    return $service->getBeers(...$request->validated());
    }

    public function export()
    {
        return 'Relatório criado.';
    }
}



INSTALANDO PACOTE LARAVEL-EXCEL PARA GERAR OS RELATÓRIO EM EXCEL FILTRADOS DA API:

* https://docs.laravel-excel.com/3.1/getting-started/installation.html

COMANDO PARA INSTALAR VIA COMPOSER:
./vendor/bin/sail composer require psr/simple-cache:^2.0 maatwebsite/excel

CRIAR A CLASSE DO EXCEL
./vendor/bin/sail artisan make:export BeerExport  --> Cria o arquivo em  /app/Exports/BeerExport.php

<?php

namespace App\Exports;

use Maatwebsite\Excel\Concerns\FromCollection;

class BeerExport implements FromCollection
{


    /**
    * @return \I¢lluminate\Support\Collection
    */
    public function collection()
    {
        //
    }
}

-> Dentro de colletion buscaremos as informações que serão salvas no arquivo do excel, um array de dados;

criamos um __construct() que vai ter uma propriedade privada do tipo array chamamos de $reportData.

O retorn será uma collection como informa o comentário:
 /**
    * @return \I¢lluminate\Support\Collection
    */

Na função colletion(), está recebendo um array return $this->reportData; 
Observe que não precisa mais declarar uma propriedade que vai se setada via construct(), basta defifinir o escopo junto do argumento e o php faz isso pra você. Como o retorno da função é um array usamos o helper collect para o $this->reportData:

BeerExport.php

<?php

namespace App\Exports;

use Maatwebsite\Excel\Concerns\FromCollection;

class BeerExport implements FromCollection
{

    public function __construct(
        private array $reportData
    ){}

    /**
    * @return \Illuminate\Support\Collection
    */
    public function collection()
    {
       return collect($this->reportData);
    }
}
 

Consultamos a documentação do Laravel-excel em 'Exporting collections':
em Excel Store passa o nome da classe e o nome do arquivo:

BeerController.php
<?php

namespace App\Http\Controllers;


use App\Exports\BeerExport;
use App\Http\Requests\BeerRequest;
use App\Services\PunkapiService;
use Maatwebsite\Excel\Facades\Excel;


class BeerController extends Controller
{
    public function index( BeerRequest $request, PunkapiService $service)
    {
    // return $service->getBeers(...$request->all());
    return $service->getBeers(...$request->validated());
    }

    public function export()
    {
      $params = [
        ['name' => 'Tom', 'age' => '30'],
        ['name' => 'Virgu', 'age' => '27']
       ];

       Excel::store(new BeerExport($params), 'olw-report.xlsx');
       return "Relatório criado";

    }


}

********************************************
* REFATORANDO E SALVANDO O ARQUIVO EXCEL EM /storage/app

BeerExport.php
<?php

namespace App\Exports;

use Maatwebsite\Excel\Concerns\FromCollection;

class BeerExport implements FromCollection
{

    public function __construct(
        private array $reportData
    ){}

    /**
    * @return \Illuminate\Support\Collection
    */
    public function collection()
    {
       return collect($this->reportData);
    }
}
*****************************

BeerController.php

<?php

namespace App\Http\Controllers;


use App\Exports\BeerExport;
use App\Http\Requests\BeerRequest;
use App\Services\PunkapiService;
use Maatwebsite\Excel\Facades\Excel;


class BeerController extends Controller
{
    public function index( BeerRequest $request, PunkapiService $service)
    {
        return $service->getBeers(...$request->all());

    }

    public function export(BeerRequest $request, PunkapiService $service)
    {
        $beers = $service->getBeers(...$request->validated());

        $filteredBeers = collect($beers)->map(function($value, $key){
        return collect($value)
                ->only(['name', 'tagline', 'first_brewed', 'description'])
                ->toArray();
    })->toArray();

    //dd($filteredBeers);

      $params = [
        ['name' => 'Tom', 'age' => '30'],
        ['name' => 'Virgu', 'age' => '27']
       ];

       Excel::store(new BeerExport($filteredBeers), 'olw-report.xlsx');

           return "Relatório criado";

    }


}

PARA SALVAR O ARQUIVO EXCEL EM UM STORAGE S3:
ALTERA BeerController.php

<?php

namespace App\Http\Controllers;


use App\Exports\BeerExport;
use App\Http\Requests\BeerRequest;
use App\Services\PunkapiService;
use Maatwebsite\Excel\Facades\Excel;


class BeerController extends Controller
{
    public function index( BeerRequest $request, PunkapiService $service)
    {
        return $service->getBeers(...$request->all());

    }

    public function export(BeerRequest $request, PunkapiService $service)
    {
        $beers = $service->getBeers(...$request->validated());

        $filteredBeers = collect($beers)->map(function($value, $key){
        return collect($value)
                ->only(['name', 'tagline', 'first_brewed', 'description'])
                ->toArray();
    })->toArray();


       Excel::store(
            new BeerExport($filteredBeers),
             'olw-report.xlsx',
             's3');

           return "Relatório criado";

    }


}

************
O REPOSITÓRIO DE ARQUIVOS minio:
NO DOCKER COMPOSER TEMOS O minio, um S3 que tem
MINIO_ROOT_USER: 'sail'
MINIO_ROOT_PASSWORD: 'password' e roda na porta 9000
localhost:9000
usuário: sail
senha: password

vamos criar um buncket(uma pasta)

e configurar o .env da raiz da aplicação:
originalmente é assim:
AWS_ACCESS_KEY_ID=
AWS_SECRET_ACCESS_KEY=
AWS_DEFAULT_REGION=us-east-1
AWS_BUCKET=
AWS_USE_PATH_STYLE_ENDPOINT=false

 e acrescentamos as informações para:


AWS_ACCESS_KEY_ID=sail
AWS_SECRET_ACCESS_KEY=password
AWS_DEFAULT_REGION=us-east-1
AWS_BUCKET=local
AWS_ENDPOINT=http://minio:9000
AWS_URL=http://minio:9000/local
AWS_USE_PATH_STYLE_ENDPOINT=true

altera tambem:

FILESYSTEM_DISK=local 
para:
FILESYSTEM_DISK=s3

INSTALAR UMA DEPENDÊNCIA (ADAPTER) PARA FAZER CORRESPONDÊNCIA COM A AWS:

Flysystem 3.x em laravel.com/docs/9.x/upgrade
./vendor/bin/sail composer require -W league/flysystem-aws-s3-v3 "^3.0"

em caso de erro:
 artisan vendor:publish --tag=laravel-assets --ansi --force

.env
APP_NAME=Laravel
APP_ENV=local
APP_KEY=base64:UbVvTP6Cu+LF5GamJdB4dsZZvW05ep4bZqcCEhmiDCg=
APP_DEBUG=true
APP_URL=http://localhost
APP_PORT=8000

# PUNKAPI_BASE_URL="httpadfjkljdsdfdfasf878"

LOG_CHANNEL=stack
LOG_DEPRECATIONS_CHANNEL=null
LOG_LEVEL=debug

DB_CONNECTION=mysql
FORWARD_DB_PORT=3307
DB_HOST=mysql
DB_PORT=3306
DB_DATABASE=olw
DB_USERNAME=sail
DB_PASSWORD=password

BROADCAST_DRIVER=log
CACHE_DRIVER=file
FILESYSTEM_DISK=s3
QUEUE_CONNECTION=sync
SESSION_DRIVER=file
SESSION_LIFETIME=120

MEMCACHED_HOST=memcached

REDIS_HOST=redis
REDIS_PASSWORD=null
REDIS_PORT=6379

MAIL_MAILER=smtp
MAIL_HOST=mailhog
MAIL_PORT=1025
MAIL_USERNAME=null
MAIL_PASSWORD=null
MAIL_ENCRYPTION=null
MAIL_FROM_ADDRESS="hello@example.com"
MAIL_FROM_NAME="${APP_NAME}"

AWS_ACCESS_KEY_ID=sail
AWS_SECRET_ACCESS_KEY=password
AWS_DEFAULT_REGION=us-east-1
AWS_BUCKET=local
AWS_ENDPOINT=http://minio:9000
AWS_URL=http://minio:9000/local
AWS_USE_PATH_STYLE_ENDPOINT=true

PUSHER_APP_ID=
PUSHER_APP_KEY=
PUSHER_APP_SECRET=
PUSHER_HOST=
PUSHER_PORT=443
PUSHER_SCHEME=https
PUSHER_APP_CLUSTER=mt1

VITE_PUSHER_APP_KEY="${PUSHER_APP_KEY}"
VITE_PUSHER_HOST="${PUSHER_HOST}"
VITE_PUSHER_PORT="${PUSHER_PORT}"
VITE_PUSHER_SCHEME="${PUSHER_SCHEME}"
VITE_PUSHER_APP_CLUSTER="${PUSHER_APP_CLUSTER}"

PRONTO. ENVIANDO PARA O MINIO.


/**** ABAIXO AULA DE FRONT END -> FALTA
























 







/***********************************************************
QUINTA FEIRA: 20/10/22

Open Laravel Week | Deploy com Terraform, EC2 e RDS | Fermentação

****
https://portal.aws.amazon.com/billing/signup?nc2=h_ct&src=header_signup&redirect_url=https%3A%2F%2Faws.amazon.com%2Fregistration-confirmation&language=pt_br#/start/email

Com terraform pode mudar de infra e configurar no git.

PROGRMAR A CONFIGURAÇÃO DO SERVIDOR: É basicamente construir uma nova aplicação para fazer isso, mais fácil de entender.
Terraform serve para (linguagem HCL -> linguagem própria - linguagem descritiva, descreve o resultado e não como irá ser feito), ou seja, descrever o que queremos.
Terraspace é o framework pra terraform.
Quando criamos o Terraform, ele pode variar conforme a infra cloud (aws, azure, google cloud). sua estrutura é a mesma para todos. mas cada provider tem a sua forma de usar, não consegue usar o mesmo código para mais de uma cloud.
Vamos rodar Terraform via container:

1. clonar do git: git clone 
Criar uma pasta para a infraestrutura

sail   (script que vamos usar)
#!/usr/bin/env bash

docker run -rm -it
	-u $(id -u):$(id -g) \
	-v $PWD:/workspace \
	-w /workspace
	hashicorp/terraform:light "%@"


	<no terminal

Logar em: aws.amazon.com
busca: iam
iam dashboard -> mysecurity credencials (root user) -> Acces keys ->clicar em create access keys -> salva o access key e secret access key
e coloca no arquivo credencials na maquina local.. .aws/credencials
















































//////////////////////////////////////////////////////////////////////////////////////////////////////
CONTEÚDO QUE FALTA ORGANIZAR:



/**************************************/

sail share

sail artisan sail:publish ->coloca em uma pasta na raiz chamada docker

sail --help

sail artisan optimizer:clear

sail ps

sail build --no-cache -> faz o bild da aplicação. (dá um sail down  por precaução antes.)










/*********************************

root@DELLAGS:~# curl -s "https://laravel.build/laravel-9-course?with=mysql,redis,mailhog" | bash

Dockerfile

root@DELLAGS:~/example-app# docker exec -it example-app-mysql-1 bash


FROM wyveo/nginx-php-fpm:latest
WORKDIR /usr/share/nginx
RUN rm -rf /usr/share/nginx/html
COPY . /usr/share/nginx
RUN chmod -R 755 /usr/share/nginx/storage/*
RUN ln -s public html

.env (do composer)

DB_CONNECTION=mysql
DB_HOST=mysql-app (serviço do mysql no docker-compose.yaml)
DB_PORT=3306
DB_DATABASE=laraveldockerdb
DB_USERNAME=root
DB_PASSWORD=123456



docker-compose.yaml

version: '3'

services:
  laraveldocker-app:
    build: .
    ports:
      - "3003:80"
    volumes:
      - ./:/usr/share/nginx
      - .docker/nginx:/etc/nginx/conf.d/
    networks:
      - app-network
  mysql-app:
    image: mysql:5.7.22
    ports:
      - "3306:3306"
    volumes:
      - .docker/dbdata:/var/lib/mysql
    environment:
      MYSQL_DATABASE: laraveldocker
      MYSQL_ROOT_PASSWORD: 123456
    networks:
      - app-network
networks:
  app-network:
    driver: bridge
    



/*************************************************
#criando um serviço com um nome qualquer
version: '3'

services:
  laravel-app:                    #criando um serviço com um nome qualquer
    build: . ou image: wyveo/nginx-php-fpm:latest -> neste caso sem Dockerfile.                    # endereço da imagem ou local do Dockerfile (neste caso o ponto siginifica a raiz do projeto)
    ports:
      - "8080:80"                 # 8080 porta do meu host: 80 é a porta do docker nginx
    volumes:                      # docker-compose up -d -> sobe a imagem e libera o terminal  
      - ./:/usr/share/nginx       # TUDO QUE ESTIVE NA RAIZ (na rais tem o meu projeto laravel) './' IRÁ SER REFLETIDO NA PASTA /usr/share/nginx (pasta de acesso da página html)
                                  # C:\Laravel-docker\laravel-docker>docker compose up -d --build atualiza a minha imagem

  mysql-app:
      image: mysql:5.7
      ports:
        - "3306:3306"
      volumes:
        - .docker/dbdata:/var/lib/mysql          # qualqer nome (para persistir -guardar os dados do banco de dados)


      environment:
        MYSQL_DATABASE: laravel
        MYSQL_ROOT_PASSWORD: laravel
    
      

      /***************************///


  
C:\Laravel-docker\laravel-docker>docker compose up -d --build

                                
                               

    

/******************************** Dockerfile
FROM wyveo/nginx-php-fpm:latest

/***************************///
  COMANDOS

docker compose down -> para todos os containers
C:\Laravel-docker\laravel-docker>docker exec -it laravel-docker-laravel-app-1 bash 
root@612ea0ea3340:/# cd /usr/share/nginx/
root@612ea0ea3340:/usr/share/nginx# php artisan migrate
root@612ea0ea3340:/usr/share/nginx# php artisan serve

		
/***********/
PS C:\Users\alber> docker run -e MYSQL_ROOT_PASSWORD=root --name meu-mysql -d mysql:5.7

docker inspect meu-mysql ou | grep IPAddress

PS C:\Users\alber> docker run -e MYSQL_ROOT_PASSWORD=root --name meu-mysql -d -p 3306:3306 mysql:5.7

docker ps
docker ps -l
docker ps -a
docker rm -f nome


/*** LARAVEL */
### CRIANDO UM PROJETO NO LARAVEL 
laravel new projeto_laravel_via_installer (ESTA É UM AOPÇÃO)
composer create-project --prefer-dist laravel/laravel app_controle_tarefas "8.5.9"
cd app_controle_tarefas
cd public
php -S localhost:8000

ou 
da raiz do projeto:
php artisan serve 
ou
php artisan serve --port=3000

### PARA ABRIR PORTA EM OUTRO SERVIDOR
php artisan serve --host test.com --port 8080

 **********************************************************************
cd app_controle_tarefas
cd public
php artisan serve
- acessa o navegador http://localhost:8000

### DENTRO DO PROJETO CRIADO INSTALAR O LARAVEL/UI:^3.2 - versão 3.2
composer require laravel/ui:^3.2

### SE OCORRER ERRO AUMENTAR A MEMÓRIA DISPONIVEL PARA O php

-php --ini -> localiza o arquivo de configuração do php
LOCALIZA memory_limit = 1000 e altera para 
         memory_limit  = -1 e Salva

### LISTA A RELAÇÃO DE COMANDOS 
php artisan list 

DEVERA SURGIR AS OPÇÕES ABAIXO:

 ui
  ui:auth               Scaffold basic login and registration views and routes
  ui:controllers        Scaffold the authentication controllers
 vendor

### ENTENDENDO O PACOTE UI E INICIANDO A AUTENTICAÇÃO WEB NATIVA DO LARAVEL

COMANDO PARA LISTAR ROUTES: 
php artisan route:list

### php artisan ui bootstrap --auth (bootstrap ou react ou vue)
aplicando o bootstrap incluindo os recursos de autenticação;
poderia ser aplicado o bootstrap sem os recursos de autenticação;

### php artisan route:list -> mostra as rotas - ver que aumentaram as rotas

### APÓS ESSE PROCESSO O SISTEMA PEDE PARA RODAR
npm install -> instala as dependências do package.json (inclusive o bootstrap)
npm run dev -> gera os assets da aplicação de acordo com a tecnologia selecionada (bootstrap, react ou vue) -> Geralmente roda mais de uma vez para compilar tudo.

### CRIA O BANCO DE DADOS NORMALMENTE

### EXECUTA AS MIGRATIONS PADRÕES CRIADAS PARA O SISTEMA DE login
php artisan migrate -> CRIA AS TABELAS NO BANCO DE DADOS


************************************** 
INSTALANDO O COMPOSER NO UBUNTU
**************************************
sudo apt update
sudo apt install php-cli unzip

cd ~

curl -sS https://getcomposer.org/installer -o composer-setup.php

HASH=`curl -sS https://composer.github.io/installer.sig`

echo $HASH ->saída: Output
e0012edf3e80b6978849f5eff0d4b4e4c79ff1609dd1e613307e16318854d24ae64f26d17af3ef0bf7cfb710ca74



php -r "if (hash_file('SHA384', 'composer-setup.php') === '$HASH') { echo 'Installer verified'; } else { echo 'Installer corrupt'; unlink('composer-setup.php'); } echo PHP_EOL;"

sudo php composer-setup.php --install-dir=/usr/local/bin --filename=composer





***********************

DigitalOcean Kubernetes: novo plano de controle é mais rápido e gratuito, habilita HA para SLA de 99,95% de tempo de atividade
Produtos
Preços

Documentos
divisa suspensa

Entrar
divisa suspensa

// Tutorial //
Como Instalar e Utilizar o Composer no Ubuntu 20.04
Publicado em 21 de maio de 2020
Ubuntu
PHP
Ubuntu 20.04
Avatar padrão
Por Erika Heidi
Advogado Desenvolvedor
Português
Como Instalar e Utilizar o Composer no Ubuntu 20.04
Introdução
O Composer é uma ferramenta popular de gerenciamento de dependências para o PHP, criado para facilitar a instalação e a atualização das dependências principalmente do projeto. Ele controla quais outros pacotes de projeto específico dependem e são instalados para você, usando as opções apropriadas de acordo com os requisitos do projeto. O Composer também é comumente utilizado para inicializar novos projetos em frameworks PHP populares, como o Symfon e o Laravel .

Neste tutorial, você instalará e começará a usar o Composer em um sistema Ubuntu 20.04.

Pré-requisitos
Para seguir este guia, você pode acessar um servidor como usuário Ubuntu20.04 como usuário sudonão-root um firewall habilitado em seu servidor Para configurar isto, siga nosso guia Configuração do servidor inicial para o Ubuntu 20.04

Passo 1 — Instalando o PHP e as Dependências Adicionais
Além das dependências que já devem estar incluídas em seu sistema Ubuntu 20.04, como o , o Composer exige ou gitexecuta scripts PHP na linha de comando e para extrair arquivos zipados. Vamos instalar essas dependências agora.curlphp-cliunzip

primeiro, atual, gerenciador de pacotes de soluções: o cache do gerenciador de pacotes

sudo apt update
Em seguida, o seguinte comando para instalar os pacotes, execute:

sudo apt install php-cli unzip
Você será solicitado a confirmar a instalação digitando Ye, depois, ENTER.

Assim que os pré-requisitos para instalação do Composer forem instalados, você poderá seguir.

Passo 2 — Baixando e Instalando o Compositor
O Composer fornece um instalador de script escrito em PHP. Vamos baixá-lo, verificar se ele não está danificado e, em seguida, o usaremos para instalar o Composer.

Certifique-se de estar em sua pasta home. Em seguida, baixe o instalador usando o curl:

cd ~
curl -sS https://getcomposer.org/installer -o composer-setup.php
Em seguida, vamos verificar se o instalador baixado corresponde ao hash SHA-384 para o instalador mais recente encontrado na página Composer Public Keys / Signatures . Para facilitar o passo de seleção, você pode usar o seguinte comando para obter programaticamente o hash mais recente da página do Composer e armazená-lo em uma variável do shell:

HASH=`curl -sS https://composer.github.io/installer.sig`
Se você quiser verificar o valor realizado, execute:

echo $HASH
Output
e0012edf3e80b6978849f5eff0d4b4e4c79ff1609dd1e613307e16318854d24ae64f26d17af3ef0bf7cfb710ca74755a
Agora o código PHP a seguir, execute conforme a página de download do Composer, para verificar se o script de instalação está seguro para ser executado:

php -r "if (hash_file('SHA384', 'composer-setup.php') === '$HASH') { echo 'Installer verified'; } else { echo 'Installer corrupt'; unlink('composer-setup.php'); } echo PHP_EOL;"
Você verá o seguinte resultado:

Resultado
Installer verified
Se Installer corruptvocê estiver usando o hash correto, verifique se você está usando o hash correto. Em seguida, repita o processo de verificação. Quando você tiver um instalador selecionado, você pode continuar.

Para instalar o composerglobalmente, use o seguinte comando que baixará e instalará o Composer como um comando disponível em todo o sistema chamado composer, sob /usr/local/bin:

sudo php composer-setup.php --install-dir=/usr/local/bin --filename=composer
Você verá um resultado semelhante com este:

Output
All settings correct for using Composer
Downloading...

Composer (version 1.10.5) successfully installed to: /usr/local/bin/composer
Use it: php /usr/local/bin/composer
Para testar sua instalação, execute:

composer
Output
   ______
  / ____/___  ____ ___  ____  ____  ________  _____
 / /   / __ \/ __ `__ \/ __ \/ __ \/ ___/ _ \/ ___/
/ /___/ /_/ / / / / / / /_/ / /_/ (__  )  __/ /
\____/\____/_/ /_/ /_/ .___/\____/____/\___/_/
                    /_/
Composer version 1.10.5 2020-04-10 11:44:22

Usage:
  command [options] [arguments]

Options:
  -h, --help                     Display this help message
  -q, --quiet                    Do not output any message
  -V, --version                  Display this application version
      --ansi                     Force ANSI output
      --no-ansi                  Disable ANSI output
  -n, --no-interaction           Do not ask any interactive question
      --profile                  Display timing and memory usage information
      --no-plugins               Whether to disable plugins.
  -d, --working-dir=WORKING-DIR  If specified, use the given directory as working directory.
      --no-cache                 Prevent use of the cache
  -v|vv|vvv, --verbose           Increase the verbosity of messages: 1 for normal output, 2 for more verbose output and 3 for debug
...
Isso verifica que o Composer foi instalado com sucesso em seu sistema e está disponível em todo o sistema.

Nota: se você preferirá ter-lhe-ão separados separados do Composer para projeto hospedado neste servidor, você pode instalar localmente, em uma base por projeto. Este método também é útil quando o usuário do sistema não possui permissão para instalar o software disponível em todo o sistema.

Para fazer isso, use o comando php composer-setup.php. Isso irá gerar um arquivo composer.pharem seu diretório atual, que pode ser executado com o seu atual php composer.phar.

Agora podemos dar uma dependência em como usar o Compose como gerenciar.

Passo 3 — Usando o Compositor em um Projeto PHP
Os projetos PHP geralmente dependentes de bibliotecas externas, e o gerenciamento de dependências e suas versões podem ser complicados. O Composer resolve esse problema de manter um controle de projeto de extensões e dependências, também facilita o processo de descoberta, instalação e atualização de pacotes que são definidos por enquanto.

Para usar o seu projeto, você pode compor um arquivo composer.json. O arquivo composer.jsonComposer quais dependências precisa para baixar seu projeto quais serão as versões de cada pacote tem permissão para instalações e instalações. Isso é muito importante para manter seu projeto consistente e evitar a instalação de versões instáveis ​​que podem causar problemas de compatibilidade retroativa.

Você não precisa criar este arquivo manualmente - é comum ocorrer erros de sintaxe quando fizer isso. O Composer oferece uma maneira de criar um novo arquivo composer.jsoncom base na entrada do usuário, o que é uma boa escolha se você planeja compartilhar seu projeto mais tarde como um pacote público no Packagist . O Composer gera automaticamente um arquivo básico composer.jsonquando você executa um comando composer requirepara incluir uma dependência em um projeto recém-criado.

O processo de uso do Composer para instalar um pacote como uma dependência em um projeto envolve os passos a seguir:

Identifique o tipo de biblioteca que o aplicativo precisa.
uma biblioteca de código aberto adequada no agist.org , o responsável oficial de pacotes para o Compose.
Escolha o pacote de dependência.
Execute composer requirepara incluir a dependência no arquivo composer.jsone instalar o pacote.
Vamos testar isso com uma aplicação de demonstração.

O objetivo desta aplicação é transformar uma determinação determinada em uma string de URL amigável - um slug . Isso é comumente usado para converter os títulos de página para caminhos de URL (Assim como a parte final da URL para este tutorial).

Vamos começar a criar um diretório para o nosso projeto. Vamos chamá-lo de slugify :

cd ~
mkdir slugify
cd slugify
Embora não seja necessário, você pode executar agora um comando composer init para criar um arquivo composer.json detalhado para seu projeto. Como o único objetivo do nosso projeto é demonstrar como instalar dependências com o Composer, usaremos um arquivo composer.json mais simples que será gerado automaticamente quando exigirmos nosso primeiro pacote.

Agora é hora de procurar no Packagist.org por um pacote que pode nos ajudar a gerar slugs. Se você procurar pelo termo “slug” no Packagist, receberá um resultado parecido com este:

Resultados da Pesquisa do Packagist para o termo "slug"

Você verá dois números no lado direito de cada pacote na lista. O número no topo representa quantas vezes o pacote foi instalado através do Composer, e o número em baixo mostra quantas vezes um pacote foi estrelado no GitHub. De um modo geral, os pacotes com mais instalações e mais estrelas tendem a ser mais estáveis, pois mais pessoas os utilizam. Também é importante verificar a descrição do pacote para relevância para garantir que ele é o que você precisa.

Precisamos de um conversor string-to-slug A partir dos resultados da pesquisa, o pacote cocur/slugify, que aparece como o primeiro resultado naquela página, parece ser um bom candidato, com uma quantidade razoável de instalações e estrelas.

Os pacotes no Packagist têm um nome de vendor e um nome de package. Cada pacote tem um identificador único (um namespace) no mesmo formato que o GitHub utiliza para seus repositórios: vendor/package. A biblioteca que queremos instalar utiliza o namespace cocur/slugify. Você precisa de um namespace do pacote para exigi-lo em seu projeto.

Agora que você sabe exatamente qual pacote deseja instalar, você pode executar o composer require para incluí-lo como uma dependência e gerar também o arquivo composer.json para seu projeto. Uma coisa importante é observar a exigência de pacotes. O Composer rastreia as dependências no nível da aplicação e do sistema. As dependências no nível do sistema são importantes para indicar de quais módulos PHP um pacote depende. No caso do pacote cocur/slugify, ele exige um módulo PHP que ainda não instalamos.

Quando um pacote necessário depende de uma biblioteca de sistema que não está atualmente instalada em seu servidor, você receberá um erro informando qual requisito está faltando:

composer require cocur/slugify
Output
Using version ^4.0 for cocur/slugify
./composer.json has been updated
Loading composer repositories with package information
Updating dependencies (including require-dev)
Your requirements could not be resolved to an installable set of packages.

  Problem 1
    - Installation request for cocur/slugify ^4.0 -> satisfiable by cocur/slugify[v4.0.0].
    - cocur/slugify v4.0.0 requires ext-mbstring * -> the requested PHP extension mbstring is missing from your system.
...
Para resolver o problema de dependência do sistema, podemos procurar pelo pacote que falta usando o apt search:

apt search mbstring
Output
Sorting... Done
Full Text Search... Done
php-mbstring/focal 2:7.4+75 all
  MBSTRING module for PHP [default]

php-patchwork-utf8/focal 1.3.1-1 all
  UTF-8 strings handling for PHP

php7.4-mbstring/focal 7.4.3-4ubuntu1 amd64
  MBSTRING module for PHP
Após localizar o nome do pacote correto, você pode utilizar o apt novamente para instalar a dependência de sistema:

sudo apt install php-mbstring
Assim que a instalação terminar, você pode executar novamente o comando composer require:

composer require cocur/slugify
Output
Using version ^4.0 for cocur/slugify
./composer.json has been created
Loading composer repositories with package information
Updating dependencies (including require-dev)
Package operations: 1 install, 0 updates, 0 removals
  - Installing cocur/slugify (v4.0.0): Downloading (100%)         
Writing lock file
Generating autoload files
Como você pode ver na saída, o Composer decidiu automaticamente qual versão do pacote utilizar. Se você verificar o diretório do seu projeto agora, ele irá conter dois arquivos novos: composer.json e composer.lock, e um diretório vendor:

ls -l
Output
total 12
-rw-rw-r-- 1 sammy sammy   59 May  4 13:56 composer.json
-rw-rw-r-- 1 sammy sammy 3229 May  4 13:56 composer.lock
drwxrwxr-x 4 sammy sammy 4096 May  4 13:56 vendor
O arquivo composer.lock é usado para armazenar informações sobre quais versões de cada pacote estão instaladas, e garantir que as mesmas versões sejam usadas se outra pessoa clonar seu projeto e instalar suas dependências. O diretório vendor é onde as dependências do projeto estão localizadas. Você não deve fazer commit da pasta vendor no controle de versão - você precisa apenas incluir os arquivos composer.json e composer.lock.

Ao instalar um projeto que já contém um arquivo composer.json, execute o composer install para baixar as dependências do projeto.

Vamos dar uma olhada rápida em restrições de versão. Se você verificar o conteúdo do seu arquivo composer.json, verá algo parecido com isto:

cat composer.json
Output
{
    "require": {
        "cocur/slugify": "^4.0"
    }
}
Note que há o caractere especial ^ antes do número da versão no composer.json. O Composer suporta várias restrições diferentes e formatos para definir a versão necessária do pacote, para fornecer flexibilidade enquanto também mantém seu projeto estável. O operador circunflexo (^) utilizado pelo arquivo composer.json criado automaticamente é o operador recomendado para a interoperabilidade máxima, seguindo o versionamento semântico. Neste caso, ele define 4.0 como a versão mínima compatível e permite atualizações para qualquer versão futura abaixo de 5.0.

De um modo geral, você não precisará alterar as restrições de versão em seu arquivo composer.json. No entanto, algumas situações podem exigir que você edite manualmente as restrições – por exemplo, quando uma nova versão principal da sua biblioteca requerida é liberada e você deseja atualizar, ou quando a biblioteca que você deseja usar não segue o versionamento semântico.

Aqui estão alguns exemplos para lhe dar um melhor entendimento sobre como as restrições de versão do Composer funcionam:

Restrição	Significado	Exemplo de Versões Permitidas
^1.0	>= 1.0 < 2.0	1.0, 1.2.3, 1.9.9
^1.1.0	>= 1.1.0 < 2.0	1.1.0, 1.5.6, 1.9.9
~1.0	>= 1.0 < 2.0.0	1.0, 1.4.1, 1.9.9
~1.0.0	>= 1.0.0 < 1.1	1.0.0, 1.0.4, 1.0.9
1.2.1	1.2.1	1.2.1
1.*	>= 1.0 < 2.0	1.0.0, 1.4.5, 1.9.9
1.2. *	>= 1.2 < 1.3	1.2.0, 1.2.3, 1.2.9
Para uma visualização mais detalhada das restrições de versão do Composer, consulte a documentação oficial.

A seguir, vamos ver como carregar dependências automaticamente com o Composer.

Passo 4 — Incluindo o Script Autoload
Como o PHP por si só não carrega classes automaticamente, o Composer fornece um script autoload que você pode incluir em seu projeto para obter o carregamento automático para ele. Este arquivo é gerado automaticamente pelo Composer quando você adiciona sua primeira dependência.

A única coisa que você precisa fazer é incluir o arquivo vendor/autoload.php em seus scripts PHP antes de qualquer instância de classe.

Vamos testar isso em nossa aplicação de demonstração. Abra um novo arquivo chamado test.php em seu editor de texto:

nano test.php
Adicione o código a seguir que vem no arquivo vendor/autoload.php, carrega a dependência cocur/slugify, e o utiliza para criar um slug:

test.php
<?php
require __DIR__ . '/vendor/autoload.php';

use Cocur\Slugify\Slugify;

$slugify = new Slugify();

echo $slugify->slugify('Hello World, this is a long sentence and I need to make a slug from it!');
Salve o arquivo e saia do seu editor.

Agora, execute o script.

php test.php
Isso produz a saída hello-world-this-is-a-long-sentence-and-i-need-to-make-a-slug-from-it.

As dependências precisam de atualizações quando novas versões são liberadas. Dessa forma, vamos ver como lidar com isso.

Passo 5 — Atualizando as Dependências do Projeto
Sempre que você quiser atualizar suas dependências do projeto para versões mais recentes, execute o comando update:

composer update
Isso irá verificar por versões mais recentes das bibliotecas que você requer em seu projeto. Se uma versão mais recente for encontrada e ela for compatível com a restrição de versão definida no arquivo composer.json, o Composer substituirá a versão anterior instalada. O arquivo composer.lock será atualizado para refletir essas alterações.

Você também pode atualizar uma ou mais bibliotecas específicas, especificando-as desta forma:

composer update vendor/package vendor2/package2
Certifique-se de verificar em seus arquivos composer.json e composer.lock dentro do seu sistema de controle de versão após atualizar suas dependências de modo que outros também possam instalar essas versões mais recentes.

Conclusão





***********
Algoritmo "CalculoMedia2"
// Disciplina: Lógica de programação
// Professor : Antonio Carlos Nicolodi
// Descrição : calculo da média aritimética
// Autor     : Professor Antonio
// Data atual: 01/04/2015
var
// Seção de Declarações
   v1, v2, total: Real
   sinal : Caracter
Inicio
// Seção dos Comandos
   Escreva ("Digite o primeiro valor: ")
   Leia (v1)
   Escreva ("Digite a operação + - * / : ")
   Leia (sinal)
   Escreva ("Digite o segundo valor: ")
   Leia (v2)

   Se sinal = "+" entao
   total <- v1 + v2
   Escreva("O Resultado é: ", total)
   Senao
   Se sinal = "-" entao
   total <- v1 - v2
   Escreva("O Resultado é: ", total)
   Senao
   Se sinal = "*" entao
   total <- v1 * v2
   Escreva("O Resultado é: ", total)


   Senao
     Escreva("OPERAÇÃO INVÁLIDA! ")



      Escreval("total")
   fimse
Fimalgoritmo

****
COMANDOS DOCKER
root@DELLAGS:~# curl -s "https://laravel.build/laravel-9-course?with=mysql,redis,mailhog" | bash

root@DELLAGS:~/example-app# ./vendor/bin/sail  artisan migrate --seed -> criar o banco de dados e copular dados;

Dockerfile

root@DELLAGS:~/example-app# docker exec -it example-app-mysql-1 bash


FROM wyveo/nginx-php-fpm:latest
WORKDIR /usr/share/nginx
RUN rm -rf /usr/share/nginx/html
COPY . /usr/share/nginx
RUN chmod -R 755 /usr/share/nginx/storage/*
RUN ln -s public html

.env (do composer)

DB_CONNECTION=mysql
DB_HOST=mysql-app (serviço do mysql no docker-compose.yaml)
DB_PORT=3306
DB_DATABASE=laraveldockerdb
DB_USERNAME=root
DB_PASSWORD=123456



docker-compose.yaml

version: '3'

services:
  laraveldocker-app:
    build: .
    ports:
      - "3003:80"
    volumes:
      - ./:/usr/share/nginx
      - .docker/nginx:/etc/nginx/conf.d/
    networks:
      - app-network
  mysql-app:
    image: mysql:5.7.22
    ports:
      - "3306:3306"
    volumes:
      - .docker/dbdata:/var/lib/mysql
    environment:
      MYSQL_DATABASE: laraveldocker
      MYSQL_ROOT_PASSWORD: 123456
    networks:
      - app-network
networks:
  app-network:
    driver: bridge
    



/*************************************************
#criando um serviço com um nome qualquer
version: '3'

services:
  laravel-app:                    #criando um serviço com um nome qualquer
    build: . ou image: wyveo/nginx-php-fpm:latest -> neste caso sem Dockerfile.                    # endereço da imagem ou local do Dockerfile (neste caso o ponto siginifica a raiz do projeto)
    ports:
      - "8080:80"                 # 8080 porta do meu host: 80 é a porta do docker nginx
    volumes:                      # docker-compose up -d -> sobe a imagem e libera o terminal  
      - ./:/usr/share/nginx       # TUDO QUE ESTIVE NA RAIZ (na rais tem o meu projeto laravel) './' IRÁ SER REFLETIDO NA PASTA /usr/share/nginx (pasta de acesso da página html)
                                  # C:\Laravel-docker\laravel-docker>docker compose up -d --build atualiza a minha imagem

  mysql-app:
      image: mysql:5.7
      ports:
        - "3306:3306"
      volumes:
        - .docker/dbdata:/var/lib/mysql          # qualqer nome (para persistir -guardar os dados do banco de dados)


      environment:
        MYSQL_DATABASE: laravel
        MYSQL_ROOT_PASSWORD: laravel
    
      

      /***************************///


  
C:\Laravel-docker\laravel-docker>docker compose up -d --build

                                
                               

    

/******************************** Dockerfile
FROM wyveo/nginx-php-fpm:latest

/***************************///
  COMANDOS

docker compose down -> para todos os containers
C:\Laravel-docker\laravel-docker>docker exec -it laravel-docker-laravel-app-1 bash 
root@612ea0ea3340:/# cd /usr/share/nginx/
root@612ea0ea3340:/usr/share/nginx# php artisan migrate
root@612ea0ea3340:/usr/share/nginx# php artisan serve

		
/***********/
PS C:\Users\alber> docker run -e MYSQL_ROOT_PASSWORD=root --name meu-mysql -d mysql:5.7

docker inspect meu-mysql ou | grep IPAddress

PS C:\Users\alber> docker run -e MYSQL_ROOT_PASSWORD=root --name meu-mysql -d -p 3306:3306 mysql:5.7

docker ps
docker ps -l
docker ps -a
docker rm -f nome


/*** LARAVEL */
### CRIANDO UM PROJETO NO LARAVEL 
laravel new projeto_laravel_via_installer (ESTA É UM AOPÇÃO)
composer create-project --prefer-dist laravel/laravel app_controle_tarefas "8.5.9"
cd app_controle_tarefas
cd public
php -S localhost:8000

ou 
da raiz do projeto:
php artisan serve 
ou
php artisan serve --port=3000

### PARA ABRIR PORTA EM OUTRO SERVIDOR
php artisan serve --host test.com --port 8080

 **********************************************************************
cd app_controle_tarefas
cd public
php artisan serve
- acessa o navegador http://localhost:8000

### DENTRO DO PROJETO CRIADO INSTALAR O LARAVEL/UI:^3.2 - versão 3.2
composer require laravel/ui:^3.2

### SE OCORRER ERRO AUMENTAR A MEMÓRIA DISPONIVEL PARA O php

-php --ini -> localiza o arquivo de configuração do php
LOCALIZA memory_limit = 1000 e altera para 
         memory_limit  = -1 e Salva

### LISTA A RELAÇÃO DE COMANDOS 
php artisan list 

DEVERA SURGIR AS OPÇÕES ABAIXO:

 ui
  ui:auth               Scaffold basic login and registration views and routes
  ui:controllers        Scaffold the authentication controllers
 vendor

### ENTENDENDO O PACOTE UI E INICIANDO A AUTENTICAÇÃO WEB NATIVA DO LARAVEL

COMANDO PARA LISTAR ROUTES: 
php artisan route:list

### php artisan ui bootstrap --auth (bootstrap ou react ou vue)
aplicando o bootstrap incluindo os recursos de autenticação;
poderia ser aplicado o bootstrap sem os recursos de autenticação;

### php artisan route:list -> mostra as rotas - ver que aumentaram as rotas

### APÓS ESSE PROCESSO O SISTEMA PEDE PARA RODAR
npm install -> instala as dependências do package.json (inclusive o bootstrap)
npm run dev -> gera os assets da aplicação de acordo com a tecnologia selecionada (bootstrap, react ou vue) -> Geralmente roda mais de uma vez para compilar tudo.

### CRIA O BANCO DE DADOS NORMALMENTE

### EXECUTA AS MIGRATIONS PADRÕES CRIADAS PARA O SISTEMA DE login
php artisan migrate -> CRIA AS TABELAS NO BANCO DE DADOS


************************************** 
INSTALANDO O COMPOSER NO UBUNTU
**************************************
sudo apt update
sudo apt install php-cli unzip

cd ~

curl -sS https://getcomposer.org/installer -o composer-setup.php

HASH=`curl -sS https://composer.github.io/installer.sig`

echo $HASH ->saída: Output
e0012edf3e80b6978849f5eff0d4b4e4c79ff1609dd1e613307e16318854d24ae64f26d17af3ef0bf7cfb710ca74



php -r "if (hash_file('SHA384', 'composer-setup.php') === '$HASH') { echo 'Installer verified'; } else { echo 'Installer corrupt'; unlink('composer-setup.php'); } echo PHP_EOL;"

sudo php composer-setup.php --install-dir=/usr/local/bin --filename=composer





***********************

DigitalOcean Kubernetes: novo plano de controle é mais rápido e gratuito, habilita HA para SLA de 99,95% de tempo de atividade
Produtos
Preços

Documentos
divisa suspensa

Entrar
divisa suspensa

// Tutorial //
Como Instalar e Utilizar o Composer no Ubuntu 20.04
Publicado em 21 de maio de 2020
Ubuntu
PHP
Ubuntu 20.04
Avatar padrão
Por Erika Heidi
Advogado Desenvolvedor
Português
Como Instalar e Utilizar o Composer no Ubuntu 20.04
Introdução
O Composer é uma ferramenta popular de gerenciamento de dependências para o PHP, criado para facilitar a instalação e a atualização das dependências principalmente do projeto. Ele controla quais outros pacotes de projeto específico dependem e são instalados para você, usando as opções apropriadas de acordo com os requisitos do projeto. O Composer também é comumente utilizado para inicializar novos projetos em frameworks PHP populares, como o Symfon e o Laravel .

Neste tutorial, você instalará e começará a usar o Composer em um sistema Ubuntu 20.04.

Pré-requisitos
Para seguir este guia, você pode acessar um servidor como usuário Ubuntu20.04 como usuário sudonão-root um firewall habilitado em seu servidor Para configurar isto, siga nosso guia Configuração do servidor inicial para o Ubuntu 20.04

Passo 1 — Instalando o PHP e as Dependências Adicionais
Além das dependências que já devem estar incluídas em seu sistema Ubuntu 20.04, como o , o Composer exige ou gitexecuta scripts PHP na linha de comando e para extrair arquivos zipados. Vamos instalar essas dependências agora.curlphp-cliunzip

primeiro, atual, gerenciador de pacotes de soluções: o cache do gerenciador de pacotes

sudo apt update
Em seguida, o seguinte comando para instalar os pacotes, execute:

sudo apt install php-cli unzip
Você será solicitado a confirmar a instalação digitando Ye, depois, ENTER.

Assim que os pré-requisitos para instalação do Composer forem instalados, você poderá seguir.

Passo 2 — Baixando e Instalando o Compositor
O Composer fornece um instalador de script escrito em PHP. Vamos baixá-lo, verificar se ele não está danificado e, em seguida, o usaremos para instalar o Composer.

Certifique-se de estar em sua pasta home. Em seguida, baixe o instalador usando o curl:

cd ~
curl -sS https://getcomposer.org/installer -o composer-setup.php
Em seguida, vamos verificar se o instalador baixado corresponde ao hash SHA-384 para o instalador mais recente encontrado na página Composer Public Keys / Signatures . Para facilitar o passo de seleção, você pode usar o seguinte comando para obter programaticamente o hash mais recente da página do Composer e armazená-lo em uma variável do shell:

HASH=`curl -sS https://composer.github.io/installer.sig`
Se você quiser verificar o valor realizado, execute:

echo $HASH
Output
e0012edf3e80b6978849f5eff0d4b4e4c79ff1609dd1e613307e16318854d24ae64f26d17af3ef0bf7cfb710ca74755a
Agora o código PHP a seguir, execute conforme a página de download do Composer, para verificar se o script de instalação está seguro para ser executado:

php -r "if (hash_file('SHA384', 'composer-setup.php') === '$HASH') { echo 'Installer verified'; } else { echo 'Installer corrupt'; unlink('composer-setup.php'); } echo PHP_EOL;"
Você verá o seguinte resultado:

Resultado
Installer verified
Se Installer corruptvocê estiver usando o hash correto, verifique se você está usando o hash correto. Em seguida, repita o processo de verificação. Quando você tiver um instalador selecionado, você pode continuar.

Para instalar o composerglobalmente, use o seguinte comando que baixará e instalará o Composer como um comando disponível em todo o sistema chamado composer, sob /usr/local/bin:

sudo php composer-setup.php --install-dir=/usr/local/bin --filename=composer
Você verá um resultado semelhante com este:

Output
All settings correct for using Composer
Downloading...

Composer (version 1.10.5) successfully installed to: /usr/local/bin/composer
Use it: php /usr/local/bin/composer
Para testar sua instalação, execute:

composer
Output
   ______
  / ____/___  ____ ___  ____  ____  ________  _____
 / /   / __ \/ __ `__ \/ __ \/ __ \/ ___/ _ \/ ___/
/ /___/ /_/ / / / / / / /_/ / /_/ (__  )  __/ /
\____/\____/_/ /_/ /_/ .___/\____/____/\___/_/
                    /_/
Composer version 1.10.5 2020-04-10 11:44:22

Usage:
  command [options] [arguments]

Options:
  -h, --help                     Display this help message
  -q, --quiet                    Do not output any message
  -V, --version                  Display this application version
      --ansi                     Force ANSI output
      --no-ansi                  Disable ANSI output
  -n, --no-interaction           Do not ask any interactive question
      --profile                  Display timing and memory usage information
      --no-plugins               Whether to disable plugins.
  -d, --working-dir=WORKING-DIR  If specified, use the given directory as working directory.
      --no-cache                 Prevent use of the cache
  -v|vv|vvv, --verbose           Increase the verbosity of messages: 1 for normal output, 2 for more verbose output and 3 for debug
...
Isso verifica que o Composer foi instalado com sucesso em seu sistema e está disponível em todo o sistema.

Nota: se você preferirá ter-lhe-ão separados separados do Composer para projeto hospedado neste servidor, você pode instalar localmente, em uma base por projeto. Este método também é útil quando o usuário do sistema não possui permissão para instalar o software disponível em todo o sistema.

Para fazer isso, use o comando php composer-setup.php. Isso irá gerar um arquivo composer.pharem seu diretório atual, que pode ser executado com o seu atual php composer.phar.

Agora podemos dar uma dependência em como usar o Compose como gerenciar.

Passo 3 — Usando o Compositor em um Projeto PHP
Os projetos PHP geralmente dependentes de bibliotecas externas, e o gerenciamento de dependências e suas versões podem ser complicados. O Composer resolve esse problema de manter um controle de projeto de extensões e dependências, também facilita o processo de descoberta, instalação e atualização de pacotes que são definidos por enquanto.

Para usar o seu projeto, você pode compor um arquivo composer.json. O arquivo composer.jsonComposer quais dependências precisa para baixar seu projeto quais serão as versões de cada pacote tem permissão para instalações e instalações. Isso é muito importante para manter seu projeto consistente e evitar a instalação de versões instáveis ​​que podem causar problemas de compatibilidade retroativa.

Você não precisa criar este arquivo manualmente - é comum ocorrer erros de sintaxe quando fizer isso. O Composer oferece uma maneira de criar um novo arquivo composer.jsoncom base na entrada do usuário, o que é uma boa escolha se você planeja compartilhar seu projeto mais tarde como um pacote público no Packagist . O Composer gera automaticamente um arquivo básico composer.jsonquando você executa um comando composer requirepara incluir uma dependência em um projeto recém-criado.

O processo de uso do Composer para instalar um pacote como uma dependência em um projeto envolve os passos a seguir:

Identifique o tipo de biblioteca que o aplicativo precisa.
uma biblioteca de código aberto adequada no agist.org , o responsável oficial de pacotes para o Compose.
Escolha o pacote de dependência.
Execute composer requirepara incluir a dependência no arquivo composer.jsone instalar o pacote.
Vamos testar isso com uma aplicação de demonstração.

O objetivo desta aplicação é transformar uma determinação determinada em uma string de URL amigável - um slug . Isso é comumente usado para converter os títulos de página para caminhos de URL (Assim como a parte final da URL para este tutorial).

Vamos começar a criar um diretório para o nosso projeto. Vamos chamá-lo de slugify :

cd ~
mkdir slugify
cd slugify
Embora não seja necessário, você pode executar agora um comando composer init para criar um arquivo composer.json detalhado para seu projeto. Como o único objetivo do nosso projeto é demonstrar como instalar dependências com o Composer, usaremos um arquivo composer.json mais simples que será gerado automaticamente quando exigirmos nosso primeiro pacote.

Agora é hora de procurar no Packagist.org por um pacote que pode nos ajudar a gerar slugs. Se você procurar pelo termo “slug” no Packagist, receberá um resultado parecido com este:

Resultados da Pesquisa do Packagist para o termo "slug"

Você verá dois números no lado direito de cada pacote na lista. O número no topo representa quantas vezes o pacote foi instalado através do Composer, e o número em baixo mostra quantas vezes um pacote foi estrelado no GitHub. De um modo geral, os pacotes com mais instalações e mais estrelas tendem a ser mais estáveis, pois mais pessoas os utilizam. Também é importante verificar a descrição do pacote para relevância para garantir que ele é o que você precisa.

Precisamos de um conversor string-to-slug A partir dos resultados da pesquisa, o pacote cocur/slugify, que aparece como o primeiro resultado naquela página, parece ser um bom candidato, com uma quantidade razoável de instalações e estrelas.

Os pacotes no Packagist têm um nome de vendor e um nome de package. Cada pacote tem um identificador único (um namespace) no mesmo formato que o GitHub utiliza para seus repositórios: vendor/package. A biblioteca que queremos instalar utiliza o namespace cocur/slugify. Você precisa de um namespace do pacote para exigi-lo em seu projeto.

Agora que você sabe exatamente qual pacote deseja instalar, você pode executar o composer require para incluí-lo como uma dependência e gerar também o arquivo composer.json para seu projeto. Uma coisa importante é observar a exigência de pacotes. O Composer rastreia as dependências no nível da aplicação e do sistema. As dependências no nível do sistema são importantes para indicar de quais módulos PHP um pacote depende. No caso do pacote cocur/slugify, ele exige um módulo PHP que ainda não instalamos.

Quando um pacote necessário depende de uma biblioteca de sistema que não está atualmente instalada em seu servidor, você receberá um erro informando qual requisito está faltando:

composer require cocur/slugify
Output
Using version ^4.0 for cocur/slugify
./composer.json has been updated
Loading composer repositories with package information
Updating dependencies (including require-dev)
Your requirements could not be resolved to an installable set of packages.

  Problem 1
    - Installation request for cocur/slugify ^4.0 -> satisfiable by cocur/slugify[v4.0.0].
    - cocur/slugify v4.0.0 requires ext-mbstring * -> the requested PHP extension mbstring is missing from your system.
...
Para resolver o problema de dependência do sistema, podemos procurar pelo pacote que falta usando o apt search:

apt search mbstring
Output
Sorting... Done
Full Text Search... Done
php-mbstring/focal 2:7.4+75 all
  MBSTRING module for PHP [default]

php-patchwork-utf8/focal 1.3.1-1 all
  UTF-8 strings handling for PHP

php7.4-mbstring/focal 7.4.3-4ubuntu1 amd64
  MBSTRING module for PHP
Após localizar o nome do pacote correto, você pode utilizar o apt novamente para instalar a dependência de sistema:

sudo apt install php-mbstring
Assim que a instalação terminar, você pode executar novamente o comando composer require:

composer require cocur/slugify
Output
Using version ^4.0 for cocur/slugify
./composer.json has been created
Loading composer repositories with package information
Updating dependencies (including require-dev)
Package operations: 1 install, 0 updates, 0 removals
  - Installing cocur/slugify (v4.0.0): Downloading (100%)         
Writing lock file
Generating autoload files
Como você pode ver na saída, o Composer decidiu automaticamente qual versão do pacote utilizar. Se você verificar o diretório do seu projeto agora, ele irá conter dois arquivos novos: composer.json e composer.lock, e um diretório vendor:

ls -l
Output
total 12
-rw-rw-r-- 1 sammy sammy   59 May  4 13:56 composer.json
-rw-rw-r-- 1 sammy sammy 3229 May  4 13:56 composer.lock
drwxrwxr-x 4 sammy sammy 4096 May  4 13:56 vendor
O arquivo composer.lock é usado para armazenar informações sobre quais versões de cada pacote estão instaladas, e garantir que as mesmas versões sejam usadas se outra pessoa clonar seu projeto e instalar suas dependências. O diretório vendor é onde as dependências do projeto estão localizadas. Você não deve fazer commit da pasta vendor no controle de versão - você precisa apenas incluir os arquivos composer.json e composer.lock.

Ao instalar um projeto que já contém um arquivo composer.json, execute o composer install para baixar as dependências do projeto.

Vamos dar uma olhada rápida em restrições de versão. Se você verificar o conteúdo do seu arquivo composer.json, verá algo parecido com isto:

cat composer.json
Output
{
    "require": {
        "cocur/slugify": "^4.0"
    }
}
Note que há o caractere especial ^ antes do número da versão no composer.json. O Composer suporta várias restrições diferentes e formatos para definir a versão necessária do pacote, para fornecer flexibilidade enquanto também mantém seu projeto estável. O operador circunflexo (^) utilizado pelo arquivo composer.json criado automaticamente é o operador recomendado para a interoperabilidade máxima, seguindo o versionamento semântico. Neste caso, ele define 4.0 como a versão mínima compatível e permite atualizações para qualquer versão futura abaixo de 5.0.

De um modo geral, você não precisará alterar as restrições de versão em seu arquivo composer.json. No entanto, algumas situações podem exigir que você edite manualmente as restrições – por exemplo, quando uma nova versão principal da sua biblioteca requerida é liberada e você deseja atualizar, ou quando a biblioteca que você deseja usar não segue o versionamento semântico.

Aqui estão alguns exemplos para lhe dar um melhor entendimento sobre como as restrições de versão do Composer funcionam:

Restrição	Significado	Exemplo de Versões Permitidas
^1.0	>= 1.0 < 2.0	1.0, 1.2.3, 1.9.9
^1.1.0	>= 1.1.0 < 2.0	1.1.0, 1.5.6, 1.9.9
~1.0	>= 1.0 < 2.0.0	1.0, 1.4.1, 1.9.9
~1.0.0	>= 1.0.0 < 1.1	1.0.0, 1.0.4, 1.0.9
1.2.1	1.2.1	1.2.1
1.*	>= 1.0 < 2.0	1.0.0, 1.4.5, 1.9.9
1.2. *	>= 1.2 < 1.3	1.2.0, 1.2.3, 1.2.9
Para uma visualização mais detalhada das restrições de versão do Composer, consulte a documentação oficial.

A seguir, vamos ver como carregar dependências automaticamente com o Composer.

Passo 4 — Incluindo o Script Autoload
Como o PHP por si só não carrega classes automaticamente, o Composer fornece um script autoload que você pode incluir em seu projeto para obter o carregamento automático para ele. Este arquivo é gerado automaticamente pelo Composer quando você adiciona sua primeira dependência.

A única coisa que você precisa fazer é incluir o arquivo vendor/autoload.php em seus scripts PHP antes de qualquer instância de classe.

Vamos testar isso em nossa aplicação de demonstração. Abra um novo arquivo chamado test.php em seu editor de texto:

nano test.php
Adicione o código a seguir que vem no arquivo vendor/autoload.php, carrega a dependência cocur/slugify, e o utiliza para criar um slug:

test.php
<?php
require __DIR__ . '/vendor/autoload.php';

use Cocur\Slugify\Slugify;

$slugify = new Slugify();

echo $slugify->slugify('Hello World, this is a long sentence and I need to make a slug from it!');
Salve o arquivo e saia do seu editor.

Agora, execute o script.

php test.php
Isso produz a saída hello-world-this-is-a-long-sentence-and-i-need-to-make-a-slug-from-it.

As dependências precisam de atualizações quando novas versões são liberadas. Dessa forma, vamos ver como lidar com isso.

Passo 5 — Atualizando as Dependências do Projeto
Sempre que você quiser atualizar suas dependências do projeto para versões mais recentes, execute o comando update:

composer update
Isso irá verificar por versões mais recentes das bibliotecas que você requer em seu projeto. Se uma versão mais recente for encontrada e ela for compatível com a restrição de versão definida no arquivo composer.json, o Composer substituirá a versão anterior instalada. O arquivo composer.lock será atualizado para refletir essas alterações.

Você também pode atualizar uma ou mais bibliotecas específicas, especificando-as desta forma:

composer update vendor/package vendor2/package2
Certifique-se de verificar em seus arquivos composer.json e composer.lock dentro do seu sistema de controle de versão após atualizar suas dependências de modo que outros também possam instalar essas versões mais recentes.








INÍCIO:

1 instalar o docker

2 abrir wsl2/Windows ou linux
 curl -s "https://laravel.build/olw?with=mysql,redis,mailhog,minio" | bash

3 cd olw
./vendor/bin/sail up -d
	ou
4 cd olw && ./vendor/bin/sail up -d

5 ATRIBUINDO PERMISSÃO PARA A PASTA
cd .. -> sai da pasta
sudo chmod 777 olw/ -R ou sem o 'sudo' chmod 777 olw/ -R

6 CRIANDO ALIAS PARA O COMANDO ANTERIOR
alias sail='[ -f sail ] && sh sail || sh vendor/bin/sail'
passa a usar assim: sail ps

7 CONFIGURAR PORTAS PARA A APLICAÇÃO NO NAVEGADOR E MYSQL
.env
APP_PORT=8000

*porta do myql
FORWARD_DB_PORT=3307

8 INSTALANDO DEPENDÊNCIA AO PROJETO
./vendor/bin/sail composer require laravel/breeze --dev

9 DEIXAR TELA DE AUTENTICAÇÃO PRONTA, ROTA AUTENTICADA, TAWINDCSS INSTALADO E INERTIA INSTALADO
./vendor/bin/sail artisan breeze:install vue 
ou
./vendor/bin/sail art breeze:install vue


10 RODAR AS MIGRATES PADRÕES DO PROJETO AI JÁ PODE CADASTRAR USUÁRIOS PARA LOGIN:
./vendor/bin/sail art migrate

11 


/*******************************************/
2a AULA:

O PROJETO CONSISTE EM RECEBER DADOS DE UMA API (punkapi.com) DE INFORMAÇÕES SOBRE CERVEJAS, VAMOS CONSTRUIR AS ROTAS PARA CONSUMIR A API E CRIAR A ESTRUTURA PARA O RELATÓRIO QUE IREMOS GERAR EM EXCEL E ENVIAR PARA O STORAGE...
1 CRIAR ROTAS:
code .
olw/routes/web.php


sail up -d -> SOBE O CONTAINER localhost:8000 (nesse projeto)

Route::get('/beers', fn()=> 'Olw - testando a rota /beers');

**************************************************
obs:
- laravel.com/api -> acesso a documentação do código;
- in line paramets for vscode -> extensão para vscode para exibir o nome dos métodos na hora que codificar;
- fira code -> extensão para fonte no vscode

Copilot vs Tabnine, qual preferem? (pesquisar sobre)
Link para extensões vscode:
https://github.com/icarojobs/vscode-useful-extensions
*************************************************


Route::get('/beers', fn()=> 'Olw - testando a rota /beers')
                             ->middleware(['auth']);

* FLUXO PADRÃO DO MVC-LARAVEL: 
life cicle: sai do usuário pelo navegador, insomnia ou postman -> passa pelo index.php(pasta public) -> passa pelos arquivos do bootstrap retornando uma instância da aplicação -> passa pelo kernel do http (carrega mais instâncias) -> Service provider -> despacha a requisição pro Router -> Cai no arquivo Web.php -> Middleware (se tiver, geralmente tem os globais) -> Controller (faz as regras de negócio e pode chamar outras classes como Serviços por exemplo)
-> Retorna uma view ou um json (No caso estamos usando inértia, ele não vai reinderizar a 'view.blade' padrão, ele vai reinderizar componente vue.js através do inértia.).


* EM VEZ DE USAR A FUNÇÃO AQUI NA ROTA CRIAMOS UM CONTROLLER:
obs.: ​dica: php artisan make:controller -r cria o Resource também.

sail artisan make:controller BeerController
ou 
sail art make:controller BeerController -> CRIA O ARQUIVO BeerController.php na pasta app/Http/Controllers
->
<?php

namespace App\Http\Controllers;

use Illuminate\Http\Request;

class BeerController extends Controller
{
    public function index()
    {
    return 'Virgu & Beer & Code'
    }
}

* NO ARQUIVO DE ROTAS Web.php CHAMA O BeersController:

importante importar o Controller <nomeDoController>+<CTRL=ENTER:
use App\Http\Controllers\BeerController;

Route::get('/beers', [BeerController::class, 'index'])
                        ->middleware(['auth']);


* PRECISAMOS CRIAR UM MÉTODO PARA PEGAR A LISTA, LISTAR OS DADOS DA API (listar as bebidas de https://api.punkapi.com/v2 ->
VAMOS CRIAR UMA NOVA CLASSE de serviços em app/Sevices/PunkapiService.php

* O LARAVEL POSSUI UM RECURSO CHAMADO HTTPClient que abstrai o uso de uma ferramenta chama guzeo, esse guzeo é o client http mais comum para php, com ele fazemos requisições pra diversos serviços web dentro do php para outras url, ele é robusto, então o laravel simplifica importando o recurso que faz tudo por 'detrás dos panos':

PunkapiService.php

<?php

namespace App\Services;

use Illuminate\Support\Facades\Http;

class PunkapiService
{
    public function getBeers()
    {
        return Http::get('https://api.punkapi.com/v2/beers');
    }
}

E NO BeerController.php fica:
<?php

namespace App\Http\Controllers;

use App\Services\PunkapiService;
use Illuminate\Http\Request;

class BeerController extends Controller
{
    public function index()
    {
    //return 'Virgu & Beer & Code';
    $service = new PunkapiService;

    return $service->getBeers();
    }
}

* TRATE É CARACTERÍSTICA QUE A CLASSE ADQUIRE (pode ter mesmos métodos e atributos substituindo o recurso de um classe extender várias classes que não tem no php, a trate é uma forma de fazer isso. O service  é uma outra camada na maioria das vezes abstrair seviços que vc vai consumir, por exemplo API.

Estando logado, os dados da api já serão exibidos em localhost:8000/beers, se usar um aplicativo cliente tipo insomnia pode apresentar os dados também, melhor comentar a linha de de autenticação da rota:
Route::get('/beers', [BeerController::class, 'index']);
linha de autenticação da rota // ->middleware(['auth']);

* ESSA API PERMITE FAZER FILTROS VIA PARÂMETROS NA PRÓPRIA ROTA. PRIMEIRO VAMOS REFATORAR O CÓDIO, A CLASSE PunkapiService.php:

USO DE CONFIG E MACRO


Vamos alterar a url, primeiro acessando a pasta config da raiz do projeto e criar o arquivo punkapi.php. O que acontece é que o config(pasta config da raiz) carrega todos os arquivos da pasta e permite que sejam acessados via funções simples(HELPERS), isso é muito legal porque podemos acessar esses arquivos de configurações de qualquer lugar do projeto: 

<?php

return [
    'url' => env('PUNK_BASE_URL', 'https://api.punkapi.com/v2')
];

Usando o helper env significa dizer que, se não houver a constante PUNK_BASE_URL setada no arquivo .env do projeto, seu valor será o segundo parâmetro: http://api.punkapi.com/v2 e no arquivo PunkapiService.php da pasta app/Services fica:

<?php

namespace App\Services;

use Illuminate\Support\Facades\Http;

class PunkapiService
{
    public function getBeers()
    {
        return Http::get('/beers');
    }
}

MACRO é uma forma de criar funções customizadas:
 em app\Providers vamos acessar o arquivo AppServiceProvider.php que é uma classe que tem dois métodos register e boot. No método boot vamos chamar o método Http do laravel e chamar o método macro, no primeiro parâmetro será um nome atribuído à função e e o segundo uma clausure (uma função).
Neste arquivo é passado o arquivo de configuração da url (em 'config/punkapi.php') além de tokens, headers,...
 

use Illuminate\Support\Facades\Http; -> deve ser importado
E a função boot fica:

  public function boot()
    {
        Http::macro('punkapi', function(){
            return Http::acceptJson()
            ->baseUrl(config('punkapi.url'));
        });
    }

Então criamos uma macro(uma função customizada) chamada punkapi que já retorna o client com accept/Json no Header e com o baseUrl configurado lá do arquivo /config/punkapi.php e se estiver setado no .env pegará de lá.

/app/Services/PunkapiService.php fica:

<?php

namespace App\Services;

use Illuminate\Support\Facades\Http;

class PunkapiService
{
    public function getBeers()
    {
        return Http::punkapi()->get('/beers');
    }
}

*obs.: a baseUrl poderia ser setada no construtor, que pode setar token também.(uma outra abordagem para versão sem macros);

->Testamos o retorno Json em localhost:8000/beers.

Refatorando o arquivo PunkapiService.php: O client Http não lança exceção e podemos forçar o retorno em modo Json:
<?php

namespace App\Services;

use Illuminate\Support\Facades\Http;

class PunkapiService
{
    public function getBeers()
    {
       // return Http::punkapi()->get('/beers');
       return Http::punkapi()
            ->get('/beers')
            ->throw()  // Exceção em caso de erro
            ->json();   // Força o retorno em formato Json
    }
}

Podemos testar forçando um erro alterando a constante PUNKAPI_BASE_URL criada em /config/punkapi.php, vamos atribuir um valor diferente no arquivo .env:

PUNKAPI_BASE_URL="adfjklj878"

Podemos usar a função retry tem dois parâmetros, o número de tentativas pra buscar a requisição e o intervalo entre elas. Refatorando o código fica:
<?php

namespace App\Services;

use Illuminate\Support\Facades\Http;

class PunkapiService
{
    public function getBeers()
    {
       // return Http::punkapi()->get('/beers');
       return Http::punkapi()
            ->get('/beers')
            ->throw()  // Exceção em caso de erro
            ->json();   // Força o retorno em formato Json
    }
}

- Quando sai a exceção nao deveriamos retornar o erro em json por ser um api neste caso estamos usamos um app web e não uma api. E usaríamos o Route Api.

Refatorando o método boot de /app/Providers/AppServiceProvider.php, inserindo o retry():

     */
    public function boot()
    {
        Http::macro('punkapi', function(){
            return Http::acceptJson()
            ->baseUrl(config('punkapi.url'))
            ->retry(3,100);
        });
    }
}

comando de help

* sail composer dump-autoload
* Verificar Nome do arquivo se bate com o nome das rotas(Classes criadas e importar o nome errado);
* inteliphense

Refatorando BeerController.php
<?php

namespace App\Http\Controllers;

use App\Services\PunkapiService;

class BeerController extends Controller
{
    public function index()
    {

    $service = new PunkapiService();

    return $service->getBeers();
    }
}

Em vez de instanciar o método PunkapiService() dentro de index, vamos passar por parâmetro de index() declarando seu Próprio nome (PunkapiService) como tipo. Fica assim:

<?php

namespace App\Http\Controllers;

use App\Services\PunkapiService;

class BeerController extends Controller
{
    public function index(PunkapiService $service)
    {
    return $service->getBeers();
    }
}

Assim usamos feactures do php(injeção de dependências) e ao mesmo tempo feactures do laravel. Em vez de criar uma instância dentro do método index, vamos injetar a classe como parâmetro para o método index(), ficando index($service) e a instância de dentro da função passa como parâmetro de 'tipo da variável'. Isso quebra a cadeia de dependência entre as classes.
Assim, o método index ganha independência não mais dependendo da instância de new PunkapiService e passamos a olhar a função index em si.
Assim, o Laravel tenta fazer um binding, um match, o laravel tenta encontrar alguma classe PunkapiService e cria uma instância dessa classe e usa ali como parâmetro. Se não fizer assim, lá em Rotas teria que ser passado como parâmetro o que fica desnecessário.
Não poderia ser feito se na classe PunkapiService existisse o construtor para atribuir valores automaticamente à classe. Assim podemos usar porque não precisamos passar nenhum valor.

ADICIONAR OS FILTROS:
Vamos filtrar o retorno api com os seguintes itens: beer_name, food, ibu_gt, malte:

var_dump($v)
die();
dd($variável)
benchmarck -> ?

/*****REFATORA PARA TESTE alterando BeerController.php e PunkapiService.php
BeerController.php
<?php

namespace App\Http\Controllers;

use App\Services\PunkapiService;

class BeerController extends Controller
{
    public function index(PunkapiService $service)
    {
    return $service->getBeers(
        'heineken',
        'cheese',
        'corn',
        45
    );
    }
}

PunkapiService.php
<?php

namespace App\Services;

use Illuminate\Support\Facades\Http;

class PunkapiService
{
    public function getBeers(
        string $beer_name,
        string $food,
        string $malt,
        string $ibu_gt
    )
    {
        $params = get_defined_vars();

        dd($params);

        return Http::punkapi()
            ->get('/beers', $params)
            ->throw()  // Exceção em caso de erro
            ->json();   // Força o retorno em formato Json
    }
}

Resultado do debug no insomnia ou no navegador:
array:4 [▼ // app/Services/PunkapiService.php:18
  "beer_name" => "heineken"
  "food" => "cheese"
  "malt" => "corn"
  "ibu_gt" => "45"
]
//* fim teste

Refatorando:

class PunkapiService
{
    public function getBeers(
        string $beer_name = null,
        string $food = null,
        string $malt = null,
        string $ibu_gt = null
    )
    {
        $params = get_defined_vars();

        dd($params);

        return Http::punkapi()
            ->get('/beers', $params)
            ->throw()  // Exceção em caso de erro
            ->json();   // Força o retorno em formato Json
    }
}

Assim quando não passar o valor para a chave ele exibirá a chave e o valor Null, vamos refatorar para não exibir nem a chave englobando get_defined_vers() com array_filter no arquivo PunkapiService.php:

$params = array_filter(get_defined_vars());

<?php

namespace App\Http\Controllers;

use App\Services\PunkapiService;

class BeerController extends Controller
{
    public function index(PunkapiService $service)
    {
    return $service->getBeers(
        'heineken',
        'cheese',
        'corn',
       // 45 -> Esse não é passado
    );
    }
}


array:3 [▼ // app/Services/PunkapiService.php:18
  "beer_name" => "heineken"
  "food" => "cheese"
  "malt" => "corn"
	Aqui não exibiu o valor 45
]


USANDO A FUNÇÃO NAMED_ARGS passamos só os parâmetros que precisamos retornar da api e o php com essa função saberá qual a posição dela no array de argumentos passados como parâmetro sem a necessidade de seguir a mesma sequência dos argumentos:
class BeerController extends Controller
{
    public function index(PunkapiService $service)
    {
    return $service->getBeers(food: 'cheese');
    }
}

REFATORANDO:
BeerController.php
<?php

namespace App\Http\Controllers;

use App\Services\PunkapiService;
use Illuminate\Http\Request;

class BeerController extends Controller
{
    public function index( Request $request, PunkapiService $service)
    {
    return $service->getBeers(...$request->all());
    }
}

PunkapiService.php
<?php

namespace App\Services;

use Illuminate\Support\Facades\Http;

class PunkapiService
{
    public function getBeers(
        string $beer_name = null,
        string $food = null,
        string $malt = null,
        string $ibu_gt = null
    )
    {
        $params = array_filter(get_defined_vars());

     //   dd($params);

        return Http::punkapi()
            ->get('/beers', $params)
            ->throw()  // Exceção em caso de erro
            ->json();   // Força o retorno em formato Json
    }
}

CRIANDO UMA REQUEST
sail artisan make:request BeerRequest
/app/Http/Requests/BeerRequest.php

* clouser é uma função passada como parâmetro


AGRUPANDO AS ROTAS 2:01MINUTO 
open laravel week | MVC, rotas , services, api, filas, redis laravel Excel e S3 | Mosturação










 
































/**************************************/

sail share

sail artisan sail:publish ->coloca em uma pasta na raiz chamada docker

sail --help

sail artisan optimizer:clear

sail ps

sail build --no-cache -> faz o bild da aplicação. (dá um sail down  por precaução antes.)










/*********************************

root@DELLAGS:~# curl -s "https://laravel.build/laravel-9-course?with=mysql,redis,mailhog" | bash

Dockerfile

root@DELLAGS:~/example-app# docker exec -it example-app-mysql-1 bash


FROM wyveo/nginx-php-fpm:latest
WORKDIR /usr/share/nginx
RUN rm -rf /usr/share/nginx/html
COPY . /usr/share/nginx
RUN chmod -R 755 /usr/share/nginx/storage/*
RUN ln -s public html

.env (do composer)

DB_CONNECTION=mysql
DB_HOST=mysql-app (serviço do mysql no docker-compose.yaml)
DB_PORT=3306
DB_DATABASE=laraveldockerdb
DB_USERNAME=root
DB_PASSWORD=123456



docker-compose.yaml

version: '3'

services:
  laraveldocker-app:
    build: .
    ports:
      - "3003:80"
    volumes:
      - ./:/usr/share/nginx
      - .docker/nginx:/etc/nginx/conf.d/
    networks:
      - app-network
  mysql-app:
    image: mysql:5.7.22
    ports:
      - "3306:3306"
    volumes:
      - .docker/dbdata:/var/lib/mysql
    environment:
      MYSQL_DATABASE: laraveldocker
      MYSQL_ROOT_PASSWORD: 123456
    networks:
      - app-network
networks:
  app-network:
    driver: bridge
    



/*************************************************
#criando um serviço com um nome qualquer
version: '3'

services:
  laravel-app:                    #criando um serviço com um nome qualquer
    build: . ou image: wyveo/nginx-php-fpm:latest -> neste caso sem Dockerfile.                    # endereço da imagem ou local do Dockerfile (neste caso o ponto siginifica a raiz do projeto)
    ports:
      - "8080:80"                 # 8080 porta do meu host: 80 é a porta do docker nginx
    volumes:                      # docker-compose up -d -> sobe a imagem e libera o terminal  
      - ./:/usr/share/nginx       # TUDO QUE ESTIVE NA RAIZ (na rais tem o meu projeto laravel) './' IRÁ SER REFLETIDO NA PASTA /usr/share/nginx (pasta de acesso da página html)
                                  # C:\Laravel-docker\laravel-docker>docker compose up -d --build atualiza a minha imagem

  mysql-app:
      image: mysql:5.7
      ports:
        - "3306:3306"
      volumes:
        - .docker/dbdata:/var/lib/mysql          # qualqer nome (para persistir -guardar os dados do banco de dados)


      environment:
        MYSQL_DATABASE: laravel
        MYSQL_ROOT_PASSWORD: laravel
    
      

      /***************************///


  
C:\Laravel-docker\laravel-docker>docker compose up -d --build

                                
                               

    

/******************************** Dockerfile
FROM wyveo/nginx-php-fpm:latest

/***************************///
  COMANDOS

docker compose down -> para todos os containers
C:\Laravel-docker\laravel-docker>docker exec -it laravel-docker-laravel-app-1 bash 
root@612ea0ea3340:/# cd /usr/share/nginx/
root@612ea0ea3340:/usr/share/nginx# php artisan migrate
root@612ea0ea3340:/usr/share/nginx# php artisan serve

		
/***********/
PS C:\Users\alber> docker run -e MYSQL_ROOT_PASSWORD=root --name meu-mysql -d mysql:5.7

docker inspect meu-mysql ou | grep IPAddress

PS C:\Users\alber> docker run -e MYSQL_ROOT_PASSWORD=root --name meu-mysql -d -p 3306:3306 mysql:5.7

docker ps
docker ps -l
docker ps -a
docker rm -f nome


/*** LARAVEL */
### CRIANDO UM PROJETO NO LARAVEL 
laravel new projeto_laravel_via_installer (ESTA É UM AOPÇÃO)
composer create-project --prefer-dist laravel/laravel app_controle_tarefas "8.5.9"
cd app_controle_tarefas
cd public
php -S localhost:8000

ou 
da raiz do projeto:
php artisan serve 
ou
php artisan serve --port=3000

### PARA ABRIR PORTA EM OUTRO SERVIDOR
php artisan serve --host test.com --port 8080

 **********************************************************************
cd app_controle_tarefas
cd public
php artisan serve
- acessa o navegador http://localhost:8000

### DENTRO DO PROJETO CRIADO INSTALAR O LARAVEL/UI:^3.2 - versão 3.2
composer require laravel/ui:^3.2

### SE OCORRER ERRO AUMENTAR A MEMÓRIA DISPONIVEL PARA O php

-php --ini -> localiza o arquivo de configuração do php
LOCALIZA memory_limit = 1000 e altera para 
         memory_limit  = -1 e Salva

### LISTA A RELAÇÃO DE COMANDOS 
php artisan list 

DEVERA SURGIR AS OPÇÕES ABAIXO:

 ui
  ui:auth               Scaffold basic login and registration views and routes
  ui:controllers        Scaffold the authentication controllers
 vendor

### ENTENDENDO O PACOTE UI E INICIANDO A AUTENTICAÇÃO WEB NATIVA DO LARAVEL

COMANDO PARA LISTAR ROUTES: 
php artisan route:list

### php artisan ui bootstrap --auth (bootstrap ou react ou vue)
aplicando o bootstrap incluindo os recursos de autenticação;
poderia ser aplicado o bootstrap sem os recursos de autenticação;

### php artisan route:list -> mostra as rotas - ver que aumentaram as rotas

### APÓS ESSE PROCESSO O SISTEMA PEDE PARA RODAR
npm install -> instala as dependências do package.json (inclusive o bootstrap)
npm run dev -> gera os assets da aplicação de acordo com a tecnologia selecionada (bootstrap, react ou vue) -> Geralmente roda mais de uma vez para compilar tudo.

### CRIA O BANCO DE DADOS NORMALMENTE

### EXECUTA AS MIGRATIONS PADRÕES CRIADAS PARA O SISTEMA DE login
php artisan migrate -> CRIA AS TABELAS NO BANCO DE DADOS


************************************** 
INSTALANDO O COMPOSER NO UBUNTU
**************************************
sudo apt update
sudo apt install php-cli unzip

cd ~

curl -sS https://getcomposer.org/installer -o composer-setup.php

HASH=`curl -sS https://composer.github.io/installer.sig`

echo $HASH ->saída: Output
e0012edf3e80b6978849f5eff0d4b4e4c79ff1609dd1e613307e16318854d24ae64f26d17af3ef0bf7cfb710ca74



php -r "if (hash_file('SHA384', 'composer-setup.php') === '$HASH') { echo 'Installer verified'; } else { echo 'Installer corrupt'; unlink('composer-setup.php'); } echo PHP_EOL;"

sudo php composer-setup.php --install-dir=/usr/local/bin --filename=composer





***********************

DigitalOcean Kubernetes: novo plano de controle é mais rápido e gratuito, habilita HA para SLA de 99,95% de tempo de atividade
Produtos
Preços

Documentos
divisa suspensa

Entrar
divisa suspensa

// Tutorial //
Como Instalar e Utilizar o Composer no Ubuntu 20.04
Publicado em 21 de maio de 2020
Ubuntu
PHP
Ubuntu 20.04
Avatar padrão
Por Erika Heidi
Advogado Desenvolvedor
Português
Como Instalar e Utilizar o Composer no Ubuntu 20.04
Introdução
O Composer é uma ferramenta popular de gerenciamento de dependências para o PHP, criado para facilitar a instalação e a atualização das dependências principalmente do projeto. Ele controla quais outros pacotes de projeto específico dependem e são instalados para você, usando as opções apropriadas de acordo com os requisitos do projeto. O Composer também é comumente utilizado para inicializar novos projetos em frameworks PHP populares, como o Symfon e o Laravel .

Neste tutorial, você instalará e começará a usar o Composer em um sistema Ubuntu 20.04.

Pré-requisitos
Para seguir este guia, você pode acessar um servidor como usuário Ubuntu20.04 como usuário sudonão-root um firewall habilitado em seu servidor Para configurar isto, siga nosso guia Configuração do servidor inicial para o Ubuntu 20.04

Passo 1 — Instalando o PHP e as Dependências Adicionais
Além das dependências que já devem estar incluídas em seu sistema Ubuntu 20.04, como o , o Composer exige ou gitexecuta scripts PHP na linha de comando e para extrair arquivos zipados. Vamos instalar essas dependências agora.curlphp-cliunzip

primeiro, atual, gerenciador de pacotes de soluções: o cache do gerenciador de pacotes

sudo apt update
Em seguida, o seguinte comando para instalar os pacotes, execute:

sudo apt install php-cli unzip
Você será solicitado a confirmar a instalação digitando Ye, depois, ENTER.

Assim que os pré-requisitos para instalação do Composer forem instalados, você poderá seguir.

Passo 2 — Baixando e Instalando o Compositor
O Composer fornece um instalador de script escrito em PHP. Vamos baixá-lo, verificar se ele não está danificado e, em seguida, o usaremos para instalar o Composer.

Certifique-se de estar em sua pasta home. Em seguida, baixe o instalador usando o curl:

cd ~
curl -sS https://getcomposer.org/installer -o composer-setup.php
Em seguida, vamos verificar se o instalador baixado corresponde ao hash SHA-384 para o instalador mais recente encontrado na página Composer Public Keys / Signatures . Para facilitar o passo de seleção, você pode usar o seguinte comando para obter programaticamente o hash mais recente da página do Composer e armazená-lo em uma variável do shell:

HASH=`curl -sS https://composer.github.io/installer.sig`
Se você quiser verificar o valor realizado, execute:

echo $HASH
Output
e0012edf3e80b6978849f5eff0d4b4e4c79ff1609dd1e613307e16318854d24ae64f26d17af3ef0bf7cfb710ca74755a
Agora o código PHP a seguir, execute conforme a página de download do Composer, para verificar se o script de instalação está seguro para ser executado:

php -r "if (hash_file('SHA384', 'composer-setup.php') === '$HASH') { echo 'Installer verified'; } else { echo 'Installer corrupt'; unlink('composer-setup.php'); } echo PHP_EOL;"
Você verá o seguinte resultado:

Resultado
Installer verified
Se Installer corruptvocê estiver usando o hash correto, verifique se você está usando o hash correto. Em seguida, repita o processo de verificação. Quando você tiver um instalador selecionado, você pode continuar.

Para instalar o composerglobalmente, use o seguinte comando que baixará e instalará o Composer como um comando disponível em todo o sistema chamado composer, sob /usr/local/bin:

sudo php composer-setup.php --install-dir=/usr/local/bin --filename=composer
Você verá um resultado semelhante com este:

Output
All settings correct for using Composer
Downloading...

Composer (version 1.10.5) successfully installed to: /usr/local/bin/composer
Use it: php /usr/local/bin/composer
Para testar sua instalação, execute:

composer
Output
   ______
  / ____/___  ____ ___  ____  ____  ________  _____
 / /   / __ \/ __ `__ \/ __ \/ __ \/ ___/ _ \/ ___/
/ /___/ /_/ / / / / / / /_/ / /_/ (__  )  __/ /
\____/\____/_/ /_/ /_/ .___/\____/____/\___/_/
                    /_/
Composer version 1.10.5 2020-04-10 11:44:22

Usage:
  command [options] [arguments]

Options:
  -h, --help                     Display this help message
  -q, --quiet                    Do not output any message
  -V, --version                  Display this application version
      --ansi                     Force ANSI output
      --no-ansi                  Disable ANSI output
  -n, --no-interaction           Do not ask any interactive question
      --profile                  Display timing and memory usage information
      --no-plugins               Whether to disable plugins.
  -d, --working-dir=WORKING-DIR  If specified, use the given directory as working directory.
      --no-cache                 Prevent use of the cache
  -v|vv|vvv, --verbose           Increase the verbosity of messages: 1 for normal output, 2 for more verbose output and 3 for debug
...
Isso verifica que o Composer foi instalado com sucesso em seu sistema e está disponível em todo o sistema.

Nota: se você preferirá ter-lhe-ão separados separados do Composer para projeto hospedado neste servidor, você pode instalar localmente, em uma base por projeto. Este método também é útil quando o usuário do sistema não possui permissão para instalar o software disponível em todo o sistema.

Para fazer isso, use o comando php composer-setup.php. Isso irá gerar um arquivo composer.pharem seu diretório atual, que pode ser executado com o seu atual php composer.phar.

Agora podemos dar uma dependência em como usar o Compose como gerenciar.

Passo 3 — Usando o Compositor em um Projeto PHP
Os projetos PHP geralmente dependentes de bibliotecas externas, e o gerenciamento de dependências e suas versões podem ser complicados. O Composer resolve esse problema de manter um controle de projeto de extensões e dependências, também facilita o processo de descoberta, instalação e atualização de pacotes que são definidos por enquanto.

Para usar o seu projeto, você pode compor um arquivo composer.json. O arquivo composer.jsonComposer quais dependências precisa para baixar seu projeto quais serão as versões de cada pacote tem permissão para instalações e instalações. Isso é muito importante para manter seu projeto consistente e evitar a instalação de versões instáveis ​​que podem causar problemas de compatibilidade retroativa.

Você não precisa criar este arquivo manualmente - é comum ocorrer erros de sintaxe quando fizer isso. O Composer oferece uma maneira de criar um novo arquivo composer.jsoncom base na entrada do usuário, o que é uma boa escolha se você planeja compartilhar seu projeto mais tarde como um pacote público no Packagist . O Composer gera automaticamente um arquivo básico composer.jsonquando você executa um comando composer requirepara incluir uma dependência em um projeto recém-criado.

O processo de uso do Composer para instalar um pacote como uma dependência em um projeto envolve os passos a seguir:

Identifique o tipo de biblioteca que o aplicativo precisa.
uma biblioteca de código aberto adequada no agist.org , o responsável oficial de pacotes para o Compose.
Escolha o pacote de dependência.
Execute composer requirepara incluir a dependência no arquivo composer.jsone instalar o pacote.
Vamos testar isso com uma aplicação de demonstração.

O objetivo desta aplicação é transformar uma determinação determinada em uma string de URL amigável - um slug . Isso é comumente usado para converter os títulos de página para caminhos de URL (Assim como a parte final da URL para este tutorial).

Vamos começar a criar um diretório para o nosso projeto. Vamos chamá-lo de slugify :

cd ~
mkdir slugify
cd slugify
Embora não seja necessário, você pode executar agora um comando composer init para criar um arquivo composer.json detalhado para seu projeto. Como o único objetivo do nosso projeto é demonstrar como instalar dependências com o Composer, usaremos um arquivo composer.json mais simples que será gerado automaticamente quando exigirmos nosso primeiro pacote.

Agora é hora de procurar no Packagist.org por um pacote que pode nos ajudar a gerar slugs. Se você procurar pelo termo “slug” no Packagist, receberá um resultado parecido com este:

Resultados da Pesquisa do Packagist para o termo "slug"

Você verá dois números no lado direito de cada pacote na lista. O número no topo representa quantas vezes o pacote foi instalado através do Composer, e o número em baixo mostra quantas vezes um pacote foi estrelado no GitHub. De um modo geral, os pacotes com mais instalações e mais estrelas tendem a ser mais estáveis, pois mais pessoas os utilizam. Também é importante verificar a descrição do pacote para relevância para garantir que ele é o que você precisa.

Precisamos de um conversor string-to-slug A partir dos resultados da pesquisa, o pacote cocur/slugify, que aparece como o primeiro resultado naquela página, parece ser um bom candidato, com uma quantidade razoável de instalações e estrelas.

Os pacotes no Packagist têm um nome de vendor e um nome de package. Cada pacote tem um identificador único (um namespace) no mesmo formato que o GitHub utiliza para seus repositórios: vendor/package. A biblioteca que queremos instalar utiliza o namespace cocur/slugify. Você precisa de um namespace do pacote para exigi-lo em seu projeto.

Agora que você sabe exatamente qual pacote deseja instalar, você pode executar o composer require para incluí-lo como uma dependência e gerar também o arquivo composer.json para seu projeto. Uma coisa importante é observar a exigência de pacotes. O Composer rastreia as dependências no nível da aplicação e do sistema. As dependências no nível do sistema são importantes para indicar de quais módulos PHP um pacote depende. No caso do pacote cocur/slugify, ele exige um módulo PHP que ainda não instalamos.

Quando um pacote necessário depende de uma biblioteca de sistema que não está atualmente instalada em seu servidor, você receberá um erro informando qual requisito está faltando:

composer require cocur/slugify
Output
Using version ^4.0 for cocur/slugify
./composer.json has been updated
Loading composer repositories with package information
Updating dependencies (including require-dev)
Your requirements could not be resolved to an installable set of packages.

  Problem 1
    - Installation request for cocur/slugify ^4.0 -> satisfiable by cocur/slugify[v4.0.0].
    - cocur/slugify v4.0.0 requires ext-mbstring * -> the requested PHP extension mbstring is missing from your system.
...
Para resolver o problema de dependência do sistema, podemos procurar pelo pacote que falta usando o apt search:

apt search mbstring
Output
Sorting... Done
Full Text Search... Done
php-mbstring/focal 2:7.4+75 all
  MBSTRING module for PHP [default]

php-patchwork-utf8/focal 1.3.1-1 all
  UTF-8 strings handling for PHP

php7.4-mbstring/focal 7.4.3-4ubuntu1 amd64
  MBSTRING module for PHP
Após localizar o nome do pacote correto, você pode utilizar o apt novamente para instalar a dependência de sistema:

sudo apt install php-mbstring
Assim que a instalação terminar, você pode executar novamente o comando composer require:

composer require cocur/slugify
Output
Using version ^4.0 for cocur/slugify
./composer.json has been created
Loading composer repositories with package information
Updating dependencies (including require-dev)
Package operations: 1 install, 0 updates, 0 removals
  - Installing cocur/slugify (v4.0.0): Downloading (100%)         
Writing lock file
Generating autoload files
Como você pode ver na saída, o Composer decidiu automaticamente qual versão do pacote utilizar. Se você verificar o diretório do seu projeto agora, ele irá conter dois arquivos novos: composer.json e composer.lock, e um diretório vendor:

ls -l
Output
total 12
-rw-rw-r-- 1 sammy sammy   59 May  4 13:56 composer.json
-rw-rw-r-- 1 sammy sammy 3229 May  4 13:56 composer.lock
drwxrwxr-x 4 sammy sammy 4096 May  4 13:56 vendor
O arquivo composer.lock é usado para armazenar informações sobre quais versões de cada pacote estão instaladas, e garantir que as mesmas versões sejam usadas se outra pessoa clonar seu projeto e instalar suas dependências. O diretório vendor é onde as dependências do projeto estão localizadas. Você não deve fazer commit da pasta vendor no controle de versão - você precisa apenas incluir os arquivos composer.json e composer.lock.

Ao instalar um projeto que já contém um arquivo composer.json, execute o composer install para baixar as dependências do projeto.

Vamos dar uma olhada rápida em restrições de versão. Se você verificar o conteúdo do seu arquivo composer.json, verá algo parecido com isto:

cat composer.json
Output
{
    "require": {
        "cocur/slugify": "^4.0"
    }
}
Note que há o caractere especial ^ antes do número da versão no composer.json. O Composer suporta várias restrições diferentes e formatos para definir a versão necessária do pacote, para fornecer flexibilidade enquanto também mantém seu projeto estável. O operador circunflexo (^) utilizado pelo arquivo composer.json criado automaticamente é o operador recomendado para a interoperabilidade máxima, seguindo o versionamento semântico. Neste caso, ele define 4.0 como a versão mínima compatível e permite atualizações para qualquer versão futura abaixo de 5.0.

De um modo geral, você não precisará alterar as restrições de versão em seu arquivo composer.json. No entanto, algumas situações podem exigir que você edite manualmente as restrições – por exemplo, quando uma nova versão principal da sua biblioteca requerida é liberada e você deseja atualizar, ou quando a biblioteca que você deseja usar não segue o versionamento semântico.

Aqui estão alguns exemplos para lhe dar um melhor entendimento sobre como as restrições de versão do Composer funcionam:

Restrição	Significado	Exemplo de Versões Permitidas
^1.0	>= 1.0 < 2.0	1.0, 1.2.3, 1.9.9
^1.1.0	>= 1.1.0 < 2.0	1.1.0, 1.5.6, 1.9.9
~1.0	>= 1.0 < 2.0.0	1.0, 1.4.1, 1.9.9
~1.0.0	>= 1.0.0 < 1.1	1.0.0, 1.0.4, 1.0.9
1.2.1	1.2.1	1.2.1
1.*	>= 1.0 < 2.0	1.0.0, 1.4.5, 1.9.9
1.2. *	>= 1.2 < 1.3	1.2.0, 1.2.3, 1.2.9
Para uma visualização mais detalhada das restrições de versão do Composer, consulte a documentação oficial.

A seguir, vamos ver como carregar dependências automaticamente com o Composer.

Passo 4 — Incluindo o Script Autoload
Como o PHP por si só não carrega classes automaticamente, o Composer fornece um script autoload que você pode incluir em seu projeto para obter o carregamento automático para ele. Este arquivo é gerado automaticamente pelo Composer quando você adiciona sua primeira dependência.

A única coisa que você precisa fazer é incluir o arquivo vendor/autoload.php em seus scripts PHP antes de qualquer instância de classe.

Vamos testar isso em nossa aplicação de demonstração. Abra um novo arquivo chamado test.php em seu editor de texto:

nano test.php
Adicione o código a seguir que vem no arquivo vendor/autoload.php, carrega a dependência cocur/slugify, e o utiliza para criar um slug:

test.php
<?php
require __DIR__ . '/vendor/autoload.php';

use Cocur\Slugify\Slugify;

$slugify = new Slugify();

echo $slugify->slugify('Hello World, this is a long sentence and I need to make a slug from it!');
Salve o arquivo e saia do seu editor.

Agora, execute o script.

php test.php
Isso produz a saída hello-world-this-is-a-long-sentence-and-i-need-to-make-a-slug-from-it.

As dependências precisam de atualizações quando novas versões são liberadas. Dessa forma, vamos ver como lidar com isso.

Passo 5 — Atualizando as Dependências do Projeto
Sempre que você quiser atualizar suas dependências do projeto para versões mais recentes, execute o comando update:

composer update
Isso irá verificar por versões mais recentes das bibliotecas que você requer em seu projeto. Se uma versão mais recente for encontrada e ela for compatível com a restrição de versão definida no arquivo composer.json, o Composer substituirá a versão anterior instalada. O arquivo composer.lock será atualizado para refletir essas alterações.

Você também pode atualizar uma ou mais bibliotecas específicas, especificando-as desta forma:

composer update vendor/package vendor2/package2
Certifique-se de verificar em seus arquivos composer.json e composer.lock dentro do seu sistema de controle de versão após atualizar suas dependências de modo que outros também possam instalar essas versões mais recentes.

Conclusão





***********
Algoritmo "CalculoMedia2"
// Disciplina: Lógica de programação
// Professor : Antonio Carlos Nicolodi
// Descrição : calculo da média aritimética
// Autor     : Professor Antonio
// Data atual: 01/04/2015
var
// Seção de Declarações
   v1, v2, total: Real
   sinal : Caracter
Inicio
// Seção dos Comandos
   Escreva ("Digite o primeiro valor: ")
   Leia (v1)
   Escreva ("Digite a operação + - * / : ")
   Leia (sinal)
   Escreva ("Digite o segundo valor: ")
   Leia (v2)

   Se sinal = "+" entao
   total <- v1 + v2
   Escreva("O Resultado é: ", total)
   Senao
   Se sinal = "-" entao
   total <- v1 - v2
   Escreva("O Resultado é: ", total)
   Senao
   Se sinal = "*" entao
   total <- v1 * v2
   Escreva("O Resultado é: ", total)


   Senao
     Escreva("OPERAÇÃO INVÁLIDA! ")



      Escreval("total")
   fimse
Fimalgoritmo

****
COMANDOS DOCKER
root@DELLAGS:~# curl -s "https://laravel.build/laravel-9-course?with=mysql,redis,mailhog" | bash

root@DELLAGS:~/example-app# ./vendor/bin/sail  artisan migrate --seed -> criar o banco de dados e copular dados;

Dockerfile

root@DELLAGS:~/example-app# docker exec -it example-app-mysql-1 bash


FROM wyveo/nginx-php-fpm:latest
WORKDIR /usr/share/nginx
RUN rm -rf /usr/share/nginx/html
COPY . /usr/share/nginx
RUN chmod -R 755 /usr/share/nginx/storage/*
RUN ln -s public html

.env (do composer)

DB_CONNECTION=mysql
DB_HOST=mysql-app (serviço do mysql no docker-compose.yaml)
DB_PORT=3306
DB_DATABASE=laraveldockerdb
DB_USERNAME=root
DB_PASSWORD=123456



docker-compose.yaml

version: '3'

services:
  laraveldocker-app:
    build: .
    ports:
      - "3003:80"
    volumes:
      - ./:/usr/share/nginx
      - .docker/nginx:/etc/nginx/conf.d/
    networks:
      - app-network
  mysql-app:
    image: mysql:5.7.22
    ports:
      - "3306:3306"
    volumes:
      - .docker/dbdata:/var/lib/mysql
    environment:
      MYSQL_DATABASE: laraveldocker
      MYSQL_ROOT_PASSWORD: 123456
    networks:
      - app-network
networks:
  app-network:
    driver: bridge
    



/*************************************************
#criando um serviço com um nome qualquer
version: '3'

services:
  laravel-app:                    #criando um serviço com um nome qualquer
    build: . ou image: wyveo/nginx-php-fpm:latest -> neste caso sem Dockerfile.                    # endereço da imagem ou local do Dockerfile (neste caso o ponto siginifica a raiz do projeto)
    ports:
      - "8080:80"                 # 8080 porta do meu host: 80 é a porta do docker nginx
    volumes:                      # docker-compose up -d -> sobe a imagem e libera o terminal  
      - ./:/usr/share/nginx       # TUDO QUE ESTIVE NA RAIZ (na rais tem o meu projeto laravel) './' IRÁ SER REFLETIDO NA PASTA /usr/share/nginx (pasta de acesso da página html)
                                  # C:\Laravel-docker\laravel-docker>docker compose up -d --build atualiza a minha imagem

  mysql-app:
      image: mysql:5.7
      ports:
        - "3306:3306"
      volumes:
        - .docker/dbdata:/var/lib/mysql          # qualqer nome (para persistir -guardar os dados do banco de dados)


      environment:
        MYSQL_DATABASE: laravel
        MYSQL_ROOT_PASSWORD: laravel
    
      

      /***************************///


  
C:\Laravel-docker\laravel-docker>docker compose up -d --build

                                
                               

    

/******************************** Dockerfile
FROM wyveo/nginx-php-fpm:latest

/***************************///
  COMANDOS

docker compose down -> para todos os containers
C:\Laravel-docker\laravel-docker>docker exec -it laravel-docker-laravel-app-1 bash 
root@612ea0ea3340:/# cd /usr/share/nginx/
root@612ea0ea3340:/usr/share/nginx# php artisan migrate
root@612ea0ea3340:/usr/share/nginx# php artisan serve

		
/***********/
PS C:\Users\alber> docker run -e MYSQL_ROOT_PASSWORD=root --name meu-mysql -d mysql:5.7

docker inspect meu-mysql ou | grep IPAddress

PS C:\Users\alber> docker run -e MYSQL_ROOT_PASSWORD=root --name meu-mysql -d -p 3306:3306 mysql:5.7

docker ps
docker ps -l
docker ps -a
docker rm -f nome


/*** LARAVEL */
### CRIANDO UM PROJETO NO LARAVEL 
laravel new projeto_laravel_via_installer (ESTA É UM AOPÇÃO)
composer create-project --prefer-dist laravel/laravel app_controle_tarefas "8.5.9"
cd app_controle_tarefas
cd public
php -S localhost:8000

ou 
da raiz do projeto:
php artisan serve 
ou
php artisan serve --port=3000

### PARA ABRIR PORTA EM OUTRO SERVIDOR
php artisan serve --host test.com --port 8080

 **********************************************************************
cd app_controle_tarefas
cd public
php artisan serve
- acessa o navegador http://localhost:8000

### DENTRO DO PROJETO CRIADO INSTALAR O LARAVEL/UI:^3.2 - versão 3.2
composer require laravel/ui:^3.2

### SE OCORRER ERRO AUMENTAR A MEMÓRIA DISPONIVEL PARA O php

-php --ini -> localiza o arquivo de configuração do php
LOCALIZA memory_limit = 1000 e altera para 
         memory_limit  = -1 e Salva

### LISTA A RELAÇÃO DE COMANDOS 
php artisan list 

DEVERA SURGIR AS OPÇÕES ABAIXO:

 ui
  ui:auth               Scaffold basic login and registration views and routes
  ui:controllers        Scaffold the authentication controllers
 vendor

### ENTENDENDO O PACOTE UI E INICIANDO A AUTENTICAÇÃO WEB NATIVA DO LARAVEL

COMANDO PARA LISTAR ROUTES: 
php artisan route:list

### php artisan ui bootstrap --auth (bootstrap ou react ou vue)
aplicando o bootstrap incluindo os recursos de autenticação;
poderia ser aplicado o bootstrap sem os recursos de autenticação;

### php artisan route:list -> mostra as rotas - ver que aumentaram as rotas

### APÓS ESSE PROCESSO O SISTEMA PEDE PARA RODAR
npm install -> instala as dependências do package.json (inclusive o bootstrap)
npm run dev -> gera os assets da aplicação de acordo com a tecnologia selecionada (bootstrap, react ou vue) -> Geralmente roda mais de uma vez para compilar tudo.

### CRIA O BANCO DE DADOS NORMALMENTE

### EXECUTA AS MIGRATIONS PADRÕES CRIADAS PARA O SISTEMA DE login
php artisan migrate -> CRIA AS TABELAS NO BANCO DE DADOS


************************************** 
INSTALANDO O COMPOSER NO UBUNTU
**************************************
sudo apt update
sudo apt install php-cli unzip

cd ~

curl -sS https://getcomposer.org/installer -o composer-setup.php

HASH=`curl -sS https://composer.github.io/installer.sig`

echo $HASH ->saída: Output
e0012edf3e80b6978849f5eff0d4b4e4c79ff1609dd1e613307e16318854d24ae64f26d17af3ef0bf7cfb710ca74



php -r "if (hash_file('SHA384', 'composer-setup.php') === '$HASH') { echo 'Installer verified'; } else { echo 'Installer corrupt'; unlink('composer-setup.php'); } echo PHP_EOL;"

sudo php composer-setup.php --install-dir=/usr/local/bin --filename=composer





***********************

DigitalOcean Kubernetes: novo plano de controle é mais rápido e gratuito, habilita HA para SLA de 99,95% de tempo de atividade
Produtos
Preços

Documentos
divisa suspensa

Entrar
divisa suspensa

// Tutorial //
Como Instalar e Utilizar o Composer no Ubuntu 20.04
Publicado em 21 de maio de 2020
Ubuntu
PHP
Ubuntu 20.04
Avatar padrão
Por Erika Heidi
Advogado Desenvolvedor
Português
Como Instalar e Utilizar o Composer no Ubuntu 20.04
Introdução
O Composer é uma ferramenta popular de gerenciamento de dependências para o PHP, criado para facilitar a instalação e a atualização das dependências principalmente do projeto. Ele controla quais outros pacotes de projeto específico dependem e são instalados para você, usando as opções apropriadas de acordo com os requisitos do projeto. O Composer também é comumente utilizado para inicializar novos projetos em frameworks PHP populares, como o Symfon e o Laravel .

Neste tutorial, você instalará e começará a usar o Composer em um sistema Ubuntu 20.04.

Pré-requisitos
Para seguir este guia, você pode acessar um servidor como usuário Ubuntu20.04 como usuário sudonão-root um firewall habilitado em seu servidor Para configurar isto, siga nosso guia Configuração do servidor inicial para o Ubuntu 20.04

Passo 1 — Instalando o PHP e as Dependências Adicionais
Além das dependências que já devem estar incluídas em seu sistema Ubuntu 20.04, como o , o Composer exige ou gitexecuta scripts PHP na linha de comando e para extrair arquivos zipados. Vamos instalar essas dependências agora.curlphp-cliunzip

primeiro, atual, gerenciador de pacotes de soluções: o cache do gerenciador de pacotes

sudo apt update
Em seguida, o seguinte comando para instalar os pacotes, execute:

sudo apt install php-cli unzip
Você será solicitado a confirmar a instalação digitando Ye, depois, ENTER.

Assim que os pré-requisitos para instalação do Composer forem instalados, você poderá seguir.

Passo 2 — Baixando e Instalando o Compositor
O Composer fornece um instalador de script escrito em PHP. Vamos baixá-lo, verificar se ele não está danificado e, em seguida, o usaremos para instalar o Composer.

Certifique-se de estar em sua pasta home. Em seguida, baixe o instalador usando o curl:

cd ~
curl -sS https://getcomposer.org/installer -o composer-setup.php
Em seguida, vamos verificar se o instalador baixado corresponde ao hash SHA-384 para o instalador mais recente encontrado na página Composer Public Keys / Signatures . Para facilitar o passo de seleção, você pode usar o seguinte comando para obter programaticamente o hash mais recente da página do Composer e armazená-lo em uma variável do shell:

HASH=`curl -sS https://composer.github.io/installer.sig`
Se você quiser verificar o valor realizado, execute:

echo $HASH
Output
e0012edf3e80b6978849f5eff0d4b4e4c79ff1609dd1e613307e16318854d24ae64f26d17af3ef0bf7cfb710ca74755a
Agora o código PHP a seguir, execute conforme a página de download do Composer, para verificar se o script de instalação está seguro para ser executado:

php -r "if (hash_file('SHA384', 'composer-setup.php') === '$HASH') { echo 'Installer verified'; } else { echo 'Installer corrupt'; unlink('composer-setup.php'); } echo PHP_EOL;"
Você verá o seguinte resultado:

Resultado
Installer verified
Se Installer corruptvocê estiver usando o hash correto, verifique se você está usando o hash correto. Em seguida, repita o processo de verificação. Quando você tiver um instalador selecionado, você pode continuar.

Para instalar o composerglobalmente, use o seguinte comando que baixará e instalará o Composer como um comando disponível em todo o sistema chamado composer, sob /usr/local/bin:

sudo php composer-setup.php --install-dir=/usr/local/bin --filename=composer
Você verá um resultado semelhante com este:

Output
All settings correct for using Composer
Downloading...

Composer (version 1.10.5) successfully installed to: /usr/local/bin/composer
Use it: php /usr/local/bin/composer
Para testar sua instalação, execute:

composer
Output
   ______
  / ____/___  ____ ___  ____  ____  ________  _____
 / /   / __ \/ __ `__ \/ __ \/ __ \/ ___/ _ \/ ___/
/ /___/ /_/ / / / / / / /_/ / /_/ (__  )  __/ /
\____/\____/_/ /_/ /_/ .___/\____/____/\___/_/
                    /_/
Composer version 1.10.5 2020-04-10 11:44:22

Usage:
  command [options] [arguments]

Options:
  -h, --help                     Display this help message
  -q, --quiet                    Do not output any message
  -V, --version                  Display this application version
      --ansi                     Force ANSI output
      --no-ansi                  Disable ANSI output
  -n, --no-interaction           Do not ask any interactive question
      --profile                  Display timing and memory usage information
      --no-plugins               Whether to disable plugins.
  -d, --working-dir=WORKING-DIR  If specified, use the given directory as working directory.
      --no-cache                 Prevent use of the cache
  -v|vv|vvv, --verbose           Increase the verbosity of messages: 1 for normal output, 2 for more verbose output and 3 for debug
...
Isso verifica que o Composer foi instalado com sucesso em seu sistema e está disponível em todo o sistema.

Nota: se você preferirá ter-lhe-ão separados separados do Composer para projeto hospedado neste servidor, você pode instalar localmente, em uma base por projeto. Este método também é útil quando o usuário do sistema não possui permissão para instalar o software disponível em todo o sistema.

Para fazer isso, use o comando php composer-setup.php. Isso irá gerar um arquivo composer.pharem seu diretório atual, que pode ser executado com o seu atual php composer.phar.

Agora podemos dar uma dependência em como usar o Compose como gerenciar.

Passo 3 — Usando o Compositor em um Projeto PHP
Os projetos PHP geralmente dependentes de bibliotecas externas, e o gerenciamento de dependências e suas versões podem ser complicados. O Composer resolve esse problema de manter um controle de projeto de extensões e dependências, também facilita o processo de descoberta, instalação e atualização de pacotes que são definidos por enquanto.

Para usar o seu projeto, você pode compor um arquivo composer.json. O arquivo composer.jsonComposer quais dependências precisa para baixar seu projeto quais serão as versões de cada pacote tem permissão para instalações e instalações. Isso é muito importante para manter seu projeto consistente e evitar a instalação de versões instáveis ​​que podem causar problemas de compatibilidade retroativa.

Você não precisa criar este arquivo manualmente - é comum ocorrer erros de sintaxe quando fizer isso. O Composer oferece uma maneira de criar um novo arquivo composer.jsoncom base na entrada do usuário, o que é uma boa escolha se você planeja compartilhar seu projeto mais tarde como um pacote público no Packagist . O Composer gera automaticamente um arquivo básico composer.jsonquando você executa um comando composer requirepara incluir uma dependência em um projeto recém-criado.

O processo de uso do Composer para instalar um pacote como uma dependência em um projeto envolve os passos a seguir:

Identifique o tipo de biblioteca que o aplicativo precisa.
uma biblioteca de código aberto adequada no agist.org , o responsável oficial de pacotes para o Compose.
Escolha o pacote de dependência.
Execute composer requirepara incluir a dependência no arquivo composer.jsone instalar o pacote.
Vamos testar isso com uma aplicação de demonstração.

O objetivo desta aplicação é transformar uma determinação determinada em uma string de URL amigável - um slug . Isso é comumente usado para converter os títulos de página para caminhos de URL (Assim como a parte final da URL para este tutorial).

Vamos começar a criar um diretório para o nosso projeto. Vamos chamá-lo de slugify :

cd ~
mkdir slugify
cd slugify
Embora não seja necessário, você pode executar agora um comando composer init para criar um arquivo composer.json detalhado para seu projeto. Como o único objetivo do nosso projeto é demonstrar como instalar dependências com o Composer, usaremos um arquivo composer.json mais simples que será gerado automaticamente quando exigirmos nosso primeiro pacote.

Agora é hora de procurar no Packagist.org por um pacote que pode nos ajudar a gerar slugs. Se você procurar pelo termo “slug” no Packagist, receberá um resultado parecido com este:

Resultados da Pesquisa do Packagist para o termo "slug"

Você verá dois números no lado direito de cada pacote na lista. O número no topo representa quantas vezes o pacote foi instalado através do Composer, e o número em baixo mostra quantas vezes um pacote foi estrelado no GitHub. De um modo geral, os pacotes com mais instalações e mais estrelas tendem a ser mais estáveis, pois mais pessoas os utilizam. Também é importante verificar a descrição do pacote para relevância para garantir que ele é o que você precisa.

Precisamos de um conversor string-to-slug A partir dos resultados da pesquisa, o pacote cocur/slugify, que aparece como o primeiro resultado naquela página, parece ser um bom candidato, com uma quantidade razoável de instalações e estrelas.

Os pacotes no Packagist têm um nome de vendor e um nome de package. Cada pacote tem um identificador único (um namespace) no mesmo formato que o GitHub utiliza para seus repositórios: vendor/package. A biblioteca que queremos instalar utiliza o namespace cocur/slugify. Você precisa de um namespace do pacote para exigi-lo em seu projeto.

Agora que você sabe exatamente qual pacote deseja instalar, você pode executar o composer require para incluí-lo como uma dependência e gerar também o arquivo composer.json para seu projeto. Uma coisa importante é observar a exigência de pacotes. O Composer rastreia as dependências no nível da aplicação e do sistema. As dependências no nível do sistema são importantes para indicar de quais módulos PHP um pacote depende. No caso do pacote cocur/slugify, ele exige um módulo PHP que ainda não instalamos.

Quando um pacote necessário depende de uma biblioteca de sistema que não está atualmente instalada em seu servidor, você receberá um erro informando qual requisito está faltando:

composer require cocur/slugify
Output
Using version ^4.0 for cocur/slugify
./composer.json has been updated
Loading composer repositories with package information
Updating dependencies (including require-dev)
Your requirements could not be resolved to an installable set of packages.

  Problem 1
    - Installation request for cocur/slugify ^4.0 -> satisfiable by cocur/slugify[v4.0.0].
    - cocur/slugify v4.0.0 requires ext-mbstring * -> the requested PHP extension mbstring is missing from your system.
...
Para resolver o problema de dependência do sistema, podemos procurar pelo pacote que falta usando o apt search:

apt search mbstring
Output
Sorting... Done
Full Text Search... Done
php-mbstring/focal 2:7.4+75 all
  MBSTRING module for PHP [default]

php-patchwork-utf8/focal 1.3.1-1 all
  UTF-8 strings handling for PHP

php7.4-mbstring/focal 7.4.3-4ubuntu1 amd64
  MBSTRING module for PHP
Após localizar o nome do pacote correto, você pode utilizar o apt novamente para instalar a dependência de sistema:

sudo apt install php-mbstring
Assim que a instalação terminar, você pode executar novamente o comando composer require:

composer require cocur/slugify
Output
Using version ^4.0 for cocur/slugify
./composer.json has been created
Loading composer repositories with package information
Updating dependencies (including require-dev)
Package operations: 1 install, 0 updates, 0 removals
  - Installing cocur/slugify (v4.0.0): Downloading (100%)         
Writing lock file
Generating autoload files
Como você pode ver na saída, o Composer decidiu automaticamente qual versão do pacote utilizar. Se você verificar o diretório do seu projeto agora, ele irá conter dois arquivos novos: composer.json e composer.lock, e um diretório vendor:

ls -l
Output
total 12
-rw-rw-r-- 1 sammy sammy   59 May  4 13:56 composer.json
-rw-rw-r-- 1 sammy sammy 3229 May  4 13:56 composer.lock
drwxrwxr-x 4 sammy sammy 4096 May  4 13:56 vendor
O arquivo composer.lock é usado para armazenar informações sobre quais versões de cada pacote estão instaladas, e garantir que as mesmas versões sejam usadas se outra pessoa clonar seu projeto e instalar suas dependências. O diretório vendor é onde as dependências do projeto estão localizadas. Você não deve fazer commit da pasta vendor no controle de versão - você precisa apenas incluir os arquivos composer.json e composer.lock.

Ao instalar um projeto que já contém um arquivo composer.json, execute o composer install para baixar as dependências do projeto.

Vamos dar uma olhada rápida em restrições de versão. Se você verificar o conteúdo do seu arquivo composer.json, verá algo parecido com isto:

cat composer.json
Output
{
    "require": {
        "cocur/slugify": "^4.0"
    }
}
Note que há o caractere especial ^ antes do número da versão no composer.json. O Composer suporta várias restrições diferentes e formatos para definir a versão necessária do pacote, para fornecer flexibilidade enquanto também mantém seu projeto estável. O operador circunflexo (^) utilizado pelo arquivo composer.json criado automaticamente é o operador recomendado para a interoperabilidade máxima, seguindo o versionamento semântico. Neste caso, ele define 4.0 como a versão mínima compatível e permite atualizações para qualquer versão futura abaixo de 5.0.

De um modo geral, você não precisará alterar as restrições de versão em seu arquivo composer.json. No entanto, algumas situações podem exigir que você edite manualmente as restrições – por exemplo, quando uma nova versão principal da sua biblioteca requerida é liberada e você deseja atualizar, ou quando a biblioteca que você deseja usar não segue o versionamento semântico.

Aqui estão alguns exemplos para lhe dar um melhor entendimento sobre como as restrições de versão do Composer funcionam:

Restrição	Significado	Exemplo de Versões Permitidas
^1.0	>= 1.0 < 2.0	1.0, 1.2.3, 1.9.9
^1.1.0	>= 1.1.0 < 2.0	1.1.0, 1.5.6, 1.9.9
~1.0	>= 1.0 < 2.0.0	1.0, 1.4.1, 1.9.9
~1.0.0	>= 1.0.0 < 1.1	1.0.0, 1.0.4, 1.0.9
1.2.1	1.2.1	1.2.1
1.*	>= 1.0 < 2.0	1.0.0, 1.4.5, 1.9.9
1.2. *	>= 1.2 < 1.3	1.2.0, 1.2.3, 1.2.9
Para uma visualização mais detalhada das restrições de versão do Composer, consulte a documentação oficial.

A seguir, vamos ver como carregar dependências automaticamente com o Composer.

Passo 4 — Incluindo o Script Autoload
Como o PHP por si só não carrega classes automaticamente, o Composer fornece um script autoload que você pode incluir em seu projeto para obter o carregamento automático para ele. Este arquivo é gerado automaticamente pelo Composer quando você adiciona sua primeira dependência.

A única coisa que você precisa fazer é incluir o arquivo vendor/autoload.php em seus scripts PHP antes de qualquer instância de classe.

Vamos testar isso em nossa aplicação de demonstração. Abra um novo arquivo chamado test.php em seu editor de texto:

nano test.php
Adicione o código a seguir que vem no arquivo vendor/autoload.php, carrega a dependência cocur/slugify, e o utiliza para criar um slug:

test.php
<?php
require __DIR__ . '/vendor/autoload.php';

use Cocur\Slugify\Slugify;

$slugify = new Slugify();

echo $slugify->slugify('Hello World, this is a long sentence and I need to make a slug from it!');
Salve o arquivo e saia do seu editor.

Agora, execute o script.

php test.php
Isso produz a saída hello-world-this-is-a-long-sentence-and-i-need-to-make-a-slug-from-it.

As dependências precisam de atualizações quando novas versões são liberadas. Dessa forma, vamos ver como lidar com isso.

Passo 5 — Atualizando as Dependências do Projeto
Sempre que você quiser atualizar suas dependências do projeto para versões mais recentes, execute o comando update:

composer update
Isso irá verificar por versões mais recentes das bibliotecas que você requer em seu projeto. Se uma versão mais recente for encontrada e ela for compatível com a restrição de versão definida no arquivo composer.json, o Composer substituirá a versão anterior instalada. O arquivo composer.lock será atualizado para refletir essas alterações.

Você também pode atualizar uma ou mais bibliotecas específicas, especificando-as desta forma:

composer update vendor/package vendor2/package2
Certifique-se de verificar em seus arquivos composer.json e composer.lock dentro do seu sistema de controle de versão após atualizar suas dependências de modo que outros também possam instalar essas versões mais recentes.
 -->
exit
pwd
exit
curl
curl -s "https://laravel.build/example-app?with=mysql,redis" |bash
docker
curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -
docker
apt-cache policy docker-ce
docker
curl
curl --help
apt install docker
systemctl status docker
docker
exit
docker
ver
sudo apt-get update
sudo apt-get install ./docker-desktop-<version>-<arch>.deb
sudo apt-get install     ca-certificates     curl     gnupg     lsb-release
sudo mkdir -p /etc/apt/keyrings
curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg
echo   "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu \
  $(lsb_release -cs) stable" | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null
sudo apt-get update
sudo apt-get install docker-ce docker-ce-cli containerd.io docker-compose-plugin
sudo service docker start
sudo docker run hello-world
docker
exit
pwd
ls
cd Desktop
ls
mkdir ProjetosDocker
ls
cd ProjetosDocker/
ls
curl
curl -s "https://laravel.build/example-app?with=mysql,redir" | bash
docker
docker run
systemctl status docker
sudo systemctl status docker
wget -qO- https://get.docker.com/ | sh
curl -L https://github.com/docker/compose/releases/download/1.6.2/docker-compose-`uname -s`-`uname -m` > /usr/local/bin/docker-compose
chmod +x /usr/local/bin/docker-compose
docker-compose version
docker-machine version
docker
curl -s "https://laravel.build/example-app?with=mysql,redir" | bash
docker ls
docker --help
docker start
docker start --help
docker start -i
docker image list
cd ..
cd var
cd /var
cd run
ls
docker
docker run
docker run *
cd /
ls
pwd
cd rn
cd run
ls
docker
docker run
exit
docker
sytemctl status
sudo systemctl
cmd
docker
docker run
curl
curl --help
curl -V
docker -v
code .
cls
clear
docker
clear
docker ps
sudo sevice docker start
sudo service docker start
docker ps
sudo service docker start
docker ps
apt get install docker
apt install docker
docker ps
sudo service docker start
docker ps
sudo service docker start
sudo service docker-start
curl -s "https://laravel.build/example-app?wit..." | bash
docker
docker ps
exit
docker start
docker ps
docker start
docker ps
docker
docker ps
docker --version
docker run hello-world
docker image ls
Enable WSL 2 Windows features
Set-ExecutionPolicy -ExecutionPolicy RemoteSigned
lsb_release -a
dotnet --version
sudo wget https://packages.microsoft.com/config/ubuntu/20.04/packages-microsoft-prod.deb -O packages-microsoft-prod.deb
sudo dpkg -i packages-microsoft-prod.deb
sudo apt-get update
sudo apt-get install apt-transport-https
sudo apt-get update
sudo apt-get install dotnet-sdk-3.1
dotnet --version
code .
docker
sudo apt install gnome-terminal
docker
docker ps
docker start
sudo apt remove docker-desktop
sudo apt-get install ./docker-desktop-<version>-<arch>.deb
sudo apt-get update
sudo apt-get install ./docker-desktop-<version>-<arch>.deb
systemctl --user enable docker-desktop
systemctl --user stop docker-desktop
wsl.exe -l -v
wsl
apt install wsl
code .
curl -s https://laravel.build/example-app | bash
docker
apt get install docker
sudo su
clear
docker ps
y
pwd
ls
cd ProjetosDocker/
pwd
php -v
cls
clear
curl -s "https://laravel.build/example-app?with=mysql,redis,pgsql" |bash
sudo apt-get curl
curl
curl --manual
clear
docker ps
curl -s "https://laravel.build/example-app?with=mysql,redis,pgsql" |bash
docker ps
docker
docker ps
exit
ls
./vendor/bin/sail up
./vendor/bin/sail up -D
./vendor/bin/sail up -d
./vendor/bin/sail ps
./vendor/bin/sail composer require/breeze --dev
./vendor/bin/sail compose require/breeze --dev
./vendor/bin/sail composer require laravel/breeze --dev
sudo su
./vendor/bin/sail composer require laravel/breese --dev
docker ps
docker stop
docker ps
./vendor/bin/sail stop
./vendor/bin/sail composer require laravel/breese --dev
docker start
docker ps
./vendor/bin/sail up
./vendor/bin/sail up -d
docker ps
docker stop
./vendor/bin/sail stop
docker ps
docker ls
docker -ls
docker -l
docker ls
docker --help
docker rmi
docker rm
docker rm --help
docker rm -f
docker ls
list
docker ps
docker start
docker run
docker ps
curl -s "https://laravel.build/example-app?with=mysql,redis" | bash
docker ps
docker ls
ls
cd ProjetosDocker/
cd ..
cd example-app/
code .
docker run -d -p 80:80 docker/getting-started
docker up -d
clear
docker run -d -p 80:80 docker/getting-started
docker up 0094
docker run 7b0aed04f7c251a872242ec415f2d99551385af0c8ceb8409af2ffa9c3fedf6a -d
docker
docker ps
code .
docker
clear
clear ps
docker ps
sudo apt install curl 
exit
pwd
./vendor/bin/sail up -d
cls
clear

./vendor/bin/sail up -d
docker ps
clear
docker ps
./vendor/bin/sail up -d
docker kill
docker stop
doker ps
docker
exit
curl -s "https://laravel.build/laravel-curso?with=mysql,redis,mailhog" |bash
cd laravel-curso/
./vendeor/bin/sail up -d
./vendor/bin/sail up -d
docker ps
code .
./vendor/bin/sail up -d
curl "http://localhost/tutorial/"    -X GET    -H 'host: localhost'    -H 'connection: keep-alive'    -H 'sec-ch-ua: "Chromium";v="106", "Google Chrome";v="106", "Not;A=Brand";v="99"'    -H 'sec-ch-ua-mobile: ?0'    -H 'sec-ch-ua-platform: "Windows"'    -H 'upgrade-insecure-requests: 1'    -H 'user-agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/106.0.0.0 Safari/537.36'    -H 'accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9'    -H 'sec-fetch-site: same-origin'    -H 'sec-fetch-mode: navigate'    -H 'sec-fetch-dest: document'    -H 'referer: http://localhost/'    -H 'accept-encoding: gzip, deflate, br'    -H 'accept-language: pt-BR,pt;q=0.9,en-US;q=0.8,en;q=0.7,es;q=0.6'    -H 'cookie: _ga=GA1.1.171439518.1657383921; _ga_E7H41BFJ0Q=GS1.1.1657462355.2.1.1657462635.0; pma_lang=pt';
clear
./vendor/bin/sail up -d
pwd
ls
cd ProjetosDocker/
ls
cd example-app
ls
cd ..
cd example-app
ls
cd ..
rm -rf example-app
ls
rm-rf laravel-curso/
ls
rm -rf laravel-curso/
clear
ls
cd ProjetosDocker/
ls
curl -s "https://laravel.build/laravel-curso?with=mysql,redis,mailhog" |bash
cd laravel-curso && ./vendor/bin/sail up -d
code .
pwd
ls
cd ProjetosDocker/
ls
rm -rf laravel-curso/
ls
clear
curl -s "https://laravel.build/laravel-curso?with=mysql" |bash
pwd
ls
cd ProjetosDocker/
ls
rm -rf laravel-curso/
ls
cd ..
cd laravel-curso/
ls
exit
php -S localhost:8080
apt install php-cli
php -S localhost:8080
docker run -d -p 80:80 docker/getting-started
curl -s "https://laravel.build/laravel-curso?with=mysql" |bash
docker ps
docker ls
docker -l
docker l
docker ps
docker exec
docker exec -it docker/getting-started bash
docker ps
docker exec -it 6ec4e45db98a bash
docker exec -it 6ec4e45db98a 
docker exec --help
docker exec -it 6ec4e45db98a bash
clear
docker ps
code .
ls
cd laravel-curso/
ls
docker ps
cd ..
ls
pwd
cd socket/
ls
cd ..
cd ProjetosDocker/
ls
cd ..
rm -rf laravel-curso/
ls
cd ..
ls
clear
docker ps
docker exec -it docker/getting-started: bash
docker exec -it docker/getting-started bash
docker exec -it getting-started bash
docker exec -it 6ec4e45db98a bash
docker exec -it 6ec4e45db98a 
ls
cd socket/
ls
cd ..
cd snap
ls
cd ..
cd \
cd /
ls
cd var
ls
cd lib
ls
cd docker
ls
cd containers
ls
cd ..
cd image
ls
cd ..
sudo service docker status
status docker
sudo status docker
sudo service status docker
sudo service docker
sudo service docker status
docker start
cd ..
pwd
ls
cd usr
ls
ls -l
cd ..
docker ps
docker
docker ps
apt-get docker
apt-get install docker 
docker ps
apt-get uninstall docker 
pwd
ls
cd ..
ls
cd usr
ls
cd bin
ls
cd ..
cd lig
cd lib
ls
clear
ls
cd ..
ls
cd usr
ls
ls docker
cld
cd ..
ls
cd ProjetosDocker/
ls
sudo apt update
sudo apt install apt-transport-https ca-certificates curl software-properties-common
curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -
sudo add-apt-repository "deb [arch=amd64] https://download.docker.com/linux/ubuntu focal stable"
sudo apt update
apt-cache policy docker-ce
sudo apt install docker-ce
sudo systemctl status docker
wsl --set-version Ubuntu 2
sudo apt update
sudo apt install apt-transport-https ca-certificates curl software-properties-common
sudo apt install build-essential
curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add
sudo add-apt-repository "deb [arch=amd64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable"
sudo apt update
sudo apt install docker-ce
sudo docker run hello-world
início do docker de serviço sudo
sudo service docker start
sudo docker run hello-world
docker ps
sudo etc
cd etc
ls
cd ..
ls
cd etc
ls
vi init.d
cd ..
ls
sudo apt install docker-ce
sudo service docker status
sudo service docker start
docker ps
ls
cd var/run
ls
vi docker.sock
docker.sock
cd user
ls
cd ..
ls
cd run
ls
cd docker
ls
cd ..
sudo service docker start
docker ps
curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add
sudo add-apt-repository "deb [arch=amd64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable"
sudo docker run hello-world
docker ps
sudo service docker start
sudo service status
sudo service docker start
sudo curl -L "https://github.com/docker/compose/releases/download/1.24.0/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
sudo chmod +x /usr/local/bin/docker-compose
docker-compose --version
ls
cd ProjetosDocker/
code .
curl -s "https://laravel.build/laravel-9-course?with=mysql,redis,mailhog" | bash
docker start
docker ps
sudo apt install docker-ce
docker start
sudo service docker start
curl -s "https://laravel.build/laravel-9-course?with=mysql,redis,mailhog" | bash
docker ps
exit
docker ps
ls
docker ps
clear
docker ps
curl -s "https://laravel.build/laravel-9-course?with=mysql,redis,mailhog" | bash
cd laravel-9-course && ./vendor/bin/sail up -d
docker ps
clear
docker ps
docker ps -l
./vendor/bin/sail up -d
php artisan about
./vendor/bin/sail up -d
docker ps
docker-compose up -d
./vendor/bin/sail up -d
pwd
ls
cd laravel-9-course/
./vendor/bin/sail up -d
docker exec -it b6870e2dd73e bash
clear
ls
cd ..
clear
ls
cd laravel-9-course/
ls
php artisan serve
php artisan
clear
ls
code .
docker ps
docker ps -l
docker exec -it laravel-9-course-laravel.test-1 bash
ls
php artisan serve
vi
vi docker-compose.yml
code .
exit
php artisan serve
exit
php -v
mysql -v
mysql -u root
mysql -u root -p
docker ps
docker ps -l
exit
ls
rm -rf laravel-9-course/
ls
cd example-app/
ls
php -v
mysql -u root -p
apt install mysql-client-core-8.0
mysql -u root -p
jdflkjadsl
curl -s https://laravel.build/example-app | bash
cd example-app && ./vendor/bin/sail up -d
ls
php -S localhost:8000
php artisan serve
ls
cd public/
php -S localhost:8000
php artisan serve
clear
./vendor/bin/sail up -d
php artisan cache:clear
./vendor/bin/sail php artisan cache:clear
./vendor/bin/sail up -d
./vendor/bin/sail php artisan route:clear
./vendor/bin/sail down
./vendor/bin/sail php artisan route:clear
dir
cd public/
php -S localhost:80
cd ..
./vendor/bin/sail up -d
./vendor/bin/sail down
curl -s "https://laravel.build/olw?with=mysql,redis,mailhog,minio" | bash
LS
ls
cd ProjetosDocker/
ls
cd olw
ls
cd ..
cd olw
ls
sail artisan serve
sail php artisan serve
cls
clear
ls
code .
docker ps
clear
docker ps
alias sail='[ -f sail ] && sh sail || sh vendor/bin/sail'
sail up -d
code .
sail down
ls
cd ..
ls
version
ls
cd ..
ls
cd var
ls
cls
ls
cd www
cd /
ls
cd var
ls
cd www
cd ..
ls
cd home
ls
cd alber
ls
cd ..
laravel -v
laravel -V
composer -V
./vendor/bin/sail up -d
./vendor/bin/sail down
./vendor/bin/sail up -d
sail ps
sail down
clear
./vendor/bin/sail ps
./vendor/bin/sail down
./vendor/bin/sail up -d
php artisan --version
./vendor/bin/sail down
./vendor/bin/sail ps
docker up -d
docker run -d
docker ps
./vendor/bin/sail ps
./vendor/bin/sail up -d
docke ps
docker ps
docker exec -it ffc7fa4e28ed bash
docker ps
sail up -d
cd ..
./vendor/bin/sail up -d
docker ps
./vendor/bin/sail up -d
ls
cd home
ls
cd alber/
ls
cd ..
ls
cd ..
ls
cd home
ls
cd var
ls
cd ..
cd var
ls
cd ..
ls
docker ps
exit
wsl --set-version <Distro> 2, – wsl --set-default-version 2
wsl --importe visando WSL 2wsl --export
cls
clear
wsl
wsl2
wsl.exe -l -v
wsl.exe --set-default-version 2
docker ps
./vendor/bin/sail up -d
docker run
docker run olw-laravel.test-1
start-container
docker start-container
docker up start-container
docker run start-container
docker down
clear
docker ps
ls
cd olw
./vendor/bin/sail down
./vendor/bin/sail up -d
./vendor/bin/sail down
ls
cd ..
ls
rm -rf olw
ls
rm -rf ProjetosDocker/
rm -rf example-app/
ls
exit
curl.exe -L -o ubuntu-2004.appx https://aka.ms/wslubuntu2004
wsl --set-default-version 2
Error: 0x1bc
For information on key differences with WSL 2 please visit https://aka.ms/wsl2
[    0.363323] 9p: Installing v9fs 9p2000 file system support
[    0.363336] FS-Cache: Netfs '9p' registered for caching
[    0.398989] 9pnet: Installing 9P2000 support
wsl --update
apt-get upgrade
Get-WindowsOptionalFeature -Online -FeatureName Microsoft-Windows-Subsystem-Linux
sudo service ssh status
debug1: sshd version OpenSSH_7.2, OpenSSL 1.0.2g  1 Mar 2016
debug1: key_load_private: incorrect passphrase supplied to decrypt private key
debug1: key_load_public: No such file or directory
Could not load host key: /etc/ssh/ssh_host_rsa_key
debug1: key_load_private: No such file or directory
debug1: key_load_public: No such file or directory
Could not load host key: /etc/ssh/ssh_host_dsa_key
debug1: key_load_private: No such file or directory
debug1: key_load_public: No such file or directory
Could not load host key: /etc/ssh/ssh_host_ecdsa_key
debug1: key_load_private: No such file or directory
debug1: key_load_public: No such file or directory
Could not load host key: /etc/ssh/ssh_host_ed25519_key
sudo apt-get purge openssh-server
sudo apt-get install openssh-server
wsl --install
wsl --update
wsl --shutdown
exit
sudo apt update
sudo apt install gedit -y
sudo apt-get install     ca-certificates     curl     gnupg     lsb-release
sudo mkdir -p /etc/apt/keyrings
curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg
echo   "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu \
  $(lsb_release -cs) stable" | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null
sudo apt-get update
sudo apt-get install docker-ce docker-ce-cli containerd.io docker-compose-plugin
sudo service docker start
sudo docker run hello-world
sudo su docker run hello-world
docker ps
ps aux | grep docker
sudo service docker status
systemctl start docker
gpasswd -a $USER docker
systemctl start docker
sudo service docker start
docke ps
docker ps
sudo service docker start
sudo service --status-all
sudo service docker start
systemctl enable docker
systemctl restart docker
systemctl enable docker
sudo service docker start
/var/run/docker.sock
sudo nohup docker daemon -H tcp://0.0.0.0:2375 -H unix:///var/run/docker.sock
sudo usermod -aG docker $USER
reboot
docker ps
sudo /var/run/docker.sock
cd  /var/run/docker.sock
cd  /var/run/
ls
cd WSL
ls
cd ..
ls
cd ..
ls
curl -s "https://laravel.build/olw?with=mysql,redis,mailhog,minio" | bash
docker ps
docker start
service docker start
sudo service docker status
sudo service docker start
sudo service docker status
sudo service docker start
sudo service docker status
& $Env:ProgramFiles\Docker\Docker\DockerCli.exe -SwitchDaemon .
docker pull mcr.microsoft.com/windows/nanoserver:ltsc2022
dockerd --debug
docker -H tcp://0.0.0.0:2375 ps
sudo dockerd -H unix:///var/run/docker.sock -H tcp://192.168.59.106 -H tcp://10.10.10.2sudo dockerd -H unix:///var/run/docker.sock -H tcp://192.168.59.106 -H tcp://10.10.10.2
docker --tlsverify ps
docker ps
docker -H :5555 pull ubuntu
docker -H tcp://127.0.0.1:2375 pull ubuntu
docker 
docker ps
docker version
docker ps
systemclt start docker 
systemctl start docker 
docker 
docker -H
docker -H --host list
docker -H --host
docker -H --help
docker ps
curl -s "https://laravel.build/olw?with=mysql,redis,mailhog,minio" | bash
cd olw && ./vendor/bin/sail up
cd olw && ./vendor/bin/sail up -d
cd ..
cd olw
./vendor/bin/sail up -d
./vendor/bin/sail down
./vendor/bin/sail tinker
cls
clear
sail php --version
sail share
sudo chmod 777 storage/ -R
sudo chmod 0777 storage/ -R
./vendor/bin/sail up -d
./vendor/bin/sail down
ls
cd olw
./vendor/bin/sail up -d
sudo chmod 777 storage/ -R
./vendor/bin/sail up -d
code .
./vendor/bin/sail down
curl -s "https://laravel.build/example-app | bash
cd ..
curl -s "https://laravel.build/example-app | bash
ls
curl -s https://laravel.build/example-app | bash
cd example-app/
./vendor/bin/sail up -d
sudo chmod 777 storage/ -R
./vendor/bin/sail up -d
sail share
./vendor/bin/sail share
mysql 
myqsl -u root -p
alias sail='[ -f sail ] && sh sail || sh vendor/bin/sail'
ls
sail ps
./vendor/bin/sail ps
docker ps
cd example-app/
sail ps
sail down
composer global require beyondcode/expose
expose default-server sa-1
expose token 89e90595-06a7-4245-99c9-03536b633447
composer global require beyondcode/expose
ls
php artisan serve
cd public/
php -S localhost:8080
clear
cd..
cd ..
cd example-app/
clear
sail up -d
code .
ls
code .
sail down
cd ..
docker ps
clear
./vendor/bin/sail up -d
cd example-app/
./vendor/bin/sail up -d
code .
./vendor/bin/sail down
php artisan route:list
sail artisan route:list
sail
cls
clear
./vendor/bin/sail list
./vendor/bin/sail down
./vendor/bin/sail up -d
./vendor/bin/sail down
./vendor/bin/sail up -d
/ls
mysql -u root -p
mysql -u sail -p
mysql
docker ps
ls
cd example-app/
./vendor/bin/sail up -d
code .
cd ..
mysql
mysql --version
mysql -u sail -p
cd ..
ls
cd example-app/
clear
mysql -u root -p
cd..
ls
cd ..
sail down
./vendor/bin/sail down
docker ps
cd example-app/
sail down
./vendor/bin/sail down
ls
cd ..
ls
sail up -d
./vendor/bin/sail up -d
cd example-app/
./vendor/bin/sail up -d
docker ps
./vendor/bin/sail up -d
mysql -u root -p
mysql -u sail -p
exit
mysql -u sail -p
./vendor/bin/sail up -d
mysql -u sail -p
clear
./vendor/bin/sail down
mysql -u sail -p
exit
docker ps
docker ps -l
docker ps -a
clear
ls
cd ex
cd example-app/
ls
./vendor/bin/sail up -d
code .
mysql --version
mysql -u sail -p
mysql -u root -p
mysql -u sail -p
mysql --version
myql -u root -p
mysql -u root -p
ls
sudo
sudo chmod 777 storage/ -R
ls
cd ..
ls
cd ..
ls
sudo chmod 777 var/ -R
mysql -u root -p
ls
docker ps
cd example-app/
sail down
./vendor/bin/sail down
./vendor/bin/sail up -d
code .
ls
cd ..
ls
cd ..
ls
cd ..
ls
cd home
ls
cd ..
cd root
ls
cd example-app/
ls
cd ..
docker ps
docker exec -it example-app-mysql-1 bash
ls
cd example-app/
ping localhost:3306
ping 0.0.0.0:3306
clear
./vendor/bin/sail down
sail ps
./vendor/bin/sail ps
ls
cd ..
pwd
ls
cd olw
ls
cd ..
cd example-app/
sail ps
./vendor/bin/sail up -d
sail artisan migrate --seed
p
./vendor/bin/sail  artisan migrate --seed[A
./vendor/bin/sail artisan make:controller UserController
php artisan make:controller UserController
./vendor/bin/sail artisan make:controller UserController
php artisan make:controller UserController
clear
docker ps
./vendor/bin/sail  up -d
php -v
docker ps
docker run hello-world
exit
./vendor/bin/sail artisan serve
docker ps
clear
./vendor/bin/sail  up -d
mysql --v
mysql -v
mysql -u root -p
cd ..
mysql -u root -p
clear
mysql --version;
composer
clear
docker ps -l
docker ps
docker run hello-world
clear
docker ps -l
ls
cd example-app/
./vendor/bin/sail up -d
code .
./vendor/bin/sail down
./vendor/bin/sail up -d
./vendor/bin/sail down
./vendor/bin/sail up -d
./vendor/bin/sail down
./vendor/bin/sail up -d
./vendor/bin/sail down
./vendor/bin/sail up -d
code .
./vendor/bin/sail down
./vendor/bin/sail up -d
ping
ping 127.0.0.1:3307
ping 127.0.0.1:3306
ping 127.0.0.1
ping 127.0.0.1:80
ping 127.0.0.1:6379
ping 127.0.0.1:3306
ping 127.0.0.1:3307
./vendor/bin/sail down
./vendor/bin/sail up -d
code .
./vendor/bin/sail down
./vendor/bin/sail up -d
code .
./vendor/bin/sail down
./vendor/bin/sail up -d
code .
./vendor/bin/sail up -d
./vendor/bin/sail down
./vendor/bin/sail up -d
code .
./vendor/bin/sail up -d
./vendor/bin/sail down
./vendor/bin/sail up -d
code .
./vendor/bin/sail up -d
./vendor/bin/sail down
./vendor/bin/sail up -d
./vendor/bin/sail down
./vendor/bin/sail up -d
./vendor/bin/sail down
./vendor/bin/sail up -d
./vendor/bin/sail down
./vendor/bin/sail up -d
./vendor/bin/sail down
./vendor/bin/sail up -d
./vendor/bin/sail down
./vendor/bin/sail up -d
./vendor/bin/sail down
./vendor/bin/sail up -d
./vendor/bin/sail down
./vendor/bin/sail up -d
./vendor/bin/sail down
./vendor/bin/sail up -d
code .
./vendor/bin/sail up -d
./vendor/bin/sail down
./vendor/bin/sail up -d
./vendor/bin/sail down
./vendor/bin/sail up -d
clear
docker ps
docker exec -it example-app-mysql-1
docker exec -it example-app-mysql-1 bash
./vendor/bin/sail up -d
./vendor/bin/sail down
./vendor/bin/sail up -d
ls
cd example-app/
docker ps
ls
php artisan serve
clear
ls
cd vendor
cd bin
ls
vi sail
clear
code .
ls
cd sail
cd ..
cd vendor
cd bin
sail up -d
cd ..
./vendor/bin/sail up -d
ls
code .
./vendor/bin/sail ps
clear

./vendor/bin/sail down
docker ps -l
docker  -l
ls
cd olw
./vendor/bin/sail up -d
code .
docker ps
./vendor/bin/sail up -d
clear
./vendor/bin/sail up -d
./vendor/bin/sail composer require laravel/breeze --dev
./vendor/bin/sail up -d
./vendor/bin/sail composer require laravel/breeze --dev
cd ..
sudo chmod 777 olw/ -R
./vendor/bin/sail composer require laravel/breeze --dev
cd olw
./vendor/bin/sail composer require laravel/breeze --dev
./vendor/bin/sail art breeze:install vue
./vendor/bin/sail art migrate
CLEAR
clear
alias sail='bash vendor/bin/sail'
sail ps
git init
git add .
git commit -m "comit inicial"
git add .
git remote add origin https://github.com/albertogomesdasilva/laravel- sail-olw.git
git remote add origin -m https://github.com/albertogomesdasilva/laravel- sail-olw.git
git push
git push --set-upstream origin master
git remote add origin https://github.com/albertogomesdasilva/laravel-sail-olw.git
git push -u origin main
git remote add origin https://github.com/albertogomesdasilva/laravel-sail-olw.git
git push -u origin main
git login
git user.name albertogomesdasilva
echo "# laravel-sail-olw" >> README.md 
git init 
git add README.md 
git commit -m "first commit" 
git branch -M main 
git remote add origin https://github.com/albertogomesdasilva/laravel- sail-olw.git
echo "# laravel-sail-olw" >> README.md 
git init 
git add README.md 
git commit -m "first commit" 
git branch -M main 
git remote add origin https://github.com/albertogomesdasilva/laravel- sail-olw.git
echo "# laravel-sail-olw" >> README.md 
git init
git add README.md
git commit -m "first commit"
git config  user.name "Albertogomesdasilva"
git config  user.email "albertogomesdasilva@hotmail.com"
git branch -M main
git remote add origin https://github.com/albertogomesdasilva/laravel-sail-olw.git
git push -u origin main
ping www.google.com
clear
git remote add origin https://github.com/albertogomesdasilva/laravel-sail-olw.git
git push -u origin main
git remote add origin https://github.com/albertogomesdasilva/laravel-sail-olw
echo "# laravel-sail-olw" >> README.md
git init
git add README.md
git commit -m "first commit"
git branch -M main
git remote add origin https://github.com/albertogomesdasilva/laravel-sail-olw.git2
git push -u origin main
git remote add origin https://github.com/albertogomesdasilva/laravel-sail-olw.git
git remote add origin https://github.com/albertogomesdasilva/laravel-sail-olw.git2
git remote add origin https://github.com/albertogomesdasilva/laravel-sail-olw.git
clear
git remote add origin https://github.com/albertogomesdasilva/laravel-sail-olw
git config --global user.email  "albertogomesdasilva@hotmail.com"
git status
touch .gitignore
git add .
git commit -a -m "commit inicial"
git remote add origin https://github.com/albertogomesdasilva/laravel- sail-olw.git
git branch -M main 
git remote add origin https://github.com/albertogomesdasilva/laravel- sail-olw.git
clear
git status
git push --set-upstream origin master
git branch
git status
git init
git status
git add.
git add .
git status
git commit -a -m "commit inicial"
git status
git remote add origin https://github.com/albertogomesdasilva/laravel-sail-olw.git
git push
cd ..
git remote add origin https://github.com/albertogomesdasilva/laravel-sail-olw.git
cd owl
ls
cd olw
git remote add origin https://github.com/albertogomesdasilva/laravel-sail-olw
git push -u origin main
git init
clear
git reset
git status
git logout
git --help
git exit
clear
git add ANOTAÇÕES.md
git log
git commit "anotações"
clear
sail ps
clear
alias sail='bash vendor/bin/sail'
alias s='bash vendor/bin/sail'
s ps
clear
sail ps
s ps
clear
s down
s up -d
clear
s art make:controller BeerController
alias sail='bash vendor/bin/sail'
sail art migrate
sail npm run dev
npm run dev
sail npm run dev
npm run dev
sail npm run dev
sail art migrate
./vendor/bin/sail art migrate
./vendor/bin/sail artisan migrate
npm i
composer install
php --ini
php ini
php -i
ls
composer update
composer install
docker ps
ls
cd olw
s up -d
./vendor/bin/sail up -d
ls
cd public
ls
cd build
ls
cd assets/
ls
cd ..
ls
cd resources/
ls
cd views
ls
cd..
cd ..
code .
./vendor/bin/sail up -d
./vendor/bin/sail down
./vendor/bin/sail up -d
sail art migrate
./vendor/bin/sail up -d
./vendor/bin/sail donw
./vendor/bin/sail down
./vendor/bin/sail up -d
./vendor/bin/sail down
composer install
--ignore-platform-req=ext-simplexml --ignore-platform-req=ext-dom --ignore-platform-req=ext-xml --ignore-platform-req=ext-curl
composer install --ignore-platform-req=ext-simplexml --ignore-platform-req=ext-dom --ignore-platform-req=ext-xml --ignore-platform-req=ext-curl
sudo su composer update
sudo composer update
sudo su
sudo composer update
composer i
apt install composer
composer update
composer update --with-all-dependencies
php composer.phar install --no-plugins --no-scripts
cd olw
php composer.phar install --no-plugins --no-scripts
ls
cd olw
ls
apt update
composer update
./vendor/bin/sail up -d
./vendor/bin/sail down
./vendor/bin/sail up -d
composer update
composer update --with-all
ls
sudo su albert
sudo su alber
cd ow
cd olw
./vendor/bin/sail up -d
code .
./vendor/bin/sail up -d
php composer.phar update --no-plugins --no-scripts
ls
composer install
code .
php composer.phar install --no-plugins --no-scripts
cls
clear
./vendor/bin/sail up -d
./vendor/bin/sail down
php composer.phar install --no-plugins --no-scripts
composer update
cd ..
ls
cd ..
ls
chmod 777 usr/ -R
php --ini
php -ini
composer install
cd olw
pwd
ls
cd home
ls
cd ..
ls
cd root
ls
cd olw
composer install
npm i
cd public/
ls
cd buido
cd buid
cd build
ls
cd asstes
cd assets
ls
ls
chmod 777 olw/ -R
cd olw
sail up -d
./vendor/bin/sail up -d
./vendor/bin/sail composer dumpautoload
./vendor/bin/sail composer autoload
./vendor/bin/sail composer dump-autoload
composer install
composer --ignore-platform-req=ext-simplexml --ignore-platform-req=ext-dom --ignore-platform-req=ext-dom --ignore-platform-req=ext-xml --ignore-platform-req=ext-dom --ignore-platform-req=ext-dom --ignore-platform-req=ext-dom --ignore-platform-req=ext-curl --ignore-platform-req=ext-dom --ignore-platform-req=ext-simplexml
composer dumautoload --ignore-platform-req=ext-simplexml --ignore-platform-req=ext-dom --ignore-platform-req=ext-dom --ignore-platform-req=ext-xml --ignore-platform-req=ext-dom --ignore-platform-req=ext-dom --ignore-platform-req=ext-dom --ignore-platform-req=ext-curl --ignore-platform-req=ext-dom --ignore-platform-req=ext-simplexml
composer dumpautoload --ignore-platform-req=ext-simplexml --ignore-platform-req=ext-dom --ignore-platform-req=ext-dom --ignore-platform-req=ext-xml --ignore-platform-req=ext-dom --ignore-platform-req=ext-dom --ignore-platform-req=ext-dom --ignore-platform-req=ext-curl --ignore-platform-req=ext-dom --ignore-platform-req=ext-simplexml
./vendor/bin/sail up -d
code .
./vendor/bin/sail up -d
cd ..
ls
./vendor/bin/down
./vendor/bin/sail down
cd root
cd olw
./vendor/bin/sail down
cd olw
./vendor/bin/sail up -d
cd ..
rm -rf olw
ls
exit
docker ps
docker ps -la
docker ps -l
exit
nmp run dev
ls
cd example-app/
ls
sail 
./vendor/bin/sail up -d
code .
./vendor/bin/sail stop
cd ..
docker
docker ps
clear
cd ..
sudo chmod 777 olw/ -R
composer require laravel/breeze --dev
php -ini
php --ini
clear
./vendor/bin/sail composer require laravel/breeze --dev
cd olw
./vendor/bin/sail composer require laravel/breeze --dev
./vendor/bin/sail artisan breeze:install vue
./vendor/bin/sail art migrate
alias sail='[ -f sail ] && sh sail || sh vendor/bin/sail'
sail art make:controller BeerController
sail ps
sail artisan make:controller BeerController
sail artisan make:request BeerRequest
sail composer require psr/simple-cache:^2.0 maatwebsite/excel
./vendor/bin/sail composer require psr/simple-cache:^2.0 maatwebsite/excel
./vendor/bin/sail composer dump-autoload
./vendor/bin/sail artisan make:export BeerExport
./vendor/bin/sail art config:cache
./vendor/bin/sail art optimize:clear
./vendor/bin/sail composer require psr/simple-cache:^2.0 maatwebsite/excel
./vendor/bin/sail composer require -W league/flysystem-aws-s3-v3 "^3.0"
curl -s "https://laravel.build/olw?with=mysql,redis,mailhog,minio" | bash
ls
rm -rf example-app/
ls
rm -rf olw
clear
curl -s "https://laravel.build/olw?with=mysql,redis,mailhog,minio" | bash
docker scan
cd olw && ./vendor/bin/sail up -d
code .
cd olw && ./vendor/bin/sail up -d
./vendor/bin/sail up -d
code .
./vendor/bin/sail down
./vendor/bin/sail up -d
sail down
./vendor/bin/sail down
./vendor/bin/sail up -d
code .
./vendor/bin/sail up -d
code .
./vendor/bin/sail up -d
sail down
./vendor/bin/sail down
ls
cd olw
./vendor/bin/sail up -d
docker ps
ls
cd olx
ls
cd olw
./vendor/bin/sail up -d
docker ps
clear
code .
ls
cd ..
ls
docker ps
docker exec -it 51288723f17a bash
ls
./vendor/bin/sail up -d
cd olw
./vendor/bin/sail up -d
./vendor/bin/sail down
./vendor/bin/sail up -d
./vendor/bin/sail art migrate
php artisan migrate
clear
composer update
npm i
npm
composer install
php --ini
alias sail='[ -f sail ] && sh sail || sh vendor/bin/sail'
sail ps
s ps
sh ps
clear
sail art make:migration create_history_table
sail art make:model Export -mr
sail art make: Export -mr
sail art make:model Export -mr
sail art make:model Meal -mr
sail art make:factory MealFactory
sail art make:seed MealSeeder
sail composer require jzonta/faker-restaurant
sail composer dump-autoload
./vendor/bin/sail composer dump-autoload
clear
alias sail='[ -f sail ]
alias sail='[ -f sail ] && sh sail || sh vendor/bin/sail'
sail art migrate:fresh --seed
clear
sail art migrate:fresh --seed
sail art make:mail ExportEmail
sail up -d
sail down
sail up -d
docker ps
ols
olw
ls
cd olw
ls
sail ps
clear
./vendor/bin/sail up -d
code .
./vendor/bin/sail up -d
./vendor/bin/sail art server
./vendor/bin/sail art serve
sail art migrate:fresh --seed
alias sail='[ -f sail ] && sh sail || sh vendor/bin/sail'
sail composer dump-autoload
sail up -d
sail composer require jzonta/faker-restaurant
sail ps
sail composer install
composer install
php --ini
composer install
php -S localhost:8000
cd ..
chmod 777 olw/ -R
sail ps
./vendor/bin/sail up -d
cd olw
./vendor/bin/sail up -d
docker ps
./vendor/bin/sail up -d -->



//////////////////////////////////////////////////////////////////////////////////////////////////////
CONTEÚDO QUE FALTA ORGANIZAR:



/**************************************/

sail share

sail artisan sail:publish ->coloca em uma pasta na raiz chamada docker

sail --help

sail artisan optimizer:clear

sail ps

sail build --no-cache -> faz o bild da aplicação. (dá um sail down  por precaução antes.)










/*********************************

root@DELLAGS:~# curl -s "https://laravel.build/laravel-9-course?with=mysql,redis,mailhog" | bash

Dockerfile

root@DELLAGS:~/example-app# docker exec -it example-app-mysql-1 bash


FROM wyveo/nginx-php-fpm:latest
WORKDIR /usr/share/nginx
RUN rm -rf /usr/share/nginx/html
COPY . /usr/share/nginx
RUN chmod -R 755 /usr/share/nginx/storage/*
RUN ln -s public html

.env (do composer)

DB_CONNECTION=mysql
DB_HOST=mysql-app (serviço do mysql no docker-compose.yaml)
DB_PORT=3306
DB_DATABASE=laraveldockerdb
DB_USERNAME=root
DB_PASSWORD=123456



docker-compose.yaml

version: '3'

services:
  laraveldocker-app:
    build: .
    ports:
      - "3003:80"
    volumes:
      - ./:/usr/share/nginx
      - .docker/nginx:/etc/nginx/conf.d/
    networks:
      - app-network
  mysql-app:
    image: mysql:5.7.22
    ports:
      - "3306:3306"
    volumes:
      - .docker/dbdata:/var/lib/mysql
    environment:
      MYSQL_DATABASE: laraveldocker
      MYSQL_ROOT_PASSWORD: 123456
    networks:
      - app-network
networks:
  app-network:
    driver: bridge
    
https://calculator.aws/#/addService
################



/*************************************************
#criando um serviço com um nome qualquer
version: '3'

services:
  laravel-app:                    #criando um serviço com um nome qualquer
    build: . ou image: wyveo/nginx-php-fpm:latest -> neste caso sem Dockerfile.                    # endereço da imagem ou local do Dockerfile (neste caso o ponto siginifica a raiz do projeto)
    ports:
      - "8080:80"                 # 8080 porta do meu host: 80 é a porta do docker nginx
    volumes:                      # docker-compose up -d -> sobe a imagem e libera o terminal  
      - ./:/usr/share/nginx       # TUDO QUE ESTIVE NA RAIZ (na rais tem o meu projeto laravel) './' IRÁ SER REFLETIDO NA PASTA /usr/share/nginx (pasta de acesso da página html)
                                  # C:\Laravel-docker\laravel-docker>docker compose up -d --build atualiza a minha imagem

  mysql-app:
      image: mysql:5.7
      ports:
        - "3306:3306"
      volumes:
        - .docker/dbdata:/var/lib/mysql          # qualqer nome (para persistir -guardar os dados do banco de dados)


      environment:
        MYSQL_DATABASE: laravel
        MYSQL_ROOT_PASSWORD: laravel
    
      

      /***************************///


  
C:\Laravel-docker\laravel-docker>docker compose up -d --build

                                
                               

    

/******************************** Dockerfile
FROM wyveo/nginx-php-fpm:latest

/***************************///
  COMANDOS

docker compose down -> para todos os containers
C:\Laravel-docker\laravel-docker>docker exec -it laravel-docker-laravel-app-1 bash 
root@612ea0ea3340:/# cd /usr/share/nginx/
root@612ea0ea3340:/usr/share/nginx# php artisan migrate
root@612ea0ea3340:/usr/share/nginx# php artisan serve

		
/***********/
PS C:\Users\alber> docker run -e MYSQL_ROOT_PASSWORD=root --name meu-mysql -d mysql:5.7

docker inspect meu-mysql ou | grep IPAddress

PS C:\Users\alber> docker run -e MYSQL_ROOT_PASSWORD=root --name meu-mysql -d -p 3306:3306 mysql:5.7

docker ps
docker ps -l
docker ps -a
docker rm -f nome


/*** LARAVEL */
### CRIANDO UM PROJETO NO LARAVEL 
laravel new projeto_laravel_via_installer (ESTA É UM AOPÇÃO)
composer create-project --prefer-dist laravel/laravel app_controle_tarefas "8.5.9"
cd app_controle_tarefas
cd public
php -S localhost:8000

ou 
da raiz do projeto:
php artisan serve 
ou
php artisan serve --port=3000

### PARA ABRIR PORTA EM OUTRO SERVIDOR
php artisan serve --host test.com --port 8080

 **********************************************************************
cd app_controle_tarefas
cd public
php artisan serve
- acessa o navegador http://localhost:8000

### DENTRO DO PROJETO CRIADO INSTALAR O LARAVEL/UI:^3.2 - versão 3.2
composer require laravel/ui:^3.2

### SE OCORRER ERRO AUMENTAR A MEMÓRIA DISPONIVEL PARA O php

-php --ini -> localiza o arquivo de configuração do php
LOCALIZA memory_limit = 1000 e altera para 
         memory_limit  = -1 e Salva

### LISTA A RELAÇÃO DE COMANDOS 
php artisan list 

DEVERA SURGIR AS OPÇÕES ABAIXO:

 ui
  ui:auth               Scaffold basic login and registration views and routes
  ui:controllers        Scaffold the authentication controllers
 vendor
### APÓS ESSE PROCESSO O SISTEMA PEDE PARA RODAR
npm install -> instala as dependências do package.json (inclusive o bootstrap)
npm run dev -> gera os assets da aplicação de acordo com a tecnologia selecionada (bootstrap, react ou vue) -> Geralmente roda mais de uma vez para compilar tudo.

### ENTENDENDO O PACOTE UI E INICIANDO A AUTENTICAÇÃO WEB NATIVA DO LARAVEL

COMANDO PARA LISTAR ROUTES: 
php artisan route:list

### php artisan ui bootstrap --auth (bootstrap ou react ou vue)
aplicando o bootstrap incluindo os recursos de autenticação;
poderia ser aplicado o bootstrap sem os recursos de autenticação;

### php artisan route:list -> mostra as rotas - ver que aumentaram as rotas


### CRIA O BANCO DE DADOS NORMALMENTE

### EXECUTA AS MIGRATIONS PADRÕES CRIADAS PARA O SISTEMA DE login
php artisan migrate -> CRIA AS TABELAS NO BANCO DE DADOS


************************************** 
INSTALANDO O COMPOSER NO UBUNTU
**************************************
sudo apt update
sudo apt install php-cli unzip

cd ~

curl -sS https://getcomposer.org/installer -o composer-setup.php

HASH=`curl -sS https://composer.github.io/installer.sig`

echo $HASH ->saída: Output
e0012edf3e80b6978849f5eff0d4b4e4c79ff1609dd1e613307e16318854d24ae64f26d17af3ef0bf7cfb710ca74



php -r "if (hash_file('SHA384', 'composer-setup.php') === '$HASH') { echo 'Installer verified'; } else { echo 'Installer corrupt'; unlink('composer-setup.php'); } echo PHP_EOL;"

sudo php composer-setup.php --install-dir=/usr/local/bin --filename=composer





***********************

DigitalOcean Kubernetes: novo plano de controle é mais rápido e gratuito, habilita HA para SLA de 99,95% de tempo de atividade
Produtos
Preços

Documentos
divisa suspensa

Entrar
divisa suspensa

// Tutorial //
Como Instalar e Utilizar o Composer no Ubuntu 20.04
Publicado em 21 de maio de 2020
Ubuntu
PHP
Ubuntu 20.04
Avatar padrão
Por Erika Heidi
Advogado Desenvolvedor
Português
Como Instalar e Utilizar o Composer no Ubuntu 20.04
Introdução
O Composer é uma ferramenta popular de gerenciamento de dependências para o PHP, criado para facilitar a instalação e a atualização das dependências principalmente do projeto. Ele controla quais outros pacotes de projeto específico dependem e são instalados para você, usando as opções apropriadas de acordo com os requisitos do projeto. O Composer também é comumente utilizado para inicializar novos projetos em frameworks PHP populares, como o Symfon e o Laravel .

Neste tutorial, você instalará e começará a usar o Composer em um sistema Ubuntu 20.04.

Pré-requisitos
Para seguir este guia, você pode acessar um servidor como usuário Ubuntu20.04 como usuário sudonão-root um firewall habilitado em seu servidor Para configurar isto, siga nosso guia Configuração do servidor inicial para o Ubuntu 20.04

Passo 1 — Instalando o PHP e as Dependências Adicionais
Além das dependências que já devem estar incluídas em seu sistema Ubuntu 20.04, como o , o Composer exige ou gitexecuta scripts PHP na linha de comando e para extrair arquivos zipados. Vamos instalar essas dependências agora.curlphp-cliunzip

primeiro, atual, gerenciador de pacotes de soluções: o cache do gerenciador de pacotes

sudo apt update
Em seguida, o seguinte comando para instalar os pacotes, execute:

sudo apt install php-cli unzip
Você será solicitado a confirmar a instalação digitando Ye, depois, ENTER.

Assim que os pré-requisitos para instalação do Composer forem instalados, você poderá seguir.

Passo 2 — Baixando e Instalando o Compositor
O Composer fornece um instalador de script escrito em PHP. Vamos baixá-lo, verificar se ele não está danificado e, em seguida, o usaremos para instalar o Composer.

Certifique-se de estar em sua pasta home. Em seguida, baixe o instalador usando o curl:

cd ~
curl -sS https://getcomposer.org/installer -o composer-setup.php
Em seguida, vamos verificar se o instalador baixado corresponde ao hash SHA-384 para o instalador mais recente encontrado na página Composer Public Keys / Signatures . Para facilitar o passo de seleção, você pode usar o seguinte comando para obter programaticamente o hash mais recente da página do Composer e armazená-lo em uma variável do shell:

HASH=`curl -sS https://composer.github.io/installer.sig`
Se você quiser verificar o valor realizado, execute:

echo $HASH
Output
e0012edf3e80b6978849f5eff0d4b4e4c79ff1609dd1e613307e16318854d24ae64f26d17af3ef0bf7cfb710ca74755a
Agora o código PHP a seguir, execute conforme a página de download do Composer, para verificar se o script de instalação está seguro para ser executado:

php -r "if (hash_file('SHA384', 'composer-setup.php') === '$HASH') { echo 'Installer verified'; } else { echo 'Installer corrupt'; unlink('composer-setup.php'); } echo PHP_EOL;"
Você verá o seguinte resultado:

Resultado
Installer verified
Se Installer corruptvocê estiver usando o hash correto, verifique se você está usando o hash correto. Em seguida, repita o processo de verificação. Quando você tiver um instalador selecionado, você pode continuar.

Para instalar o composerglobalmente, use o seguinte comando que baixará e instalará o Composer como um comando disponível em todo o sistema chamado composer, sob /usr/local/bin:

sudo php composer-setup.php --install-dir=/usr/local/bin --filename=composer
Você verá um resultado semelhante com este:

Output
All settings correct for using Composer
Downloading...

Composer (version 1.10.5) successfully installed to: /usr/local/bin/composer
Use it: php /usr/local/bin/composer
Para testar sua instalação, execute:

composer
Output
   ______
  / ____/___  ____ ___  ____  ____  ________  _____
 / /   / __ \/ __ `__ \/ __ \/ __ \/ ___/ _ \/ ___/
/ /___/ /_/ / / / / / / /_/ / /_/ (__  )  __/ /
\____/\____/_/ /_/ /_/ .___/\____/____/\___/_/
                    /_/
Composer version 1.10.5 2020-04-10 11:44:22

Usage:
  command [options] [arguments]

Options:
  -h, --help                     Display this help message
  -q, --quiet                    Do not output any message
  -V, --version                  Display this application version
      --ansi                     Force ANSI output
      --no-ansi                  Disable ANSI output
  -n, --no-interaction           Do not ask any interactive question
      --profile                  Display timing and memory usage information
      --no-plugins               Whether to disable plugins.
  -d, --working-dir=WORKING-DIR  If specified, use the given directory as working directory.
      --no-cache                 Prevent use of the cache
  -v|vv|vvv, --verbose           Increase the verbosity of messages: 1 for normal output, 2 for more verbose output and 3 for debug
...
Isso verifica que o Composer foi instalado com sucesso em seu sistema e está disponível em todo o sistema.

Nota: se você preferirá ter-lhe-ão separados separados do Composer para projeto hospedado neste servidor, você pode instalar localmente, em uma base por projeto. Este método também é útil quando o usuário do sistema não possui permissão para instalar o software disponível em todo o sistema.

Para fazer isso, use o comando php composer-setup.php. Isso irá gerar um arquivo composer.pharem seu diretório atual, que pode ser executado com o seu atual php composer.phar.

Agora podemos dar uma dependência em como usar o Compose como gerenciar.

Passo 3 — Usando o Compositor em um Projeto PHP
Os projetos PHP geralmente dependentes de bibliotecas externas, e o gerenciamento de dependências e suas versões podem ser complicados. O Composer resolve esse problema de manter um controle de projeto de extensões e dependências, também facilita o processo de descoberta, instalação e atualização de pacotes que são definidos por enquanto.

Para usar o seu projeto, você pode compor um arquivo composer.json. O arquivo composer.jsonComposer quais dependências precisa para baixar seu projeto quais serão as versões de cada pacote tem permissão para instalações e instalações. Isso é muito importante para manter seu projeto consistente e evitar a instalação de versões instáveis ​​que podem causar problemas de compatibilidade retroativa.

Você não precisa criar este arquivo manualmente - é comum ocorrer erros de sintaxe quando fizer isso. O Composer oferece uma maneira de criar um novo arquivo composer.jsoncom base na entrada do usuário, o que é uma boa escolha se você planeja compartilhar seu projeto mais tarde como um pacote público no Packagist . O Composer gera automaticamente um arquivo básico composer.jsonquando você executa um comando composer requirepara incluir uma dependência em um projeto recém-criado.

O processo de uso do Composer para instalar um pacote como uma dependência em um projeto envolve os passos a seguir:

Identifique o tipo de biblioteca que o aplicativo precisa.
uma biblioteca de código aberto adequada no agist.org , o responsável oficial de pacotes para o Compose.
Escolha o pacote de dependência.
Execute composer requirepara incluir a dependência no arquivo composer.jsone instalar o pacote.
Vamos testar isso com uma aplicação de demonstração.

O objetivo desta aplicação é transformar uma determinação determinada em uma string de URL amigável - um slug . Isso é comumente usado para converter os títulos de página para caminhos de URL (Assim como a parte final da URL para este tutorial).

Vamos começar a criar um diretório para o nosso projeto. Vamos chamá-lo de slugify :

cd ~
mkdir slugify
cd slugify
Embora não seja necessário, você pode executar agora um comando composer init para criar um arquivo composer.json detalhado para seu projeto. Como o único objetivo do nosso projeto é demonstrar como instalar dependências com o Composer, usaremos um arquivo composer.json mais simples que será gerado automaticamente quando exigirmos nosso primeiro pacote.

Agora é hora de procurar no Packagist.org por um pacote que pode nos ajudar a gerar slugs. Se você procurar pelo termo “slug” no Packagist, receberá um resultado parecido com este:

Resultados da Pesquisa do Packagist para o termo "slug"

Você verá dois números no lado direito de cada pacote na lista. O número no topo representa quantas vezes o pacote foi instalado através do Composer, e o número em baixo mostra quantas vezes um pacote foi estrelado no GitHub. De um modo geral, os pacotes com mais instalações e mais estrelas tendem a ser mais estáveis, pois mais pessoas os utilizam. Também é importante verificar a descrição do pacote para relevância para garantir que ele é o que você precisa.

Precisamos de um conversor string-to-slug A partir dos resultados da pesquisa, o pacote cocur/slugify, que aparece como o primeiro resultado naquela página, parece ser um bom candidato, com uma quantidade razoável de instalações e estrelas.

Os pacotes no Packagist têm um nome de vendor e um nome de package. Cada pacote tem um identificador único (um namespace) no mesmo formato que o GitHub utiliza para seus repositórios: vendor/package. A biblioteca que queremos instalar utiliza o namespace cocur/slugify. Você precisa de um namespace do pacote para exigi-lo em seu projeto.

Agora que você sabe exatamente qual pacote deseja instalar, você pode executar o composer require para incluí-lo como uma dependência e gerar também o arquivo composer.json para seu projeto. Uma coisa importante é observar a exigência de pacotes. O Composer rastreia as dependências no nível da aplicação e do sistema. As dependências no nível do sistema são importantes para indicar de quais módulos PHP um pacote depende. No caso do pacote cocur/slugify, ele exige um módulo PHP que ainda não instalamos.

Quando um pacote necessário depende de uma biblioteca de sistema que não está atualmente instalada em seu servidor, você receberá um erro informando qual requisito está faltando:

composer require cocur/slugify
Output
Using version ^4.0 for cocur/slugify
./composer.json has been updated
Loading composer repositories with package information
Updating dependencies (including require-dev)
Your requirements could not be resolved to an installable set of packages.

  Problem 1
    - Installation request for cocur/slugify ^4.0 -> satisfiable by cocur/slugify[v4.0.0].
    - cocur/slugify v4.0.0 requires ext-mbstring * -> the requested PHP extension mbstring is missing from your system.
...
Para resolver o problema de dependência do sistema, podemos procurar pelo pacote que falta usando o apt search:

apt search mbstring
Output
Sorting... Done
Full Text Search... Done
php-mbstring/focal 2:7.4+75 all
  MBSTRING module for PHP [default]

php-patchwork-utf8/focal 1.3.1-1 all
  UTF-8 strings handling for PHP

php7.4-mbstring/focal 7.4.3-4ubuntu1 amd64
  MBSTRING module for PHP
Após localizar o nome do pacote correto, você pode utilizar o apt novamente para instalar a dependência de sistema:

sudo apt install php-mbstring
Assim que a instalação terminar, você pode executar novamente o comando composer require:

composer require cocur/slugify
Output
Using version ^4.0 for cocur/slugify
./composer.json has been created
Loading composer repositories with package information
Updating dependencies (including require-dev)
Package operations: 1 install, 0 updates, 0 removals
  - Installing cocur/slugify (v4.0.0): Downloading (100%)         
Writing lock file
Generating autoload files
Como você pode ver na saída, o Composer decidiu automaticamente qual versão do pacote utilizar. Se você verificar o diretório do seu projeto agora, ele irá conter dois arquivos novos: composer.json e composer.lock, e um diretório vendor:

ls -l
Output
total 12
-rw-rw-r-- 1 sammy sammy   59 May  4 13:56 composer.json
-rw-rw-r-- 1 sammy sammy 3229 May  4 13:56 composer.lock
drwxrwxr-x 4 sammy sammy 4096 May  4 13:56 vendor
O arquivo composer.lock é usado para armazenar informações sobre quais versões de cada pacote estão instaladas, e garantir que as mesmas versões sejam usadas se outra pessoa clonar seu projeto e instalar suas dependências. O diretório vendor é onde as dependências do projeto estão localizadas. Você não deve fazer commit da pasta vendor no controle de versão - você precisa apenas incluir os arquivos composer.json e composer.lock.

Ao instalar um projeto que já contém um arquivo composer.json, execute o composer install para baixar as dependências do projeto.

Vamos dar uma olhada rápida em restrições de versão. Se você verificar o conteúdo do seu arquivo composer.json, verá algo parecido com isto:

cat composer.json
Output
{
    "require": {
        "cocur/slugify": "^4.0"
    }
}
Note que há o caractere especial ^ antes do número da versão no composer.json. O Composer suporta várias restrições diferentes e formatos para definir a versão necessária do pacote, para fornecer flexibilidade enquanto também mantém seu projeto estável. O operador circunflexo (^) utilizado pelo arquivo composer.json criado automaticamente é o operador recomendado para a interoperabilidade máxima, seguindo o versionamento semântico. Neste caso, ele define 4.0 como a versão mínima compatível e permite atualizações para qualquer versão futura abaixo de 5.0.

De um modo geral, você não precisará alterar as restrições de versão em seu arquivo composer.json. No entanto, algumas situações podem exigir que você edite manualmente as restrições – por exemplo, quando uma nova versão principal da sua biblioteca requerida é liberada e você deseja atualizar, ou quando a biblioteca que você deseja usar não segue o versionamento semântico.

Aqui estão alguns exemplos para lhe dar um melhor entendimento sobre como as restrições de versão do Composer funcionam:

Restrição	Significado	Exemplo de Versões Permitidas
^1.0	>= 1.0 < 2.0	1.0, 1.2.3, 1.9.9
^1.1.0	>= 1.1.0 < 2.0	1.1.0, 1.5.6, 1.9.9
~1.0	>= 1.0 < 2.0.0	1.0, 1.4.1, 1.9.9
~1.0.0	>= 1.0.0 < 1.1	1.0.0, 1.0.4, 1.0.9
1.2.1	1.2.1	1.2.1
1.*	>= 1.0 < 2.0	1.0.0, 1.4.5, 1.9.9
1.2. *	>= 1.2 < 1.3	1.2.0, 1.2.3, 1.2.9
Para uma visualização mais detalhada das restrições de versão do Composer, consulte a documentação oficial.

A seguir, vamos ver como carregar dependências automaticamente com o Composer.

Passo 4 — Incluindo o Script Autoload
Como o PHP por si só não carrega classes automaticamente, o Composer fornece um script autoload que você pode incluir em seu projeto para obter o carregamento automático para ele. Este arquivo é gerado automaticamente pelo Composer quando você adiciona sua primeira dependência.

A única coisa que você precisa fazer é incluir o arquivo vendor/autoload.php em seus scripts PHP antes de qualquer instância de classe.

Vamos testar isso em nossa aplicação de demonstração. Abra um novo arquivo chamado test.php em seu editor de texto:

nano test.php
Adicione o código a seguir que vem no arquivo vendor/autoload.php, carrega a dependência cocur/slugify, e o utiliza para criar um slug:

test.php
<?php
require __DIR__ . '/vendor/autoload.php';

use Cocur\Slugify\Slugify;

$slugify = new Slugify();

echo $slugify->slugify('Hello World, this is a long sentence and I need to make a slug from it!');
Salve o arquivo e saia do seu editor.

Agora, execute o script.

php test.php
Isso produz a saída hello-world-this-is-a-long-sentence-and-i-need-to-make-a-slug-from-it.

As dependências precisam de atualizações quando novas versões são liberadas. Dessa forma, vamos ver como lidar com isso.

Passo 5 — Atualizando as Dependências do Projeto
Sempre que você quiser atualizar suas dependências do projeto para versões mais recentes, execute o comando update:

composer update
Isso irá verificar por versões mais recentes das bibliotecas que você requer em seu projeto. Se uma versão mais recente for encontrada e ela for compatível com a restrição de versão definida no arquivo composer.json, o Composer substituirá a versão anterior instalada. O arquivo composer.lock será atualizado para refletir essas alterações.

Você também pode atualizar uma ou mais bibliotecas específicas, especificando-as desta forma:

composer update vendor/package vendor2/package2
Certifique-se de verificar em seus arquivos composer.json e composer.lock dentro do seu sistema de controle de versão após atualizar suas dependências de modo que outros também possam instalar essas versões mais recentes.

Conclusão





***********
Algoritmo "CalculoMedia2"
// Disciplina: Lógica de programação
// Professor : Antonio Carlos Nicolodi
// Descrição : calculo da média aritimética
// Autor     : Professor Antonio
// Data atual: 01/04/2015
var
// Seção de Declarações
   v1, v2, total: Real
   sinal : Caracter
Inicio
// Seção dos Comandos
   Escreva ("Digite o primeiro valor: ")
   Leia (v1)
   Escreva ("Digite a operação + - * / : ")
   Leia (sinal)
   Escreva ("Digite o segundo valor: ")
   Leia (v2)

   Se sinal = "+" entao
   total <- v1 + v2
   Escreva("O Resultado é: ", total)
   Senao
   Se sinal = "-" entao
   total <- v1 - v2
   Escreva("O Resultado é: ", total)
   Senao
   Se sinal = "*" entao
   total <- v1 * v2
   Escreva("O Resultado é: ", total)


   Senao
     Escreva("OPERAÇÃO INVÁLIDA! ")



      Escreval("total")
   fimse
Fimalgoritmo

****
COMANDOS DOCKER
root@DELLAGS:~# curl -s "https://laravel.build/laravel-9-course?with=mysql,redis,mailhog" | bash

root@DELLAGS:~/example-app# ./vendor/bin/sail  artisan migrate --seed -> criar o banco de dados e copular dados;


### DatabaseSeeder.php
class DatabaseSeeder extends Seeder
{
    /**
     * Seed the application's database.
     *
     * @return void
     */
    public function run()
    {
        \App\Models\User::factory(10)->create();

        //  \App\Models\User::factory()->create([
        //      'name' => 'Test User',
        //      'email' => 'test@example.com',
        //  ]);
    }
}

### Rota get por id ou email
// Route::get('user/{user:email}', function(\App\Models\User $user){
Route::get('user/{user}', function(\App\Models\User $user){
    
  //  ddd($user);
  //  dd($user);
    var_dump($user);
    die();

    return $user;
})->name('user');

Dockerfile

root@DELLAGS:~/example-app# docker exec -it example-app-mysql-1 bash


FROM wyveo/nginx-php-fpm:latest
WORKDIR /usr/share/nginx
RUN rm -rf /usr/share/nginx/html
COPY . /usr/share/nginx
RUN chmod -R 755 /usr/share/nginx/storage/*
RUN ln -s public html

.env (do composer)

DB_CONNECTION=mysql
DB_HOST=mysql-app (serviço do mysql no docker-compose.yaml)
DB_PORT=3306
DB_DATABASE=laraveldockerdb
DB_USERNAME=root
DB_PASSWORD=123456



docker-compose.yaml

version: '3'

services:
  laraveldocker-app:
    build: .
    ports:
      - "3003:80"
    volumes:
      - ./:/usr/share/nginx
      - .docker/nginx:/etc/nginx/conf.d/
    networks:
      - app-network
  mysql-app:
    image: mysql:5.7.22
    ports:
      - "3306:3306"
    volumes:
      - .docker/dbdata:/var/lib/mysql
    environment:
      MYSQL_DATABASE: laraveldocker
      MYSQL_ROOT_PASSWORD: 123456
    networks:
      - app-network
networks:
  app-network:
    driver: bridge
    



/*************************************************
#criando um serviço com um nome qualquer
version: '3'

services:
  laravel-app:                    #criando um serviço com um nome qualquer
    build: . ou image: wyveo/nginx-php-fpm:latest -> neste caso sem Dockerfile.                    # endereço da imagem ou local do Dockerfile (neste caso o ponto siginifica a raiz do projeto)
    ports:
      - "8080:80"                 # 8080 porta do meu host: 80 é a porta do docker nginx
    volumes:                      # docker-compose up -d -> sobe a imagem e libera o terminal  
      - ./:/usr/share/nginx       # TUDO QUE ESTIVE NA RAIZ (na rais tem o meu projeto laravel) './' IRÁ SER REFLETIDO NA PASTA /usr/share/nginx (pasta de acesso da página html)
                                  # C:\Laravel-docker\laravel-docker>docker compose up -d --build atualiza a minha imagem

  mysql-app:
      image: mysql:5.7
      ports:
        - "3306:3306"
      volumes:
        - .docker/dbdata:/var/lib/mysql          # qualqer nome (para persistir -guardar os dados do banco de dados)


      environment:
        MYSQL_DATABASE: laravel
        MYSQL_ROOT_PASSWORD: laravel
    
      

      /***************************///


  
C:\Laravel-docker\laravel-docker>docker compose up -d --build

                                
                               

    

/******************************** Dockerfile
FROM wyveo/nginx-php-fpm:latest

/***************************///
  COMANDOS

docker compose down -> para todos os containers
C:\Laravel-docker\laravel-docker>docker exec -it laravel-docker-laravel-app-1 bash 
root@612ea0ea3340:/# cd /usr/share/nginx/
root@612ea0ea3340:/usr/share/nginx# php artisan migrate
root@612ea0ea3340:/usr/share/nginx# php artisan serve

		
/***********/
PS C:\Users\alber> docker run -e MYSQL_ROOT_PASSWORD=root --name meu-mysql -d mysql:5.7

docker inspect meu-mysql ou | grep IPAddress

PS C:\Users\alber> docker run -e MYSQL_ROOT_PASSWORD=root --name meu-mysql -d -p 3306:3306 mysql:5.7

docker ps
docker ps -l
docker ps -a
docker rm -f nome


/*** LARAVEL */
### CRIANDO UM PROJETO NO LARAVEL 
laravel new projeto_laravel_via_installer (ESTA É UM AOPÇÃO)
composer create-project --prefer-dist laravel/laravel app_controle_tarefas "8.5.9"
cd app_controle_tarefas
cd public
php -S localhost:8000

ou 
da raiz do projeto:
php artisan serve 
ou
php artisan serve --port=3000

### PARA ABRIR PORTA EM OUTRO SERVIDOR
php artisan serve --host test.com --port 8080

 **********************************************************************
cd app_controle_tarefas
cd public
php artisan serve
- acessa o navegador http://localhost:8000

### DENTRO DO PROJETO CRIADO INSTALAR O LARAVEL/UI:^3.2 - versão 3.2
composer require laravel/ui:^3.2

### SE OCORRER ERRO AUMENTAR A MEMÓRIA DISPONIVEL PARA O php

-php --ini -> localiza o arquivo de configuração do php
LOCALIZA memory_limit = 1000 e altera para 
         memory_limit  = -1 e Salva

### LISTA A RELAÇÃO DE COMANDOS 
php artisan list 

DEVERA SURGIR AS OPÇÕES ABAIXO:

 ui
  ui:auth               Scaffold basic login and registration views and routes
  ui:controllers        Scaffold the authentication controllers
 vendor

### ENTENDENDO O PACOTE UI E INICIANDO A AUTENTICAÇÃO WEB NATIVA DO LARAVEL

COMANDO PARA LISTAR ROUTES: 
php artisan route:list

### php artisan ui bootstrap --auth (bootstrap ou react ou vue)
aplicando o bootstrap incluindo os recursos de autenticação;
poderia ser aplicado o bootstrap sem os recursos de autenticação;

### php artisan route:list -> mostra as rotas - ver que aumentaram as rotas

### APÓS ESSE PROCESSO O SISTEMA PEDE PARA RODAR
npm install -> instala as dependências do package.json (inclusive o bootstrap)
npm run dev -> gera os assets da aplicação de acordo com a tecnologia selecionada (bootstrap, react ou vue) -> Geralmente roda mais de uma vez para compilar tudo.

### CRIA O BANCO DE DADOS NORMALMENTE

### EXECUTA AS MIGRATIONS PADRÕES CRIADAS PARA O SISTEMA DE login
php artisan migrate -> CRIA AS TABELAS NO BANCO DE DADOS


************************************** 
INSTALANDO O COMPOSER NO UBUNTU
**************************************
sudo apt update
sudo apt install php-cli unzip

cd ~

curl -sS https://getcomposer.org/installer -o composer-setup.php

HASH=`curl -sS https://composer.github.io/installer.sig`

echo $HASH ->saída: Output
e0012edf3e80b6978849f5eff0d4b4e4c79ff1609dd1e613307e16318854d24ae64f26d17af3ef0bf7cfb710ca74



php -r "if (hash_file('SHA384', 'composer-setup.php') === '$HASH') { echo 'Installer verified'; } else { echo 'Installer corrupt'; unlink('composer-setup.php'); } echo PHP_EOL;"

sudo php composer-setup.php --install-dir=/usr/local/bin --filename=composer





***********************

DigitalOcean Kubernetes: novo plano de controle é mais rápido e gratuito, habilita HA para SLA de 99,95% de tempo de atividade
Produtos
Preços

Documentos
divisa suspensa

Entrar
divisa suspensa

// Tutorial //
Como Instalar e Utilizar o Composer no Ubuntu 20.04
Publicado em 21 de maio de 2020
Ubuntu
PHP
Ubuntu 20.04
Avatar padrão
Por Erika Heidi
Advogado Desenvolvedor
Português
Como Instalar e Utilizar o Composer no Ubuntu 20.04
Introdução
O Composer é uma ferramenta popular de gerenciamento de dependências para o PHP, criado para facilitar a instalação e a atualização das dependências principalmente do projeto. Ele controla quais outros pacotes de projeto específico dependem e são instalados para você, usando as opções apropriadas de acordo com os requisitos do projeto. O Composer também é comumente utilizado para inicializar novos projetos em frameworks PHP populares, como o Symfon e o Laravel .

Neste tutorial, você instalará e começará a usar o Composer em um sistema Ubuntu 20.04.

Pré-requisitos
Para seguir este guia, você pode acessar um servidor como usuário Ubuntu20.04 como usuário sudonão-root um firewall habilitado em seu servidor Para configurar isto, siga nosso guia Configuração do servidor inicial para o Ubuntu 20.04

Passo 1 — Instalando o PHP e as Dependências Adicionais
Além das dependências que já devem estar incluídas em seu sistema Ubuntu 20.04, como o , o Composer exige ou gitexecuta scripts PHP na linha de comando e para extrair arquivos zipados. Vamos instalar essas dependências agora.curlphp-cliunzip

primeiro, atual, gerenciador de pacotes de soluções: o cache do gerenciador de pacotes

sudo apt update
Em seguida, o seguinte comando para instalar os pacotes, execute:

sudo apt install php-cli unzip
Você será solicitado a confirmar a instalação digitando Ye, depois, ENTER.

Assim que os pré-requisitos para instalação do Composer forem instalados, você poderá seguir.

Passo 2 — Baixando e Instalando o Compositor
O Composer fornece um instalador de script escrito em PHP. Vamos baixá-lo, verificar se ele não está danificado e, em seguida, o usaremos para instalar o Composer.

Certifique-se de estar em sua pasta home. Em seguida, baixe o instalador usando o curl:

cd ~
curl -sS https://getcomposer.org/installer -o composer-setup.php
Em seguida, vamos verificar se o instalador baixado corresponde ao hash SHA-384 para o instalador mais recente encontrado na página Composer Public Keys / Signatures . Para facilitar o passo de seleção, você pode usar o seguinte comando para obter programaticamente o hash mais recente da página do Composer e armazená-lo em uma variável do shell:

HASH=`curl -sS https://composer.github.io/installer.sig`
Se você quiser verificar o valor realizado, execute:

echo $HASH
Output
e0012edf3e80b6978849f5eff0d4b4e4c79ff1609dd1e613307e16318854d24ae64f26d17af3ef0bf7cfb710ca74755a
Agora o código PHP a seguir, execute conforme a página de download do Composer, para verificar se o script de instalação está seguro para ser executado:

php -r "if (hash_file('SHA384', 'composer-setup.php') === '$HASH') { echo 'Installer verified'; } else { echo 'Installer corrupt'; unlink('composer-setup.php'); } echo PHP_EOL;"
Você verá o seguinte resultado:

Resultado
Installer verified
Se Installer corruptvocê estiver usando o hash correto, verifique se você está usando o hash correto. Em seguida, repita o processo de verificação. Quando você tiver um instalador selecionado, você pode continuar.

Para instalar o composerglobalmente, use o seguinte comando que baixará e instalará o Composer como um comando disponível em todo o sistema chamado composer, sob /usr/local/bin:

sudo php composer-setup.php --install-dir=/usr/local/bin --filename=composer
Você verá um resultado semelhante com este:

Output
All settings correct for using Composer
Downloading...

Composer (version 1.10.5) successfully installed to: /usr/local/bin/composer
Use it: php /usr/local/bin/composer
Para testar sua instalação, execute:

composer
Output
   ______
  / ____/___  ____ ___  ____  ____  ________  _____
 / /   / __ \/ __ `__ \/ __ \/ __ \/ ___/ _ \/ ___/
/ /___/ /_/ / / / / / / /_/ / /_/ (__  )  __/ /
\____/\____/_/ /_/ /_/ .___/\____/____/\___/_/
                    /_/
Composer version 1.10.5 2020-04-10 11:44:22

Usage:
  command [options] [arguments]

Options:
  -h, --help                     Display this help message
  -q, --quiet                    Do not output any message
  -V, --version                  Display this application version
      --ansi                     Force ANSI output
      --no-ansi                  Disable ANSI output
  -n, --no-interaction           Do not ask any interactive question
      --profile                  Display timing and memory usage information
      --no-plugins               Whether to disable plugins.
  -d, --working-dir=WORKING-DIR  If specified, use the given directory as working directory.
      --no-cache                 Prevent use of the cache
  -v|vv|vvv, --verbose           Increase the verbosity of messages: 1 for normal output, 2 for more verbose output and 3 for debug
...
Isso verifica que o Composer foi instalado com sucesso em seu sistema e está disponível em todo o sistema.

Nota: se você preferirá ter-lhe-ão separados separados do Composer para projeto hospedado neste servidor, você pode instalar localmente, em uma base por projeto. Este método também é útil quando o usuário do sistema não possui permissão para instalar o software disponível em todo o sistema.

Para fazer isso, use o comando php composer-setup.php. Isso irá gerar um arquivo composer.pharem seu diretório atual, que pode ser executado com o seu atual php composer.phar.

Agora podemos dar uma dependência em como usar o Compose como gerenciar.

Passo 3 — Usando o Compositor em um Projeto PHP
Os projetos PHP geralmente dependentes de bibliotecas externas, e o gerenciamento de dependências e suas versões podem ser complicados. O Composer resolve esse problema de manter um controle de projeto de extensões e dependências, também facilita o processo de descoberta, instalação e atualização de pacotes que são definidos por enquanto.

Para usar o seu projeto, você pode compor um arquivo composer.json. O arquivo composer.jsonComposer quais dependências precisa para baixar seu projeto quais serão as versões de cada pacote tem permissão para instalações e instalações. Isso é muito importante para manter seu projeto consistente e evitar a instalação de versões instáveis ​​que podem causar problemas de compatibilidade retroativa.

Você não precisa criar este arquivo manualmente - é comum ocorrer erros de sintaxe quando fizer isso. O Composer oferece uma maneira de criar um novo arquivo composer.jsoncom base na entrada do usuário, o que é uma boa escolha se você planeja compartilhar seu projeto mais tarde como um pacote público no Packagist . O Composer gera automaticamente um arquivo básico composer.jsonquando você executa um comando composer requirepara incluir uma dependência em um projeto recém-criado.

O processo de uso do Composer para instalar um pacote como uma dependência em um projeto envolve os passos a seguir:

Identifique o tipo de biblioteca que o aplicativo precisa.
uma biblioteca de código aberto adequada no agist.org , o responsável oficial de pacotes para o Compose.
Escolha o pacote de dependência.
Execute composer requirepara incluir a dependência no arquivo composer.jsone instalar o pacote.
Vamos testar isso com uma aplicação de demonstração.

O objetivo desta aplicação é transformar uma determinação determinada em uma string de URL amigável - um slug . Isso é comumente usado para converter os títulos de página para caminhos de URL (Assim como a parte final da URL para este tutorial).

Vamos começar a criar um diretório para o nosso projeto. Vamos chamá-lo de slugify :

cd ~
mkdir slugify
cd slugify
Embora não seja necessário, você pode executar agora um comando composer init para criar um arquivo composer.json detalhado para seu projeto. Como o único objetivo do nosso projeto é demonstrar como instalar dependências com o Composer, usaremos um arquivo composer.json mais simples que será gerado automaticamente quando exigirmos nosso primeiro pacote.

Agora é hora de procurar no Packagist.org por um pacote que pode nos ajudar a gerar slugs. Se você procurar pelo termo “slug” no Packagist, receberá um resultado parecido com este:

Resultados da Pesquisa do Packagist para o termo "slug"

Você verá dois números no lado direito de cada pacote na lista. O número no topo representa quantas vezes o pacote foi instalado através do Composer, e o número em baixo mostra quantas vezes um pacote foi estrelado no GitHub. De um modo geral, os pacotes com mais instalações e mais estrelas tendem a ser mais estáveis, pois mais pessoas os utilizam. Também é importante verificar a descrição do pacote para relevância para garantir que ele é o que você precisa.

Precisamos de um conversor string-to-slug A partir dos resultados da pesquisa, o pacote cocur/slugify, que aparece como o primeiro resultado naquela página, parece ser um bom candidato, com uma quantidade razoável de instalações e estrelas.

Os pacotes no Packagist têm um nome de vendor e um nome de package. Cada pacote tem um identificador único (um namespace) no mesmo formato que o GitHub utiliza para seus repositórios: vendor/package. A biblioteca que queremos instalar utiliza o namespace cocur/slugify. Você precisa de um namespace do pacote para exigi-lo em seu projeto.

Agora que você sabe exatamente qual pacote deseja instalar, você pode executar o composer require para incluí-lo como uma dependência e gerar também o arquivo composer.json para seu projeto. Uma coisa importante é observar a exigência de pacotes. O Composer rastreia as dependências no nível da aplicação e do sistema. As dependências no nível do sistema são importantes para indicar de quais módulos PHP um pacote depende. No caso do pacote cocur/slugify, ele exige um módulo PHP que ainda não instalamos.

Quando um pacote necessário depende de uma biblioteca de sistema que não está atualmente instalada em seu servidor, você receberá um erro informando qual requisito está faltando:

composer require cocur/slugify
Output
Using version ^4.0 for cocur/slugify
./composer.json has been updated
Loading composer repositories with package information
Updating dependencies (including require-dev)
Your requirements could not be resolved to an installable set of packages.

  Problem 1
    - Installation request for cocur/slugify ^4.0 -> satisfiable by cocur/slugify[v4.0.0].
    - cocur/slugify v4.0.0 requires ext-mbstring * -> the requested PHP extension mbstring is missing from your system.
...
Para resolver o problema de dependência do sistema, podemos procurar pelo pacote que falta usando o apt search:

apt search mbstring
Output
Sorting... Done
Full Text Search... Done
php-mbstring/focal 2:7.4+75 all
  MBSTRING module for PHP [default]

php-patchwork-utf8/focal 1.3.1-1 all
  UTF-8 strings handling for PHP

php7.4-mbstring/focal 7.4.3-4ubuntu1 amd64
  MBSTRING module for PHP
Após localizar o nome do pacote correto, você pode utilizar o apt novamente para instalar a dependência de sistema:

sudo apt install php-mbstring
Assim que a instalação terminar, você pode executar novamente o comando composer require:

composer require cocur/slugify
Output
Using version ^4.0 for cocur/slugify
./composer.json has been created
Loading composer repositories with package information
Updating dependencies (including require-dev)
Package operations: 1 install, 0 updates, 0 removals
  - Installing cocur/slugify (v4.0.0): Downloading (100%)         
Writing lock file
Generating autoload files
Como você pode ver na saída, o Composer decidiu automaticamente qual versão do pacote utilizar. Se você verificar o diretório do seu projeto agora, ele irá conter dois arquivos novos: composer.json e composer.lock, e um diretório vendor:

ls -l
Output
total 12
-rw-rw-r-- 1 sammy sammy   59 May  4 13:56 composer.json
-rw-rw-r-- 1 sammy sammy 3229 May  4 13:56 composer.lock
drwxrwxr-x 4 sammy sammy 4096 May  4 13:56 vendor
O arquivo composer.lock é usado para armazenar informações sobre quais versões de cada pacote estão instaladas, e garantir que as mesmas versões sejam usadas se outra pessoa clonar seu projeto e instalar suas dependências. O diretório vendor é onde as dependências do projeto estão localizadas. Você não deve fazer commit da pasta vendor no controle de versão - você precisa apenas incluir os arquivos composer.json e composer.lock.

Ao instalar um projeto que já contém um arquivo composer.json, execute o composer install para baixar as dependências do projeto.

Vamos dar uma olhada rápida em restrições de versão. Se você verificar o conteúdo do seu arquivo composer.json, verá algo parecido com isto:

cat composer.json
Output
{
    "require": {
        "cocur/slugify": "^4.0"
    }
}
Note que há o caractere especial ^ antes do número da versão no composer.json. O Composer suporta várias restrições diferentes e formatos para definir a versão necessária do pacote, para fornecer flexibilidade enquanto também mantém seu projeto estável. O operador circunflexo (^) utilizado pelo arquivo composer.json criado automaticamente é o operador recomendado para a interoperabilidade máxima, seguindo o versionamento semântico. Neste caso, ele define 4.0 como a versão mínima compatível e permite atualizações para qualquer versão futura abaixo de 5.0.

De um modo geral, você não precisará alterar as restrições de versão em seu arquivo composer.json. No entanto, algumas situações podem exigir que você edite manualmente as restrições – por exemplo, quando uma nova versão principal da sua biblioteca requerida é liberada e você deseja atualizar, ou quando a biblioteca que você deseja usar não segue o versionamento semântico.

Aqui estão alguns exemplos para lhe dar um melhor entendimento sobre como as restrições de versão do Composer funcionam:

Restrição	Significado	Exemplo de Versões Permitidas
^1.0	>= 1.0 < 2.0	1.0, 1.2.3, 1.9.9
^1.1.0	>= 1.1.0 < 2.0	1.1.0, 1.5.6, 1.9.9
~1.0	>= 1.0 < 2.0.0	1.0, 1.4.1, 1.9.9
~1.0.0	>= 1.0.0 < 1.1	1.0.0, 1.0.4, 1.0.9
1.2.1	1.2.1	1.2.1
1.*	>= 1.0 < 2.0	1.0.0, 1.4.5, 1.9.9
1.2. *	>= 1.2 < 1.3	1.2.0, 1.2.3, 1.2.9
Para uma visualização mais detalhada das restrições de versão do Composer, consulte a documentação oficial.

A seguir, vamos ver como carregar dependências automaticamente com o Composer.

Passo 4 — Incluindo o Script Autoload
Como o PHP por si só não carrega classes automaticamente, o Composer fornece um script autoload que você pode incluir em seu projeto para obter o carregamento automático para ele. Este arquivo é gerado automaticamente pelo Composer quando você adiciona sua primeira dependência.

A única coisa que você precisa fazer é incluir o arquivo vendor/autoload.php em seus scripts PHP antes de qualquer instância de classe.

Vamos testar isso em nossa aplicação de demonstração. Abra um novo arquivo chamado test.php em seu editor de texto:

nano test.php
Adicione o código a seguir que vem no arquivo vendor/autoload.php, carrega a dependência cocur/slugify, e o utiliza para criar um slug:

test.php
<?php
require __DIR__ . '/vendor/autoload.php';

use Cocur\Slugify\Slugify;

$slugify = new Slugify();

echo $slugify->slugify('Hello World, this is a long sentence and I need to make a slug from it!');
Salve o arquivo e saia do seu editor.

Agora, execute o script.

php test.php
Isso produz a saída hello-world-this-is-a-long-sentence-and-i-need-to-make-a-slug-from-it.

As dependências precisam de atualizações quando novas versões são liberadas. Dessa forma, vamos ver como lidar com isso.

Passo 5 — Atualizando as Dependências do Projeto
Sempre que você quiser atualizar suas dependências do projeto para versões mais recentes, execute o comando update:

composer update
Isso irá verificar por versões mais recentes das bibliotecas que você requer em seu projeto. Se uma versão mais recente for encontrada e ela for compatível com a restrição de versão definida no arquivo composer.json, o Composer substituirá a versão anterior instalada. O arquivo composer.lock será atualizado para refletir essas alterações.

Você também pode atualizar uma ou mais bibliotecas específicas, especificando-as desta forma:

composer update vendor/package vendor2/package2
Certifique-se de verificar em seus arquivos composer.json e composer.lock dentro do seu sistema de controle de versão após atualizar suas dependências de modo que outros também possam instalar essas versões mais recentes.








INÍCIO:

1 instalar o docker

2 abrir wsl2/Windows ou linux
 curl -s "https://laravel.build/olw?with=mysql,redis,mailhog,minio" | bash

3 cd olw
./vendor/bin/sail up -d
	ou
4 cd olw && ./vendor/bin/sail up -d

5 ATRIBUINDO PERMISSÃO PARA A PASTA
cd .. -> sai da pasta
sudo chmod 777 olw/ -R ou sem o 'sudo' chmod 777 olw/ -R

6 CRIANDO ALIAS PARA O COMANDO ANTERIOR
alias sail='[ -f sail ] && sh sail || sh vendor/bin/sail'
alias sail='[ -f sail ] && sh sail || sh docker-compose exec app php artisan'

passa a usar assim: sail ps

7 CONFIGURAR PORTAS PARA A APLICAÇÃO NO NAVEGADOR E MYSQL
.env
APP_PORT=8000

*porta do myql
FORWARD_DB_PORT=3307

8 INSTALANDO DEPENDÊNCIA AO PROJETO
./vendor/bin/sail composer require laravel/breeze --dev

9 DEIXAR TELA DE AUTENTICAÇÃO PRONTA, ROTA AUTENTICADA, TAWINDCSS INSTALADO E INERTIA INSTALADO
./vendor/bin/sail artisan breeze:install vue 
ou
./vendor/bin/sail art breeze:install vue


10 RODAR AS MIGRATES PADRÕES DO PROJETO AI JÁ PODE CADASTRAR USUÁRIOS PARA LOGIN:
./vendor/bin/sail art migrate

11 


/*******************************************/
2a AULA:

O PROJETO CONSISTE EM RECEBER DADOS DE UMA API (punkapi.com) DE INFORMAÇÕES SOBRE CERVEJAS, VAMOS CONSTRUIR AS ROTAS PARA CONSUMIR A API E CRIAR A ESTRUTURA PARA O RELATÓRIO QUE IREMOS GERAR EM EXCEL E ENVIAR PARA O STORAGE...
1 CRIAR ROTAS:
code .
olw/routes/web.php


sail up -d -> SOBE O CONTAINER localhost:8000 (nesse projeto)

Route::get('/beers', fn()=> 'Olw - testando a rota /beers');

**************************************************
obs:
- laravel.com/api -> acesso a documentação do código;
- in line paramets for vscode -> extensão para vscode para exibir o nome dos métodos na hora que codificar;
- fira code -> extensão para fonte no vscode

git Hub Copilot vs Tabnine -> (pesquisar sobre)
Link para extensões vscode:
https://github.com/icarojobs/vscode-useful-extensions
*************************************************


Route::get('/beers', fn()=> 'Olw - testando a rota /beers')
                             ->middleware(['auth']);

* FLUXO PADRÃO DO MVC-LARAVEL: 
life cicle: sai do usuário pelo navegador, insomnia ou postman -> passa pelo index.php(pasta public) -> passa pelos arquivos do bootstrap retornando uma instância da aplicação -> passa pelo kernel do http (carrega mais instâncias) -> Service provider -> despacha a requisição pro Router -> Cai no arquivo Web.php -> Middleware (se tiver, geralmente tem os globais) -> Controller (faz as regras de negócio e pode chamar outras classes como Serviços por exemplo)
-> Retorna uma view ou um json (No caso estamos usando inértia, ele não vai reinderizar a 'view.blade' padrão, ele vai reinderizar componente vue.js através do inértia.).


* EM VEZ DE USAR A FUNÇÃO AQUI NA ROTA CRIAMOS UM CONTROLLER:

obs.: ​dica: php artisan make:controller -r cria o Resource também.
dica: limpar o cache do container:
./vendor/bin/sail art config:cache
./vendor/bin/sail art optimize:clear


sail artisan make:controller BeerController
ou 
sail art make:controller BeerController -> CRIA O ARQUIVO BeerController.php na pasta app/Http/Controllers
->
<?php

namespace App\Http\Controllers;

use Illuminate\Http\Request;

class BeerController extends Controller
{
    public function index()
    {
    return 'Virgu & Beer & Code'
    }
}

* NO ARQUIVO DE ROTAS Web.php CHAMA O BeersController:

importante importar o Controller <nomeDoController>+<CTRL=ENTER:
use App\Http\Controllers\BeerController;

Route::get('/beers', [BeerController::class, 'index'])
                        ->middleware(['auth']);


* PRECISAMOS CRIAR UM MÉTODO PARA PEGAR A LISTA, LISTAR OS DADOS DA API (listar as bebidas de https://api.punkapi.com/v2 ->
VAMOS CRIAR UMA NOVA CLASSE de serviços em app/Sevices/PunkapiService.php

* O LARAVEL POSSUI UM RECURSO CHAMADO HTTPClient que abstrai o uso de uma ferramenta chama guzeo, esse guzeo é o client http mais comum para php, com ele fazemos requisições pra diversos serviços web dentro do php para outras url, ele é robusto, então o laravel simplifica importando o recurso que faz tudo por 'detrás dos panos':

PunkapiService.php

<?php

namespace App\Services;

use Illuminate\Support\Facades\Http;

class PunkapiService
{
    public function getBeers()
    {
        return Http::get('https://api.punkapi.com/v2/beers');
    }
}

E NO BeerController.php fica:
<?php

namespace App\Http\Controllers;

use App\Services\PunkapiService;
use Illuminate\Http\Request;

class BeerController extends Controller
{
    public function index()
    {
    //return 'Virgu & Beer & Code';
    $service = new PunkapiService;

    return $service->getBeers();
    }
}

* TRATE É CARACTERÍSTICA QUE A CLASSE ADQUIRE (pode ter mesmos métodos e atributos substituindo o recurso de um classe extender várias classes que não tem no php, a trate é uma forma de fazer isso. O service  é uma outra camada na maioria das vezes abstrair seviços que vc vai consumir, por exemplo API.

Estando logado, os dados da api já serão exibidos em localhost:8000/beers, se usar um aplicativo cliente tipo insomnia pode apresentar os dados também, melhor comentar a linha de de autenticação da rota:
Route::get('/beers', [BeerController::class, 'index']);
linha de autenticação da rota // ->middleware(['auth']);

* ESSA API PERMITE FAZER FILTROS VIA PARÂMETROS NA PRÓPRIA ROTA. PRIMEIRO VAMOS REFATORAR O CÓDIO, A CLASSE PunkapiService.php:

USO DE CONFIG E MACRO


Vamos alterar a url, primeiro acessando a pasta config da raiz do projeto e criar o arquivo punkapi.php. O que acontece é que o config(pasta config da raiz) carrega todos os arquivos da pasta e permite que sejam acessados via funções simples(HELPERS), isso é muito legal porque podemos acessar esses arquivos de configurações de qualquer lugar do projeto: 

<?php

return [
    'url' => env('PUNK_BASE_URL', 'https://api.punkapi.com/v2')
];

Usando o helper env significa dizer que, se não houver a constante PUNK_BASE_URL setada no arquivo .env do projeto, seu valor será o segundo parâmetro: http://api.punkapi.com/v2 e no arquivo PunkapiService.php da pasta app/Services fica:

<?php

namespace App\Services;

use Illuminate\Support\Facades\Http;

class PunkapiService
{
    public function getBeers()
    {
        return Http::get('/beers');
    }
}

MACRO é uma forma de criar funções customizadas:
 em app\Providers vamos acessar o arquivo AppServiceProvider.php que é uma classe que tem dois métodos register e boot. No método boot vamos chamar o método Http do laravel e chamar o método macro, no primeiro parâmetro será um nome atribuído à função e e o segundo uma clausure (uma função).
Neste arquivo é passado o arquivo de configuração da url (em 'config/punkapi.php') além de tokens, headers,...
 

use Illuminate\Support\Facades\Http; -> deve ser importado
E a função boot fica:

  public function boot()
    {
        Http::macro('punkapi', function(){
            return Http::acceptJson()
            ->baseUrl(config('punkapi.url'));
        });
    }

Então criamos uma macro(uma função customizada) chamada punkapi que já retorna o client com accept/Json no Header e com o baseUrl configurado lá do arquivo /config/punkapi.php e se estiver setado no .env pegará de lá.

/app/Services/PunkapiService.php fica:

<?php

namespace App\Services;

use Illuminate\Support\Facades\Http;

class PunkapiService
{
    public function getBeers()
    {
        return Http::punkapi()->get('/beers');
    }
}

*obs.: a baseUrl poderia ser setada no construtor, que pode setar token também.(uma outra abordagem para versão sem macros);

->Testamos o retorno Json em localhost:8000/beers.

Refatorando o arquivo PunkapiService.php: O client Http não lança exceção e podemos forçar o retorno em modo Json:
<?php

namespace App\Services;

use Illuminate\Support\Facades\Http;

class PunkapiService
{
    public function getBeers()
    {
       // return Http::punkapi()->get('/beers');
       return Http::punkapi()
            ->get('/beers')
            ->throw()  // Exceção em caso de erro
            ->json();   // Força o retorno em formato Json
    }
}

Podemos testar forçando um erro alterando a constante PUNKAPI_BASE_URL criada em /config/punkapi.php, vamos atribuir um valor diferente no arquivo .env:

PUNKAPI_BASE_URL="adfjklj878"

Podemos usar a função retry tem dois parâmetros, o número de tentativas pra buscar a requisição e o intervalo entre elas. Refatorando o código fica:
<?php

namespace App\Services;

use Illuminate\Support\Facades\Http;

class PunkapiService
{
    public function getBeers()
    {
       // return Http::punkapi()->get('/beers');
       return Http::punkapi()
            ->get('/beers')
            ->throw()  // Exceção em caso de erro
            ->json();   // Força o retorno em formato Json
    }
}

- Quando sai a exceção nao deveriamos retornar o erro em json por ser um api neste caso estamos usamos um app web e não uma api. E usaríamos o Route Api.

Refatorando o método boot de /app/Providers/AppServiceProvider.php, inserindo o retry():

     */
    public function boot()
    {
        Http::macro('punkapi', function(){
            return Http::acceptJson()
            ->baseUrl(config('punkapi.url'))
            ->retry(3,100);
        });
    }
}

comando de help

* ./vendor/bin/sail composer dump-autoload
* Verificar Nome do arquivo se bate com o nome das rotas(Classes criadas e importar o nome errado);
* inteliphense

Refatorando BeerController.php
<?php

namespace App\Http\Controllers;

use App\Services\PunkapiService;

class BeerController extends Controller
{
    public function index()
    {

    $service = new PunkapiService();

    return $service->getBeers();
    }
}

Em vez de instanciar o método PunkapiService() dentro de index, vamos passar por parâmetro de index() declarando seu Próprio nome (PunkapiService) como tipo. Fica assim:

<?php

namespace App\Http\Controllers;

use App\Services\PunkapiService;

class BeerController extends Controller
{
    public function index(PunkapiService $service)
    {
    return $service->getBeers();
    }
}

Assim usamos feactures do php(injeção de dependências) e ao mesmo tempo feactures do laravel. Em vez de criar uma instância dentro do método index, vamos injetar a classe como parâmetro para o método index(), ficando index($service) e a instância de dentro da função passa como parâmetro de 'tipo da variável'. Isso quebra a cadeia de dependência entre as classes.
Assim, o método index ganha independência não mais dependendo da instância de new PunkapiService e passamos a olhar a função index em si.
Assim, o Laravel tenta fazer um binding, um match, o laravel tenta encontrar alguma classe PunkapiService e cria uma instância dessa classe e usa ali como parâmetro. Se não fizer assim, lá em Rotas teria que ser passado como parâmetro o que fica desnecessário.
Não poderia ser feito se na classe PunkapiService existisse o construtor para atribuir valores automaticamente à classe. Assim podemos usar porque não precisamos passar nenhum valor.

ADICIONAR OS FILTROS:
Vamos filtrar o retorno api com os seguintes itens: beer_name, food, ibu_gt, malte:

var_dump($v)
die();
dd($variável)
benchmarck -> ?

/*****REFATORA PARA TESTE alterando BeerController.php e PunkapiService.php
BeerController.php
<?php

namespace App\Http\Controllers;

use App\Services\PunkapiService;

class BeerController extends Controller
{
    public function index(PunkapiService $service)
    {
    return $service->getBeers(
        'heineken',
        'cheese',
        'corn',
        45
    );
    }
}

PunkapiService.php
<?php

namespace App\Services;

use Illuminate\Support\Facades\Http;

class PunkapiService
{
    public function getBeers(
        string $beer_name,
        string $food,
        string $malt,
        string $ibu_gt
    )
    {
        $params = get_defined_vars();

        dd($params);

        return Http::punkapi()
            ->get('/beers', $params)
            ->throw()  // Exceção em caso de erro
            ->json();   // Força o retorno em formato Json
    }
}

Resultado do debug no insomnia ou no navegador:
array:4 [▼ // app/Services/PunkapiService.php:18
  "beer_name" => "heineken"
  "food" => "cheese"
  "malt" => "corn"
  "ibu_gt" => "45"
]
//* fim teste

Refatorando:

class PunkapiService
{
    public function getBeers(
        string $beer_name = null,
        string $food = null,
        string $malt = null,
        string $ibu_gt = null
    )
    {
        $params = get_defined_vars();

        dd($params);

        return Http::punkapi()
            ->get('/beers', $params)
            ->throw()  // Exceção em caso de erro
            ->json();   // Força o retorno em formato Json
    }
}

Assim quando não passar o valor para a chave ele exibirá a chave e o valor Null, vamos refatorar para não exibir nem a chave englobando get_defined_vers() com array_filter no arquivo PunkapiService.php:

$params = array_filter(get_defined_vars());

<?php

namespace App\Http\Controllers;

use App\Services\PunkapiService;

class BeerController extends Controller
{
    public function index(PunkapiService $service)
    {
    return $service->getBeers(
        'heineken',
        'cheese',
        'corn',
       // 45 -> Esse não é passado
    );
    }
}


array:3 [▼ // app/Services/PunkapiService.php:18
  "beer_name" => "heineken"
  "food" => "cheese"
  "malt" => "corn"
	Aqui não exibiu o valor 45
]


USANDO A FUNÇÃO NAMED_ARGS passamos só os parâmetros que precisamos retornar da api e o php com essa função saberá qual a posição dela no array de argumentos passados como parâmetro sem a necessidade de seguir a mesma sequência dos argumentos:
class BeerController extends Controller
{
    public function index(PunkapiService $service)
    {
    return $service->getBeers(food: 'cheese');
    }
}

REFATORANDO:
BeerController.php
<?php

namespace App\Http\Controllers;

use App\Services\PunkapiService;
use Illuminate\Http\Request;

class BeerController extends Controller
{
    public function index( Request $request, PunkapiService $service)
    {
    return $service->getBeers(...$request->all());
    }
}

PunkapiService.php
<?php

namespace App\Services;

use Illuminate\Support\Facades\Http;

class PunkapiService
{
    public function getBeers(
        string $beer_name = null,
        string $food = null,
        string $malt = null,
        string $ibu_gt = null
    )
    {
        $params = array_filter(get_defined_vars());

     //   dd($params);

        return Http::punkapi()
            ->get('/beers', $params)
            ->throw()  // Exceção em caso de erro
            ->json();   // Força o retorno em formato Json
    }
}

CRIANDO UMA REQUEST
sail artisan make:request BeerRequest
/app/Http/Requests/BeerRequest.php

* Funções anônimas, também conhecidas como closures , permitem a criação de funções que não tem o nome especificado. Elas são mais úteis como o valor de parâmetros callable, mas podem ter vários outros usos.. É uma função passada como parâmetro

CRIANDO NOVA ROTA PARA SALVAR COMO EXCEL
* https://docs.laravel-excel.com/3.1/getting-started/installation.html

Route::group([
    'prefix' => 'beers',
], function() {

    Route::get('/', [BeerController::class, 'index']); //-> Se houver necessidade de salvar dados por essa rota mudamos o método(verbo html) para post(os dados não serão expostos na url).
                          //  ->middleware(['auth']);
    Route::get('/export', [BeerController::class, 'export']);

});

Então passamos a ter duas rotas: localhost:8000/beers
localhost:8000/beers/export

No BeerController incluimos o método export():
class BeerController extends Controller
{
    public function index( BeerRequest $request, PunkapiService $service)
    {
    // return $service->getBeers(...$request->all());
    return $service->getBeers(...$request->validated());
    }

    public function export()
    {
        return 'Relatório criado.';
    }
}



INSTALANDO PACOTE LARAVEL-EXCEL PARA GERAR OS RELATÓRIO EM EXCEL FILTRADOS DA API:

* https://docs.laravel-excel.com/3.1/getting-started/installation.html

COMANDO PARA INSTALAR VIA COMPOSER:
./vendor/bin/sail composer require psr/simple-cache:^2.0 maatwebsite/excel

CRIAR A CLASSE DO EXCEL
./vendor/bin/sail artisan make:export BeerExport  --> Cria o arquivo em  /app/Exports/BeerExport.php

<?php

namespace App\Exports;

use Maatwebsite\Excel\Concerns\FromCollection;

class BeerExport implements FromCollection
{


    /**
    * @return \I¢lluminate\Support\Collection
    */
    public function collection()
    {
        //
    }
}

-> Dentro de colletion buscaremos as informações que serão salvas no arquivo do excel, um array de dados;

criamos um __construct() que vai ter uma propriedade privada do tipo array chamamos de $reportData.

O retorn será uma collection como informa o comentário:
 /**
    * @return \I¢lluminate\Support\Collection
    */

Na função colletion(), está recebendo um array return $this->reportData; 
Observe que não precisa mais declarar uma propriedade que vai se setada via construct(), basta defifinir o escopo junto do argumento e o php faz isso pra você. Como o retorno da função é um array usamos o helper collect para o $this->reportData:

BeerExport.php

<?php

namespace App\Exports;

use Maatwebsite\Excel\Concerns\FromCollection;

class BeerExport implements FromCollection
{

    public function __construct(
        private array $reportData
    ){}

    /**
    * @return \Illuminate\Support\Collection
    */
    public function collection()
    {
       return collect($this->reportData);
    }
}
 

Consultamos a documentação do Laravel-excel em 'Exporting collections':
em Excel Store passa o nome da classe e o nome do arquivo:

BeerController.php
<?php

namespace App\Http\Controllers;


use App\Exports\BeerExport;
use App\Http\Requests\BeerRequest;
use App\Services\PunkapiService;
use Maatwebsite\Excel\Facades\Excel;


class BeerController extends Controller
{
    public function index( BeerRequest $request, PunkapiService $service)
    {
    // return $service->getBeers(...$request->all());
    return $service->getBeers(...$request->validated());
    }

    public function export()
    {
      $params = [
        ['name' => 'Tom', 'age' => '30'],
        ['name' => 'Virgu', 'age' => '27']
       ];

       Excel::store(new BeerExport($params), 'olw-report.xlsx');
       return "Relatório criado";

    }


}

********************************************
* REFATORANDO E SALVANDO O ARQUIVO EXCEL EM /storage/app

BeerExport.php
<?php

namespace App\Exports;

use Maatwebsite\Excel\Concerns\FromCollection;

class BeerExport implements FromCollection
{

    public function __construct(
        private array $reportData
    ){}

    /**
    * @return \Illuminate\Support\Collection
    */
    public function collection()
    {
       return collect($this->reportData);
    }
}
*****************************

BeerController.php

<?php

namespace App\Http\Controllers;


use App\Exports\BeerExport;
use App\Http\Requests\BeerRequest;
use App\Services\PunkapiService;
use Maatwebsite\Excel\Facades\Excel;


class BeerController extends Controller
{
    public function index( BeerRequest $request, PunkapiService $service)
    {
        return $service->getBeers(...$request->all());

    }

    public function export(BeerRequest $request, PunkapiService $service)
    {
        $beers = $service->getBeers(...$request->validated());

        $filteredBeers = collect($beers)->map(function($value, $key){
        return collect($value)
                ->only(['name', 'tagline', 'first_brewed', 'description'])
                ->toArray();
    })->toArray();

    //dd($filteredBeers);

      $params = [
        ['name' => 'Tom', 'age' => '30'],
        ['name' => 'Virgu', 'age' => '27']
       ];

       Excel::store(new BeerExport($filteredBeers), 'olw-report.xlsx');

           return "Relatório criado";

    }


}

PARA SALVAR O ARQUIVO EXCEL EM UM STORAGE S3:
ALTERA BeerController.php

<?php

namespace App\Http\Controllers;


use App\Exports\BeerExport;
use App\Http\Requests\BeerRequest;
use App\Services\PunkapiService;
use Maatwebsite\Excel\Facades\Excel;


class BeerController extends Controller
{
    public function index( BeerRequest $request, PunkapiService $service)
    {
        return $service->getBeers(...$request->all());

    }

    public function export(BeerRequest $request, PunkapiService $service)
    {
        $beers = $service->getBeers(...$request->validated());

        $filteredBeers = collect($beers)->map(function($value, $key){
        return collect($value)
                ->only(['name', 'tagline', 'first_brewed', 'description'])
                ->toArray();
    })->toArray();


       Excel::store(
            new BeerExport($filteredBeers),
             'olw-report.xlsx',
             's3');

           return "Relatório criado";

    }


}

************
O REPOSITÓRIO DE ARQUIVOS minio:
NO DOCKER COMPOSER TEMOS O minio, um S3 que tem
MINIO_ROOT_USER: 'sail'
MINIO_ROOT_PASSWORD: 'password' e roda na porta 9000
localhost:9000
usuário: sail
senha: password

vamos criar um buncket(uma pasta)

e configurar o .env da raiz da aplicação:
originalmente é assim:
AWS_ACCESS_KEY_ID=
AWS_SECRET_ACCESS_KEY=
AWS_DEFAULT_REGION=us-east-1
AWS_BUCKET=
AWS_USE_PATH_STYLE_ENDPOINT=false

 e acrescentamos as informações para:


AWS_ACCESS_KEY_ID=sail
AWS_SECRET_ACCESS_KEY=password
AWS_DEFAULT_REGION=us-east-1
AWS_BUCKET=local
AWS_ENDPOINT=http://minio:9000
AWS_URL=http://minio:9000/local
AWS_USE_PATH_STYLE_ENDPOINT=true

altera tambem:

FILESYSTEM_DISK=local 
para:
FILESYSTEM_DISK=s3

INSTALAR UMA DEPENDÊNCIA (ADAPTER) PARA FAZER CORRESPONDÊNCIA COM A AWS:

Flysystem 3.x em laravel.com/docs/9.x/upgrade
./vendor/bin/sail composer require -W league/flysystem-aws-s3-v3 "^3.0"

em caso de erro:
 artisan vendor:publish --tag=laravel-assets --ansi --force

.env
APP_NAME=Laravel
APP_ENV=local
APP_KEY=base64:UbVvTP6Cu+LF5GamJdB4dsZZvW05ep4bZqcCEhmiDCg=
APP_DEBUG=true
APP_URL=http://localhost
APP_PORT=8000

# PUNKAPI_BASE_URL="httpadfjkljdsdfdfasf878"

LOG_CHANNEL=stack
LOG_DEPRECATIONS_CHANNEL=null
LOG_LEVEL=debug

DB_CONNECTION=mysql
FORWARD_DB_PORT=3307
DB_HOST=mysql
DB_PORT=3306
DB_DATABASE=olw
DB_USERNAME=sail
DB_PASSWORD=password

BROADCAST_DRIVER=log
CACHE_DRIVER=file
FILESYSTEM_DISK=s3
QUEUE_CONNECTION=sync
SESSION_DRIVER=file
SESSION_LIFETIME=120

MEMCACHED_HOST=memcached

REDIS_HOST=redis
REDIS_PASSWORD=null
REDIS_PORT=6379

MAIL_MAILER=smtp
MAIL_HOST=mailhog
MAIL_PORT=1025
MAIL_USERNAME=null
MAIL_PASSWORD=null
MAIL_ENCRYPTION=null
MAIL_FROM_ADDRESS="hello@example.com"
MAIL_FROM_NAME="${APP_NAME}"

AWS_ACCESS_KEY_ID=sail
AWS_SECRET_ACCESS_KEY=password
AWS_DEFAULT_REGION=us-east-1
AWS_BUCKET=local
AWS_ENDPOINT=http://minio:9000
AWS_URL=http://minio:9000/local
AWS_USE_PATH_STYLE_ENDPOINT=true

PUSHER_APP_ID=
PUSHER_APP_KEY=
PUSHER_APP_SECRET=
PUSHER_HOST=
PUSHER_PORT=443
PUSHER_SCHEME=https
PUSHER_APP_CLUSTER=mt1

VITE_PUSHER_APP_KEY="${PUSHER_APP_KEY}"
VITE_PUSHER_HOST="${PUSHER_HOST}"
VITE_PUSHER_PORT="${PUSHER_PORT}"
VITE_PUSHER_SCHEME="${PUSHER_SCHEME}"
VITE_PUSHER_APP_CLUSTER="${PUSHER_APP_CLUSTER}"

PRONTO. ENVIANDO PARA O MINIO.


### /**** ABAIXO AULA DE FRONT END -> FALTA
virgu 3a. aula seed model factory

olw# sail art make:migration create_history_table
/olw# sail art make:model Export -mr

/olw# sail art migrate:fresh --seed ->


























 







/***********************************************************
QUINTA FEIRA: 20/10/22

Open Laravel Week | Deploy com Terraform, EC2 e RDS | Fermentação

****
https://portal.aws.amazon.com/billing/signup?nc2=h_ct&src=header_signup&redirect_url=https%3A%2F%2Faws.amazon.com%2Fregistration-confirmation&language=pt_br#/start/email

Com terraform pode mudar de infra e configurar no git.

PROGRMAR A CONFIGURAÇÃO DO SERVIDOR: É basicamente construir uma nova aplicação para fazer isso, mais fácil de entender.
Terraform serve para (linguagem HCL -> linguagem própria - linguagem descritiva, descreve o resultado e não como irá ser feito), ou seja, descrever o que queremos.
Terraspace é o framework pra terraform.
Quando criamos o Terraform, ele pode variar conforme a infra cloud (aws, azure, google cloud). sua estrutura é a mesma para todos. mas cada provider tem a sua forma de usar, não consegue usar o mesmo código para mais de uma cloud.
Vamos rodar Terraform via container:

1. clonar do git: git clone 
Criar uma pasta para a infraestrutura

sail   (script que vamos usar)
#!/usr/bin/env bash

docker run -rm -it
	-u $(id -u):$(id -g) \
	-v $PWD:/workspace \
	-w /workspace
	hashicorp/terraform:light "%@"


	<no terminal

Logar em: aws.amazon.com
busca: iam
iam dashboard -> mysecurity credencials (root user) -> Acces keys ->clicar em create access keys -> salva o access key e secret access key
e coloca no arquivo credencials na maquina local.. .aws/credencials
















































//////////////////////////////////////////////////////////////////////////////////////////////////////
CONTEÚDO QUE FALTA ORGANIZAR:



/**************************************/

sail share

sail artisan sail:publish ->coloca em uma pasta na raiz chamada docker

sail --help

sail artisan optimizer:clear

sail ps

sail build --no-cache -> faz o bild da aplicação. (dá um sail down  por precaução antes.)










/*********************************

root@DELLAGS:~# curl -s "https://laravel.build/laravel-9-course?with=mysql,redis,mailhog" | bash

Dockerfile

root@DELLAGS:~/example-app# docker exec -it example-app-mysql-1 bash


FROM wyveo/nginx-php-fpm:latest
WORKDIR /usr/share/nginx
RUN rm -rf /usr/share/nginx/html
COPY . /usr/share/nginx
RUN chmod -R 755 /usr/share/nginx/storage/*
RUN ln -s public html

.env (do composer)

DB_CONNECTION=mysql
DB_HOST=mysql-app (serviço do mysql no docker-compose.yaml)
DB_PORT=3306
DB_DATABASE=laraveldockerdb
DB_USERNAME=root
DB_PASSWORD=123456



docker-compose.yaml

version: '3'

services:
  laraveldocker-app:
    build: .
    ports:
      - "3003:80"
    volumes:
      - ./:/usr/share/nginx
      - .docker/nginx:/etc/nginx/conf.d/
    networks:
      - app-network
  mysql-app:
    image: mysql:5.7.22
    ports:
      - "3306:3306"
    volumes:
      - .docker/dbdata:/var/lib/mysql
    environment:
      MYSQL_DATABASE: laraveldocker
      MYSQL_ROOT_PASSWORD: 123456
    networks:
      - app-network
networks:
  app-network:
    driver: bridge
    



/*************************************************
#criando um serviço com um nome qualquer
version: '3'

services:
  laravel-app:                    #criando um serviço com um nome qualquer
    build: . ou image: wyveo/nginx-php-fpm:latest -> neste caso sem Dockerfile.                    # endereço da imagem ou local do Dockerfile (neste caso o ponto siginifica a raiz do projeto)
    ports:
      - "8080:80"                 # 8080 porta do meu host: 80 é a porta do docker nginx
    volumes:                      # docker-compose up -d -> sobe a imagem e libera o terminal  
      - ./:/usr/share/nginx       # TUDO QUE ESTIVE NA RAIZ (na rais tem o meu projeto laravel) './' IRÁ SER REFLETIDO NA PASTA /usr/share/nginx (pasta de acesso da página html)
                                  # C:\Laravel-docker\laravel-docker>docker compose up -d --build atualiza a minha imagem

  mysql-app:
      image: mysql:5.7
      ports:
        - "3306:3306"
      volumes:
        - .docker/dbdata:/var/lib/mysql          # qualqer nome (para persistir -guardar os dados do banco de dados)


      environment:
        MYSQL_DATABASE: laravel
        MYSQL_ROOT_PASSWORD: laravel
    
      

      /***************************///


  
C:\Laravel-docker\laravel-docker>docker compose up -d --build

                                
                               

    

/******************************** Dockerfile
FROM wyveo/nginx-php-fpm:latest

/***************************///
  COMANDOS

docker compose down -> para todos os containers
C:\Laravel-docker\laravel-docker>docker exec -it laravel-docker-laravel-app-1 bash 
root@612ea0ea3340:/# cd /usr/share/nginx/
root@612ea0ea3340:/usr/share/nginx# php artisan migrate
root@612ea0ea3340:/usr/share/nginx# php artisan serve

		
/***********/
PS C:\Users\alber> docker run -e MYSQL_ROOT_PASSWORD=root --name meu-mysql -d mysql:5.7

docker inspect meu-mysql ou | grep IPAddress

PS C:\Users\alber> docker run -e MYSQL_ROOT_PASSWORD=root --name meu-mysql -d -p 3306:3306 mysql:5.7

docker ps
docker ps -l
docker ps -a
docker rm -f nome


/*** LARAVEL */
### CRIANDO UM PROJETO NO LARAVEL 
laravel new projeto_laravel_via_installer (ESTA É UM AOPÇÃO)
composer create-project --prefer-dist laravel/laravel app_controle_tarefas "8.5.9"
cd app_controle_tarefas
cd public
php -S localhost:8000

ou 
da raiz do projeto:
php artisan serve 
ou
php artisan serve --port=3000

### PARA ABRIR PORTA EM OUTRO SERVIDOR
php artisan serve --host test.com --port 8080

 **********************************************************************
cd app_controle_tarefas
cd public
php artisan serve
- acessa o navegador http://localhost:8000

### DENTRO DO PROJETO CRIADO INSTALAR O LARAVEL/UI:^3.2 - versão 3.2
composer require laravel/ui:^3.2

### SE OCORRER ERRO AUMENTAR A MEMÓRIA DISPONIVEL PARA O php

-php --ini -> localiza o arquivo de configuração do php
LOCALIZA memory_limit = 1000 e altera para 
         memory_limit  = -1 e Salva

### LISTA A RELAÇÃO DE COMANDOS 
php artisan list 

DEVERA SURGIR AS OPÇÕES ABAIXO:

 ui
  ui:auth               Scaffold basic login and registration views and routes
  ui:controllers        Scaffold the authentication controllers
 vendor

### ENTENDENDO O PACOTE UI E INICIANDO A AUTENTICAÇÃO WEB NATIVA DO LARAVEL

COMANDO PARA LISTAR ROUTES: 
php artisan route:list

### php artisan ui bootstrap --auth (bootstrap ou react ou vue)
aplicando o bootstrap incluindo os recursos de autenticação;
poderia ser aplicado o bootstrap sem os recursos de autenticação;

### php artisan route:list -> mostra as rotas - ver que aumentaram as rotas

### APÓS ESSE PROCESSO O SISTEMA PEDE PARA RODAR
npm install -> instala as dependências do package.json (inclusive o bootstrap)
npm run dev -> gera os assets da aplicação de acordo com a tecnologia selecionada (bootstrap, react ou vue) -> Geralmente roda mais de uma vez para compilar tudo.

### CRIA O BANCO DE DADOS NORMALMENTE

### EXECUTA AS MIGRATIONS PADRÕES CRIADAS PARA O SISTEMA DE login
php artisan migrate -> CRIA AS TABELAS NO BANCO DE DADOS


************************************** 
INSTALANDO O COMPOSER NO UBUNTU
**************************************
sudo apt update
sudo apt install php-cli unzip

cd ~

curl -sS https://getcomposer.org/installer -o composer-setup.php

HASH=`curl -sS https://composer.github.io/installer.sig`

echo $HASH ->saída: Output
e0012edf3e80b6978849f5eff0d4b4e4c79ff1609dd1e613307e16318854d24ae64f26d17af3ef0bf7cfb710ca74



php -r "if (hash_file('SHA384', 'composer-setup.php') === '$HASH') { echo 'Installer verified'; } else { echo 'Installer corrupt'; unlink('composer-setup.php'); } echo PHP_EOL;"

sudo php composer-setup.php --install-dir=/usr/local/bin --filename=composer





***********************

DigitalOcean Kubernetes: novo plano de controle é mais rápido e gratuito, habilita HA para SLA de 99,95% de tempo de atividade
Produtos
Preços

Documentos
divisa suspensa

Entrar
divisa suspensa

// Tutorial //
Como Instalar e Utilizar o Composer no Ubuntu 20.04
Publicado em 21 de maio de 2020
Ubuntu
PHP
Ubuntu 20.04
Avatar padrão
Por Erika Heidi
Advogado Desenvolvedor
Português
Como Instalar e Utilizar o Composer no Ubuntu 20.04
Introdução
O Composer é uma ferramenta popular de gerenciamento de dependências para o PHP, criado para facilitar a instalação e a atualização das dependências principalmente do projeto. Ele controla quais outros pacotes de projeto específico dependem e são instalados para você, usando as opções apropriadas de acordo com os requisitos do projeto. O Composer também é comumente utilizado para inicializar novos projetos em frameworks PHP populares, como o Symfon e o Laravel .

Neste tutorial, você instalará e começará a usar o Composer em um sistema Ubuntu 20.04.

Pré-requisitos
Para seguir este guia, você pode acessar um servidor como usuário Ubuntu20.04 como usuário sudonão-root um firewall habilitado em seu servidor Para configurar isto, siga nosso guia Configuração do servidor inicial para o Ubuntu 20.04

Passo 1 — Instalando o PHP e as Dependências Adicionais
Além das dependências que já devem estar incluídas em seu sistema Ubuntu 20.04, como o , o Composer exige ou gitexecuta scripts PHP na linha de comando e para extrair arquivos zipados. Vamos instalar essas dependências agora.curlphp-cliunzip

primeiro, atual, gerenciador de pacotes de soluções: o cache do gerenciador de pacotes

sudo apt update
Em seguida, o seguinte comando para instalar os pacotes, execute:

sudo apt install php-cli unzip
Você será solicitado a confirmar a instalação digitando Ye, depois, ENTER.

Assim que os pré-requisitos para instalação do Composer forem instalados, você poderá seguir.

Passo 2 — Baixando e Instalando o Compositor
O Composer fornece um instalador de script escrito em PHP. Vamos baixá-lo, verificar se ele não está danificado e, em seguida, o usaremos para instalar o Composer.

Certifique-se de estar em sua pasta home. Em seguida, baixe o instalador usando o curl:

cd ~
curl -sS https://getcomposer.org/installer -o composer-setup.php
Em seguida, vamos verificar se o instalador baixado corresponde ao hash SHA-384 para o instalador mais recente encontrado na página Composer Public Keys / Signatures . Para facilitar o passo de seleção, você pode usar o seguinte comando para obter programaticamente o hash mais recente da página do Composer e armazená-lo em uma variável do shell:

HASH=`curl -sS https://composer.github.io/installer.sig`
Se você quiser verificar o valor realizado, execute:

echo $HASH
Output
e0012edf3e80b6978849f5eff0d4b4e4c79ff1609dd1e613307e16318854d24ae64f26d17af3ef0bf7cfb710ca74755a
Agora o código PHP a seguir, execute conforme a página de download do Composer, para verificar se o script de instalação está seguro para ser executado:

php -r "if (hash_file('SHA384', 'composer-setup.php') === '$HASH') { echo 'Installer verified'; } else { echo 'Installer corrupt'; unlink('composer-setup.php'); } echo PHP_EOL;"
Você verá o seguinte resultado:

Resultado
Installer verified
Se Installer corruptvocê estiver usando o hash correto, verifique se você está usando o hash correto. Em seguida, repita o processo de verificação. Quando você tiver um instalador selecionado, você pode continuar.

Para instalar o composerglobalmente, use o seguinte comando que baixará e instalará o Composer como um comando disponível em todo o sistema chamado composer, sob /usr/local/bin:

sudo php composer-setup.php --install-dir=/usr/local/bin --filename=composer
Você verá um resultado semelhante com este:

Output
All settings correct for using Composer
Downloading...

Composer (version 1.10.5) successfully installed to: /usr/local/bin/composer
Use it: php /usr/local/bin/composer
Para testar sua instalação, execute:

composer
Output
   ______
  / ____/___  ____ ___  ____  ____  ________  _____
 / /   / __ \/ __ `__ \/ __ \/ __ \/ ___/ _ \/ ___/
/ /___/ /_/ / / / / / / /_/ / /_/ (__  )  __/ /
\____/\____/_/ /_/ /_/ .___/\____/____/\___/_/
                    /_/
Composer version 1.10.5 2020-04-10 11:44:22

Usage:
  command [options] [arguments]

Options:
  -h, --help                     Display this help message
  -q, --quiet                    Do not output any message
  -V, --version                  Display this application version
      --ansi                     Force ANSI output
      --no-ansi                  Disable ANSI output
  -n, --no-interaction           Do not ask any interactive question
      --profile                  Display timing and memory usage information
      --no-plugins               Whether to disable plugins.
  -d, --working-dir=WORKING-DIR  If specified, use the given directory as working directory.
      --no-cache                 Prevent use of the cache
  -v|vv|vvv, --verbose           Increase the verbosity of messages: 1 for normal output, 2 for more verbose output and 3 for debug
...
Isso verifica que o Composer foi instalado com sucesso em seu sistema e está disponível em todo o sistema.

Nota: se você preferirá ter-lhe-ão separados separados do Composer para projeto hospedado neste servidor, você pode instalar localmente, em uma base por projeto. Este método também é útil quando o usuário do sistema não possui permissão para instalar o software disponível em todo o sistema.

Para fazer isso, use o comando php composer-setup.php. Isso irá gerar um arquivo composer.pharem seu diretório atual, que pode ser executado com o seu atual php composer.phar.

Agora podemos dar uma dependência em como usar o Compose como gerenciar.

Passo 3 — Usando o Compositor em um Projeto PHP
Os projetos PHP geralmente dependentes de bibliotecas externas, e o gerenciamento de dependências e suas versões podem ser complicados. O Composer resolve esse problema de manter um controle de projeto de extensões e dependências, também facilita o processo de descoberta, instalação e atualização de pacotes que são definidos por enquanto.

Para usar o seu projeto, você pode compor um arquivo composer.json. O arquivo composer.jsonComposer quais dependências precisa para baixar seu projeto quais serão as versões de cada pacote tem permissão para instalações e instalações. Isso é muito importante para manter seu projeto consistente e evitar a instalação de versões instáveis ​​que podem causar problemas de compatibilidade retroativa.

Você não precisa criar este arquivo manualmente - é comum ocorrer erros de sintaxe quando fizer isso. O Composer oferece uma maneira de criar um novo arquivo composer.jsoncom base na entrada do usuário, o que é uma boa escolha se você planeja compartilhar seu projeto mais tarde como um pacote público no Packagist . O Composer gera automaticamente um arquivo básico composer.jsonquando você executa um comando composer requirepara incluir uma dependência em um projeto recém-criado.

O processo de uso do Composer para instalar um pacote como uma dependência em um projeto envolve os passos a seguir:

Identifique o tipo de biblioteca que o aplicativo precisa.
uma biblioteca de código aberto adequada no agist.org , o responsável oficial de pacotes para o Compose.
Escolha o pacote de dependência.
Execute composer requirepara incluir a dependência no arquivo composer.jsone instalar o pacote.
Vamos testar isso com uma aplicação de demonstração.

O objetivo desta aplicação é transformar uma determinação determinada em uma string de URL amigável - um slug . Isso é comumente usado para converter os títulos de página para caminhos de URL (Assim como a parte final da URL para este tutorial).

Vamos começar a criar um diretório para o nosso projeto. Vamos chamá-lo de slugify :

cd ~
mkdir slugify
cd slugify
Embora não seja necessário, você pode executar agora um comando composer init para criar um arquivo composer.json detalhado para seu projeto. Como o único objetivo do nosso projeto é demonstrar como instalar dependências com o Composer, usaremos um arquivo composer.json mais simples que será gerado automaticamente quando exigirmos nosso primeiro pacote.

Agora é hora de procurar no Packagist.org por um pacote que pode nos ajudar a gerar slugs. Se você procurar pelo termo “slug” no Packagist, receberá um resultado parecido com este:

Resultados da Pesquisa do Packagist para o termo "slug"

Você verá dois números no lado direito de cada pacote na lista. O número no topo representa quantas vezes o pacote foi instalado através do Composer, e o número em baixo mostra quantas vezes um pacote foi estrelado no GitHub. De um modo geral, os pacotes com mais instalações e mais estrelas tendem a ser mais estáveis, pois mais pessoas os utilizam. Também é importante verificar a descrição do pacote para relevância para garantir que ele é o que você precisa.

Precisamos de um conversor string-to-slug A partir dos resultados da pesquisa, o pacote cocur/slugify, que aparece como o primeiro resultado naquela página, parece ser um bom candidato, com uma quantidade razoável de instalações e estrelas.

Os pacotes no Packagist têm um nome de vendor e um nome de package. Cada pacote tem um identificador único (um namespace) no mesmo formato que o GitHub utiliza para seus repositórios: vendor/package. A biblioteca que queremos instalar utiliza o namespace cocur/slugify. Você precisa de um namespace do pacote para exigi-lo em seu projeto.

Agora que você sabe exatamente qual pacote deseja instalar, você pode executar o composer require para incluí-lo como uma dependência e gerar também o arquivo composer.json para seu projeto. Uma coisa importante é observar a exigência de pacotes. O Composer rastreia as dependências no nível da aplicação e do sistema. As dependências no nível do sistema são importantes para indicar de quais módulos PHP um pacote depende. No caso do pacote cocur/slugify, ele exige um módulo PHP que ainda não instalamos.

Quando um pacote necessário depende de uma biblioteca de sistema que não está atualmente instalada em seu servidor, você receberá um erro informando qual requisito está faltando:

composer require cocur/slugify
Output
Using version ^4.0 for cocur/slugify
./composer.json has been updated
Loading composer repositories with package information
Updating dependencies (including require-dev)
Your requirements could not be resolved to an installable set of packages.

  Problem 1
    - Installation request for cocur/slugify ^4.0 -> satisfiable by cocur/slugify[v4.0.0].
    - cocur/slugify v4.0.0 requires ext-mbstring * -> the requested PHP extension mbstring is missing from your system.
...
Para resolver o problema de dependência do sistema, podemos procurar pelo pacote que falta usando o apt search:

apt search mbstring
Output
Sorting... Done
Full Text Search... Done
php-mbstring/focal 2:7.4+75 all
  MBSTRING module for PHP [default]

php-patchwork-utf8/focal 1.3.1-1 all
  UTF-8 strings handling for PHP

php7.4-mbstring/focal 7.4.3-4ubuntu1 amd64
  MBSTRING module for PHP
Após localizar o nome do pacote correto, você pode utilizar o apt novamente para instalar a dependência de sistema:

sudo apt install php-mbstring
Assim que a instalação terminar, você pode executar novamente o comando composer require:

composer require cocur/slugify
Output
Using version ^4.0 for cocur/slugify
./composer.json has been created
Loading composer repositories with package information
Updating dependencies (including require-dev)
Package operations: 1 install, 0 updates, 0 removals
  - Installing cocur/slugify (v4.0.0): Downloading (100%)         
Writing lock file
Generating autoload files
Como você pode ver na saída, o Composer decidiu automaticamente qual versão do pacote utilizar. Se você verificar o diretório do seu projeto agora, ele irá conter dois arquivos novos: composer.json e composer.lock, e um diretório vendor:

ls -l
Output
total 12
-rw-rw-r-- 1 sammy sammy   59 May  4 13:56 composer.json
-rw-rw-r-- 1 sammy sammy 3229 May  4 13:56 composer.lock
drwxrwxr-x 4 sammy sammy 4096 May  4 13:56 vendor
O arquivo composer.lock é usado para armazenar informações sobre quais versões de cada pacote estão instaladas, e garantir que as mesmas versões sejam usadas se outra pessoa clonar seu projeto e instalar suas dependências. O diretório vendor é onde as dependências do projeto estão localizadas. Você não deve fazer commit da pasta vendor no controle de versão - você precisa apenas incluir os arquivos composer.json e composer.lock.

Ao instalar um projeto que já contém um arquivo composer.json, execute o composer install para baixar as dependências do projeto.

Vamos dar uma olhada rápida em restrições de versão. Se você verificar o conteúdo do seu arquivo composer.json, verá algo parecido com isto:

cat composer.json
Output
{
    "require": {
        "cocur/slugify": "^4.0"
    }
}
Note que há o caractere especial ^ antes do número da versão no composer.json. O Composer suporta várias restrições diferentes e formatos para definir a versão necessária do pacote, para fornecer flexibilidade enquanto também mantém seu projeto estável. O operador circunflexo (^) utilizado pelo arquivo composer.json criado automaticamente é o operador recomendado para a interoperabilidade máxima, seguindo o versionamento semântico. Neste caso, ele define 4.0 como a versão mínima compatível e permite atualizações para qualquer versão futura abaixo de 5.0.

De um modo geral, você não precisará alterar as restrições de versão em seu arquivo composer.json. No entanto, algumas situações podem exigir que você edite manualmente as restrições – por exemplo, quando uma nova versão principal da sua biblioteca requerida é liberada e você deseja atualizar, ou quando a biblioteca que você deseja usar não segue o versionamento semântico.

Aqui estão alguns exemplos para lhe dar um melhor entendimento sobre como as restrições de versão do Composer funcionam:

Restrição	Significado	Exemplo de Versões Permitidas
^1.0	>= 1.0 < 2.0	1.0, 1.2.3, 1.9.9
^1.1.0	>= 1.1.0 < 2.0	1.1.0, 1.5.6, 1.9.9
~1.0	>= 1.0 < 2.0.0	1.0, 1.4.1, 1.9.9
~1.0.0	>= 1.0.0 < 1.1	1.0.0, 1.0.4, 1.0.9
1.2.1	1.2.1	1.2.1
1.*	>= 1.0 < 2.0	1.0.0, 1.4.5, 1.9.9
1.2. *	>= 1.2 < 1.3	1.2.0, 1.2.3, 1.2.9
Para uma visualização mais detalhada das restrições de versão do Composer, consulte a documentação oficial.

A seguir, vamos ver como carregar dependências automaticamente com o Composer.

Passo 4 — Incluindo o Script Autoload
Como o PHP por si só não carrega classes automaticamente, o Composer fornece um script autoload que você pode incluir em seu projeto para obter o carregamento automático para ele. Este arquivo é gerado automaticamente pelo Composer quando você adiciona sua primeira dependência.

A única coisa que você precisa fazer é incluir o arquivo vendor/autoload.php em seus scripts PHP antes de qualquer instância de classe.

Vamos testar isso em nossa aplicação de demonstração. Abra um novo arquivo chamado test.php em seu editor de texto:

nano test.php
Adicione o código a seguir que vem no arquivo vendor/autoload.php, carrega a dependência cocur/slugify, e o utiliza para criar um slug:

test.php
<?php
require __DIR__ . '/vendor/autoload.php';

use Cocur\Slugify\Slugify;

$slugify = new Slugify();

echo $slugify->slugify('Hello World, this is a long sentence and I need to make a slug from it!');
Salve o arquivo e saia do seu editor.

Agora, execute o script.

php test.php
Isso produz a saída hello-world-this-is-a-long-sentence-and-i-need-to-make-a-slug-from-it.

As dependências precisam de atualizações quando novas versões são liberadas. Dessa forma, vamos ver como lidar com isso.

Passo 5 — Atualizando as Dependências do Projeto
Sempre que você quiser atualizar suas dependências do projeto para versões mais recentes, execute o comando update:

composer update
Isso irá verificar por versões mais recentes das bibliotecas que você requer em seu projeto. Se uma versão mais recente for encontrada e ela for compatível com a restrição de versão definida no arquivo composer.json, o Composer substituirá a versão anterior instalada. O arquivo composer.lock será atualizado para refletir essas alterações.

Você também pode atualizar uma ou mais bibliotecas específicas, especificando-as desta forma:

composer update vendor/package vendor2/package2
Certifique-se de verificar em seus arquivos composer.json e composer.lock dentro do seu sistema de controle de versão após atualizar suas dependências de modo que outros também possam instalar essas versões mais recentes.

Conclusão





***********
Algoritmo "CalculoMedia2"
// Disciplina: Lógica de programação
// Professor : Antonio Carlos Nicolodi
// Descrição : calculo da média aritimética
// Autor     : Professor Antonio
// Data atual: 01/04/2015
var
// Seção de Declarações
   v1, v2, total: Real
   sinal : Caracter
Inicio
// Seção dos Comandos
   Escreva ("Digite o primeiro valor: ")
   Leia (v1)
   Escreva ("Digite a operação + - * / : ")
   Leia (sinal)
   Escreva ("Digite o segundo valor: ")
   Leia (v2)

   Se sinal = "+" entao
   total <- v1 + v2
   Escreva("O Resultado é: ", total)
   Senao
   Se sinal = "-" entao
   total <- v1 - v2
   Escreva("O Resultado é: ", total)
   Senao
   Se sinal = "*" entao
   total <- v1 * v2
   Escreva("O Resultado é: ", total)


   Senao
     Escreva("OPERAÇÃO INVÁLIDA! ")



      Escreval("total")
   fimse
Fimalgoritmo

****
COMANDOS DOCKER
root@DELLAGS:~# curl -s "https://laravel.build/laravel-9-course?with=mysql,redis,mailhog" | bash

root@DELLAGS:~/example-app# ./vendor/bin/sail  artisan migrate --seed -> criar o banco de dados e copular dados;

Dockerfile

root@DELLAGS:~/example-app# docker exec -it example-app-mysql-1 bash


FROM wyveo/nginx-php-fpm:latest
WORKDIR /usr/share/nginx
RUN rm -rf /usr/share/nginx/html
COPY . /usr/share/nginx
RUN chmod -R 755 /usr/share/nginx/storage/*
RUN ln -s public html

.env (do composer)

DB_CONNECTION=mysql
DB_HOST=mysql-app (serviço do mysql no docker-compose.yaml)
DB_PORT=3306
DB_DATABASE=laraveldockerdb
DB_USERNAME=root
DB_PASSWORD=123456



docker-compose.yaml

version: '3'

services:
  laraveldocker-app:
    build: .
    ports:
      - "3003:80"
    volumes:
      - ./:/usr/share/nginx
      - .docker/nginx:/etc/nginx/conf.d/
    networks:
      - app-network
  mysql-app:
    image: mysql:5.7.22
    ports:
      - "3306:3306"
    volumes:
      - .docker/dbdata:/var/lib/mysql
    environment:
      MYSQL_DATABASE: laraveldocker
      MYSQL_ROOT_PASSWORD: 123456
    networks:
      - app-network
networks:
  app-network:
    driver: bridge
    



/*************************************************
#criando um serviço com um nome qualquer
version: '3'

services:
  laravel-app:                    #criando um serviço com um nome qualquer
    build: . ou image: wyveo/nginx-php-fpm:latest -> neste caso sem Dockerfile.                    # endereço da imagem ou local do Dockerfile (neste caso o ponto siginifica a raiz do projeto)
    ports:
      - "8080:80"                 # 8080 porta do meu host: 80 é a porta do docker nginx
    volumes:                      # docker-compose up -d -> sobe a imagem e libera o terminal  
      - ./:/usr/share/nginx       # TUDO QUE ESTIVE NA RAIZ (na rais tem o meu projeto laravel) './' IRÁ SER REFLETIDO NA PASTA /usr/share/nginx (pasta de acesso da página html)
                                  # C:\Laravel-docker\laravel-docker>docker compose up -d --build atualiza a minha imagem

  mysql-app:
      image: mysql:5.7
      ports:
        - "3306:3306"
      volumes:
        - .docker/dbdata:/var/lib/mysql          # qualqer nome (para persistir -guardar os dados do banco de dados)


      environment:
        MYSQL_DATABASE: laravel
        MYSQL_ROOT_PASSWORD: laravel
    
      

      /***************************///


  
C:\Laravel-docker\laravel-docker>docker compose up -d --build

                                
                               

    

/******************************** Dockerfile
FROM wyveo/nginx-php-fpm:latest

/***************************///
  COMANDOS

docker compose down -> para todos os containers
C:\Laravel-docker\laravel-docker>docker exec -it laravel-docker-laravel-app-1 bash 
root@612ea0ea3340:/# cd /usr/share/nginx/
root@612ea0ea3340:/usr/share/nginx# php artisan migrate
root@612ea0ea3340:/usr/share/nginx# php artisan serve

		
/***********/
PS C:\Users\alber> docker run -e MYSQL_ROOT_PASSWORD=root --name meu-mysql -d mysql:5.7

docker inspect meu-mysql ou | grep IPAddress

PS C:\Users\alber> docker run -e MYSQL_ROOT_PASSWORD=root --name meu-mysql -d -p 3306:3306 mysql:5.7

docker ps
docker ps -l
docker ps -a
docker rm -f nome


/*** LARAVEL */
### CRIANDO UM PROJETO NO LARAVEL 
laravel new projeto_laravel_via_installer (ESTA É UM AOPÇÃO)
composer create-project --prefer-dist laravel/laravel app_controle_tarefas "8.5.9"
cd app_controle_tarefas
cd public
php -S localhost:8000

ou 
da raiz do projeto:
php artisan serve 
ou
php artisan serve --port=3000

### PARA ABRIR PORTA EM OUTRO SERVIDOR
php artisan serve --host test.com --port 8080

 **********************************************************************
cd app_controle_tarefas
cd public
php artisan serve
- acessa o navegador http://localhost:8000

### DENTRO DO PROJETO CRIADO INSTALAR O LARAVEL/UI:^3.2 - versão 3.2
composer require laravel/ui:^3.2

### SE OCORRER ERRO AUMENTAR A MEMÓRIA DISPONIVEL PARA O php

-php --ini -> localiza o arquivo de configuração do php
LOCALIZA memory_limit = 1000 e altera para 
         memory_limit  = -1 e Salva

### LISTA A RELAÇÃO DE COMANDOS 
php artisan list 

DEVERA SURGIR AS OPÇÕES ABAIXO:

 ui
  ui:auth               Scaffold basic login and registration views and routes
  ui:controllers        Scaffold the authentication controllers
 vendor

### ENTENDENDO O PACOTE UI E INICIANDO A AUTENTICAÇÃO WEB NATIVA DO LARAVEL

COMANDO PARA LISTAR ROUTES: 
php artisan route:list

### php artisan ui bootstrap --auth (bootstrap ou react ou vue)
aplicando o bootstrap incluindo os recursos de autenticação;
poderia ser aplicado o bootstrap sem os recursos de autenticação;

### php artisan route:list -> mostra as rotas - ver que aumentaram as rotas

### APÓS ESSE PROCESSO O SISTEMA PEDE PARA RODAR
npm install -> instala as dependências do package.json (inclusive o bootstrap)
npm run dev -> gera os assets da aplicação de acordo com a tecnologia selecionada (bootstrap, react ou vue) -> Geralmente roda mais de uma vez para compilar tudo.

### CRIA O BANCO DE DADOS NORMALMENTE

### EXECUTA AS MIGRATIONS PADRÕES CRIADAS PARA O SISTEMA DE login
php artisan migrate -> CRIA AS TABELAS NO BANCO DE DADOS


************************************** 
INSTALANDO O COMPOSER NO UBUNTU
**************************************
sudo apt update
sudo apt install php-cli unzip

cd ~

curl -sS https://getcomposer.org/installer -o composer-setup.php

HASH=`curl -sS https://composer.github.io/installer.sig`

echo $HASH ->saída: Output
e0012edf3e80b6978849f5eff0d4b4e4c79ff1609dd1e613307e16318854d24ae64f26d17af3ef0bf7cfb710ca74



php -r "if (hash_file('SHA384', 'composer-setup.php') === '$HASH') { echo 'Installer verified'; } else { echo 'Installer corrupt'; unlink('composer-setup.php'); } echo PHP_EOL;"

sudo php composer-setup.php --install-dir=/usr/local/bin --filename=composer





***********************

DigitalOcean Kubernetes: novo plano de controle é mais rápido e gratuito, habilita HA para SLA de 99,95% de tempo de atividade
Produtos
Preços

Documentos
divisa suspensa

Entrar
divisa suspensa

// Tutorial //
Como Instalar e Utilizar o Composer no Ubuntu 20.04
Publicado em 21 de maio de 2020
Ubuntu
PHP
Ubuntu 20.04
Avatar padrão
Por Erika Heidi
Advogado Desenvolvedor
Português
Como Instalar e Utilizar o Composer no Ubuntu 20.04
Introdução
O Composer é uma ferramenta popular de gerenciamento de dependências para o PHP, criado para facilitar a instalação e a atualização das dependências principalmente do projeto. Ele controla quais outros pacotes de projeto específico dependem e são instalados para você, usando as opções apropriadas de acordo com os requisitos do projeto. O Composer também é comumente utilizado para inicializar novos projetos em frameworks PHP populares, como o Symfon e o Laravel .

Neste tutorial, você instalará e começará a usar o Composer em um sistema Ubuntu 20.04.

Pré-requisitos
Para seguir este guia, você pode acessar um servidor como usuário Ubuntu20.04 como usuário sudonão-root um firewall habilitado em seu servidor Para configurar isto, siga nosso guia Configuração do servidor inicial para o Ubuntu 20.04

Passo 1 — Instalando o PHP e as Dependências Adicionais
Além das dependências que já devem estar incluídas em seu sistema Ubuntu 20.04, como o , o Composer exige ou gitexecuta scripts PHP na linha de comando e para extrair arquivos zipados. Vamos instalar essas dependências agora.curlphp-cliunzip

primeiro, atual, gerenciador de pacotes de soluções: o cache do gerenciador de pacotes

sudo apt update
Em seguida, o seguinte comando para instalar os pacotes, execute:

sudo apt install php-cli unzip
Você será solicitado a confirmar a instalação digitando Ye, depois, ENTER.

Assim que os pré-requisitos para instalação do Composer forem instalados, você poderá seguir.

Passo 2 — Baixando e Instalando o Compositor
O Composer fornece um instalador de script escrito em PHP. Vamos baixá-lo, verificar se ele não está danificado e, em seguida, o usaremos para instalar o Composer.

Certifique-se de estar em sua pasta home. Em seguida, baixe o instalador usando o curl:

cd ~
curl -sS https://getcomposer.org/installer -o composer-setup.php
Em seguida, vamos verificar se o instalador baixado corresponde ao hash SHA-384 para o instalador mais recente encontrado na página Composer Public Keys / Signatures . Para facilitar o passo de seleção, você pode usar o seguinte comando para obter programaticamente o hash mais recente da página do Composer e armazená-lo em uma variável do shell:

HASH=`curl -sS https://composer.github.io/installer.sig`
Se você quiser verificar o valor realizado, execute:

echo $HASH
Output
e0012edf3e80b6978849f5eff0d4b4e4c79ff1609dd1e613307e16318854d24ae64f26d17af3ef0bf7cfb710ca74755a
Agora o código PHP a seguir, execute conforme a página de download do Composer, para verificar se o script de instalação está seguro para ser executado:

php -r "if (hash_file('SHA384', 'composer-setup.php') === '$HASH') { echo 'Installer verified'; } else { echo 'Installer corrupt'; unlink('composer-setup.php'); } echo PHP_EOL;"
Você verá o seguinte resultado:

Resultado
Installer verified
Se Installer corruptvocê estiver usando o hash correto, verifique se você está usando o hash correto. Em seguida, repita o processo de verificação. Quando você tiver um instalador selecionado, você pode continuar.

Para instalar o composerglobalmente, use o seguinte comando que baixará e instalará o Composer como um comando disponível em todo o sistema chamado composer, sob /usr/local/bin:

sudo php composer-setup.php --install-dir=/usr/local/bin --filename=composer
Você verá um resultado semelhante com este:

Output
All settings correct for using Composer
Downloading...

Composer (version 1.10.5) successfully installed to: /usr/local/bin/composer
Use it: php /usr/local/bin/composer
Para testar sua instalação, execute:

composer
Output
   ______
  / ____/___  ____ ___  ____  ____  ________  _____
 / /   / __ \/ __ `__ \/ __ \/ __ \/ ___/ _ \/ ___/
/ /___/ /_/ / / / / / / /_/ / /_/ (__  )  __/ /
\____/\____/_/ /_/ /_/ .___/\____/____/\___/_/
                    /_/
Composer version 1.10.5 2020-04-10 11:44:22

Usage:
  command [options] [arguments]

Options:
  -h, --help                     Display this help message
  -q, --quiet                    Do not output any message
  -V, --version                  Display this application version
      --ansi                     Force ANSI output
      --no-ansi                  Disable ANSI output
  -n, --no-interaction           Do not ask any interactive question
      --profile                  Display timing and memory usage information
      --no-plugins               Whether to disable plugins.
  -d, --working-dir=WORKING-DIR  If specified, use the given directory as working directory.
      --no-cache                 Prevent use of the cache
  -v|vv|vvv, --verbose           Increase the verbosity of messages: 1 for normal output, 2 for more verbose output and 3 for debug
...
Isso verifica que o Composer foi instalado com sucesso em seu sistema e está disponível em todo o sistema.

Nota: se você preferirá ter-lhe-ão separados separados do Composer para projeto hospedado neste servidor, você pode instalar localmente, em uma base por projeto. Este método também é útil quando o usuário do sistema não possui permissão para instalar o software disponível em todo o sistema.

Para fazer isso, use o comando php composer-setup.php. Isso irá gerar um arquivo composer.pharem seu diretório atual, que pode ser executado com o seu atual php composer.phar.

Agora podemos dar uma dependência em como usar o Compose como gerenciar.

Passo 3 — Usando o Compositor em um Projeto PHP
Os projetos PHP geralmente dependentes de bibliotecas externas, e o gerenciamento de dependências e suas versões podem ser complicados. O Composer resolve esse problema de manter um controle de projeto de extensões e dependências, também facilita o processo de descoberta, instalação e atualização de pacotes que são definidos por enquanto.

Para usar o seu projeto, você pode compor um arquivo composer.json. O arquivo composer.jsonComposer quais dependências precisa para baixar seu projeto quais serão as versões de cada pacote tem permissão para instalações e instalações. Isso é muito importante para manter seu projeto consistente e evitar a instalação de versões instáveis ​​que podem causar problemas de compatibilidade retroativa.

Você não precisa criar este arquivo manualmente - é comum ocorrer erros de sintaxe quando fizer isso. O Composer oferece uma maneira de criar um novo arquivo composer.jsoncom base na entrada do usuário, o que é uma boa escolha se você planeja compartilhar seu projeto mais tarde como um pacote público no Packagist . O Composer gera automaticamente um arquivo básico composer.jsonquando você executa um comando composer requirepara incluir uma dependência em um projeto recém-criado.

O processo de uso do Composer para instalar um pacote como uma dependência em um projeto envolve os passos a seguir:

Identifique o tipo de biblioteca que o aplicativo precisa.
uma biblioteca de código aberto adequada no agist.org , o responsável oficial de pacotes para o Compose.
Escolha o pacote de dependência.
Execute composer requirepara incluir a dependência no arquivo composer.jsone instalar o pacote.
Vamos testar isso com uma aplicação de demonstração.

O objetivo desta aplicação é transformar uma determinação determinada em uma string de URL amigável - um slug . Isso é comumente usado para converter os títulos de página para caminhos de URL (Assim como a parte final da URL para este tutorial).

Vamos começar a criar um diretório para o nosso projeto. Vamos chamá-lo de slugify :

cd ~
mkdir slugify
cd slugify
Embora não seja necessário, você pode executar agora um comando composer init para criar um arquivo composer.json detalhado para seu projeto. Como o único objetivo do nosso projeto é demonstrar como instalar dependências com o Composer, usaremos um arquivo composer.json mais simples que será gerado automaticamente quando exigirmos nosso primeiro pacote.

Agora é hora de procurar no Packagist.org por um pacote que pode nos ajudar a gerar slugs. Se você procurar pelo termo “slug” no Packagist, receberá um resultado parecido com este:

Resultados da Pesquisa do Packagist para o termo "slug"

Você verá dois números no lado direito de cada pacote na lista. O número no topo representa quantas vezes o pacote foi instalado através do Composer, e o número em baixo mostra quantas vezes um pacote foi estrelado no GitHub. De um modo geral, os pacotes com mais instalações e mais estrelas tendem a ser mais estáveis, pois mais pessoas os utilizam. Também é importante verificar a descrição do pacote para relevância para garantir que ele é o que você precisa.

Precisamos de um conversor string-to-slug A partir dos resultados da pesquisa, o pacote cocur/slugify, que aparece como o primeiro resultado naquela página, parece ser um bom candidato, com uma quantidade razoável de instalações e estrelas.

Os pacotes no Packagist têm um nome de vendor e um nome de package. Cada pacote tem um identificador único (um namespace) no mesmo formato que o GitHub utiliza para seus repositórios: vendor/package. A biblioteca que queremos instalar utiliza o namespace cocur/slugify. Você precisa de um namespace do pacote para exigi-lo em seu projeto.

Agora que você sabe exatamente qual pacote deseja instalar, você pode executar o composer require para incluí-lo como uma dependência e gerar também o arquivo composer.json para seu projeto. Uma coisa importante é observar a exigência de pacotes. O Composer rastreia as dependências no nível da aplicação e do sistema. As dependências no nível do sistema são importantes para indicar de quais módulos PHP um pacote depende. No caso do pacote cocur/slugify, ele exige um módulo PHP que ainda não instalamos.

Quando um pacote necessário depende de uma biblioteca de sistema que não está atualmente instalada em seu servidor, você receberá um erro informando qual requisito está faltando:

composer require cocur/slugify
Output
Using version ^4.0 for cocur/slugify
./composer.json has been updated
Loading composer repositories with package information
Updating dependencies (including require-dev)
Your requirements could not be resolved to an installable set of packages.

  Problem 1
    - Installation request for cocur/slugify ^4.0 -> satisfiable by cocur/slugify[v4.0.0].
    - cocur/slugify v4.0.0 requires ext-mbstring * -> the requested PHP extension mbstring is missing from your system.
...
Para resolver o problema de dependência do sistema, podemos procurar pelo pacote que falta usando o apt search:

apt search mbstring
Output
Sorting... Done
Full Text Search... Done
php-mbstring/focal 2:7.4+75 all
  MBSTRING module for PHP [default]

php-patchwork-utf8/focal 1.3.1-1 all
  UTF-8 strings handling for PHP

php7.4-mbstring/focal 7.4.3-4ubuntu1 amd64
  MBSTRING module for PHP
Após localizar o nome do pacote correto, você pode utilizar o apt novamente para instalar a dependência de sistema:

sudo apt install php-mbstring
Assim que a instalação terminar, você pode executar novamente o comando composer require:

composer require cocur/slugify
Output
Using version ^4.0 for cocur/slugify
./composer.json has been created
Loading composer repositories with package information
Updating dependencies (including require-dev)
Package operations: 1 install, 0 updates, 0 removals
  - Installing cocur/slugify (v4.0.0): Downloading (100%)         
Writing lock file
Generating autoload files
Como você pode ver na saída, o Composer decidiu automaticamente qual versão do pacote utilizar. Se você verificar o diretório do seu projeto agora, ele irá conter dois arquivos novos: composer.json e composer.lock, e um diretório vendor:

ls -l
Output
total 12
-rw-rw-r-- 1 sammy sammy   59 May  4 13:56 composer.json
-rw-rw-r-- 1 sammy sammy 3229 May  4 13:56 composer.lock
drwxrwxr-x 4 sammy sammy 4096 May  4 13:56 vendor
O arquivo composer.lock é usado para armazenar informações sobre quais versões de cada pacote estão instaladas, e garantir que as mesmas versões sejam usadas se outra pessoa clonar seu projeto e instalar suas dependências. O diretório vendor é onde as dependências do projeto estão localizadas. Você não deve fazer commit da pasta vendor no controle de versão - você precisa apenas incluir os arquivos composer.json e composer.lock.

Ao instalar um projeto que já contém um arquivo composer.json, execute o composer install para baixar as dependências do projeto.

Vamos dar uma olhada rápida em restrições de versão. Se você verificar o conteúdo do seu arquivo composer.json, verá algo parecido com isto:

cat composer.json
Output
{
    "require": {
        "cocur/slugify": "^4.0"
    }
}
Note que há o caractere especial ^ antes do número da versão no composer.json. O Composer suporta várias restrições diferentes e formatos para definir a versão necessária do pacote, para fornecer flexibilidade enquanto também mantém seu projeto estável. O operador circunflexo (^) utilizado pelo arquivo composer.json criado automaticamente é o operador recomendado para a interoperabilidade máxima, seguindo o versionamento semântico. Neste caso, ele define 4.0 como a versão mínima compatível e permite atualizações para qualquer versão futura abaixo de 5.0.

De um modo geral, você não precisará alterar as restrições de versão em seu arquivo composer.json. No entanto, algumas situações podem exigir que você edite manualmente as restrições – por exemplo, quando uma nova versão principal da sua biblioteca requerida é liberada e você deseja atualizar, ou quando a biblioteca que você deseja usar não segue o versionamento semântico.

Aqui estão alguns exemplos para lhe dar um melhor entendimento sobre como as restrições de versão do Composer funcionam:

Restrição	Significado	Exemplo de Versões Permitidas
^1.0	>= 1.0 < 2.0	1.0, 1.2.3, 1.9.9
^1.1.0	>= 1.1.0 < 2.0	1.1.0, 1.5.6, 1.9.9
~1.0	>= 1.0 < 2.0.0	1.0, 1.4.1, 1.9.9
~1.0.0	>= 1.0.0 < 1.1	1.0.0, 1.0.4, 1.0.9
1.2.1	1.2.1	1.2.1
1.*	>= 1.0 < 2.0	1.0.0, 1.4.5, 1.9.9
1.2. *	>= 1.2 < 1.3	1.2.0, 1.2.3, 1.2.9
Para uma visualização mais detalhada das restrições de versão do Composer, consulte a documentação oficial.

A seguir, vamos ver como carregar dependências automaticamente com o Composer.

Passo 4 — Incluindo o Script Autoload
Como o PHP por si só não carrega classes automaticamente, o Composer fornece um script autoload que você pode incluir em seu projeto para obter o carregamento automático para ele. Este arquivo é gerado automaticamente pelo Composer quando você adiciona sua primeira dependência.

A única coisa que você precisa fazer é incluir o arquivo vendor/autoload.php em seus scripts PHP antes de qualquer instância de classe.

Vamos testar isso em nossa aplicação de demonstração. Abra um novo arquivo chamado test.php em seu editor de texto:

nano test.php
Adicione o código a seguir que vem no arquivo vendor/autoload.php, carrega a dependência cocur/slugify, e o utiliza para criar um slug:

test.php
<?php
require __DIR__ . '/vendor/autoload.php';

use Cocur\Slugify\Slugify;

$slugify = new Slugify();

echo $slugify->slugify('Hello World, this is a long sentence and I need to make a slug from it!');
Salve o arquivo e saia do seu editor.

Agora, execute o script.

php test.php
Isso produz a saída hello-world-this-is-a-long-sentence-and-i-need-to-make-a-slug-from-it.

As dependências precisam de atualizações quando novas versões são liberadas. Dessa forma, vamos ver como lidar com isso.

Passo 5 — Atualizando as Dependências do Projeto
Sempre que você quiser atualizar suas dependências do projeto para versões mais recentes, execute o comando update:

composer update
Isso irá verificar por versões mais recentes das bibliotecas que você requer em seu projeto. Se uma versão mais recente for encontrada e ela for compatível com a restrição de versão definida no arquivo composer.json, o Composer substituirá a versão anterior instalada. O arquivo composer.lock será atualizado para refletir essas alterações.

Você também pode atualizar uma ou mais bibliotecas específicas, especificando-as desta forma:

composer update vendor/package vendor2/package2
Certifique-se de verificar em seus arquivos composer.json e composer.lock dentro do seu sistema de controle de versão após atualizar suas dependências de modo que outros também possam instalar essas versões mais recentes.








INÍCIO:

1 instalar o docker

2 abrir wsl2/Windows ou linux
 curl -s "https://laravel.build/olw?with=mysql,redis,mailhog,minio" | bash

3 cd olw
./vendor/bin/sail up -d
	ou
4 cd olw && ./vendor/bin/sail up -d

5 ATRIBUINDO PERMISSÃO PARA A PASTA
cd .. -> sai da pasta
sudo chmod 777 olw/ -R ou sem o 'sudo' chmod 777 olw/ -R

6 CRIANDO ALIAS PARA O COMANDO ANTERIOR
alias sail='[ -f sail ] && sh sail || sh vendor/bin/sail'
passa a usar assim: sail ps

7 CONFIGURAR PORTAS PARA A APLICAÇÃO NO NAVEGADOR E MYSQL
.env
APP_PORT=8000

*porta do myql
FORWARD_DB_PORT=3307

8 INSTALANDO DEPENDÊNCIA AO PROJETO
./vendor/bin/sail composer require laravel/breeze --dev

9 DEIXAR TELA DE AUTENTICAÇÃO PRONTA, ROTA AUTENTICADA, TAWINDCSS INSTALADO E INERTIA INSTALADO
./vendor/bin/sail artisan breeze:install vue 
ou
./vendor/bin/sail art breeze:install vue


10 RODAR AS MIGRATES PADRÕES DO PROJETO AI JÁ PODE CADASTRAR USUÁRIOS PARA LOGIN:
./vendor/bin/sail art migrate

11 


/*******************************************/
2a AULA:

O PROJETO CONSISTE EM RECEBER DADOS DE UMA API (punkapi.com) DE INFORMAÇÕES SOBRE CERVEJAS, VAMOS CONSTRUIR AS ROTAS PARA CONSUMIR A API E CRIAR A ESTRUTURA PARA O RELATÓRIO QUE IREMOS GERAR EM EXCEL E ENVIAR PARA O STORAGE...
1 CRIAR ROTAS:
code .
olw/routes/web.php


sail up -d -> SOBE O CONTAINER localhost:8000 (nesse projeto)

Route::get('/beers', fn()=> 'Olw - testando a rota /beers');

**************************************************
obs:
- laravel.com/api -> acesso a documentação do código;
- Inline Parameters for VSCode-> extensão para vscode para exibir o nome dos métodos na hora que codificar;
- fira code -> extensão para fonte no vscode

git Hub Copilot vs Tabnine -> (pesquisar sobre)
Link para extensões vscode:
https://github.com/icarojobs/vscode-useful-extensions
*************************************************


Route::get('/beers', fn()=> 'Olw - testando a rota /beers')
                             ->middleware(['auth']);

* FLUXO PADRÃO DO MVC-LARAVEL: 
life cicle: sai do usuário pelo navegador, insomnia ou postman -> passa pelo index.php(pasta public) -> passa pelos arquivos do bootstrap retornando uma instância da aplicação -> passa pelo kernel do http (carrega mais instâncias) -> Service provider -> despacha a requisição pro Router -> Cai no arquivo Web.php -> Middleware (se tiver, geralmente tem os globais) -> Controller (faz as regras de negócio e pode chamar outras classes como Serviços por exemplo)
-> Retorna uma view ou um json (No caso estamos usando inértia, ele não vai reinderizar a 'view.blade' padrão, ele vai reinderizar componente vue.js através do inértia.).


* EM VEZ DE USAR A FUNÇÃO AQUI NA ROTA CRIAMOS UM CONTROLLER:

obs.: ​dica: php artisan make:controller -r cria o Resource também.
dica: limpar o cache do container:
./vendor/bin/sail art config:cache
./vendor/bin/sail art optimize:clear


sail artisan make:controller BeerController
ou 
sail art make:controller BeerController -> CRIA O ARQUIVO BeerController.php na pasta app/Http/Controllers
->
<?php

namespace App\Http\Controllers;

use Illuminate\Http\Request;

class BeerController extends Controller
{
    public function index()
    {
    return 'Virgu & Beer & Code'
    }
}

* NO ARQUIVO DE ROTAS Web.php CHAMA O BeersController:

importante importar o Controller <nomeDoController>+<CTRL=ENTER:
use App\Http\Controllers\BeerController;

Route::get('/beers', [BeerController::class, 'index'])
                        ->middleware(['auth']);


* PRECISAMOS CRIAR UM MÉTODO PARA PEGAR A LISTA, LISTAR OS DADOS DA API (listar as bebidas de https://api.punkapi.com/v2 ->
VAMOS CRIAR UMA NOVA CLASSE de serviços em app/Sevices/PunkapiService.php

* O LARAVEL POSSUI UM RECURSO CHAMADO HTTPClient que abstrai o uso de uma ferramenta chama guzeo, esse guzeo é o client http mais comum para php, com ele fazemos requisições pra diversos serviços web dentro do php para outras url, ele é robusto, então o laravel simplifica importando o recurso que faz tudo por 'detrás dos panos':

PunkapiService.php

<?php

namespace App\Services;

use Illuminate\Support\Facades\Http;

class PunkapiService
{
    public function getBeers()
    {
        return Http::get('https://api.punkapi.com/v2/beers');
    }
}

E NO BeerController.php fica:
<?php

namespace App\Http\Controllers;

use App\Services\PunkapiService;
use Illuminate\Http\Request;

class BeerController extends Controller
{
    public function index()
    {
    //return 'Virgu & Beer & Code';
    $service = new PunkapiService;

    return $service->getBeers();
    }
}

* TRATE É CARACTERÍSTICA QUE A CLASSE ADQUIRE (pode ter mesmos métodos e atributos substituindo o recurso de um classe extender várias classes que não tem no php, a trate é uma forma de fazer isso. O service  é uma outra camada na maioria das vezes abstrair seviços que vc vai consumir, por exemplo API.

Estando logado, os dados da api já serão exibidos em localhost:8000/beers, se usar um aplicativo cliente tipo insomnia pode apresentar os dados também, melhor comentar a linha de de autenticação da rota:
Route::get('/beers', [BeerController::class, 'index']);
linha de autenticação da rota // ->middleware(['auth']);

* ESSA API PERMITE FAZER FILTROS VIA PARÂMETROS NA PRÓPRIA ROTA. PRIMEIRO VAMOS REFATORAR O CÓDIO, A CLASSE PunkapiService.php:

USO DE CONFIG E MACRO


Vamos alterar a url, primeiro acessando a pasta config da raiz do projeto e criar o arquivo punkapi.php. O que acontece é que o config(pasta config da raiz) carrega todos os arquivos da pasta e permite que sejam acessados via funções simples(HELPERS), isso é muito legal porque podemos acessar esses arquivos de configurações de qualquer lugar do projeto: 

<?php

return [
    'url' => env('PUNK_BASE_URL', 'https://api.punkapi.com/v2')
];

Usando o helper env significa dizer que, se não houver a constante PUNK_BASE_URL setada no arquivo .env do projeto, seu valor será o segundo parâmetro: http://api.punkapi.com/v2 e no arquivo PunkapiService.php da pasta app/Services fica:

<?php

namespace App\Services;

use Illuminate\Support\Facades\Http;

class PunkapiService
{
    public function getBeers()
    {
        return Http::get('/beers');
    }
}

MACRO é uma forma de criar funções customizadas:
 em app\Providers vamos acessar o arquivo AppServiceProvider.php que é uma classe que tem dois métodos register e boot. No método boot vamos chamar o método Http do laravel e chamar o método macro, no primeiro parâmetro será um nome atribuído à função e e o segundo uma clausure (uma função).
Neste arquivo é passado o arquivo de configuração da url (em 'config/punkapi.php') além de tokens, headers,...
 

use Illuminate\Support\Facades\Http; -> deve ser importado
E a função boot fica:

  public function boot()
    {
        Http::macro('punkapi', function(){
            return Http::acceptJson()
            ->baseUrl(config('punkapi.url'));
        });
    }

Então criamos uma macro(uma função customizada) chamada punkapi que já retorna o client com accept/Json no Header e com o baseUrl configurado lá do arquivo /config/punkapi.php e se estiver setado no .env pegará de lá.

/app/Services/PunkapiService.php fica:

<?php

namespace App\Services;

use Illuminate\Support\Facades\Http;

class PunkapiService
{
    public function getBeers()
    {
        return Http::punkapi()->get('/beers');
    }
}

*obs.: a baseUrl poderia ser setada no construtor, que pode setar token também.(uma outra abordagem para versão sem macros);

->Testamos o retorno Json em localhost:8000/beers.

Refatorando o arquivo PunkapiService.php: O client Http não lança exceção e podemos forçar o retorno em modo Json:
<?php

namespace App\Services;

use Illuminate\Support\Facades\Http;

class PunkapiService
{
    public function getBeers()
    {
       // return Http::punkapi()->get('/beers');
       return Http::punkapi()
            ->get('/beers')
            ->throw()  // Exceção em caso de erro
            ->json();   // Força o retorno em formato Json
    }
}

Podemos testar forçando um erro alterando a constante PUNKAPI_BASE_URL criada em /config/punkapi.php, vamos atribuir um valor diferente no arquivo .env:

PUNKAPI_BASE_URL="adfjklj878"

Podemos usar a função retry tem dois parâmetros, o número de tentativas pra buscar a requisição e o intervalo entre elas. Refatorando o código fica:
<?php

namespace App\Services;

use Illuminate\Support\Facades\Http;

class PunkapiService
{
    public function getBeers()
    {
       // return Http::punkapi()->get('/beers');
       return Http::punkapi()
            ->get('/beers')
            ->throw()  // Exceção em caso de erro
            ->json();   // Força o retorno em formato Json
    }
}

- Quando sai a exceção nao deveriamos retornar o erro em json por ser um api neste caso estamos usamos um app web e não uma api. E usaríamos o Route Api.

Refatorando o método boot de /app/Providers/AppServiceProvider.php, inserindo o retry():

     */
    public function boot()
    {
        Http::macro('punkapi', function(){
            return Http::acceptJson()
            ->baseUrl(config('punkapi.url'))
            ->retry(3,100);
        });
    }
}

comando de help

* ./vendor/bin/sail composer dump-autoload
* Verificar Nome do arquivo se bate com o nome das rotas(Classes criadas e importar o nome errado);
* inteliphense

Refatorando BeerController.php
<?php

namespace App\Http\Controllers;

use App\Services\PunkapiService;

class BeerController extends Controller
{
    public function index()
    {

    $service = new PunkapiService();

    return $service->getBeers();
    }
}

Em vez de instanciar o método PunkapiService() dentro de index, vamos passar por parâmetro de index() declarando seu Próprio nome (PunkapiService) como tipo. Fica assim:

<?php

namespace App\Http\Controllers;

use App\Services\PunkapiService;

class BeerController extends Controller
{
    public function index(PunkapiService $service)
    {
    return $service->getBeers();
    }
}

Assim usamos feactures do php(injeção de dependências) e ao mesmo tempo feactures do laravel. Em vez de criar uma instância dentro do método index, vamos injetar a classe como parâmetro para o método index(), ficando index($service) e a instância de dentro da função passa como parâmetro de 'tipo da variável'. Isso quebra a cadeia de dependência entre as classes.
Assim, o método index ganha independência não mais dependendo da instância de new PunkapiService e passamos a olhar a função index em si.
Assim, o Laravel tenta fazer um binding, um match, o laravel tenta encontrar alguma classe PunkapiService e cria uma instância dessa classe e usa ali como parâmetro. Se não fizer assim, lá em Rotas teria que ser passado como parâmetro o que fica desnecessário.
Não poderia ser feito se na classe PunkapiService existisse o construtor para atribuir valores automaticamente à classe. Assim podemos usar porque não precisamos passar nenhum valor.

ADICIONAR OS FILTROS:
Vamos filtrar o retorno api com os seguintes itens: beer_name, food, ibu_gt, malte:

var_dump($v)
die();
dd($variável)
benchmarck -> ?

/*****REFATORA PARA TESTE alterando BeerController.php e PunkapiService.php
BeerController.php
<?php

namespace App\Http\Controllers;

use App\Services\PunkapiService;

class BeerController extends Controller
{
    public function index(PunkapiService $service)
    {
    return $service->getBeers(
        'heineken',
        'cheese',
        'corn',
        45
    );
    }
}

PunkapiService.php
<?php

namespace App\Services;

use Illuminate\Support\Facades\Http;

class PunkapiService
{
    public function getBeers(
        string $beer_name,
        string $food,
        string $malt,
        string $ibu_gt
    )
    {
        $params = get_defined_vars();

        dd($params);

        return Http::punkapi()
            ->get('/beers', $params)
            ->throw()  // Exceção em caso de erro
            ->json();   // Força o retorno em formato Json
    }
}

Resultado do debug no insomnia ou no navegador:
array:4 [▼ // app/Services/PunkapiService.php:18
  "beer_name" => "heineken"
  "food" => "cheese"
  "malt" => "corn"
  "ibu_gt" => "45"
]
//* fim teste

Refatorando:

class PunkapiService
{
    public function getBeers(
        string $beer_name = null,
        string $food = null,
        string $malt = null,
        string $ibu_gt = null
    )
    {
        $params = get_defined_vars();

        dd($params);

        return Http::punkapi()
            ->get('/beers', $params)
            ->throw()  // Exceção em caso de erro
            ->json();   // Força o retorno em formato Json
    }
}

Assim quando não passar o valor para a chave ele exibirá a chave e o valor Null, vamos refatorar para não exibir nem a chave englobando get_defined_vers() com array_filter no arquivo PunkapiService.php:

$params = array_filter(get_defined_vars());

<?php

namespace App\Http\Controllers;

use App\Services\PunkapiService;

class BeerController extends Controller
{
    public function index(PunkapiService $service)
    {
    return $service->getBeers(
        'heineken',
        'cheese',
        'corn',
       // 45 -> Esse não é passado
    );
    }
}


array:3 [▼ // app/Services/PunkapiService.php:18
  "beer_name" => "heineken"
  "food" => "cheese"
  "malt" => "corn"
	Aqui não exibiu o valor 45
]


USANDO A FUNÇÃO NAMED_ARGS passamos só os parâmetros que precisamos retornar da api e o php com essa função saberá qual a posição dela no array de argumentos passados como parâmetro sem a necessidade de seguir a mesma sequência dos argumentos:
class BeerController extends Controller
{
    public function index(PunkapiService $service)
    {
    return $service->getBeers(food: 'cheese');
    }
}

REFATORANDO:
BeerController.php
<?php

namespace App\Http\Controllers;

use App\Services\PunkapiService;
use Illuminate\Http\Request;

class BeerController extends Controller
{
    public function index( Request $request, PunkapiService $service)
    {
    return $service->getBeers(...$request->all());
    }
}

PunkapiService.php
<?php

namespace App\Services;

use Illuminate\Support\Facades\Http;

class PunkapiService
{
    public function getBeers(
        string $beer_name = null,
        string $food = null,
        string $malt = null,
        string $ibu_gt = null
    )
    {
        $params = array_filter(get_defined_vars());

     //   dd($params);

        return Http::punkapi()
            ->get('/beers', $params)
            ->throw()  // Exceção em caso de erro
            ->json();   // Força o retorno em formato Json
    }
}

CRIANDO UMA REQUEST
sail artisan make:request BeerRequest
/app/Http/Requests/BeerRequest.php

* Funções anônimas, também conhecidas como closures , permitem a criação de funções que não tem o nome especificado. Elas são mais úteis como o valor de parâmetros callable, mas podem ter vários outros usos.. É uma função passada como parâmetro

CRIANDO NOVA ROTA PARA SALVAR COMO EXCEL
* https://docs.laravel-excel.com/3.1/getting-started/installation.html

Route::group([
    'prefix' => 'beers',
], function() {

    Route::get('/', [BeerController::class, 'index']); //-> Se houver necessidade de salvar dados por essa rota mudamos o método(verbo html) para post(os dados não serão expostos na url).
                          //  ->middleware(['auth']);
    Route::get('/export', [BeerController::class, 'export']);

});

Então passamos a ter duas rotas: localhost:8000/beers
localhost:8000/beers/export

No BeerController incluimos o método export():
class BeerController extends Controller
{
    public function index( BeerRequest $request, PunkapiService $service)
    {
    // return $service->getBeers(...$request->all());
    return $service->getBeers(...$request->validated());
    }

    public function export()
    {
        return 'Relatório criado.';
    }
}



INSTALANDO PACOTE LARAVEL-EXCEL PARA GERAR OS RELATÓRIO EM EXCEL FILTRADOS DA API:

* https://docs.laravel-excel.com/3.1/getting-started/installation.html

COMANDO PARA INSTALAR VIA COMPOSER:
./vendor/bin/sail composer require psr/simple-cache:^2.0 maatwebsite/excel

CRIAR A CLASSE DO EXCEL
./vendor/bin/sail artisan make:export BeerExport  --> Cria o arquivo em  /app/Exports/BeerExport.php

<?php

namespace App\Exports;

use Maatwebsite\Excel\Concerns\FromCollection;

class BeerExport implements FromCollection
{


    /**
    * @return \I¢lluminate\Support\Collection
    */
    public function collection()
    {
        //
    }
}

-> Dentro de colletion buscaremos as informações que serão salvas no arquivo do excel, um array de dados;

criamos um __construct() que vai ter uma propriedade privada do tipo array chamamos de $reportData.

O retorn será uma collection como informa o comentário:
 /**
    * @return \I¢lluminate\Support\Collection
    */

Na função colletion(), está recebendo um array return $this->reportData; 
Observe que não precisa mais declarar uma propriedade que vai se setada via construct(), basta defifinir o escopo junto do argumento e o php faz isso pra você. Como o retorno da função é um array usamos o helper collect para o $this->reportData:

BeerExport.php

<?php

namespace App\Exports;

use Maatwebsite\Excel\Concerns\FromCollection;

class BeerExport implements FromCollection
{

    public function __construct(
        private array $reportData
    ){}

    /**
    * @return \Illuminate\Support\Collection
    */
    public function collection()
    {
       return collect($this->reportData);
    }
}
 

Consultamos a documentação do Laravel-excel em 'Exporting collections':
em Excel Store passa o nome da classe e o nome do arquivo:

BeerController.php
<?php

namespace App\Http\Controllers;


use App\Exports\BeerExport;
use App\Http\Requests\BeerRequest;
use App\Services\PunkapiService;
use Maatwebsite\Excel\Facades\Excel;


class BeerController extends Controller
{
    public function index( BeerRequest $request, PunkapiService $service)
    {
    // return $service->getBeers(...$request->all());
    return $service->getBeers(...$request->validated());
    }

    public function export()
    {
      $params = [
        ['name' => 'Tom', 'age' => '30'],
        ['name' => 'Virgu', 'age' => '27']
       ];

       Excel::store(new BeerExport($params), 'olw-report.xlsx');
       return "Relatório criado";

    }


}

********************************************
* REFATORANDO E SALVANDO O ARQUIVO EXCEL EM /storage/app

BeerExport.php
<?php

namespace App\Exports;

use Maatwebsite\Excel\Concerns\FromCollection;

class BeerExport implements FromCollection
{

    public function __construct(
        private array $reportData
    ){}

    /**
    * @return \Illuminate\Support\Collection
    */
    public function collection()
    {
       return collect($this->reportData);
    }
}
*****************************

BeerController.php

<?php

namespace App\Http\Controllers;


use App\Exports\BeerExport;
use App\Http\Requests\BeerRequest;
use App\Services\PunkapiService;
use Maatwebsite\Excel\Facades\Excel;


class BeerController extends Controller
{
    public function index( BeerRequest $request, PunkapiService $service)
    {
        return $service->getBeers(...$request->all());

    }

    public function export(BeerRequest $request, PunkapiService $service)
    {
        $beers = $service->getBeers(...$request->validated());

        $filteredBeers = collect($beers)->map(function($value, $key){
        return collect($value)
                ->only(['name', 'tagline', 'first_brewed', 'description'])
                ->toArray();
    })->toArray();

    //dd($filteredBeers);

      $params = [
        ['name' => 'Tom', 'age' => '30'],
        ['name' => 'Virgu', 'age' => '27']
       ];

       Excel::store(new BeerExport($filteredBeers), 'olw-report.xlsx');

           return "Relatório criado";

    }


}

PARA SALVAR O ARQUIVO EXCEL EM UM STORAGE S3:
ALTERA BeerController.php

<?php

namespace App\Http\Controllers;


use App\Exports\BeerExport;
use App\Http\Requests\BeerRequest;
use App\Services\PunkapiService;
use Maatwebsite\Excel\Facades\Excel;


class BeerController extends Controller
{
    public function index( BeerRequest $request, PunkapiService $service)
    {
        return $service->getBeers(...$request->all());

    }

    public function export(BeerRequest $request, PunkapiService $service)
    {
        $beers = $service->getBeers(...$request->validated());

        $filteredBeers = collect($beers)->map(function($value, $key){
        return collect($value)
                ->only(['name', 'tagline', 'first_brewed', 'description'])
                ->toArray();
    })->toArray();


       Excel::store(
            new BeerExport($filteredBeers),
             'olw-report.xlsx',
             's3');

           return "Relatório criado";

    }


}

************
O REPOSITÓRIO DE ARQUIVOS minio:
NO DOCKER COMPOSER TEMOS O minio, um S3 que tem
MINIO_ROOT_USER: 'sail'
MINIO_ROOT_PASSWORD: 'password' e roda na porta 9000
localhost:9000
usuário: sail
senha: password

vamos criar um buncket(uma pasta)

e configurar o .env da raiz da aplicação:
originalmente é assim:
AWS_ACCESS_KEY_ID=
AWS_SECRET_ACCESS_KEY=
AWS_DEFAULT_REGION=us-east-1
AWS_BUCKET=
AWS_USE_PATH_STYLE_ENDPOINT=false

 e acrescentamos as informações para:


AWS_ACCESS_KEY_ID=sail
AWS_SECRET_ACCESS_KEY=password
AWS_DEFAULT_REGION=us-east-1
AWS_BUCKET=local
AWS_ENDPOINT=http://minio:9000
AWS_URL=http://minio:9000/local
AWS_USE_PATH_STYLE_ENDPOINT=true

altera tambem:

FILESYSTEM_DISK=local 
para:
FILESYSTEM_DISK=s3

INSTALAR UMA DEPENDÊNCIA (ADAPTER) PARA FAZER CORRESPONDÊNCIA COM A AWS:

Flysystem 3.x em laravel.com/docs/9.x/upgrade
./vendor/bin/sail composer require -W league/flysystem-aws-s3-v3 "^3.0"

em caso de erro:
 artisan vendor:publish --tag=laravel-assets --ansi --force

.env
APP_NAME=Laravel
APP_ENV=local
APP_KEY=base64:UbVvTP6Cu+LF5GamJdB4dsZZvW05ep4bZqcCEhmiDCg=
APP_DEBUG=true
APP_URL=http://localhost
APP_PORT=8000

# PUNKAPI_BASE_URL="httpadfjkljdsdfdfasf878"

LOG_CHANNEL=stack
LOG_DEPRECATIONS_CHANNEL=null
LOG_LEVEL=debug

DB_CONNECTION=mysql
FORWARD_DB_PORT=3307
DB_HOST=mysql
DB_PORT=3306
DB_DATABASE=olw
DB_USERNAME=sail
DB_PASSWORD=password

BROADCAST_DRIVER=log
CACHE_DRIVER=file
FILESYSTEM_DISK=s3
QUEUE_CONNECTION=sync
SESSION_DRIVER=file
SESSION_LIFETIME=120

MEMCACHED_HOST=memcached

REDIS_HOST=redis
REDIS_PASSWORD=null
REDIS_PORT=6379

MAIL_MAILER=smtp
MAIL_HOST=mailhog
MAIL_PORT=1025
MAIL_USERNAME=null
MAIL_PASSWORD=null
MAIL_ENCRYPTION=null
MAIL_FROM_ADDRESS="hello@example.com"
MAIL_FROM_NAME="${APP_NAME}"

AWS_ACCESS_KEY_ID=sail
AWS_SECRET_ACCESS_KEY=password
AWS_DEFAULT_REGION=us-east-1
AWS_BUCKET=local
AWS_ENDPOINT=http://minio:9000
AWS_URL=http://minio:9000/local
AWS_USE_PATH_STYLE_ENDPOINT=true

PUSHER_APP_ID=
PUSHER_APP_KEY=
PUSHER_APP_SECRET=
PUSHER_HOST=
PUSHER_PORT=443
PUSHER_SCHEME=https
PUSHER_APP_CLUSTER=mt1

VITE_PUSHER_APP_KEY="${PUSHER_APP_KEY}"
VITE_PUSHER_HOST="${PUSHER_HOST}"
VITE_PUSHER_PORT="${PUSHER_PORT}"
VITE_PUSHER_SCHEME="${PUSHER_SCHEME}"
VITE_PUSHER_APP_CLUSTER="${PUSHER_APP_CLUSTER}"

PRONTO. ENVIANDO PARA O MINIO.


/**** ABAIXO AULA DE FRONT END -> FALTA
























 







/***********************************************************
QUINTA FEIRA: 20/10/22

Open Laravel Week | Deploy com Terraform, EC2 e RDS | Fermentação

****
https://portal.aws.amazon.com/billing/signup?nc2=h_ct&src=header_signup&redirect_url=https%3A%2F%2Faws.amazon.com%2Fregistration-confirmation&language=pt_br#/start/email

Com terraform pode mudar de infra e configurar no git.

PROGRMAR A CONFIGURAÇÃO DO SERVIDOR: É basicamente construir uma nova aplicação para fazer isso, mais fácil de entender.
Terraform serve para (linguagem HCL -> linguagem própria - linguagem descritiva, descreve o resultado e não como irá ser feito), ou seja, descrever o que queremos.
Terraspace é o framework pra terraform.
Quando criamos o Terraform, ele pode variar conforme a infra cloud (aws, azure, google cloud). sua estrutura é a mesma para todos. mas cada provider tem a sua forma de usar, não consegue usar o mesmo código para mais de uma cloud.
Vamos rodar Terraform via container:

1. clonar do git: git clone 
Criar uma pasta para a infraestrutura

sail   (script que vamos usar)
#!/usr/bin/env bash

docker run -rm -it
	-u $(id -u):$(id -g) \
	-v $PWD:/workspace \
	-w /workspace
	hashicorp/terraform:light "%@"


	<no terminal

Logar em: aws.amazon.com
busca: iam
iam dashboard -> mysecurity credencials (root user) -> Acces keys ->clicar em create access keys -> salva o access key e secret access key
e coloca no arquivo credencials na maquina local.. .aws/credencials
















































//////////////////////////////////////////////////////////////////////////////////////////////////////
CONTEÚDO QUE FALTA ORGANIZAR:



/**************************************/

sail share

sail artisan sail:publish ->coloca em uma pasta na raiz chamada docker

sail --help

sail artisan optimizer:clear

sail ps

sail build --no-cache -> faz o bild da aplicação. (dá um sail down  por precaução antes.)










/*********************************

root@DELLAGS:~# curl -s "https://laravel.build/laravel-9-course?with=mysql,redis,mailhog" | bash

Dockerfile

root@DELLAGS:~/example-app# docker exec -it example-app-mysql-1 bash


FROM wyveo/nginx-php-fpm:latest
WORKDIR /usr/share/nginx
RUN rm -rf /usr/share/nginx/html
COPY . /usr/share/nginx
RUN chmod -R 755 /usr/share/nginx/storage/*
RUN ln -s public html

.env (do composer)

DB_CONNECTION=mysql
DB_HOST=mysql-app (serviço do mysql no docker-compose.yaml)
DB_PORT=3306
DB_DATABASE=laraveldockerdb
DB_USERNAME=root
DB_PASSWORD=123456



docker-compose.yaml

version: '3'

services:
  laraveldocker-app:
    build: .
    ports:
      - "3003:80"
    volumes:
      - ./:/usr/share/nginx
      - .docker/nginx:/etc/nginx/conf.d/
    networks:
      - app-network
  mysql-app:
    image: mysql:5.7.22
    ports:
      - "3306:3306"
    volumes:
      - .docker/dbdata:/var/lib/mysql
    environment:
      MYSQL_DATABASE: laraveldocker
      MYSQL_ROOT_PASSWORD: 123456
    networks:
      - app-network
networks:
  app-network:
    driver: bridge
    



/*************************************************
#criando um serviço com um nome qualquer
version: '3'

services:
  laravel-app:                    #criando um serviço com um nome qualquer
    build: . ou image: wyveo/nginx-php-fpm:latest -> neste caso sem Dockerfile.                    # endereço da imagem ou local do Dockerfile (neste caso o ponto siginifica a raiz do projeto)
    ports:
      - "8080:80"                 # 8080 porta do meu host: 80 é a porta do docker nginx
    volumes:                      # docker-compose up -d -> sobe a imagem e libera o terminal  
      - ./:/usr/share/nginx       # TUDO QUE ESTIVE NA RAIZ (na rais tem o meu projeto laravel) './' IRÁ SER REFLETIDO NA PASTA /usr/share/nginx (pasta de acesso da página html)
                                  # C:\Laravel-docker\laravel-docker>docker compose up -d --build atualiza a minha imagem

  mysql-app:
      image: mysql:5.7
      ports:
        - "3306:3306"
      volumes:
        - .docker/dbdata:/var/lib/mysql          # qualqer nome (para persistir -guardar os dados do banco de dados)


      environment:
        MYSQL_DATABASE: laravel
        MYSQL_ROOT_PASSWORD: laravel
    
      

      /***************************///


  
C:\Laravel-docker\laravel-docker>docker compose up -d --build

                                
                               

    

/******************************** Dockerfile
FROM wyveo/nginx-php-fpm:latest

/***************************///
  COMANDOS

docker compose down -> para todos os containers
C:\Laravel-docker\laravel-docker>docker exec -it laravel-docker-laravel-app-1 bash 
root@612ea0ea3340:/# cd /usr/share/nginx/
root@612ea0ea3340:/usr/share/nginx# php artisan migrate
root@612ea0ea3340:/usr/share/nginx# php artisan serve

		
/***********/
PS C:\Users\alber> docker run -e MYSQL_ROOT_PASSWORD=root --name meu-mysql -d mysql:5.7

docker inspect meu-mysql ou | grep IPAddress

PS C:\Users\alber> docker run -e MYSQL_ROOT_PASSWORD=root --name meu-mysql -d -p 3306:3306 mysql:5.7

docker ps
docker ps -l
docker ps -a
docker rm -f nome


/*** LARAVEL */
### CRIANDO UM PROJETO NO LARAVEL 
laravel new projeto_laravel_via_installer (ESTA É UM AOPÇÃO)
composer create-project --prefer-dist laravel/laravel app_controle_tarefas "8.5.9"
cd app_controle_tarefas
cd public
php -S localhost:8000

ou 
da raiz do projeto:
php artisan serve 
ou
php artisan serve --port=3000

### PARA ABRIR PORTA EM OUTRO SERVIDOR
php artisan serve --host test.com --port 8080

 **********************************************************************
cd app_controle_tarefas
cd public
php artisan serve
- acessa o navegador http://localhost:8000

### DENTRO DO PROJETO CRIADO INSTALAR O LARAVEL/UI:^3.2 - versão 3.2
composer require laravel/ui:^3.2

### SE OCORRER ERRO AUMENTAR A MEMÓRIA DISPONIVEL PARA O php

-php --ini -> localiza o arquivo de configuração do php
LOCALIZA memory_limit = 1000 e altera para 
         memory_limit  = -1 e Salva

### LISTA A RELAÇÃO DE COMANDOS 
php artisan list 

DEVERA SURGIR AS OPÇÕES ABAIXO:

 ui
  ui:auth               Scaffold basic login and registration views and routes
  ui:controllers        Scaffold the authentication controllers
 vendor

### ENTENDENDO O PACOTE UI E INICIANDO A AUTENTICAÇÃO WEB NATIVA DO LARAVEL

COMANDO PARA LISTAR ROUTES: 
php artisan route:list

### php artisan ui bootstrap --auth (bootstrap ou react ou vue)
aplicando o bootstrap incluindo os recursos de autenticação;
poderia ser aplicado o bootstrap sem os recursos de autenticação;

### php artisan route:list -> mostra as rotas - ver que aumentaram as rotas

### APÓS ESSE PROCESSO O SISTEMA PEDE PARA RODAR
npm install -> instala as dependências do package.json (inclusive o bootstrap)
npm run dev -> gera os assets da aplicação de acordo com a tecnologia selecionada (bootstrap, react ou vue) -> Geralmente roda mais de uma vez para compilar tudo.

### CRIA O BANCO DE DADOS NORMALMENTE

### EXECUTA AS MIGRATIONS PADRÕES CRIADAS PARA O SISTEMA DE login
php artisan migrate -> CRIA AS TABELAS NO BANCO DE DADOS


************************************** 
INSTALANDO O COMPOSER NO UBUNTU
**************************************
sudo apt update
sudo apt install php-cli unzip

cd ~

curl -sS https://getcomposer.org/installer -o composer-setup.php

HASH=`curl -sS https://composer.github.io/installer.sig`

echo $HASH ->saída: Output
e0012edf3e80b6978849f5eff0d4b4e4c79ff1609dd1e613307e16318854d24ae64f26d17af3ef0bf7cfb710ca74



php -r "if (hash_file('SHA384', 'composer-setup.php') === '$HASH') { echo 'Installer verified'; } else { echo 'Installer corrupt'; unlink('composer-setup.php'); } echo PHP_EOL;"

sudo php composer-setup.php --install-dir=/usr/local/bin --filename=composer





***********************

DigitalOcean Kubernetes: novo plano de controle é mais rápido e gratuito, habilita HA para SLA de 99,95% de tempo de atividade
Produtos
Preços

Documentos
divisa suspensa

Entrar
divisa suspensa

// Tutorial //
Como Instalar e Utilizar o Composer no Ubuntu 20.04
Publicado em 21 de maio de 2020
Ubuntu
PHP
Ubuntu 20.04
Avatar padrão
Por Erika Heidi
Advogado Desenvolvedor
Português
Como Instalar e Utilizar o Composer no Ubuntu 20.04
Introdução
O Composer é uma ferramenta popular de gerenciamento de dependências para o PHP, criado para facilitar a instalação e a atualização das dependências principalmente do projeto. Ele controla quais outros pacotes de projeto específico dependem e são instalados para você, usando as opções apropriadas de acordo com os requisitos do projeto. O Composer também é comumente utilizado para inicializar novos projetos em frameworks PHP populares, como o Symfon e o Laravel .

Neste tutorial, você instalará e começará a usar o Composer em um sistema Ubuntu 20.04.

Pré-requisitos
Para seguir este guia, você pode acessar um servidor como usuário Ubuntu20.04 como usuário sudonão-root um firewall habilitado em seu servidor Para configurar isto, siga nosso guia Configuração do servidor inicial para o Ubuntu 20.04

Passo 1 — Instalando o PHP e as Dependências Adicionais
Além das dependências que já devem estar incluídas em seu sistema Ubuntu 20.04, como o , o Composer exige ou gitexecuta scripts PHP na linha de comando e para extrair arquivos zipados. Vamos instalar essas dependências agora.curlphp-cliunzip

primeiro, atual, gerenciador de pacotes de soluções: o cache do gerenciador de pacotes

sudo apt update
Em seguida, o seguinte comando para instalar os pacotes, execute:

sudo apt install php-cli unzip
Você será solicitado a confirmar a instalação digitando Ye, depois, ENTER.

Assim que os pré-requisitos para instalação do Composer forem instalados, você poderá seguir.

Passo 2 — Baixando e Instalando o Compositor
O Composer fornece um instalador de script escrito em PHP. Vamos baixá-lo, verificar se ele não está danificado e, em seguida, o usaremos para instalar o Composer.

Certifique-se de estar em sua pasta home. Em seguida, baixe o instalador usando o curl:

cd ~
curl -sS https://getcomposer.org/installer -o composer-setup.php
Em seguida, vamos verificar se o instalador baixado corresponde ao hash SHA-384 para o instalador mais recente encontrado na página Composer Public Keys / Signatures . Para facilitar o passo de seleção, você pode usar o seguinte comando para obter programaticamente o hash mais recente da página do Composer e armazená-lo em uma variável do shell:

HASH=`curl -sS https://composer.github.io/installer.sig`
Se você quiser verificar o valor realizado, execute:

echo $HASH
Output
e0012edf3e80b6978849f5eff0d4b4e4c79ff1609dd1e613307e16318854d24ae64f26d17af3ef0bf7cfb710ca74755a
Agora o código PHP a seguir, execute conforme a página de download do Composer, para verificar se o script de instalação está seguro para ser executado:

php -r "if (hash_file('SHA384', 'composer-setup.php') === '$HASH') { echo 'Installer verified'; } else { echo 'Installer corrupt'; unlink('composer-setup.php'); } echo PHP_EOL;"
Você verá o seguinte resultado:

Resultado
Installer verified
Se Installer corruptvocê estiver usando o hash correto, verifique se você está usando o hash correto. Em seguida, repita o processo de verificação. Quando você tiver um instalador selecionado, você pode continuar.

Para instalar o composerglobalmente, use o seguinte comando que baixará e instalará o Composer como um comando disponível em todo o sistema chamado composer, sob /usr/local/bin:

sudo php composer-setup.php --install-dir=/usr/local/bin --filename=composer
Você verá um resultado semelhante com este:

Output
All settings correct for using Composer
Downloading...

Composer (version 1.10.5) successfully installed to: /usr/local/bin/composer
Use it: php /usr/local/bin/composer
Para testar sua instalação, execute:

composer
Output
   ______
  / ____/___  ____ ___  ____  ____  ________  _____
 / /   / __ \/ __ `__ \/ __ \/ __ \/ ___/ _ \/ ___/
/ /___/ /_/ / / / / / / /_/ / /_/ (__  )  __/ /
\____/\____/_/ /_/ /_/ .___/\____/____/\___/_/
                    /_/
Composer version 1.10.5 2020-04-10 11:44:22

Usage:
  command [options] [arguments]

Options:
  -h, --help                     Display this help message
  -q, --quiet                    Do not output any message
  -V, --version                  Display this application version
      --ansi                     Force ANSI output
      --no-ansi                  Disable ANSI output
  -n, --no-interaction           Do not ask any interactive question
      --profile                  Display timing and memory usage information
      --no-plugins               Whether to disable plugins.
  -d, --working-dir=WORKING-DIR  If specified, use the given directory as working directory.
      --no-cache                 Prevent use of the cache
  -v|vv|vvv, --verbose           Increase the verbosity of messages: 1 for normal output, 2 for more verbose output and 3 for debug
...
Isso verifica que o Composer foi instalado com sucesso em seu sistema e está disponível em todo o sistema.

Nota: se você preferirá ter-lhe-ão separados separados do Composer para projeto hospedado neste servidor, você pode instalar localmente, em uma base por projeto. Este método também é útil quando o usuário do sistema não possui permissão para instalar o software disponível em todo o sistema.

Para fazer isso, use o comando php composer-setup.php. Isso irá gerar um arquivo composer.pharem seu diretório atual, que pode ser executado com o seu atual php composer.phar.

Agora podemos dar uma dependência em como usar o Compose como gerenciar.

Passo 3 — Usando o Compositor em um Projeto PHP
Os projetos PHP geralmente dependentes de bibliotecas externas, e o gerenciamento de dependências e suas versões podem ser complicados. O Composer resolve esse problema de manter um controle de projeto de extensões e dependências, também facilita o processo de descoberta, instalação e atualização de pacotes que são definidos por enquanto.

Para usar o seu projeto, você pode compor um arquivo composer.json. O arquivo composer.jsonComposer quais dependências precisa para baixar seu projeto quais serão as versões de cada pacote tem permissão para instalações e instalações. Isso é muito importante para manter seu projeto consistente e evitar a instalação de versões instáveis ​​que podem causar problemas de compatibilidade retroativa.

Você não precisa criar este arquivo manualmente - é comum ocorrer erros de sintaxe quando fizer isso. O Composer oferece uma maneira de criar um novo arquivo composer.jsoncom base na entrada do usuário, o que é uma boa escolha se você planeja compartilhar seu projeto mais tarde como um pacote público no Packagist . O Composer gera automaticamente um arquivo básico composer.jsonquando você executa um comando composer requirepara incluir uma dependência em um projeto recém-criado.

O processo de uso do Composer para instalar um pacote como uma dependência em um projeto envolve os passos a seguir:

Identifique o tipo de biblioteca que o aplicativo precisa.
uma biblioteca de código aberto adequada no agist.org , o responsável oficial de pacotes para o Compose.
Escolha o pacote de dependência.
Execute composer requirepara incluir a dependência no arquivo composer.jsone instalar o pacote.
Vamos testar isso com uma aplicação de demonstração.

O objetivo desta aplicação é transformar uma determinação determinada em uma string de URL amigável - um slug . Isso é comumente usado para converter os títulos de página para caminhos de URL (Assim como a parte final da URL para este tutorial).

Vamos começar a criar um diretório para o nosso projeto. Vamos chamá-lo de slugify :

cd ~
mkdir slugify
cd slugify
Embora não seja necessário, você pode executar agora um comando composer init para criar um arquivo composer.json detalhado para seu projeto. Como o único objetivo do nosso projeto é demonstrar como instalar dependências com o Composer, usaremos um arquivo composer.json mais simples que será gerado automaticamente quando exigirmos nosso primeiro pacote.

Agora é hora de procurar no Packagist.org por um pacote que pode nos ajudar a gerar slugs. Se você procurar pelo termo “slug” no Packagist, receberá um resultado parecido com este:

Resultados da Pesquisa do Packagist para o termo "slug"

Você verá dois números no lado direito de cada pacote na lista. O número no topo representa quantas vezes o pacote foi instalado através do Composer, e o número em baixo mostra quantas vezes um pacote foi estrelado no GitHub. De um modo geral, os pacotes com mais instalações e mais estrelas tendem a ser mais estáveis, pois mais pessoas os utilizam. Também é importante verificar a descrição do pacote para relevância para garantir que ele é o que você precisa.

Precisamos de um conversor string-to-slug A partir dos resultados da pesquisa, o pacote cocur/slugify, que aparece como o primeiro resultado naquela página, parece ser um bom candidato, com uma quantidade razoável de instalações e estrelas.

Os pacotes no Packagist têm um nome de vendor e um nome de package. Cada pacote tem um identificador único (um namespace) no mesmo formato que o GitHub utiliza para seus repositórios: vendor/package. A biblioteca que queremos instalar utiliza o namespace cocur/slugify. Você precisa de um namespace do pacote para exigi-lo em seu projeto.

Agora que você sabe exatamente qual pacote deseja instalar, você pode executar o composer require para incluí-lo como uma dependência e gerar também o arquivo composer.json para seu projeto. Uma coisa importante é observar a exigência de pacotes. O Composer rastreia as dependências no nível da aplicação e do sistema. As dependências no nível do sistema são importantes para indicar de quais módulos PHP um pacote depende. No caso do pacote cocur/slugify, ele exige um módulo PHP que ainda não instalamos.

Quando um pacote necessário depende de uma biblioteca de sistema que não está atualmente instalada em seu servidor, você receberá um erro informando qual requisito está faltando:

composer require cocur/slugify
Output
Using version ^4.0 for cocur/slugify
./composer.json has been updated
Loading composer repositories with package information
Updating dependencies (including require-dev)
Your requirements could not be resolved to an installable set of packages.

  Problem 1
    - Installation request for cocur/slugify ^4.0 -> satisfiable by cocur/slugify[v4.0.0].
    - cocur/slugify v4.0.0 requires ext-mbstring * -> the requested PHP extension mbstring is missing from your system.
...
Para resolver o problema de dependência do sistema, podemos procurar pelo pacote que falta usando o apt search:

apt search mbstring
Output
Sorting... Done
Full Text Search... Done
php-mbstring/focal 2:7.4+75 all
  MBSTRING module for PHP [default]

php-patchwork-utf8/focal 1.3.1-1 all
  UTF-8 strings handling for PHP

php7.4-mbstring/focal 7.4.3-4ubuntu1 amd64
  MBSTRING module for PHP
Após localizar o nome do pacote correto, você pode utilizar o apt novamente para instalar a dependência de sistema:

sudo apt install php-mbstring
Assim que a instalação terminar, você pode executar novamente o comando composer require:

composer require cocur/slugify
Output
Using version ^4.0 for cocur/slugify
./composer.json has been created
Loading composer repositories with package information
Updating dependencies (including require-dev)
Package operations: 1 install, 0 updates, 0 removals
  - Installing cocur/slugify (v4.0.0): Downloading (100%)         
Writing lock file
Generating autoload files
Como você pode ver na saída, o Composer decidiu automaticamente qual versão do pacote utilizar. Se você verificar o diretório do seu projeto agora, ele irá conter dois arquivos novos: composer.json e composer.lock, e um diretório vendor:

ls -l
Output
total 12
-rw-rw-r-- 1 sammy sammy   59 May  4 13:56 composer.json
-rw-rw-r-- 1 sammy sammy 3229 May  4 13:56 composer.lock
drwxrwxr-x 4 sammy sammy 4096 May  4 13:56 vendor
O arquivo composer.lock é usado para armazenar informações sobre quais versões de cada pacote estão instaladas, e garantir que as mesmas versões sejam usadas se outra pessoa clonar seu projeto e instalar suas dependências. O diretório vendor é onde as dependências do projeto estão localizadas. Você não deve fazer commit da pasta vendor no controle de versão - você precisa apenas incluir os arquivos composer.json e composer.lock.

Ao instalar um projeto que já contém um arquivo composer.json, execute o composer install para baixar as dependências do projeto.

Vamos dar uma olhada rápida em restrições de versão. Se você verificar o conteúdo do seu arquivo composer.json, verá algo parecido com isto:

cat composer.json
Output
{
    "require": {
        "cocur/slugify": "^4.0"
    }
}
Note que há o caractere especial ^ antes do número da versão no composer.json. O Composer suporta várias restrições diferentes e formatos para definir a versão necessária do pacote, para fornecer flexibilidade enquanto também mantém seu projeto estável. O operador circunflexo (^) utilizado pelo arquivo composer.json criado automaticamente é o operador recomendado para a interoperabilidade máxima, seguindo o versionamento semântico. Neste caso, ele define 4.0 como a versão mínima compatível e permite atualizações para qualquer versão futura abaixo de 5.0.

De um modo geral, você não precisará alterar as restrições de versão em seu arquivo composer.json. No entanto, algumas situações podem exigir que você edite manualmente as restrições – por exemplo, quando uma nova versão principal da sua biblioteca requerida é liberada e você deseja atualizar, ou quando a biblioteca que você deseja usar não segue o versionamento semântico.

Aqui estão alguns exemplos para lhe dar um melhor entendimento sobre como as restrições de versão do Composer funcionam:

Restrição	Significado	Exemplo de Versões Permitidas
^1.0	>= 1.0 < 2.0	1.0, 1.2.3, 1.9.9
^1.1.0	>= 1.1.0 < 2.0	1.1.0, 1.5.6, 1.9.9
~1.0	>= 1.0 < 2.0.0	1.0, 1.4.1, 1.9.9
~1.0.0	>= 1.0.0 < 1.1	1.0.0, 1.0.4, 1.0.9
1.2.1	1.2.1	1.2.1
1.*	>= 1.0 < 2.0	1.0.0, 1.4.5, 1.9.9
1.2. *	>= 1.2 < 1.3	1.2.0, 1.2.3, 1.2.9
Para uma visualização mais detalhada das restrições de versão do Composer, consulte a documentação oficial.

A seguir, vamos ver como carregar dependências automaticamente com o Composer.

Passo 4 — Incluindo o Script Autoload
Como o PHP por si só não carrega classes automaticamente, o Composer fornece um script autoload que você pode incluir em seu projeto para obter o carregamento automático para ele. Este arquivo é gerado automaticamente pelo Composer quando você adiciona sua primeira dependência.

A única coisa que você precisa fazer é incluir o arquivo vendor/autoload.php em seus scripts PHP antes de qualquer instância de classe.

Vamos testar isso em nossa aplicação de demonstração. Abra um novo arquivo chamado test.php em seu editor de texto:

nano test.php
Adicione o código a seguir que vem no arquivo vendor/autoload.php, carrega a dependência cocur/slugify, e o utiliza para criar um slug:

test.php
<?php
require __DIR__ . '/vendor/autoload.php';

use Cocur\Slugify\Slugify;

$slugify = new Slugify();

echo $slugify->slugify('Hello World, this is a long sentence and I need to make a slug from it!');
Salve o arquivo e saia do seu editor.

Agora, execute o script.

php test.php
Isso produz a saída hello-world-this-is-a-long-sentence-and-i-need-to-make-a-slug-from-it.

As dependências precisam de atualizações quando novas versões são liberadas. Dessa forma, vamos ver como lidar com isso.

Passo 5 — Atualizando as Dependências do Projeto
Sempre que você quiser atualizar suas dependências do projeto para versões mais recentes, execute o comando update:

composer update
Isso irá verificar por versões mais recentes das bibliotecas que você requer em seu projeto. Se uma versão mais recente for encontrada e ela for compatível com a restrição de versão definida no arquivo composer.json, o Composer substituirá a versão anterior instalada. O arquivo composer.lock será atualizado para refletir essas alterações.

Você também pode atualizar uma ou mais bibliotecas específicas, especificando-as desta forma:

composer update vendor/package vendor2/package2
Certifique-se de verificar em seus arquivos composer.json e composer.lock dentro do seu sistema de controle de versão após atualizar suas dependências de modo que outros também possam instalar essas versões mais recentes.

Conclusão





***********
Algoritmo "CalculoMedia2"
// Disciplina: Lógica de programação
// Professor : Antonio Carlos Nicolodi
// Descrição : calculo da média aritimética
// Autor     : Professor Antonio
// Data atual: 01/04/2015
var
// Seção de Declarações
   v1, v2, total: Real
   sinal : Caracter
Inicio
// Seção dos Comandos
   Escreva ("Digite o primeiro valor: ")
   Leia (v1)
   Escreva ("Digite a operação + - * / : ")
   Leia (sinal)
   Escreva ("Digite o segundo valor: ")
   Leia (v2)

   Se sinal = "+" entao
   total <- v1 + v2
   Escreva("O Resultado é: ", total)
   Senao
   Se sinal = "-" entao
   total <- v1 - v2
   Escreva("O Resultado é: ", total)
   Senao
   Se sinal = "*" entao
   total <- v1 * v2
   Escreva("O Resultado é: ", total)


   Senao
     Escreva("OPERAÇÃO INVÁLIDA! ")



      Escreval("total")
   fimse
Fimalgoritmo

****
COMANDOS DOCKER
root@DELLAGS:~# curl -s "https://laravel.build/laravel-9-course?with=mysql,redis,mailhog" | bash

root@DELLAGS:~/example-app# ./vendor/bin/sail  artisan migrate --seed -> criar o banco de dados e copular dados;

Dockerfile

root@DELLAGS:~/example-app# docker exec -it example-app-mysql-1 bash


FROM wyveo/nginx-php-fpm:latest
WORKDIR /usr/share/nginx
RUN rm -rf /usr/share/nginx/html
COPY . /usr/share/nginx
RUN chmod -R 755 /usr/share/nginx/storage/*
RUN ln -s public html

.env (do composer)

DB_CONNECTION=mysql
DB_HOST=mysql-app (serviço do mysql no docker-compose.yaml)
DB_PORT=3306
DB_DATABASE=laraveldockerdb
DB_USERNAME=root
DB_PASSWORD=123456



docker-compose.yaml

version: '3'

services:
  laraveldocker-app:
    build: .
    ports:
      - "3003:80"
    volumes:
      - ./:/usr/share/nginx
      - .docker/nginx:/etc/nginx/conf.d/
    networks:
      - app-network
  mysql-app:
    image: mysql:5.7.22
    ports:
      - "3306:3306"
    volumes:
      - .docker/dbdata:/var/lib/mysql
    environment:
      MYSQL_DATABASE: laraveldocker
      MYSQL_ROOT_PASSWORD: 123456
    networks:
      - app-network
networks:
  app-network:
    driver: bridge
    



/*************************************************
#criando um serviço com um nome qualquer
version: '3'

services:
  laravel-app:                    #criando um serviço com um nome qualquer
    build: . ou image: wyveo/nginx-php-fpm:latest -> neste caso sem Dockerfile.                    # endereço da imagem ou local do Dockerfile (neste caso o ponto siginifica a raiz do projeto)
    ports:
      - "8080:80"                 # 8080 porta do meu host: 80 é a porta do docker nginx
    volumes:                      # docker-compose up -d -> sobe a imagem e libera o terminal  
      - ./:/usr/share/nginx       # TUDO QUE ESTIVE NA RAIZ (na rais tem o meu projeto laravel) './' IRÁ SER REFLETIDO NA PASTA /usr/share/nginx (pasta de acesso da página html)
                                  # C:\Laravel-docker\laravel-docker>docker compose up -d --build atualiza a minha imagem

  mysql-app:
      image: mysql:5.7
      ports:
        - "3306:3306"
      volumes:
        - .docker/dbdata:/var/lib/mysql          # qualqer nome (para persistir -guardar os dados do banco de dados)


      environment:
        MYSQL_DATABASE: laravel
        MYSQL_ROOT_PASSWORD: laravel
    
      

      /***************************///


  
C:\Laravel-docker\laravel-docker>docker compose up -d --build

                                
                               

    

/******************************** Dockerfile
FROM wyveo/nginx-php-fpm:latest

/***************************///
  COMANDOS

docker compose down -> para todos os containers
C:\Laravel-docker\laravel-docker>docker exec -it laravel-docker-laravel-app-1 bash 
root@612ea0ea3340:/# cd /usr/share/nginx/
root@612ea0ea3340:/usr/share/nginx# php artisan migrate
root@612ea0ea3340:/usr/share/nginx# php artisan serve

		
/***********/
PS C:\Users\alber> docker run -e MYSQL_ROOT_PASSWORD=root --name meu-mysql -d mysql:5.7

docker inspect meu-mysql ou | grep IPAddress

PS C:\Users\alber> docker run -e MYSQL_ROOT_PASSWORD=root --name meu-mysql -d -p 3306:3306 mysql:5.7

docker ps
docker ps -l
docker ps -a
docker rm -f nome


/*** LARAVEL */
### CRIANDO UM PROJETO NO LARAVEL 
laravel new projeto_laravel_via_installer (ESTA É UM AOPÇÃO)
composer create-project --prefer-dist laravel/laravel app_controle_tarefas "8.5.9"
cd app_controle_tarefas
cd public
php -S localhost:8000

ou 
da raiz do projeto:
php artisan serve 
ou
php artisan serve --port=3000

### PARA ABRIR PORTA EM OUTRO SERVIDOR
php artisan serve --host test.com --port 8080

 **********************************************************************
cd app_controle_tarefas
cd public
php artisan serve
- acessa o navegador http://localhost:8000

### DENTRO DO PROJETO CRIADO INSTALAR O LARAVEL/UI:^3.2 - versão 3.2
composer require laravel/ui:^3.2

### SE OCORRER ERRO AUMENTAR A MEMÓRIA DISPONIVEL PARA O php

-php --ini -> localiza o arquivo de configuração do php
LOCALIZA memory_limit = 1000 e altera para 
         memory_limit  = -1 e Salva

### LISTA A RELAÇÃO DE COMANDOS 
php artisan list 

DEVERA SURGIR AS OPÇÕES ABAIXO:

 ui
  ui:auth               Scaffold basic login and registration views and routes
  ui:controllers        Scaffold the authentication controllers
 vendor

### ENTENDENDO O PACOTE UI E INICIANDO A AUTENTICAÇÃO WEB NATIVA DO LARAVEL

COMANDO PARA LISTAR ROUTES: 
php artisan route:list

### php artisan ui bootstrap --auth (bootstrap ou react ou vue)
aplicando o bootstrap incluindo os recursos de autenticação;
poderia ser aplicado o bootstrap sem os recursos de autenticação;

### php artisan route:list -> mostra as rotas - ver que aumentaram as rotas

### APÓS ESSE PROCESSO O SISTEMA PEDE PARA RODAR
npm install -> instala as dependências do package.json (inclusive o bootstrap)
npm run dev -> gera os assets da aplicação de acordo com a tecnologia selecionada (bootstrap, react ou vue) -> Geralmente roda mais de uma vez para compilar tudo.

### CRIA O BANCO DE DADOS NORMALMENTE

### EXECUTA AS MIGRATIONS PADRÕES CRIADAS PARA O SISTEMA DE login
php artisan migrate -> CRIA AS TABELAS NO BANCO DE DADOS


************************************** 
INSTALANDO O COMPOSER NO UBUNTU
**************************************
sudo apt update
sudo apt install php-cli unzip

cd ~

curl -sS https://getcomposer.org/installer -o composer-setup.php

HASH=`curl -sS https://composer.github.io/installer.sig`

echo $HASH ->saída: Output
e0012edf3e80b6978849f5eff0d4b4e4c79ff1609dd1e613307e16318854d24ae64f26d17af3ef0bf7cfb710ca74



php -r "if (hash_file('SHA384', 'composer-setup.php') === '$HASH') { echo 'Installer verified'; } else { echo 'Installer corrupt'; unlink('composer-setup.php'); } echo PHP_EOL;"

sudo php composer-setup.php --install-dir=/usr/local/bin --filename=composer





***********************

DigitalOcean Kubernetes: novo plano de controle é mais rápido e gratuito, habilita HA para SLA de 99,95% de tempo de atividade
Produtos
Preços

Documentos
divisa suspensa

Entrar
divisa suspensa

// Tutorial //
Como Instalar e Utilizar o Composer no Ubuntu 20.04
Publicado em 21 de maio de 2020
Ubuntu
PHP
Ubuntu 20.04
Avatar padrão
Por Erika Heidi
Advogado Desenvolvedor
Português
Como Instalar e Utilizar o Composer no Ubuntu 20.04
Introdução
O Composer é uma ferramenta popular de gerenciamento de dependências para o PHP, criado para facilitar a instalação e a atualização das dependências principalmente do projeto. Ele controla quais outros pacotes de projeto específico dependem e são instalados para você, usando as opções apropriadas de acordo com os requisitos do projeto. O Composer também é comumente utilizado para inicializar novos projetos em frameworks PHP populares, como o Symfon e o Laravel .

Neste tutorial, você instalará e começará a usar o Composer em um sistema Ubuntu 20.04.

Pré-requisitos
Para seguir este guia, você pode acessar um servidor como usuário Ubuntu20.04 como usuário sudonão-root um firewall habilitado em seu servidor Para configurar isto, siga nosso guia Configuração do servidor inicial para o Ubuntu 20.04

Passo 1 — Instalando o PHP e as Dependências Adicionais
Além das dependências que já devem estar incluídas em seu sistema Ubuntu 20.04, como o , o Composer exige ou gitexecuta scripts PHP na linha de comando e para extrair arquivos zipados. Vamos instalar essas dependências agora.curlphp-cliunzip

primeiro, atual, gerenciador de pacotes de soluções: o cache do gerenciador de pacotes

sudo apt update
Em seguida, o seguinte comando para instalar os pacotes, execute:

sudo apt install php-cli unzip
Você será solicitado a confirmar a instalação digitando Ye, depois, ENTER.

Assim que os pré-requisitos para instalação do Composer forem instalados, você poderá seguir.

Passo 2 — Baixando e Instalando o Compositor
O Composer fornece um instalador de script escrito em PHP. Vamos baixá-lo, verificar se ele não está danificado e, em seguida, o usaremos para instalar o Composer.

Certifique-se de estar em sua pasta home. Em seguida, baixe o instalador usando o curl:

cd ~
curl -sS https://getcomposer.org/installer -o composer-setup.php
Em seguida, vamos verificar se o instalador baixado corresponde ao hash SHA-384 para o instalador mais recente encontrado na página Composer Public Keys / Signatures . Para facilitar o passo de seleção, você pode usar o seguinte comando para obter programaticamente o hash mais recente da página do Composer e armazená-lo em uma variável do shell:

HASH=`curl -sS https://composer.github.io/installer.sig`
Se você quiser verificar o valor realizado, execute:

echo $HASH
Output
e0012edf3e80b6978849f5eff0d4b4e4c79ff1609dd1e613307e16318854d24ae64f26d17af3ef0bf7cfb710ca74755a
Agora o código PHP a seguir, execute conforme a página de download do Composer, para verificar se o script de instalação está seguro para ser executado:

php -r "if (hash_file('SHA384', 'composer-setup.php') === '$HASH') { echo 'Installer verified'; } else { echo 'Installer corrupt'; unlink('composer-setup.php'); } echo PHP_EOL;"
Você verá o seguinte resultado:

Resultado
Installer verified
Se Installer corruptvocê estiver usando o hash correto, verifique se você está usando o hash correto. Em seguida, repita o processo de verificação. Quando você tiver um instalador selecionado, você pode continuar.

Para instalar o composerglobalmente, use o seguinte comando que baixará e instalará o Composer como um comando disponível em todo o sistema chamado composer, sob /usr/local/bin:

sudo php composer-setup.php --install-dir=/usr/local/bin --filename=composer
Você verá um resultado semelhante com este:

Output
All settings correct for using Composer
Downloading...

Composer (version 1.10.5) successfully installed to: /usr/local/bin/composer
Use it: php /usr/local/bin/composer
Para testar sua instalação, execute:

composer
Output
   ______
  / ____/___  ____ ___  ____  ____  ________  _____
 / /   / __ \/ __ `__ \/ __ \/ __ \/ ___/ _ \/ ___/
/ /___/ /_/ / / / / / / /_/ / /_/ (__  )  __/ /
\____/\____/_/ /_/ /_/ .___/\____/____/\___/_/
                    /_/
Composer version 1.10.5 2020-04-10 11:44:22

Usage:
  command [options] [arguments]

Options:
  -h, --help                     Display this help message
  -q, --quiet                    Do not output any message
  -V, --version                  Display this application version
      --ansi                     Force ANSI output
      --no-ansi                  Disable ANSI output
  -n, --no-interaction           Do not ask any interactive question
      --profile                  Display timing and memory usage information
      --no-plugins               Whether to disable plugins.
  -d, --working-dir=WORKING-DIR  If specified, use the given directory as working directory.
      --no-cache                 Prevent use of the cache
  -v|vv|vvv, --verbose           Increase the verbosity of messages: 1 for normal output, 2 for more verbose output and 3 for debug
...
Isso verifica que o Composer foi instalado com sucesso em seu sistema e está disponível em todo o sistema.

Nota: se você preferirá ter-lhe-ão separados separados do Composer para projeto hospedado neste servidor, você pode instalar localmente, em uma base por projeto. Este método também é útil quando o usuário do sistema não possui permissão para instalar o software disponível em todo o sistema.

Para fazer isso, use o comando php composer-setup.php. Isso irá gerar um arquivo composer.pharem seu diretório atual, que pode ser executado com o seu atual php composer.phar.

Agora podemos dar uma dependência em como usar o Compose como gerenciar.

Passo 3 — Usando o Compositor em um Projeto PHP
Os projetos PHP geralmente dependentes de bibliotecas externas, e o gerenciamento de dependências e suas versões podem ser complicados. O Composer resolve esse problema de manter um controle de projeto de extensões e dependências, também facilita o processo de descoberta, instalação e atualização de pacotes que são definidos por enquanto.

Para usar o seu projeto, você pode compor um arquivo composer.json. O arquivo composer.jsonComposer quais dependências precisa para baixar seu projeto quais serão as versões de cada pacote tem permissão para instalações e instalações. Isso é muito importante para manter seu projeto consistente e evitar a instalação de versões instáveis ​​que podem causar problemas de compatibilidade retroativa.

Você não precisa criar este arquivo manualmente - é comum ocorrer erros de sintaxe quando fizer isso. O Composer oferece uma maneira de criar um novo arquivo composer.jsoncom base na entrada do usuário, o que é uma boa escolha se você planeja compartilhar seu projeto mais tarde como um pacote público no Packagist . O Composer gera automaticamente um arquivo básico composer.jsonquando você executa um comando composer requirepara incluir uma dependência em um projeto recém-criado.

O processo de uso do Composer para instalar um pacote como uma dependência em um projeto envolve os passos a seguir:

Identifique o tipo de biblioteca que o aplicativo precisa.
uma biblioteca de código aberto adequada no agist.org , o responsável oficial de pacotes para o Compose.
Escolha o pacote de dependência.
Execute composer requirepara incluir a dependência no arquivo composer.jsone instalar o pacote.
Vamos testar isso com uma aplicação de demonstração.

O objetivo desta aplicação é transformar uma determinação determinada em uma string de URL amigável - um slug . Isso é comumente usado para converter os títulos de página para caminhos de URL (Assim como a parte final da URL para este tutorial).

Vamos começar a criar um diretório para o nosso projeto. Vamos chamá-lo de slugify :

cd ~
mkdir slugify
cd slugify
Embora não seja necessário, você pode executar agora um comando composer init para criar um arquivo composer.json detalhado para seu projeto. Como o único objetivo do nosso projeto é demonstrar como instalar dependências com o Composer, usaremos um arquivo composer.json mais simples que será gerado automaticamente quando exigirmos nosso primeiro pacote.

Agora é hora de procurar no Packagist.org por um pacote que pode nos ajudar a gerar slugs. Se você procurar pelo termo “slug” no Packagist, receberá um resultado parecido com este:

Resultados da Pesquisa do Packagist para o termo "slug"

Você verá dois números no lado direito de cada pacote na lista. O número no topo representa quantas vezes o pacote foi instalado através do Composer, e o número em baixo mostra quantas vezes um pacote foi estrelado no GitHub. De um modo geral, os pacotes com mais instalações e mais estrelas tendem a ser mais estáveis, pois mais pessoas os utilizam. Também é importante verificar a descrição do pacote para relevância para garantir que ele é o que você precisa.

Precisamos de um conversor string-to-slug A partir dos resultados da pesquisa, o pacote cocur/slugify, que aparece como o primeiro resultado naquela página, parece ser um bom candidato, com uma quantidade razoável de instalações e estrelas.

Os pacotes no Packagist têm um nome de vendor e um nome de package. Cada pacote tem um identificador único (um namespace) no mesmo formato que o GitHub utiliza para seus repositórios: vendor/package. A biblioteca que queremos instalar utiliza o namespace cocur/slugify. Você precisa de um namespace do pacote para exigi-lo em seu projeto.

Agora que você sabe exatamente qual pacote deseja instalar, você pode executar o composer require para incluí-lo como uma dependência e gerar também o arquivo composer.json para seu projeto. Uma coisa importante é observar a exigência de pacotes. O Composer rastreia as dependências no nível da aplicação e do sistema. As dependências no nível do sistema são importantes para indicar de quais módulos PHP um pacote depende. No caso do pacote cocur/slugify, ele exige um módulo PHP que ainda não instalamos.

Quando um pacote necessário depende de uma biblioteca de sistema que não está atualmente instalada em seu servidor, você receberá um erro informando qual requisito está faltando:

composer require cocur/slugify
Output
Using version ^4.0 for cocur/slugify
./composer.json has been updated
Loading composer repositories with package information
Updating dependencies (including require-dev)
Your requirements could not be resolved to an installable set of packages.

  Problem 1
    - Installation request for cocur/slugify ^4.0 -> satisfiable by cocur/slugify[v4.0.0].
    - cocur/slugify v4.0.0 requires ext-mbstring * -> the requested PHP extension mbstring is missing from your system.
...
Para resolver o problema de dependência do sistema, podemos procurar pelo pacote que falta usando o apt search:

apt search mbstring
Output
Sorting... Done
Full Text Search... Done
php-mbstring/focal 2:7.4+75 all
  MBSTRING module for PHP [default]

php-patchwork-utf8/focal 1.3.1-1 all
  UTF-8 strings handling for PHP

php7.4-mbstring/focal 7.4.3-4ubuntu1 amd64
  MBSTRING module for PHP
Após localizar o nome do pacote correto, você pode utilizar o apt novamente para instalar a dependência de sistema:

sudo apt install php-mbstring
Assim que a instalação terminar, você pode executar novamente o comando composer require:

composer require cocur/slugify
Output
Using version ^4.0 for cocur/slugify
./composer.json has been created
Loading composer repositories with package information
Updating dependencies (including require-dev)
Package operations: 1 install, 0 updates, 0 removals
  - Installing cocur/slugify (v4.0.0): Downloading (100%)         
Writing lock file
Generating autoload files
Como você pode ver na saída, o Composer decidiu automaticamente qual versão do pacote utilizar. Se você verificar o diretório do seu projeto agora, ele irá conter dois arquivos novos: composer.json e composer.lock, e um diretório vendor:

ls -l
Output
total 12
-rw-rw-r-- 1 sammy sammy   59 May  4 13:56 composer.json
-rw-rw-r-- 1 sammy sammy 3229 May  4 13:56 composer.lock
drwxrwxr-x 4 sammy sammy 4096 May  4 13:56 vendor
O arquivo composer.lock é usado para armazenar informações sobre quais versões de cada pacote estão instaladas, e garantir que as mesmas versões sejam usadas se outra pessoa clonar seu projeto e instalar suas dependências. O diretório vendor é onde as dependências do projeto estão localizadas. Você não deve fazer commit da pasta vendor no controle de versão - você precisa apenas incluir os arquivos composer.json e composer.lock.

Ao instalar um projeto que já contém um arquivo composer.json, execute o composer install para baixar as dependências do projeto.

Vamos dar uma olhada rápida em restrições de versão. Se você verificar o conteúdo do seu arquivo composer.json, verá algo parecido com isto:

cat composer.json
Output
{
    "require": {
        "cocur/slugify": "^4.0"
    }
}
Note que há o caractere especial ^ antes do número da versão no composer.json. O Composer suporta várias restrições diferentes e formatos para definir a versão necessária do pacote, para fornecer flexibilidade enquanto também mantém seu projeto estável. O operador circunflexo (^) utilizado pelo arquivo composer.json criado automaticamente é o operador recomendado para a interoperabilidade máxima, seguindo o versionamento semântico. Neste caso, ele define 4.0 como a versão mínima compatível e permite atualizações para qualquer versão futura abaixo de 5.0.

De um modo geral, você não precisará alterar as restrições de versão em seu arquivo composer.json. No entanto, algumas situações podem exigir que você edite manualmente as restrições – por exemplo, quando uma nova versão principal da sua biblioteca requerida é liberada e você deseja atualizar, ou quando a biblioteca que você deseja usar não segue o versionamento semântico.

Aqui estão alguns exemplos para lhe dar um melhor entendimento sobre como as restrições de versão do Composer funcionam:

Restrição	Significado	Exemplo de Versões Permitidas
^1.0	>= 1.0 < 2.0	1.0, 1.2.3, 1.9.9
^1.1.0	>= 1.1.0 < 2.0	1.1.0, 1.5.6, 1.9.9
~1.0	>= 1.0 < 2.0.0	1.0, 1.4.1, 1.9.9
~1.0.0	>= 1.0.0 < 1.1	1.0.0, 1.0.4, 1.0.9
1.2.1	1.2.1	1.2.1
1.*	>= 1.0 < 2.0	1.0.0, 1.4.5, 1.9.9
1.2. *	>= 1.2 < 1.3	1.2.0, 1.2.3, 1.2.9
Para uma visualização mais detalhada das restrições de versão do Composer, consulte a documentação oficial.

A seguir, vamos ver como carregar dependências automaticamente com o Composer.

Passo 4 — Incluindo o Script Autoload
Como o PHP por si só não carrega classes automaticamente, o Composer fornece um script autoload que você pode incluir em seu projeto para obter o carregamento automático para ele. Este arquivo é gerado automaticamente pelo Composer quando você adiciona sua primeira dependência.

A única coisa que você precisa fazer é incluir o arquivo vendor/autoload.php em seus scripts PHP antes de qualquer instância de classe.

Vamos testar isso em nossa aplicação de demonstração. Abra um novo arquivo chamado test.php em seu editor de texto:

nano test.php
Adicione o código a seguir que vem no arquivo vendor/autoload.php, carrega a dependência cocur/slugify, e o utiliza para criar um slug:

test.php
<?php
require __DIR__ . '/vendor/autoload.php';

use Cocur\Slugify\Slugify;

$slugify = new Slugify();

echo $slugify->slugify('Hello World, this is a long sentence and I need to make a slug from it!');
Salve o arquivo e saia do seu editor.

Agora, execute o script.

php test.php
Isso produz a saída hello-world-this-is-a-long-sentence-and-i-need-to-make-a-slug-from-it.

As dependências precisam de atualizações quando novas versões são liberadas. Dessa forma, vamos ver como lidar com isso.

Passo 5 — Atualizando as Dependências do Projeto
Sempre que você quiser atualizar suas dependências do projeto para versões mais recentes, execute o comando update:

composer update
Isso irá verificar por versões mais recentes das bibliotecas que você requer em seu projeto. Se uma versão mais recente for encontrada e ela for compatível com a restrição de versão definida no arquivo composer.json, o Composer substituirá a versão anterior instalada. O arquivo composer.lock será atualizado para refletir essas alterações.

Você também pode atualizar uma ou mais bibliotecas específicas, especificando-as desta forma:

composer update vendor/package vendor2/package2
Certifique-se de verificar em seus arquivos composer.json e composer.lock dentro do seu sistema de controle de versão após atualizar suas dependências de modo que outros também possam instalar essas versões mais recentes.








INÍCIO:

1 instalar o docker

2 abrir wsl2/Windows ou linux
 curl -s "https://laravel.build/olw?with=mysql,redis,mailhog,minio" | bash

3 cd olw
./vendor/bin/sail up -d
	ou
4 cd olw && ./vendor/bin/sail up -d

5 ATRIBUINDO PERMISSÃO PARA A PASTA
cd .. -> sai da pasta
sudo chmod 777 olw/ -R ou sem o 'sudo' chmod 777 olw/ -R

6 CRIANDO ALIAS PARA O COMANDO ANTERIOR
alias sail='[ -f sail ] && sh sail || sh vendor/bin/sail'
passa a usar assim: sail ps

7 CONFIGURAR PORTAS PARA A APLICAÇÃO NO NAVEGADOR E MYSQL
.env
APP_PORT=8000

*porta do myql
FORWARD_DB_PORT=3307

8 INSTALANDO DEPENDÊNCIA AO PROJETO
./vendor/bin/sail composer require laravel/breeze --dev

9 DEIXAR TELA DE AUTENTICAÇÃO PRONTA, ROTA AUTENTICADA, TAWINDCSS INSTALADO E INERTIA INSTALADO
./vendor/bin/sail artisan breeze:install vue 
ou
./vendor/bin/sail art breeze:install vue


10 RODAR AS MIGRATES PADRÕES DO PROJETO AI JÁ PODE CADASTRAR USUÁRIOS PARA LOGIN:
./vendor/bin/sail art migrate

11 


/*******************************************/
2a AULA:

O PROJETO CONSISTE EM RECEBER DADOS DE UMA API (punkapi.com) DE INFORMAÇÕES SOBRE CERVEJAS, VAMOS CONSTRUIR AS ROTAS PARA CONSUMIR A API E CRIAR A ESTRUTURA PARA O RELATÓRIO QUE IREMOS GERAR EM EXCEL E ENVIAR PARA O STORAGE...
1 CRIAR ROTAS:
code .
olw/routes/web.php


sail up -d -> SOBE O CONTAINER localhost:8000 (nesse projeto)

Route::get('/beers', fn()=> 'Olw - testando a rota /beers');

**************************************************
obs:
- laravel.com/api -> acesso a documentação do código;
- in line paramets for vscode -> extensão para vscode para exibir o nome dos métodos na hora que codificar;
- fira code -> extensão para fonte no vscode

Copilot vs Tabnine, qual preferem? (pesquisar sobre)
Link para extensões vscode:
https://github.com/icarojobs/vscode-useful-extensions
*************************************************


Route::get('/beers', fn()=> 'Olw - testando a rota /beers')
                             ->middleware(['auth']);

* FLUXO PADRÃO DO MVC-LARAVEL: 
life cicle: sai do usuário pelo navegador, insomnia ou postman -> passa pelo index.php(pasta public) -> passa pelos arquivos do bootstrap retornando uma instância da aplicação -> passa pelo kernel do http (carrega mais instâncias) -> Service provider -> despacha a requisição pro Router -> Cai no arquivo Web.php -> Middleware (se tiver, geralmente tem os globais) -> Controller (faz as regras de negócio e pode chamar outras classes como Serviços por exemplo)
-> Retorna uma view ou um json (No caso estamos usando inértia, ele não vai reinderizar a 'view.blade' padrão, ele vai reinderizar componente vue.js através do inértia.).


* EM VEZ DE USAR A FUNÇÃO AQUI NA ROTA CRIAMOS UM CONTROLLER:
obs.: ​dica: php artisan make:controller -r cria o Resource também.

sail artisan make:controller BeerController
ou 
sail art make:controller BeerController -> CRIA O ARQUIVO BeerController.php na pasta app/Http/Controllers
->
<?php

namespace App\Http\Controllers;

use Illuminate\Http\Request;

class BeerController extends Controller
{
    public function index()
    {
    return 'Virgu & Beer & Code'
    }
}

* NO ARQUIVO DE ROTAS Web.php CHAMA O BeersController:

importante importar o Controller <nomeDoController>+<CTRL=ENTER:
use App\Http\Controllers\BeerController;

Route::get('/beers', [BeerController::class, 'index'])
                        ->middleware(['auth']);


* PRECISAMOS CRIAR UM MÉTODO PARA PEGAR A LISTA, LISTAR OS DADOS DA API (listar as bebidas de https://api.punkapi.com/v2 ->
VAMOS CRIAR UMA NOVA CLASSE de serviços em app/Sevices/PunkapiService.php

* O LARAVEL POSSUI UM RECURSO CHAMADO HTTPClient que abstrai o uso de uma ferramenta chama guzeo, esse guzeo é o client http mais comum para php, com ele fazemos requisições pra diversos serviços web dentro do php para outras url, ele é robusto, então o laravel simplifica importando o recurso que faz tudo por 'detrás dos panos':

PunkapiService.php

<?php

namespace App\Services;

use Illuminate\Support\Facades\Http;

class PunkapiService
{
    public function getBeers()
    {
        return Http::get('https://api.punkapi.com/v2/beers');
    }
}

E NO BeerController.php fica:
<?php

namespace App\Http\Controllers;

use App\Services\PunkapiService;
use Illuminate\Http\Request;

class BeerController extends Controller
{
    public function index()
    {
    //return 'Virgu & Beer & Code';
    $service = new PunkapiService;

    return $service->getBeers();
    }
}

* TRATE É CARACTERÍSTICA QUE A CLASSE ADQUIRE (pode ter mesmos métodos e atributos substituindo o recurso de um classe extender várias classes que não tem no php, a trate é uma forma de fazer isso. O service  é uma outra camada na maioria das vezes abstrair seviços que vc vai consumir, por exemplo API.

Estando logado, os dados da api já serão exibidos em localhost:8000/beers, se usar um aplicativo cliente tipo insomnia pode apresentar os dados também, melhor comentar a linha de de autenticação da rota:
Route::get('/beers', [BeerController::class, 'index']);
linha de autenticação da rota // ->middleware(['auth']);

* ESSA API PERMITE FAZER FILTROS VIA PARÂMETROS NA PRÓPRIA ROTA. PRIMEIRO VAMOS REFATORAR O CÓDIO, A CLASSE PunkapiService.php:

USO DE CONFIG E MACRO


Vamos alterar a url, primeiro acessando a pasta config da raiz do projeto e criar o arquivo punkapi.php. O que acontece é que o config(pasta config da raiz) carrega todos os arquivos da pasta e permite que sejam acessados via funções simples(HELPERS), isso é muito legal porque podemos acessar esses arquivos de configurações de qualquer lugar do projeto: 

<?php

return [
    'url' => env('PUNK_BASE_URL', 'https://api.punkapi.com/v2')
];

Usando o helper env significa dizer que, se não houver a constante PUNK_BASE_URL setada no arquivo .env do projeto, seu valor será o segundo parâmetro: http://api.punkapi.com/v2 e no arquivo PunkapiService.php da pasta app/Services fica:

<?php

namespace App\Services;

use Illuminate\Support\Facades\Http;

class PunkapiService
{
    public function getBeers()
    {
        return Http::get('/beers');
    }
}

MACRO é uma forma de criar funções customizadas:
 em app\Providers vamos acessar o arquivo AppServiceProvider.php que é uma classe que tem dois métodos register e boot. No método boot vamos chamar o método Http do laravel e chamar o método macro, no primeiro parâmetro será um nome atribuído à função e e o segundo uma clausure (uma função).
Neste arquivo é passado o arquivo de configuração da url (em 'config/punkapi.php') além de tokens, headers,...
 

use Illuminate\Support\Facades\Http; -> deve ser importado
E a função boot fica:

  public function boot()
    {
        Http::macro('punkapi', function(){
            return Http::acceptJson()
            ->baseUrl(config('punkapi.url'));
        });
    }

Então criamos uma macro(uma função customizada) chamada punkapi que já retorna o client com accept/Json no Header e com o baseUrl configurado lá do arquivo /config/punkapi.php e se estiver setado no .env pegará de lá.

/app/Services/PunkapiService.php fica:

<?php

namespace App\Services;

use Illuminate\Support\Facades\Http;

class PunkapiService
{
    public function getBeers()
    {
        return Http::punkapi()->get('/beers');
    }
}

*obs.: a baseUrl poderia ser setada no construtor, que pode setar token também.(uma outra abordagem para versão sem macros);

->Testamos o retorno Json em localhost:8000/beers.

Refatorando o arquivo PunkapiService.php: O client Http não lança exceção e podemos forçar o retorno em modo Json:
<?php

namespace App\Services;

use Illuminate\Support\Facades\Http;

class PunkapiService
{
    public function getBeers()
    {
       // return Http::punkapi()->get('/beers');
       return Http::punkapi()
            ->get('/beers')
            ->throw()  // Exceção em caso de erro
            ->json();   // Força o retorno em formato Json
    }
}

Podemos testar forçando um erro alterando a constante PUNKAPI_BASE_URL criada em /config/punkapi.php, vamos atribuir um valor diferente no arquivo .env:

PUNKAPI_BASE_URL="adfjklj878"

Podemos usar a função retry tem dois parâmetros, o número de tentativas pra buscar a requisição e o intervalo entre elas. Refatorando o código fica:
<?php

namespace App\Services;

use Illuminate\Support\Facades\Http;

class PunkapiService
{
    public function getBeers()
    {
       // return Http::punkapi()->get('/beers');
       return Http::punkapi()
            ->get('/beers')
            ->throw()  // Exceção em caso de erro
            ->json();   // Força o retorno em formato Json
    }
}

- Quando sai a exceção nao deveriamos retornar o erro em json por ser um api neste caso estamos usamos um app web e não uma api. E usaríamos o Route Api.

Refatorando o método boot de /app/Providers/AppServiceProvider.php, inserindo o retry():

     */
    public function boot()
    {
        Http::macro('punkapi', function(){
            return Http::acceptJson()
            ->baseUrl(config('punkapi.url'))
            ->retry(3,100);
        });
    }
}

comando de help

* sail composer dump-autoload
* Verificar Nome do arquivo se bate com o nome das rotas(Classes criadas e importar o nome errado);
* inteliphense

Refatorando BeerController.php
<?php

namespace App\Http\Controllers;

use App\Services\PunkapiService;

class BeerController extends Controller
{
    public function index()
    {

    $service = new PunkapiService();

    return $service->getBeers();
    }
}

Em vez de instanciar o método PunkapiService() dentro de index, vamos passar por parâmetro de index() declarando seu Próprio nome (PunkapiService) como tipo. Fica assim:

<?php

namespace App\Http\Controllers;

use App\Services\PunkapiService;

class BeerController extends Controller
{
    public function index(PunkapiService $service)
    {
    return $service->getBeers();
    }
}

Assim usamos feactures do php(injeção de dependências) e ao mesmo tempo feactures do laravel. Em vez de criar uma instância dentro do método index, vamos injetar a classe como parâmetro para o método index(), ficando index($service) e a instância de dentro da função passa como parâmetro de 'tipo da variável'. Isso quebra a cadeia de dependência entre as classes.
Assim, o método index ganha independência não mais dependendo da instância de new PunkapiService e passamos a olhar a função index em si.
Assim, o Laravel tenta fazer um binding, um match, o laravel tenta encontrar alguma classe PunkapiService e cria uma instância dessa classe e usa ali como parâmetro. Se não fizer assim, lá em Rotas teria que ser passado como parâmetro o que fica desnecessário.
Não poderia ser feito se na classe PunkapiService existisse o construtor para atribuir valores automaticamente à classe. Assim podemos usar porque não precisamos passar nenhum valor.

ADICIONAR OS FILTROS:
Vamos filtrar o retorno api com os seguintes itens: beer_name, food, ibu_gt, malte:

var_dump($v)
die();
dd($variável)
benchmarck -> ?

/*****REFATORA PARA TESTE alterando BeerController.php e PunkapiService.php
BeerController.php
<?php

namespace App\Http\Controllers;

use App\Services\PunkapiService;

class BeerController extends Controller
{
    public function index(PunkapiService $service)
    {
    return $service->getBeers(
        'heineken',
        'cheese',
        'corn',
        45
    );
    }
}

PunkapiService.php
<?php

namespace App\Services;

use Illuminate\Support\Facades\Http;

class PunkapiService
{
    public function getBeers(
        string $beer_name,
        string $food,
        string $malt,
        string $ibu_gt
    )
    {
        $params = get_defined_vars();

        dd($params);

        return Http::punkapi()
            ->get('/beers', $params)
            ->throw()  // Exceção em caso de erro
            ->json();   // Força o retorno em formato Json
    }
}

Resultado do debug no insomnia ou no navegador:
array:4 [▼ // app/Services/PunkapiService.php:18
  "beer_name" => "heineken"
  "food" => "cheese"
  "malt" => "corn"
  "ibu_gt" => "45"
]
//* fim teste

Refatorando:

class PunkapiService
{
    public function getBeers(
        string $beer_name = null,
        string $food = null,
        string $malt = null,
        string $ibu_gt = null
    )
    {
        $params = get_defined_vars();

        dd($params);

        return Http::punkapi()
            ->get('/beers', $params)
            ->throw()  // Exceção em caso de erro
            ->json();   // Força o retorno em formato Json
    }
}

Assim quando não passar o valor para a chave ele exibirá a chave e o valor Null, vamos refatorar para não exibir nem a chave englobando get_defined_vers() com array_filter no arquivo PunkapiService.php:

$params = array_filter(get_defined_vars());

<?php

namespace App\Http\Controllers;

use App\Services\PunkapiService;

class BeerController extends Controller
{
    public function index(PunkapiService $service)
    {
    return $service->getBeers(
        'heineken',
        'cheese',
        'corn',
       // 45 -> Esse não é passado
    );
    }
}


array:3 [▼ // app/Services/PunkapiService.php:18
  "beer_name" => "heineken"
  "food" => "cheese"
  "malt" => "corn"
	Aqui não exibiu o valor 45
]


USANDO A FUNÇÃO NAMED_ARGS passamos só os parâmetros que precisamos retornar da api e o php com essa função saberá qual a posição dela no array de argumentos passados como parâmetro sem a necessidade de seguir a mesma sequência dos argumentos:
class BeerController extends Controller
{
    public function index(PunkapiService $service)
    {
    return $service->getBeers(food: 'cheese');
    }
}

REFATORANDO:
BeerController.php
<?php

namespace App\Http\Controllers;

use App\Services\PunkapiService;
use Illuminate\Http\Request;

class BeerController extends Controller
{
    public function index( Request $request, PunkapiService $service)
    {
    return $service->getBeers(...$request->all());
    }
}

PunkapiService.php
<?php

namespace App\Services;

use Illuminate\Support\Facades\Http;

class PunkapiService
{
    public function getBeers(
        string $beer_name = null,
        string $food = null,
        string $malt = null,
        string $ibu_gt = null
    )
    {
        $params = array_filter(get_defined_vars());

     //   dd($params);

        return Http::punkapi()
            ->get('/beers', $params)
            ->throw()  // Exceção em caso de erro
            ->json();   // Força o retorno em formato Json
    }
}

CRIANDO UMA REQUEST
sail artisan make:request BeerRequest
/app/Http/Requests/BeerRequest.php

* clouser é uma função passada como parâmetro


AGRUPANDO AS ROTAS 2:01MINUTO 
open laravel week | MVC, rotas , services, api, filas, redis laravel Excel e S3 | Mosturação










 
































/**************************************/

sail share

sail artisan sail:publish ->coloca em uma pasta na raiz chamada docker

sail --help

sail artisan optimizer:clear

sail ps

sail build --no-cache -> faz o bild da aplicação. (dá um sail down  por precaução antes.)










/*********************************

root@DELLAGS:~# curl -s "https://laravel.build/laravel-9-course?with=mysql,redis,mailhog" | bash

Dockerfile

root@DELLAGS:~/example-app# docker exec -it example-app-mysql-1 bash


FROM wyveo/nginx-php-fpm:latest
WORKDIR /usr/share/nginx
RUN rm -rf /usr/share/nginx/html
COPY . /usr/share/nginx
RUN chmod -R 755 /usr/share/nginx/storage/*
RUN ln -s public html

.env (do composer)

DB_CONNECTION=mysql
DB_HOST=mysql-app (serviço do mysql no docker-compose.yaml)
DB_PORT=3306
DB_DATABASE=laraveldockerdb
DB_USERNAME=root
DB_PASSWORD=123456



docker-compose.yaml

version: '3'

services:
  laraveldocker-app:
    build: .
    ports:
      - "3003:80"
    volumes:
      - ./:/usr/share/nginx
      - .docker/nginx:/etc/nginx/conf.d/
    networks:
      - app-network
  mysql-app:
    image: mysql:5.7.22
    ports:
      - "3306:3306"
    volumes:
      - .docker/dbdata:/var/lib/mysql
    environment:
      MYSQL_DATABASE: laraveldocker
      MYSQL_ROOT_PASSWORD: 123456
    networks:
      - app-network
networks:
  app-network:
    driver: bridge
    



/*************************************************
#criando um serviço com um nome qualquer
version: '3'

services:
  laravel-app:                    #criando um serviço com um nome qualquer
    build: . ou image: wyveo/nginx-php-fpm:latest -> neste caso sem Dockerfile.                    # endereço da imagem ou local do Dockerfile (neste caso o ponto siginifica a raiz do projeto)
    ports:
      - "8080:80"                 # 8080 porta do meu host: 80 é a porta do docker nginx
    volumes:                      # docker-compose up -d -> sobe a imagem e libera o terminal  
      - ./:/usr/share/nginx       # TUDO QUE ESTIVE NA RAIZ (na rais tem o meu projeto laravel) './' IRÁ SER REFLETIDO NA PASTA /usr/share/nginx (pasta de acesso da página html)
                                  # C:\Laravel-docker\laravel-docker>docker compose up -d --build atualiza a minha imagem

  mysql-app:
      image: mysql:5.7
      ports:
        - "3306:3306"
      volumes:
        - .docker/dbdata:/var/lib/mysql          # qualqer nome (para persistir -guardar os dados do banco de dados)


      environment:
        MYSQL_DATABASE: laravel
        MYSQL_ROOT_PASSWORD: laravel
    
      

      /***************************///


  
C:\Laravel-docker\laravel-docker>docker compose up -d --build

                                
                               

    

/******************************** Dockerfile
FROM wyveo/nginx-php-fpm:latest

/***************************///
  COMANDOS

docker compose down -> para todos os containers
C:\Laravel-docker\laravel-docker>docker exec -it laravel-docker-laravel-app-1 bash 
root@612ea0ea3340:/# cd /usr/share/nginx/
root@612ea0ea3340:/usr/share/nginx# php artisan migrate
root@612ea0ea3340:/usr/share/nginx# php artisan serve

		
/***********/
PS C:\Users\alber> docker run -e MYSQL_ROOT_PASSWORD=root --name meu-mysql -d mysql:5.7

docker inspect meu-mysql ou | grep IPAddress

PS C:\Users\alber> docker run -e MYSQL_ROOT_PASSWORD=root --name meu-mysql -d -p 3306:3306 mysql:5.7

docker ps
docker ps -l
docker ps -a
docker rm -f nome


/*** LARAVEL */
### CRIANDO UM PROJETO NO LARAVEL 
laravel new projeto_laravel_via_installer (ESTA É UM AOPÇÃO)
composer create-project --prefer-dist laravel/laravel app_controle_tarefas "8.5.9"
cd app_controle_tarefas
cd public
php -S localhost:8000

ou 
da raiz do projeto:
php artisan serve 
ou
php artisan serve --port=3000

### PARA ABRIR PORTA EM OUTRO SERVIDOR
php artisan serve --host test.com --port 8080

 **********************************************************************
cd app_controle_tarefas
cd public
php artisan serve
- acessa o navegador http://localhost:8000

### DENTRO DO PROJETO CRIADO INSTALAR O LARAVEL/UI:^3.2 - versão 3.2
composer require laravel/ui:^3.2

### SE OCORRER ERRO AUMENTAR A MEMÓRIA DISPONIVEL PARA O php

-php --ini -> localiza o arquivo de configuração do php
LOCALIZA memory_limit = 1000 e altera para 
         memory_limit  = -1 e Salva

### LISTA A RELAÇÃO DE COMANDOS 
php artisan list 

DEVERA SURGIR AS OPÇÕES ABAIXO:

 ui
  ui:auth               Scaffold basic login and registration views and routes
  ui:controllers        Scaffold the authentication controllers
 vendor

### ENTENDENDO O PACOTE UI E INICIANDO A AUTENTICAÇÃO WEB NATIVA DO LARAVEL

COMANDO PARA LISTAR ROUTES: 
php artisan route:list

### php artisan ui bootstrap --auth (bootstrap ou react ou vue)
aplicando o bootstrap incluindo os recursos de autenticação;
poderia ser aplicado o bootstrap sem os recursos de autenticação;

### php artisan route:list -> mostra as rotas - ver que aumentaram as rotas

### APÓS ESSE PROCESSO O SISTEMA PEDE PARA RODAR
npm install -> instala as dependências do package.json (inclusive o bootstrap)
npm run dev -> gera os assets da aplicação de acordo com a tecnologia selecionada (bootstrap, react ou vue) -> Geralmente roda mais de uma vez para compilar tudo.

### CRIA O BANCO DE DADOS NORMALMENTE

### EXECUTA AS MIGRATIONS PADRÕES CRIADAS PARA O SISTEMA DE login
php artisan migrate -> CRIA AS TABELAS NO BANCO DE DADOS


************************************** 
INSTALANDO O COMPOSER NO UBUNTU
**************************************
sudo apt update
sudo apt install php-cli unzip

cd ~

curl -sS https://getcomposer.org/installer -o composer-setup.php

HASH=`curl -sS https://composer.github.io/installer.sig`

echo $HASH ->saída: Output
e0012edf3e80b6978849f5eff0d4b4e4c79ff1609dd1e613307e16318854d24ae64f26d17af3ef0bf7cfb710ca74



php -r "if (hash_file('SHA384', 'composer-setup.php') === '$HASH') { echo 'Installer verified'; } else { echo 'Installer corrupt'; unlink('composer-setup.php'); } echo PHP_EOL;"

sudo php composer-setup.php --install-dir=/usr/local/bin --filename=composer





***********************

DigitalOcean Kubernetes: novo plano de controle é mais rápido e gratuito, habilita HA para SLA de 99,95% de tempo de atividade
Produtos
Preços

Documentos
divisa suspensa

Entrar
divisa suspensa

// Tutorial //
Como Instalar e Utilizar o Composer no Ubuntu 20.04
Publicado em 21 de maio de 2020
Ubuntu
PHP
Ubuntu 20.04
Avatar padrão
Por Erika Heidi
Advogado Desenvolvedor
Português
Como Instalar e Utilizar o Composer no Ubuntu 20.04
Introdução
O Composer é uma ferramenta popular de gerenciamento de dependências para o PHP, criado para facilitar a instalação e a atualização das dependências principalmente do projeto. Ele controla quais outros pacotes de projeto específico dependem e são instalados para você, usando as opções apropriadas de acordo com os requisitos do projeto. O Composer também é comumente utilizado para inicializar novos projetos em frameworks PHP populares, como o Symfon e o Laravel .

Neste tutorial, você instalará e começará a usar o Composer em um sistema Ubuntu 20.04.

Pré-requisitos
Para seguir este guia, você pode acessar um servidor como usuário Ubuntu20.04 como usuário sudonão-root um firewall habilitado em seu servidor Para configurar isto, siga nosso guia Configuração do servidor inicial para o Ubuntu 20.04

Passo 1 — Instalando o PHP e as Dependências Adicionais
Além das dependências que já devem estar incluídas em seu sistema Ubuntu 20.04, como o , o Composer exige ou gitexecuta scripts PHP na linha de comando e para extrair arquivos zipados. Vamos instalar essas dependências agora.curlphp-cliunzip

primeiro, atual, gerenciador de pacotes de soluções: o cache do gerenciador de pacotes

sudo apt update
Em seguida, o seguinte comando para instalar os pacotes, execute:

sudo apt install php-cli unzip
Você será solicitado a confirmar a instalação digitando Ye, depois, ENTER.

Assim que os pré-requisitos para instalação do Composer forem instalados, você poderá seguir.

Passo 2 — Baixando e Instalando o Compositor
O Composer fornece um instalador de script escrito em PHP. Vamos baixá-lo, verificar se ele não está danificado e, em seguida, o usaremos para instalar o Composer.

Certifique-se de estar em sua pasta home. Em seguida, baixe o instalador usando o curl:

cd ~
curl -sS https://getcomposer.org/installer -o composer-setup.php
Em seguida, vamos verificar se o instalador baixado corresponde ao hash SHA-384 para o instalador mais recente encontrado na página Composer Public Keys / Signatures . Para facilitar o passo de seleção, você pode usar o seguinte comando para obter programaticamente o hash mais recente da página do Composer e armazená-lo em uma variável do shell:

HASH=`curl -sS https://composer.github.io/installer.sig`
Se você quiser verificar o valor realizado, execute:

echo $HASH
Output
e0012edf3e80b6978849f5eff0d4b4e4c79ff1609dd1e613307e16318854d24ae64f26d17af3ef0bf7cfb710ca74755a
Agora o código PHP a seguir, execute conforme a página de download do Composer, para verificar se o script de instalação está seguro para ser executado:

php -r "if (hash_file('SHA384', 'composer-setup.php') === '$HASH') { echo 'Installer verified'; } else { echo 'Installer corrupt'; unlink('composer-setup.php'); } echo PHP_EOL;"
Você verá o seguinte resultado:

Resultado
Installer verified
Se Installer corruptvocê estiver usando o hash correto, verifique se você está usando o hash correto. Em seguida, repita o processo de verificação. Quando você tiver um instalador selecionado, você pode continuar.

Para instalar o composerglobalmente, use o seguinte comando que baixará e instalará o Composer como um comando disponível em todo o sistema chamado composer, sob /usr/local/bin:

sudo php composer-setup.php --install-dir=/usr/local/bin --filename=composer
Você verá um resultado semelhante com este:

Output
All settings correct for using Composer
Downloading...

Composer (version 1.10.5) successfully installed to: /usr/local/bin/composer
Use it: php /usr/local/bin/composer
Para testar sua instalação, execute:

composer
Output
   ______
  / ____/___  ____ ___  ____  ____  ________  _____
 / /   / __ \/ __ `__ \/ __ \/ __ \/ ___/ _ \/ ___/
/ /___/ /_/ / / / / / / /_/ / /_/ (__  )  __/ /
\____/\____/_/ /_/ /_/ .___/\____/____/\___/_/
                    /_/
Composer version 1.10.5 2020-04-10 11:44:22

Usage:
  command [options] [arguments]

Options:
  -h, --help                     Display this help message
  -q, --quiet                    Do not output any message
  -V, --version                  Display this application version
      --ansi                     Force ANSI output
      --no-ansi                  Disable ANSI output
  -n, --no-interaction           Do not ask any interactive question
      --profile                  Display timing and memory usage information
      --no-plugins               Whether to disable plugins.
  -d, --working-dir=WORKING-DIR  If specified, use the given directory as working directory.
      --no-cache                 Prevent use of the cache
  -v|vv|vvv, --verbose           Increase the verbosity of messages: 1 for normal output, 2 for more verbose output and 3 for debug
...
Isso verifica que o Composer foi instalado com sucesso em seu sistema e está disponível em todo o sistema.

Nota: se você preferirá ter-lhe-ão separados separados do Composer para projeto hospedado neste servidor, você pode instalar localmente, em uma base por projeto. Este método também é útil quando o usuário do sistema não possui permissão para instalar o software disponível em todo o sistema.

Para fazer isso, use o comando php composer-setup.php. Isso irá gerar um arquivo composer.pharem seu diretório atual, que pode ser executado com o seu atual php composer.phar.

Agora podemos dar uma dependência em como usar o Compose como gerenciar.

Passo 3 — Usando o Compositor em um Projeto PHP
Os projetos PHP geralmente dependentes de bibliotecas externas, e o gerenciamento de dependências e suas versões podem ser complicados. O Composer resolve esse problema de manter um controle de projeto de extensões e dependências, também facilita o processo de descoberta, instalação e atualização de pacotes que são definidos por enquanto.

Para usar o seu projeto, você pode compor um arquivo composer.json. O arquivo composer.jsonComposer quais dependências precisa para baixar seu projeto quais serão as versões de cada pacote tem permissão para instalações e instalações. Isso é muito importante para manter seu projeto consistente e evitar a instalação de versões instáveis ​​que podem causar problemas de compatibilidade retroativa.

Você não precisa criar este arquivo manualmente - é comum ocorrer erros de sintaxe quando fizer isso. O Composer oferece uma maneira de criar um novo arquivo composer.jsoncom base na entrada do usuário, o que é uma boa escolha se você planeja compartilhar seu projeto mais tarde como um pacote público no Packagist . O Composer gera automaticamente um arquivo básico composer.jsonquando você executa um comando composer requirepara incluir uma dependência em um projeto recém-criado.

O processo de uso do Composer para instalar um pacote como uma dependência em um projeto envolve os passos a seguir:

Identifique o tipo de biblioteca que o aplicativo precisa.
uma biblioteca de código aberto adequada no agist.org , o responsável oficial de pacotes para o Compose.
Escolha o pacote de dependência.
Execute composer requirepara incluir a dependência no arquivo composer.jsone instalar o pacote.
Vamos testar isso com uma aplicação de demonstração.

O objetivo desta aplicação é transformar uma determinação determinada em uma string de URL amigável - um slug . Isso é comumente usado para converter os títulos de página para caminhos de URL (Assim como a parte final da URL para este tutorial).

Vamos começar a criar um diretório para o nosso projeto. Vamos chamá-lo de slugify :

cd ~
mkdir slugify
cd slugify
Embora não seja necessário, você pode executar agora um comando composer init para criar um arquivo composer.json detalhado para seu projeto. Como o único objetivo do nosso projeto é demonstrar como instalar dependências com o Composer, usaremos um arquivo composer.json mais simples que será gerado automaticamente quando exigirmos nosso primeiro pacote.

Agora é hora de procurar no Packagist.org por um pacote que pode nos ajudar a gerar slugs. Se você procurar pelo termo “slug” no Packagist, receberá um resultado parecido com este:

Resultados da Pesquisa do Packagist para o termo "slug"

Você verá dois números no lado direito de cada pacote na lista. O número no topo representa quantas vezes o pacote foi instalado através do Composer, e o número em baixo mostra quantas vezes um pacote foi estrelado no GitHub. De um modo geral, os pacotes com mais instalações e mais estrelas tendem a ser mais estáveis, pois mais pessoas os utilizam. Também é importante verificar a descrição do pacote para relevância para garantir que ele é o que você precisa.

Precisamos de um conversor string-to-slug A partir dos resultados da pesquisa, o pacote cocur/slugify, que aparece como o primeiro resultado naquela página, parece ser um bom candidato, com uma quantidade razoável de instalações e estrelas.

Os pacotes no Packagist têm um nome de vendor e um nome de package. Cada pacote tem um identificador único (um namespace) no mesmo formato que o GitHub utiliza para seus repositórios: vendor/package. A biblioteca que queremos instalar utiliza o namespace cocur/slugify. Você precisa de um namespace do pacote para exigi-lo em seu projeto.

Agora que você sabe exatamente qual pacote deseja instalar, você pode executar o composer require para incluí-lo como uma dependência e gerar também o arquivo composer.json para seu projeto. Uma coisa importante é observar a exigência de pacotes. O Composer rastreia as dependências no nível da aplicação e do sistema. As dependências no nível do sistema são importantes para indicar de quais módulos PHP um pacote depende. No caso do pacote cocur/slugify, ele exige um módulo PHP que ainda não instalamos.

Quando um pacote necessário depende de uma biblioteca de sistema que não está atualmente instalada em seu servidor, você receberá um erro informando qual requisito está faltando:

composer require cocur/slugify
Output
Using version ^4.0 for cocur/slugify
./composer.json has been updated
Loading composer repositories with package information
Updating dependencies (including require-dev)
Your requirements could not be resolved to an installable set of packages.

  Problem 1
    - Installation request for cocur/slugify ^4.0 -> satisfiable by cocur/slugify[v4.0.0].
    - cocur/slugify v4.0.0 requires ext-mbstring * -> the requested PHP extension mbstring is missing from your system.
...
Para resolver o problema de dependência do sistema, podemos procurar pelo pacote que falta usando o apt search:

apt search mbstring
Output
Sorting... Done
Full Text Search... Done
php-mbstring/focal 2:7.4+75 all
  MBSTRING module for PHP [default]

php-patchwork-utf8/focal 1.3.1-1 all
  UTF-8 strings handling for PHP

php7.4-mbstring/focal 7.4.3-4ubuntu1 amd64
  MBSTRING module for PHP
Após localizar o nome do pacote correto, você pode utilizar o apt novamente para instalar a dependência de sistema:

sudo apt install php-mbstring
Assim que a instalação terminar, você pode executar novamente o comando composer require:

composer require cocur/slugify
Output
Using version ^4.0 for cocur/slugify
./composer.json has been created
Loading composer repositories with package information
Updating dependencies (including require-dev)
Package operations: 1 install, 0 updates, 0 removals
  - Installing cocur/slugify (v4.0.0): Downloading (100%)         
Writing lock file
Generating autoload files
Como você pode ver na saída, o Composer decidiu automaticamente qual versão do pacote utilizar. Se você verificar o diretório do seu projeto agora, ele irá conter dois arquivos novos: composer.json e composer.lock, e um diretório vendor:

ls -l
Output
total 12
-rw-rw-r-- 1 sammy sammy   59 May  4 13:56 composer.json
-rw-rw-r-- 1 sammy sammy 3229 May  4 13:56 composer.lock
drwxrwxr-x 4 sammy sammy 4096 May  4 13:56 vendor
O arquivo composer.lock é usado para armazenar informações sobre quais versões de cada pacote estão instaladas, e garantir que as mesmas versões sejam usadas se outra pessoa clonar seu projeto e instalar suas dependências. O diretório vendor é onde as dependências do projeto estão localizadas. Você não deve fazer commit da pasta vendor no controle de versão - você precisa apenas incluir os arquivos composer.json e composer.lock.

Ao instalar um projeto que já contém um arquivo composer.json, execute o composer install para baixar as dependências do projeto.

Vamos dar uma olhada rápida em restrições de versão. Se você verificar o conteúdo do seu arquivo composer.json, verá algo parecido com isto:

cat composer.json
Output
{
    "require": {
        "cocur/slugify": "^4.0"
    }
}
Note que há o caractere especial ^ antes do número da versão no composer.json. O Composer suporta várias restrições diferentes e formatos para definir a versão necessária do pacote, para fornecer flexibilidade enquanto também mantém seu projeto estável. O operador circunflexo (^) utilizado pelo arquivo composer.json criado automaticamente é o operador recomendado para a interoperabilidade máxima, seguindo o versionamento semântico. Neste caso, ele define 4.0 como a versão mínima compatível e permite atualizações para qualquer versão futura abaixo de 5.0.

De um modo geral, você não precisará alterar as restrições de versão em seu arquivo composer.json. No entanto, algumas situações podem exigir que você edite manualmente as restrições – por exemplo, quando uma nova versão principal da sua biblioteca requerida é liberada e você deseja atualizar, ou quando a biblioteca que você deseja usar não segue o versionamento semântico.

Aqui estão alguns exemplos para lhe dar um melhor entendimento sobre como as restrições de versão do Composer funcionam:

Restrição	Significado	Exemplo de Versões Permitidas
^1.0	>= 1.0 < 2.0	1.0, 1.2.3, 1.9.9
^1.1.0	>= 1.1.0 < 2.0	1.1.0, 1.5.6, 1.9.9
~1.0	>= 1.0 < 2.0.0	1.0, 1.4.1, 1.9.9
~1.0.0	>= 1.0.0 < 1.1	1.0.0, 1.0.4, 1.0.9
1.2.1	1.2.1	1.2.1
1.*	>= 1.0 < 2.0	1.0.0, 1.4.5, 1.9.9
1.2. *	>= 1.2 < 1.3	1.2.0, 1.2.3, 1.2.9
Para uma visualização mais detalhada das restrições de versão do Composer, consulte a documentação oficial.

A seguir, vamos ver como carregar dependências automaticamente com o Composer.

Passo 4 — Incluindo o Script Autoload
Como o PHP por si só não carrega classes automaticamente, o Composer fornece um script autoload que você pode incluir em seu projeto para obter o carregamento automático para ele. Este arquivo é gerado automaticamente pelo Composer quando você adiciona sua primeira dependência.

A única coisa que você precisa fazer é incluir o arquivo vendor/autoload.php em seus scripts PHP antes de qualquer instância de classe.

Vamos testar isso em nossa aplicação de demonstração. Abra um novo arquivo chamado test.php em seu editor de texto:

nano test.php
Adicione o código a seguir que vem no arquivo vendor/autoload.php, carrega a dependência cocur/slugify, e o utiliza para criar um slug:

test.php
<?php
require __DIR__ . '/vendor/autoload.php';

use Cocur\Slugify\Slugify;

$slugify = new Slugify();

echo $slugify->slugify('Hello World, this is a long sentence and I need to make a slug from it!');
Salve o arquivo e saia do seu editor.

Agora, execute o script.

php test.php
Isso produz a saída hello-world-this-is-a-long-sentence-and-i-need-to-make-a-slug-from-it.

As dependências precisam de atualizações quando novas versões são liberadas. Dessa forma, vamos ver como lidar com isso.

Passo 5 — Atualizando as Dependências do Projeto
Sempre que você quiser atualizar suas dependências do projeto para versões mais recentes, execute o comando update:

composer update
Isso irá verificar por versões mais recentes das bibliotecas que você requer em seu projeto. Se uma versão mais recente for encontrada e ela for compatível com a restrição de versão definida no arquivo composer.json, o Composer substituirá a versão anterior instalada. O arquivo composer.lock será atualizado para refletir essas alterações.

Você também pode atualizar uma ou mais bibliotecas específicas, especificando-as desta forma:

composer update vendor/package vendor2/package2
Certifique-se de verificar em seus arquivos composer.json e composer.lock dentro do seu sistema de controle de versão após atualizar suas dependências de modo que outros também possam instalar essas versões mais recentes.

Conclusão





***********
Algoritmo "CalculoMedia2"
// Disciplina: Lógica de programação
// Professor : Antonio Carlos Nicolodi
// Descrição : calculo da média aritimética
// Autor     : Professor Antonio
// Data atual: 01/04/2015
var
// Seção de Declarações
   v1, v2, total: Real
   sinal : Caracter
Inicio
// Seção dos Comandos
   Escreva ("Digite o primeiro valor: ")
   Leia (v1)
   Escreva ("Digite a operação + - * / : ")
   Leia (sinal)
   Escreva ("Digite o segundo valor: ")
   Leia (v2)

   Se sinal = "+" entao
   total <- v1 + v2
   Escreva("O Resultado é: ", total)
   Senao
   Se sinal = "-" entao
   total <- v1 - v2
   Escreva("O Resultado é: ", total)
   Senao
   Se sinal = "*" entao
   total <- v1 * v2
   Escreva("O Resultado é: ", total)


   Senao
     Escreva("OPERAÇÃO INVÁLIDA! ")



      Escreval("total")
   fimse
Fimalgoritmo

****
COMANDOS DOCKER
root@DELLAGS:~# curl -s "https://laravel.build/laravel-9-course?with=mysql,redis,mailhog" | bash

root@DELLAGS:~/example-app# ./vendor/bin/sail  artisan migrate --seed -> criar o banco de dados e copular dados;

Dockerfile

root@DELLAGS:~/example-app# docker exec -it example-app-mysql-1 bash


FROM wyveo/nginx-php-fpm:latest
WORKDIR /usr/share/nginx
RUN rm -rf /usr/share/nginx/html
COPY . /usr/share/nginx
RUN chmod -R 755 /usr/share/nginx/storage/*
RUN ln -s public html

.env (do composer)

DB_CONNECTION=mysql
DB_HOST=mysql-app (serviço do mysql no docker-compose.yaml)
DB_PORT=3306
DB_DATABASE=laraveldockerdb
DB_USERNAME=root
DB_PASSWORD=123456



docker-compose.yaml

version: '3'

services:
  laraveldocker-app:
    build: .
    ports:
      - "3003:80"
    volumes:
      - ./:/usr/share/nginx
      - .docker/nginx:/etc/nginx/conf.d/
    networks:
      - app-network
  mysql-app:
    image: mysql:5.7.22
    ports:
      - "3306:3306"
    volumes:
      - .docker/dbdata:/var/lib/mysql
    environment:
      MYSQL_DATABASE: laraveldocker
      MYSQL_ROOT_PASSWORD: 123456
    networks:
      - app-network
networks:
  app-network:
    driver: bridge
    



/*************************************************
#criando um serviço com um nome qualquer
version: '3'

services:
  laravel-app:                    #criando um serviço com um nome qualquer
    build: . ou image: wyveo/nginx-php-fpm:latest -> neste caso sem Dockerfile.                    # endereço da imagem ou local do Dockerfile (neste caso o ponto siginifica a raiz do projeto)
    ports:
      - "8080:80"                 # 8080 porta do meu host: 80 é a porta do docker nginx
    volumes:                      # docker-compose up -d -> sobe a imagem e libera o terminal  
      - ./:/usr/share/nginx       # TUDO QUE ESTIVE NA RAIZ (na rais tem o meu projeto laravel) './' IRÁ SER REFLETIDO NA PASTA /usr/share/nginx (pasta de acesso da página html)
                                  # C:\Laravel-docker\laravel-docker>docker compose up -d --build atualiza a minha imagem

  mysql-app:
      image: mysql:5.7
      ports:
        - "3306:3306"
      volumes:
        - .docker/dbdata:/var/lib/mysql          # qualqer nome (para persistir -guardar os dados do banco de dados)


      environment:
        MYSQL_DATABASE: laravel
        MYSQL_ROOT_PASSWORD: laravel
    
      

      /***************************///


  
C:\Laravel-docker\laravel-docker>docker compose up -d --build

                                
                               

    

/******************************** Dockerfile
FROM wyveo/nginx-php-fpm:latest

/***************************///
  COMANDOS

docker compose down -> para todos os containers
C:\Laravel-docker\laravel-docker>docker exec -it laravel-docker-laravel-app-1 bash 
root@612ea0ea3340:/# cd /usr/share/nginx/
root@612ea0ea3340:/usr/share/nginx# php artisan migrate
root@612ea0ea3340:/usr/share/nginx# php artisan serve

		
/***********/
PS C:\Users\alber> docker run -e MYSQL_ROOT_PASSWORD=root --name meu-mysql -d mysql:5.7

docker inspect meu-mysql ou | grep IPAddress

PS C:\Users\alber> docker run -e MYSQL_ROOT_PASSWORD=root --name meu-mysql -d -p 3306:3306 mysql:5.7

docker ps
docker ps -l
docker ps -a
docker rm -f nome


/*** LARAVEL */
### CRIANDO UM PROJETO NO LARAVEL 
laravel new projeto_laravel_via_installer (ESTA É UM AOPÇÃO)
composer create-project --prefer-dist laravel/laravel app_controle_tarefas "8.5.9"
cd app_controle_tarefas
cd public
php -S localhost:8000

ou 
da raiz do projeto:
php artisan serve 
ou
php artisan serve --port=3000

### PARA ABRIR PORTA EM OUTRO SERVIDOR
php artisan serve --host test.com --port 8080

 **********************************************************************
cd app_controle_tarefas
cd public
php artisan serve
- acessa o navegador http://localhost:8000

### DENTRO DO PROJETO CRIADO INSTALAR O LARAVEL/UI:^3.2 - versão 3.2
composer require laravel/ui:^3.2

### SE OCORRER ERRO AUMENTAR A MEMÓRIA DISPONIVEL PARA O php

-php --ini -> localiza o arquivo de configuração do php
LOCALIZA memory_limit = 1000 e altera para 
         memory_limit  = -1 e Salva

### LISTA A RELAÇÃO DE COMANDOS 
php artisan list 

DEVERA SURGIR AS OPÇÕES ABAIXO:

 ui
  ui:auth               Scaffold basic login and registration views and routes
  ui:controllers        Scaffold the authentication controllers
 vendor

### ENTENDENDO O PACOTE UI E INICIANDO A AUTENTICAÇÃO WEB NATIVA DO LARAVEL

COMANDO PARA LISTAR ROUTES: 
php artisan route:list

### php artisan ui bootstrap --auth (bootstrap ou react ou vue)
aplicando o bootstrap incluindo os recursos de autenticação;
poderia ser aplicado o bootstrap sem os recursos de autenticação;

### php artisan route:list -> mostra as rotas - ver que aumentaram as rotas

### APÓS ESSE PROCESSO O SISTEMA PEDE PARA RODAR
npm install -> instala as dependências do package.json (inclusive o bootstrap)
npm run dev -> gera os assets da aplicação de acordo com a tecnologia selecionada (bootstrap, react ou vue) -> Geralmente roda mais de uma vez para compilar tudo.

### CRIA O BANCO DE DADOS NORMALMENTE

### EXECUTA AS MIGRATIONS PADRÕES CRIADAS PARA O SISTEMA DE login
php artisan migrate -> CRIA AS TABELAS NO BANCO DE DADOS


************************************** 
INSTALANDO O COMPOSER NO UBUNTU
**************************************
sudo apt update
sudo apt install php-cli unzip

cd ~

curl -sS https://getcomposer.org/installer -o composer-setup.php

HASH=`curl -sS https://composer.github.io/installer.sig`

echo $HASH ->saída: Output
e0012edf3e80b6978849f5eff0d4b4e4c79ff1609dd1e613307e16318854d24ae64f26d17af3ef0bf7cfb710ca74



php -r "if (hash_file('SHA384', 'composer-setup.php') === '$HASH') { echo 'Installer verified'; } else { echo 'Installer corrupt'; unlink('composer-setup.php'); } echo PHP_EOL;"

sudo php composer-setup.php --install-dir=/usr/local/bin --filename=composer





***********************

DigitalOcean Kubernetes: novo plano de controle é mais rápido e gratuito, habilita HA para SLA de 99,95% de tempo de atividade
Produtos
Preços

Documentos
divisa suspensa

Entrar
divisa suspensa

// Tutorial //
Como Instalar e Utilizar o Composer no Ubuntu 20.04
Publicado em 21 de maio de 2020
Ubuntu
PHP
Ubuntu 20.04
Avatar padrão
Por Erika Heidi
Advogado Desenvolvedor
Português
Como Instalar e Utilizar o Composer no Ubuntu 20.04
Introdução
O Composer é uma ferramenta popular de gerenciamento de dependências para o PHP, criado para facilitar a instalação e a atualização das dependências principalmente do projeto. Ele controla quais outros pacotes de projeto específico dependem e são instalados para você, usando as opções apropriadas de acordo com os requisitos do projeto. O Composer também é comumente utilizado para inicializar novos projetos em frameworks PHP populares, como o Symfon e o Laravel .

Neste tutorial, você instalará e começará a usar o Composer em um sistema Ubuntu 20.04.

Pré-requisitos
Para seguir este guia, você pode acessar um servidor como usuário Ubuntu20.04 como usuário sudonão-root um firewall habilitado em seu servidor Para configurar isto, siga nosso guia Configuração do servidor inicial para o Ubuntu 20.04

Passo 1 — Instalando o PHP e as Dependências Adicionais
Além das dependências que já devem estar incluídas em seu sistema Ubuntu 20.04, como o , o Composer exige ou gitexecuta scripts PHP na linha de comando e para extrair arquivos zipados. Vamos instalar essas dependências agora.curlphp-cliunzip

primeiro, atual, gerenciador de pacotes de soluções: o cache do gerenciador de pacotes

sudo apt update
Em seguida, o seguinte comando para instalar os pacotes, execute:

sudo apt install php-cli unzip
Você será solicitado a confirmar a instalação digitando Ye, depois, ENTER.

Assim que os pré-requisitos para instalação do Composer forem instalados, você poderá seguir.

Passo 2 — Baixando e Instalando o Compositor
O Composer fornece um instalador de script escrito em PHP. Vamos baixá-lo, verificar se ele não está danificado e, em seguida, o usaremos para instalar o Composer.

Certifique-se de estar em sua pasta home. Em seguida, baixe o instalador usando o curl:

cd ~
curl -sS https://getcomposer.org/installer -o composer-setup.php
Em seguida, vamos verificar se o instalador baixado corresponde ao hash SHA-384 para o instalador mais recente encontrado na página Composer Public Keys / Signatures . Para facilitar o passo de seleção, você pode usar o seguinte comando para obter programaticamente o hash mais recente da página do Composer e armazená-lo em uma variável do shell:

HASH=`curl -sS https://composer.github.io/installer.sig`
Se você quiser verificar o valor realizado, execute:

echo $HASH
Output
e0012edf3e80b6978849f5eff0d4b4e4c79ff1609dd1e613307e16318854d24ae64f26d17af3ef0bf7cfb710ca74755a
Agora o código PHP a seguir, execute conforme a página de download do Composer, para verificar se o script de instalação está seguro para ser executado:

php -r "if (hash_file('SHA384', 'composer-setup.php') === '$HASH') { echo 'Installer verified'; } else { echo 'Installer corrupt'; unlink('composer-setup.php'); } echo PHP_EOL;"
Você verá o seguinte resultado:

Resultado
Installer verified
Se Installer corruptvocê estiver usando o hash correto, verifique se você está usando o hash correto. Em seguida, repita o processo de verificação. Quando você tiver um instalador selecionado, você pode continuar.

Para instalar o composerglobalmente, use o seguinte comando que baixará e instalará o Composer como um comando disponível em todo o sistema chamado composer, sob /usr/local/bin:

sudo php composer-setup.php --install-dir=/usr/local/bin --filename=composer
Você verá um resultado semelhante com este:

Output
All settings correct for using Composer
Downloading...

Composer (version 1.10.5) successfully installed to: /usr/local/bin/composer
Use it: php /usr/local/bin/composer
Para testar sua instalação, execute:

composer
Output
   ______
  / ____/___  ____ ___  ____  ____  ________  _____
 / /   / __ \/ __ `__ \/ __ \/ __ \/ ___/ _ \/ ___/
/ /___/ /_/ / / / / / / /_/ / /_/ (__  )  __/ /
\____/\____/_/ /_/ /_/ .___/\____/____/\___/_/
                    /_/
Composer version 1.10.5 2020-04-10 11:44:22

Usage:
  command [options] [arguments]

Options:
  -h, --help                     Display this help message
  -q, --quiet                    Do not output any message
  -V, --version                  Display this application version
      --ansi                     Force ANSI output
      --no-ansi                  Disable ANSI output
  -n, --no-interaction           Do not ask any interactive question
      --profile                  Display timing and memory usage information
      --no-plugins               Whether to disable plugins.
  -d, --working-dir=WORKING-DIR  If specified, use the given directory as working directory.
      --no-cache                 Prevent use of the cache
  -v|vv|vvv, --verbose           Increase the verbosity of messages: 1 for normal output, 2 for more verbose output and 3 for debug
...
Isso verifica que o Composer foi instalado com sucesso em seu sistema e está disponível em todo o sistema.

Nota: se você preferirá ter-lhe-ão separados separados do Composer para projeto hospedado neste servidor, você pode instalar localmente, em uma base por projeto. Este método também é útil quando o usuário do sistema não possui permissão para instalar o software disponível em todo o sistema.

Para fazer isso, use o comando php composer-setup.php. Isso irá gerar um arquivo composer.pharem seu diretório atual, que pode ser executado com o seu atual php composer.phar.

Agora podemos dar uma dependência em como usar o Compose como gerenciar.

Passo 3 — Usando o Compositor em um Projeto PHP
Os projetos PHP geralmente dependentes de bibliotecas externas, e o gerenciamento de dependências e suas versões podem ser complicados. O Composer resolve esse problema de manter um controle de projeto de extensões e dependências, também facilita o processo de descoberta, instalação e atualização de pacotes que são definidos por enquanto.

Para usar o seu projeto, você pode compor um arquivo composer.json. O arquivo composer.jsonComposer quais dependências precisa para baixar seu projeto quais serão as versões de cada pacote tem permissão para instalações e instalações. Isso é muito importante para manter seu projeto consistente e evitar a instalação de versões instáveis ​​que podem causar problemas de compatibilidade retroativa.

Você não precisa criar este arquivo manualmente - é comum ocorrer erros de sintaxe quando fizer isso. O Composer oferece uma maneira de criar um novo arquivo composer.jsoncom base na entrada do usuário, o que é uma boa escolha se você planeja compartilhar seu projeto mais tarde como um pacote público no Packagist . O Composer gera automaticamente um arquivo básico composer.jsonquando você executa um comando composer requirepara incluir uma dependência em um projeto recém-criado.

O processo de uso do Composer para instalar um pacote como uma dependência em um projeto envolve os passos a seguir:

Identifique o tipo de biblioteca que o aplicativo precisa.
uma biblioteca de código aberto adequada no agist.org , o responsável oficial de pacotes para o Compose.
Escolha o pacote de dependência.
Execute composer requirepara incluir a dependência no arquivo composer.jsone instalar o pacote.
Vamos testar isso com uma aplicação de demonstração.

O objetivo desta aplicação é transformar uma determinação determinada em uma string de URL amigável - um slug . Isso é comumente usado para converter os títulos de página para caminhos de URL (Assim como a parte final da URL para este tutorial).

Vamos começar a criar um diretório para o nosso projeto. Vamos chamá-lo de slugify :

cd ~
mkdir slugify
cd slugify
Embora não seja necessário, você pode executar agora um comando composer init para criar um arquivo composer.json detalhado para seu projeto. Como o único objetivo do nosso projeto é demonstrar como instalar dependências com o Composer, usaremos um arquivo composer.json mais simples que será gerado automaticamente quando exigirmos nosso primeiro pacote.

Agora é hora de procurar no Packagist.org por um pacote que pode nos ajudar a gerar slugs. Se você procurar pelo termo “slug” no Packagist, receberá um resultado parecido com este:

Resultados da Pesquisa do Packagist para o termo "slug"

Você verá dois números no lado direito de cada pacote na lista. O número no topo representa quantas vezes o pacote foi instalado através do Composer, e o número em baixo mostra quantas vezes um pacote foi estrelado no GitHub. De um modo geral, os pacotes com mais instalações e mais estrelas tendem a ser mais estáveis, pois mais pessoas os utilizam. Também é importante verificar a descrição do pacote para relevância para garantir que ele é o que você precisa.

Precisamos de um conversor string-to-slug A partir dos resultados da pesquisa, o pacote cocur/slugify, que aparece como o primeiro resultado naquela página, parece ser um bom candidato, com uma quantidade razoável de instalações e estrelas.

Os pacotes no Packagist têm um nome de vendor e um nome de package. Cada pacote tem um identificador único (um namespace) no mesmo formato que o GitHub utiliza para seus repositórios: vendor/package. A biblioteca que queremos instalar utiliza o namespace cocur/slugify. Você precisa de um namespace do pacote para exigi-lo em seu projeto.

Agora que você sabe exatamente qual pacote deseja instalar, você pode executar o composer require para incluí-lo como uma dependência e gerar também o arquivo composer.json para seu projeto. Uma coisa importante é observar a exigência de pacotes. O Composer rastreia as dependências no nível da aplicação e do sistema. As dependências no nível do sistema são importantes para indicar de quais módulos PHP um pacote depende. No caso do pacote cocur/slugify, ele exige um módulo PHP que ainda não instalamos.

Quando um pacote necessário depende de uma biblioteca de sistema que não está atualmente instalada em seu servidor, você receberá um erro informando qual requisito está faltando:

composer require cocur/slugify
Output
Using version ^4.0 for cocur/slugify
./composer.json has been updated
Loading composer repositories with package information
Updating dependencies (including require-dev)
Your requirements could not be resolved to an installable set of packages.

  Problem 1
    - Installation request for cocur/slugify ^4.0 -> satisfiable by cocur/slugify[v4.0.0].
    - cocur/slugify v4.0.0 requires ext-mbstring * -> the requested PHP extension mbstring is missing from your system.
...
Para resolver o problema de dependência do sistema, podemos procurar pelo pacote que falta usando o apt search:

apt search mbstring
Output
Sorting... Done
Full Text Search... Done
php-mbstring/focal 2:7.4+75 all
  MBSTRING module for PHP [default]

php-patchwork-utf8/focal 1.3.1-1 all
  UTF-8 strings handling for PHP

php7.4-mbstring/focal 7.4.3-4ubuntu1 amd64
  MBSTRING module for PHP
Após localizar o nome do pacote correto, você pode utilizar o apt novamente para instalar a dependência de sistema:

sudo apt install php-mbstring
Assim que a instalação terminar, você pode executar novamente o comando composer require:

composer require cocur/slugify
Output
Using version ^4.0 for cocur/slugify
./composer.json has been created
Loading composer repositories with package information
Updating dependencies (including require-dev)
Package operations: 1 install, 0 updates, 0 removals
  - Installing cocur/slugify (v4.0.0): Downloading (100%)         
Writing lock file
Generating autoload files
Como você pode ver na saída, o Composer decidiu automaticamente qual versão do pacote utilizar. Se você verificar o diretório do seu projeto agora, ele irá conter dois arquivos novos: composer.json e composer.lock, e um diretório vendor:

ls -l
Output
total 12
-rw-rw-r-- 1 sammy sammy   59 May  4 13:56 composer.json
-rw-rw-r-- 1 sammy sammy 3229 May  4 13:56 composer.lock
drwxrwxr-x 4 sammy sammy 4096 May  4 13:56 vendor
O arquivo composer.lock é usado para armazenar informações sobre quais versões de cada pacote estão instaladas, e garantir que as mesmas versões sejam usadas se outra pessoa clonar seu projeto e instalar suas dependências. O diretório vendor é onde as dependências do projeto estão localizadas. Você não deve fazer commit da pasta vendor no controle de versão - você precisa apenas incluir os arquivos composer.json e composer.lock.

Ao instalar um projeto que já contém um arquivo composer.json, execute o composer install para baixar as dependências do projeto.

Vamos dar uma olhada rápida em restrições de versão. Se você verificar o conteúdo do seu arquivo composer.json, verá algo parecido com isto:

cat composer.json
Output
{
    "require": {
        "cocur/slugify": "^4.0"
    }
}
Note que há o caractere especial ^ antes do número da versão no composer.json. O Composer suporta várias restrições diferentes e formatos para definir a versão necessária do pacote, para fornecer flexibilidade enquanto também mantém seu projeto estável. O operador circunflexo (^) utilizado pelo arquivo composer.json criado automaticamente é o operador recomendado para a interoperabilidade máxima, seguindo o versionamento semântico. Neste caso, ele define 4.0 como a versão mínima compatível e permite atualizações para qualquer versão futura abaixo de 5.0.

De um modo geral, você não precisará alterar as restrições de versão em seu arquivo composer.json. No entanto, algumas situações podem exigir que você edite manualmente as restrições – por exemplo, quando uma nova versão principal da sua biblioteca requerida é liberada e você deseja atualizar, ou quando a biblioteca que você deseja usar não segue o versionamento semântico.

Aqui estão alguns exemplos para lhe dar um melhor entendimento sobre como as restrições de versão do Composer funcionam:

Restrição	Significado	Exemplo de Versões Permitidas
^1.0	>= 1.0 < 2.0	1.0, 1.2.3, 1.9.9
^1.1.0	>= 1.1.0 < 2.0	1.1.0, 1.5.6, 1.9.9
~1.0	>= 1.0 < 2.0.0	1.0, 1.4.1, 1.9.9
~1.0.0	>= 1.0.0 < 1.1	1.0.0, 1.0.4, 1.0.9
1.2.1	1.2.1	1.2.1
1.*	>= 1.0 < 2.0	1.0.0, 1.4.5, 1.9.9
1.2. *	>= 1.2 < 1.3	1.2.0, 1.2.3, 1.2.9
Para uma visualização mais detalhada das restrições de versão do Composer, consulte a documentação oficial.

A seguir, vamos ver como carregar dependências automaticamente com o Composer.

Passo 4 — Incluindo o Script Autoload
Como o PHP por si só não carrega classes automaticamente, o Composer fornece um script autoload que você pode incluir em seu projeto para obter o carregamento automático para ele. Este arquivo é gerado automaticamente pelo Composer quando você adiciona sua primeira dependência.

A única coisa que você precisa fazer é incluir o arquivo vendor/autoload.php em seus scripts PHP antes de qualquer instância de classe.

Vamos testar isso em nossa aplicação de demonstração. Abra um novo arquivo chamado test.php em seu editor de texto:

nano test.php
Adicione o código a seguir que vem no arquivo vendor/autoload.php, carrega a dependência cocur/slugify, e o utiliza para criar um slug:

test.php
<?php
require __DIR__ . '/vendor/autoload.php';

use Cocur\Slugify\Slugify;

$slugify = new Slugify();

echo $slugify->slugify('Hello World, this is a long sentence and I need to make a slug from it!');
Salve o arquivo e saia do seu editor.

Agora, execute o script.

php test.php
Isso produz a saída hello-world-this-is-a-long-sentence-and-i-need-to-make-a-slug-from-it.

As dependências precisam de atualizações quando novas versões são liberadas. Dessa forma, vamos ver como lidar com isso.

Passo 5 — Atualizando as Dependências do Projeto
Sempre que você quiser atualizar suas dependências do projeto para versões mais recentes, execute o comando update:

composer update
Isso irá verificar por versões mais recentes das bibliotecas que você requer em seu projeto. Se uma versão mais recente for encontrada e ela for compatível com a restrição de versão definida no arquivo composer.json, o Composer substituirá a versão anterior instalada. O arquivo composer.lock será atualizado para refletir essas alterações.

Você também pode atualizar uma ou mais bibliotecas específicas, especificando-as desta forma:

composer update vendor/package vendor2/package2
Certifique-se de verificar em seus arquivos composer.json e composer.lock dentro do seu sistema de controle de versão após atualizar suas dependências de modo que outros também possam instalar essas versões mais recentes.
 -->
exit
pwd
exit
curl
curl -s "https://laravel.build/example-app?with=mysql,redis" |bash
docker
curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -
docker
apt-cache policy docker-ce
docker
curl
curl --help
apt install docker
systemctl status docker
docker
exit
docker
ver
sudo apt-get update
sudo apt-get install ./docker-desktop-<version>-<arch>.deb
sudo apt-get install     ca-certificates     curl     gnupg     lsb-release
sudo mkdir -p /etc/apt/keyrings
curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg
echo   "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu \
  $(lsb_release -cs) stable" | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null
sudo apt-get update
sudo apt-get install docker-ce docker-ce-cli containerd.io docker-compose-plugin
sudo service docker start
sudo docker run hello-world
docker
exit
pwd
ls
cd Desktop
ls
mkdir ProjetosDocker
ls
cd ProjetosDocker/
ls
curl
curl -s "https://laravel.build/example-app?with=mysql,redir" | bash
docker
docker run
systemctl status docker
sudo systemctl status docker
wget -qO- https://get.docker.com/ | sh
curl -L https://github.com/docker/compose/releases/download/1.6.2/docker-compose-`uname -s`-`uname -m` > /usr/local/bin/docker-compose
chmod +x /usr/local/bin/docker-compose
docker-compose version
docker-machine version
docker
curl -s "https://laravel.build/example-app?with=mysql,redir" | bash
docker ls
docker --help
docker start
docker start --help
docker start -i
docker image list
cd ..
cd var
cd /var
cd run
ls
docker
docker run
docker run *
cd /
ls
pwd
cd rn
cd run
ls
docker
docker run
exit
docker
sytemctl status
sudo systemctl
cmd
docker
docker run
curl
curl --help
curl -V
docker -v
code .
cls
clear
docker
clear
docker ps
sudo sevice docker start
sudo service docker start
docker ps
sudo service docker start
docker ps
apt get install docker
apt install docker
docker ps
sudo service docker start
docker ps
sudo service docker start
sudo service docker-start
curl -s "https://laravel.build/example-app?wit..." | bash
docker
docker ps
exit
docker start
docker ps
docker start
docker ps
docker
docker ps
docker --version
docker run hello-world
docker image ls
Enable WSL 2 Windows features
Set-ExecutionPolicy -ExecutionPolicy RemoteSigned
lsb_release -a
dotnet --version
sudo wget https://packages.microsoft.com/config/ubuntu/20.04/packages-microsoft-prod.deb -O packages-microsoft-prod.deb
sudo dpkg -i packages-microsoft-prod.deb
sudo apt-get update
sudo apt-get install apt-transport-https
sudo apt-get update
sudo apt-get install dotnet-sdk-3.1
dotnet --version
code .
docker
sudo apt install gnome-terminal
docker
docker ps
docker start
sudo apt remove docker-desktop
sudo apt-get install ./docker-desktop-<version>-<arch>.deb
sudo apt-get update
sudo apt-get install ./docker-desktop-<version>-<arch>.deb
systemctl --user enable docker-desktop
systemctl --user stop docker-desktop
wsl.exe -l -v
wsl
apt install wsl
code .
curl -s https://laravel.build/example-app | bash
docker
apt get install docker
sudo su
clear
docker ps
y
pwd
ls
cd ProjetosDocker/
pwd
php -v
cls
clear
curl -s "https://laravel.build/example-app?with=mysql,redis,pgsql" |bash
sudo apt-get curl
curl
curl --manual
clear
docker ps
curl -s "https://laravel.build/example-app?with=mysql,redis,pgsql" |bash
docker ps
docker
docker ps
exit
ls
./vendor/bin/sail up
./vendor/bin/sail up -D
./vendor/bin/sail up -d
./vendor/bin/sail ps
./vendor/bin/sail composer require/breeze --dev
./vendor/bin/sail compose require/breeze --dev
./vendor/bin/sail composer require laravel/breeze --dev
sudo su
./vendor/bin/sail composer require laravel/breese --dev
docker ps
docker stop
docker ps
./vendor/bin/sail stop
./vendor/bin/sail composer require laravel/breese --dev
docker start
docker ps
./vendor/bin/sail up
./vendor/bin/sail up -d
docker ps
docker stop
./vendor/bin/sail stop
docker ps
docker ls
docker -ls
docker -l
docker ls
docker --help
docker rmi
docker rm
docker rm --help
docker rm -f
docker ls
list
docker ps
docker start
docker run
docker ps
curl -s "https://laravel.build/example-app?with=mysql,redis" | bash
docker ps
docker ls
ls
cd ProjetosDocker/
cd ..
cd example-app/
code .
docker run -d -p 80:80 docker/getting-started
docker up -d
clear
docker run -d -p 80:80 docker/getting-started
docker up 0094
docker run 7b0aed04f7c251a872242ec415f2d99551385af0c8ceb8409af2ffa9c3fedf6a -d
docker
docker ps
code .
docker
clear
clear ps
docker ps
sudo apt install curl 
exit
pwd
./vendor/bin/sail up -d
cls
clear

./vendor/bin/sail up -d
docker ps
clear
docker ps
./vendor/bin/sail up -d
docker kill
docker stop
doker ps
docker
exit
curl -s "https://laravel.build/laravel-curso?with=mysql,redis,mailhog" |bash
cd laravel-curso/
./vendeor/bin/sail up -d
./vendor/bin/sail up -d
docker ps
code .
./vendor/bin/sail up -d
curl "http://localhost/tutorial/"    -X GET    -H 'host: localhost'    -H 'connection: keep-alive'    -H 'sec-ch-ua: "Chromium";v="106", "Google Chrome";v="106", "Not;A=Brand";v="99"'    -H 'sec-ch-ua-mobile: ?0'    -H 'sec-ch-ua-platform: "Windows"'    -H 'upgrade-insecure-requests: 1'    -H 'user-agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/106.0.0.0 Safari/537.36'    -H 'accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9'    -H 'sec-fetch-site: same-origin'    -H 'sec-fetch-mode: navigate'    -H 'sec-fetch-dest: document'    -H 'referer: http://localhost/'    -H 'accept-encoding: gzip, deflate, br'    -H 'accept-language: pt-BR,pt;q=0.9,en-US;q=0.8,en;q=0.7,es;q=0.6'    -H 'cookie: _ga=GA1.1.171439518.1657383921; _ga_E7H41BFJ0Q=GS1.1.1657462355.2.1.1657462635.0; pma_lang=pt';
clear
./vendor/bin/sail up -d
pwd
ls
cd ProjetosDocker/
ls
cd example-app
ls
cd ..
cd example-app
ls
cd ..
rm -rf example-app
ls
rm-rf laravel-curso/
ls
rm -rf laravel-curso/
clear
ls
cd ProjetosDocker/
ls
curl -s "https://laravel.build/laravel-curso?with=mysql,redis,mailhog" |bash
cd laravel-curso && ./vendor/bin/sail up -d
code .
pwd
ls
cd ProjetosDocker/
ls
rm -rf laravel-curso/
ls
clear
curl -s "https://laravel.build/laravel-curso?with=mysql" |bash
pwd
ls
cd ProjetosDocker/
ls
rm -rf laravel-curso/
ls
cd ..
cd laravel-curso/
ls
exit
php -S localhost:8080
apt install php-cli
php -S localhost:8080
docker run -d -p 80:80 docker/getting-started
curl -s "https://laravel.build/laravel-curso?with=mysql" |bash
docker ps
docker ls
docker -l
docker l
docker ps
docker exec
docker exec -it docker/getting-started bash
docker ps
docker exec -it 6ec4e45db98a bash
docker exec -it 6ec4e45db98a 
docker exec --help
docker exec -it 6ec4e45db98a bash
clear
docker ps
code .
ls
cd laravel-curso/
ls
docker ps
cd ..
ls
pwd
cd socket/
ls
cd ..
cd ProjetosDocker/
ls
cd ..
rm -rf laravel-curso/
ls
cd ..
ls
clear
docker ps
docker exec -it docker/getting-started: bash
docker exec -it docker/getting-started bash
docker exec -it getting-started bash
docker exec -it 6ec4e45db98a bash
docker exec -it 6ec4e45db98a 
ls
cd socket/
ls
cd ..
cd snap
ls
cd ..
cd \
cd /
ls
cd var
ls
cd lib
ls
cd docker
ls
cd containers
ls
cd ..
cd image
ls
cd ..
sudo service docker status
status docker
sudo status docker
sudo service status docker
sudo service docker
sudo service docker status
docker start
cd ..
pwd
ls
cd usr
ls
ls -l
cd ..
docker ps
docker
docker ps
apt-get docker
apt-get install docker 
docker ps
apt-get uninstall docker 
pwd
ls
cd ..
ls
cd usr
ls
cd bin
ls
cd ..
cd lig
cd lib
ls
clear
ls
cd ..
ls
cd usr
ls
ls docker
cld
cd ..
ls
cd ProjetosDocker/
ls
sudo apt update
sudo apt install apt-transport-https ca-certificates curl software-properties-common
curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -
sudo add-apt-repository "deb [arch=amd64] https://download.docker.com/linux/ubuntu focal stable"
sudo apt update
apt-cache policy docker-ce
sudo apt install docker-ce
sudo systemctl status docker
wsl --set-version Ubuntu 2
sudo apt update
sudo apt install apt-transport-https ca-certificates curl software-properties-common
sudo apt install build-essential
curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add
sudo add-apt-repository "deb [arch=amd64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable"
sudo apt update
sudo apt install docker-ce
sudo docker run hello-world
início do docker de serviço sudo
sudo service docker start
sudo docker run hello-world
docker ps
sudo etc
cd etc
ls
cd ..
ls
cd etc
ls
vi init.d
cd ..
ls
sudo apt install docker-ce
sudo service docker status
sudo service docker start
docker ps
ls
cd var/run
ls
vi docker.sock
docker.sock
cd user
ls
cd ..
ls
cd run
ls
cd docker
ls
cd ..
sudo service docker start
docker ps
curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add
sudo add-apt-repository "deb [arch=amd64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable"
sudo docker run hello-world
docker ps
sudo service docker start
sudo service status
sudo service docker start
sudo curl -L "https://github.com/docker/compose/releases/download/1.24.0/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
sudo chmod +x /usr/local/bin/docker-compose
docker-compose --version
ls
cd ProjetosDocker/
code .
curl -s "https://laravel.build/laravel-9-course?with=mysql,redis,mailhog" | bash
docker start
docker ps
sudo apt install docker-ce
docker start
sudo service docker start
curl -s "https://laravel.build/laravel-9-course?with=mysql,redis,mailhog" | bash
docker ps
exit
docker ps
ls
docker ps
clear
docker ps
curl -s "https://laravel.build/laravel-9-course?with=mysql,redis,mailhog" | bash
cd laravel-9-course && ./vendor/bin/sail up -d
docker ps
clear
docker ps
docker ps -l
./vendor/bin/sail up -d
php artisan about
./vendor/bin/sail up -d
docker ps
docker-compose up -d
./vendor/bin/sail up -d
pwd
ls
cd laravel-9-course/
./vendor/bin/sail up -d
docker exec -it b6870e2dd73e bash
clear
ls
cd ..
clear
ls
cd laravel-9-course/
ls
php artisan serve
php artisan
clear
ls
code .
docker ps
docker ps -l
docker exec -it laravel-9-course-laravel.test-1 bash
ls
php artisan serve
vi
vi docker-compose.yml
code .
exit
php artisan serve
exit
php -v
mysql -v
mysql -u root
mysql -u root -p
docker ps
docker ps -l
exit
ls
rm -rf laravel-9-course/
ls
cd example-app/
ls
php -v
mysql -u root -p
apt install mysql-client-core-8.0
mysql -u root -p
jdflkjadsl
curl -s https://laravel.build/example-app | bash
cd example-app && ./vendor/bin/sail up -d
ls
php -S localhost:8000
php artisan serve
ls
cd public/
php -S localhost:8000
php artisan serve
clear
./vendor/bin/sail up -d
php artisan cache:clear
./vendor/bin/sail php artisan cache:clear
./vendor/bin/sail up -d
./vendor/bin/sail php artisan route:clear
./vendor/bin/sail down
./vendor/bin/sail php artisan route:clear
dir
cd public/
php -S localhost:80
cd ..
./vendor/bin/sail up -d
./vendor/bin/sail down
curl -s "https://laravel.build/olw?with=mysql,redis,mailhog,minio" | bash
LS
ls
cd ProjetosDocker/
ls
cd olw
ls
cd ..
cd olw
ls
sail artisan serve
sail php artisan serve
cls
clear
ls
code .
docker ps
clear
docker ps
alias sail='[ -f sail ] && sh sail || sh vendor/bin/sail'
sail up -d
code .
sail down
ls
cd ..
ls
version
ls
cd ..
ls
cd var
ls
cls
ls
cd www
cd /
ls
cd var
ls
cd www
cd ..
ls
cd home
ls
cd alber
ls
cd ..
laravel -v
laravel -V
composer -V
./vendor/bin/sail up -d
./vendor/bin/sail down
./vendor/bin/sail up -d
sail ps
sail down
clear
./vendor/bin/sail ps
./vendor/bin/sail down
./vendor/bin/sail up -d
php artisan --version
./vendor/bin/sail down
./vendor/bin/sail ps
docker up -d
docker run -d
docker ps
./vendor/bin/sail ps
./vendor/bin/sail up -d
docke ps
docker ps
docker exec -it ffc7fa4e28ed bash
docker ps
sail up -d
cd ..
./vendor/bin/sail up -d
docker ps
./vendor/bin/sail up -d
ls
cd home
ls
cd alber/
ls
cd ..
ls
cd ..
ls
cd home
ls
cd var
ls
cd ..
cd var
ls
cd ..
ls
docker ps
exit
wsl --set-version <Distro> 2, – wsl --set-default-version 2
wsl --importe visando WSL 2wsl --export
cls
clear
wsl
wsl2
wsl.exe -l -v
wsl.exe --set-default-version 2
docker ps
./vendor/bin/sail up -d
docker run
docker run olw-laravel.test-1
start-container
docker start-container
docker up start-container
docker run start-container
docker down
clear
docker ps
ls
cd olw
./vendor/bin/sail down
./vendor/bin/sail up -d
./vendor/bin/sail down
ls
cd ..
ls
rm -rf olw
ls
rm -rf ProjetosDocker/
rm -rf example-app/
ls
exit
curl.exe -L -o ubuntu-2004.appx https://aka.ms/wslubuntu2004
wsl --set-default-version 2
Error: 0x1bc
For information on key differences with WSL 2 please visit https://aka.ms/wsl2
[    0.363323] 9p: Installing v9fs 9p2000 file system support
[    0.363336] FS-Cache: Netfs '9p' registered for caching
[    0.398989] 9pnet: Installing 9P2000 support
wsl --update
apt-get upgrade
Get-WindowsOptionalFeature -Online -FeatureName Microsoft-Windows-Subsystem-Linux
sudo service ssh status
debug1: sshd version OpenSSH_7.2, OpenSSL 1.0.2g  1 Mar 2016
debug1: key_load_private: incorrect passphrase supplied to decrypt private key
debug1: key_load_public: No such file or directory
Could not load host key: /etc/ssh/ssh_host_rsa_key
debug1: key_load_private: No such file or directory
debug1: key_load_public: No such file or directory
Could not load host key: /etc/ssh/ssh_host_dsa_key
debug1: key_load_private: No such file or directory
debug1: key_load_public: No such file or directory
Could not load host key: /etc/ssh/ssh_host_ecdsa_key
debug1: key_load_private: No such file or directory
debug1: key_load_public: No such file or directory
Could not load host key: /etc/ssh/ssh_host_ed25519_key
sudo apt-get purge openssh-server
sudo apt-get install openssh-server
wsl --install
wsl --update
wsl --shutdown
exit
sudo apt update
sudo apt install gedit -y
sudo apt-get install     ca-certificates     curl     gnupg     lsb-release
sudo mkdir -p /etc/apt/keyrings
curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg
echo   "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu \
  $(lsb_release -cs) stable" | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null
sudo apt-get update
sudo apt-get install docker-ce docker-ce-cli containerd.io docker-compose-plugin
sudo service docker start
sudo docker run hello-world
sudo su docker run hello-world
docker ps
ps aux | grep docker
sudo service docker status
systemctl start docker
gpasswd -a $USER docker
systemctl start docker
sudo service docker start
docke ps
docker ps
sudo service docker start
sudo service --status-all
sudo service docker start
systemctl enable docker
systemctl restart docker
systemctl enable docker
sudo service docker start
/var/run/docker.sock
sudo nohup docker daemon -H tcp://0.0.0.0:2375 -H unix:///var/run/docker.sock
sudo usermod -aG docker $USER
reboot
docker ps
sudo /var/run/docker.sock
cd  /var/run/docker.sock
cd  /var/run/
ls
cd WSL
ls
cd ..
ls
cd ..
ls
curl -s "https://laravel.build/olw?with=mysql,redis,mailhog,minio" | bash
docker ps
docker start
service docker start
sudo service docker status
sudo service docker start
sudo service docker status
sudo service docker start
sudo service docker status
& $Env:ProgramFiles\Docker\Docker\DockerCli.exe -SwitchDaemon .
docker pull mcr.microsoft.com/windows/nanoserver:ltsc2022
dockerd --debug
docker -H tcp://0.0.0.0:2375 ps
sudo dockerd -H unix:///var/run/docker.sock -H tcp://192.168.59.106 -H tcp://10.10.10.2sudo dockerd -H unix:///var/run/docker.sock -H tcp://192.168.59.106 -H tcp://10.10.10.2
docker --tlsverify ps
docker ps
docker -H :5555 pull ubuntu
docker -H tcp://127.0.0.1:2375 pull ubuntu
docker 
docker ps
docker version
docker ps
systemclt start docker 
systemctl start docker 
docker 
docker -H
docker -H --host list
docker -H --host
docker -H --help
docker ps
curl -s "https://laravel.build/olw?with=mysql,redis,mailhog,minio" | bash
cd olw && ./vendor/bin/sail up
cd olw && ./vendor/bin/sail up -d
cd ..
cd olw
./vendor/bin/sail up -d
./vendor/bin/sail down
./vendor/bin/sail tinker
cls
clear
sail php --version
sail share
sudo chmod 777 storage/ -R
sudo chmod 0777 storage/ -R
./vendor/bin/sail up -d
./vendor/bin/sail down
ls
cd olw
./vendor/bin/sail up -d
sudo chmod 777 storage/ -R
./vendor/bin/sail up -d
code .
./vendor/bin/sail down
curl -s "https://laravel.build/example-app | bash
cd ..
curl -s "https://laravel.build/example-app | bash
ls
curl -s https://laravel.build/example-app | bash
cd example-app/
./vendor/bin/sail up -d
sudo chmod 777 storage/ -R
./vendor/bin/sail up -d
sail share
./vendor/bin/sail share
mysql 
myqsl -u root -p
alias sail='[ -f sail ] && sh sail || sh vendor/bin/sail'
ls
sail ps
./vendor/bin/sail ps
docker ps
cd example-app/
sail ps
sail down
composer global require beyondcode/expose
expose default-server sa-1
expose token 89e90595-06a7-4245-99c9-03536b633447
composer global require beyondcode/expose
ls
php artisan serve
cd public/
php -S localhost:8080
clear
cd..
cd ..
cd example-app/
clear
sail up -d
code .
ls
code .
sail down
cd ..
docker ps
clear
./vendor/bin/sail up -d
cd example-app/
./vendor/bin/sail up -d
code .
./vendor/bin/sail down
php artisan route:list
sail artisan route:list
sail
cls
clear
./vendor/bin/sail list
./vendor/bin/sail down
./vendor/bin/sail up -d
./vendor/bin/sail down
./vendor/bin/sail up -d
/ls
mysql -u root -p
mysql -u sail -p
mysql
docker ps
ls
cd example-app/
./vendor/bin/sail up -d
code .
cd ..
mysql
mysql --version
mysql -u sail -p
cd ..
ls
cd example-app/
clear
mysql -u root -p
cd..
ls
cd ..
sail down
./vendor/bin/sail down
docker ps
cd example-app/
sail down
./vendor/bin/sail down
ls
cd ..
ls
sail up -d
./vendor/bin/sail up -d
cd example-app/
./vendor/bin/sail up -d
docker ps
./vendor/bin/sail up -d
mysql -u root -p
mysql -u sail -p
exit
mysql -u sail -p
./vendor/bin/sail up -d
mysql -u sail -p
clear
./vendor/bin/sail down
mysql -u sail -p
exit
docker ps
docker ps -l
docker ps -a
clear
ls
cd ex
cd example-app/
ls
./vendor/bin/sail up -d
code .
mysql --version
mysql -u sail -p
mysql -u root -p
mysql -u sail -p
mysql --version
myql -u root -p
mysql -u root -p
ls
sudo
sudo chmod 777 storage/ -R
ls
cd ..
ls
cd ..
ls
sudo chmod 777 var/ -R
mysql -u root -p
ls
docker ps
cd example-app/
sail down
./vendor/bin/sail down
./vendor/bin/sail up -d
code .
ls
cd ..
ls
cd ..
ls
cd ..
ls
cd home
ls
cd ..
cd root
ls
cd example-app/
ls
cd ..
docker ps
docker exec -it example-app-mysql-1 bash
ls
cd example-app/
ping localhost:3306
ping 0.0.0.0:3306
clear
./vendor/bin/sail down
sail ps
./vendor/bin/sail ps
ls
cd ..
pwd
ls
cd olw
ls
cd ..
cd example-app/
sail ps
./vendor/bin/sail up -d
sail artisan migrate --seed
p
./vendor/bin/sail  artisan migrate --seed
./vendor/bin/sail artisan make:controller UserController
php artisan make:controller UserController
./vendor/bin/sail artisan make:controller UserController
php artisan make:controller UserController
clear
docker ps
./vendor/bin/sail  up -d
php -v
docker ps
docker run hello-world
exit
./vendor/bin/sail artisan serve
docker ps
clear
./vendor/bin/sail  up -d
mysql --v
mysql -v
mysql -u root -p
cd ..
mysql -u root -p
clear
mysql --version;
composer
clear
docker ps -l
docker ps
docker run hello-world
clear
docker ps -l
ls
cd example-app/
./vendor/bin/sail up -d
code .
./vendor/bin/sail down
./vendor/bin/sail up -d
./vendor/bin/sail down
./vendor/bin/sail up -d
./vendor/bin/sail down
./vendor/bin/sail up -d
./vendor/bin/sail down
./vendor/bin/sail up -d
code .
./vendor/bin/sail down
./vendor/bin/sail up -d
ping
ping 127.0.0.1:3307
ping 127.0.0.1:3306
ping 127.0.0.1
ping 127.0.0.1:80
ping 127.0.0.1:6379
ping 127.0.0.1:3306
ping 127.0.0.1:3307
./vendor/bin/sail down
./vendor/bin/sail up -d
code .
./vendor/bin/sail down
./vendor/bin/sail up -d
code .
./vendor/bin/sail down
./vendor/bin/sail up -d
code .
./vendor/bin/sail up -d
./vendor/bin/sail down
./vendor/bin/sail up -d
code .
./vendor/bin/sail up -d
./vendor/bin/sail down
./vendor/bin/sail up -d
code .
./vendor/bin/sail up -d
./vendor/bin/sail down
./vendor/bin/sail up -d
./vendor/bin/sail down
./vendor/bin/sail up -d
./vendor/bin/sail down
./vendor/bin/sail up -d
./vendor/bin/sail down
./vendor/bin/sail up -d
./vendor/bin/sail down
./vendor/bin/sail up -d
./vendor/bin/sail down
./vendor/bin/sail up -d
./vendor/bin/sail down
./vendor/bin/sail up -d
./vendor/bin/sail down
./vendor/bin/sail up -d
./vendor/bin/sail down
./vendor/bin/sail up -d
code .
./vendor/bin/sail up -d
./vendor/bin/sail down
./vendor/bin/sail up -d
./vendor/bin/sail down
./vendor/bin/sail up -d
clear
docker ps
docker exec -it example-app-mysql-1
docker exec -it example-app-mysql-1 bash
./vendor/bin/sail up -d
./vendor/bin/sail down
./vendor/bin/sail up -d
ls
cd example-app/
docker ps
ls
php artisan serve
clear
ls
cd vendor
cd bin
ls
vi sail
clear
code .
ls
cd sail
cd ..
cd vendor
cd bin
sail up -d
cd ..
./vendor/bin/sail up -d
ls
code .
./vendor/bin/sail ps
clear

./vendor/bin/sail down
docker ps -l
docker  -l
ls
cd olw
./vendor/bin/sail up -d
code .
docker ps
./vendor/bin/sail up -d
clear
./vendor/bin/sail up -d
./vendor/bin/sail composer require laravel/breeze --dev
./vendor/bin/sail up -d
./vendor/bin/sail composer require laravel/breeze --dev
cd ..
sudo chmod 777 olw/ -R
./vendor/bin/sail composer require laravel/breeze --dev
cd olw
./vendor/bin/sail composer require laravel/breeze --dev
./vendor/bin/sail art breeze:install vue
./vendor/bin/sail art migrate
CLEAR
clear
alias sail='bash vendor/bin/sail'
sail ps
git init
git add .
git commit -m "comit inicial"
git add .
git remote add origin https://github.com/albertogomesdasilva/laravel- sail-olw.git
git remote add origin -m https://github.com/albertogomesdasilva/laravel- sail-olw.git
git push
git push --set-upstream origin master
git remote add origin https://github.com/albertogomesdasilva/laravel-sail-olw.git
git push -u origin main
git remote add origin https://github.com/albertogomesdasilva/laravel-sail-olw.git
git push -u origin main
git login
git user.name albertogomesdasilva
echo "# laravel-sail-olw" >> README.md 
git init 
git add README.md 
git commit -m "first commit" 
git branch -M main 
git remote add origin https://github.com/albertogomesdasilva/laravel- sail-olw.git
echo "# laravel-sail-olw" >> README.md 
git init 
git add README.md 
git commit -m "first commit" 
git branch -M main 
git remote add origin https://github.com/albertogomesdasilva/laravel- sail-olw.git
echo "# laravel-sail-olw" >> README.md 
git init
git add README.md
git commit -m "first commit"
git config  user.name "Albertogomesdasilva"
git config  user.email "albertogomesdasilva@hotmail.com"
git branch -M main
git remote add origin https://github.com/albertogomesdasilva/laravel-sail-olw.git
git push -u origin main
ping www.google.com
clear
git remote add origin https://github.com/albertogomesdasilva/laravel-sail-olw.git
git push -u origin main
git remote add origin https://github.com/albertogomesdasilva/laravel-sail-olw
echo "# laravel-sail-olw" >> README.md
git init
git add README.md
git commit -m "first commit"
git branch -M main
git remote add origin https://github.com/albertogomesdasilva/laravel-sail-olw.git2
git push -u origin main
git remote add origin https://github.com/albertogomesdasilva/laravel-sail-olw.git
git remote add origin https://github.com/albertogomesdasilva/laravel-sail-olw.git2
git remote add origin https://github.com/albertogomesdasilva/laravel-sail-olw.git
clear
git remote add origin https://github.com/albertogomesdasilva/laravel-sail-olw
git config --global user.email  "albertogomesdasilva@hotmail.com"
git status
touch .gitignore
git add .
git commit -a -m "commit inicial"
git remote add origin https://github.com/albertogomesdasilva/laravel- sail-olw.git
git branch -M main 
git remote add origin https://github.com/albertogomesdasilva/laravel- sail-olw.git
clear
git status
git push --set-upstream origin master
git branch
git status
git init
git status
git add.
git add .
git status
git commit -a -m "commit inicial"
git status
git remote add origin https://github.com/albertogomesdasilva/laravel-sail-olw.git
git push
cd ..
git remote add origin https://github.com/albertogomesdasilva/laravel-sail-olw.git
cd owl
ls
cd olw
git remote add origin https://github.com/albertogomesdasilva/laravel-sail-olw
git push -u origin main
git init
clear
git reset
git status
git logout
git --help
git exit
clear
git add ANOTAÇÕES.md
git log
git commit "anotações"
clear
sail ps
clear
alias sail='bash vendor/bin/sail'
alias s='bash vendor/bin/sail'
s ps
clear
sail ps
s ps
clear
s down
s up -d
clear
s art make:controller BeerController
alias sail='bash vendor/bin/sail'
sail art migrate
sail npm run dev
npm run dev
sail npm run dev
npm run dev
sail npm run dev
sail art migrate
./vendor/bin/sail art migrate
./vendor/bin/sail artisan migrate
npm i
composer install
php --ini
php ini
php -i
ls
composer update
composer install
docker ps
ls
cd olw
s up -d
./vendor/bin/sail up -d
ls
cd public
ls
cd build
ls
cd assets/
ls
cd ..
ls
cd resources/
ls
cd views
ls
cd..
cd ..
code .
./vendor/bin/sail up -d
./vendor/bin/sail down
./vendor/bin/sail up -d
sail art migrate
./vendor/bin/sail up -d
./vendor/bin/sail donw
./vendor/bin/sail down
./vendor/bin/sail up -d
./vendor/bin/sail down
composer install
--ignore-platform-req=ext-simplexml --ignore-platform-req=ext-dom --ignore-platform-req=ext-xml --ignore-platform-req=ext-curl
composer install --ignore-platform-req=ext-simplexml --ignore-platform-req=ext-dom --ignore-platform-req=ext-xml --ignore-platform-req=ext-curl
sudo su composer update
sudo composer update
sudo su
sudo composer update
composer i
apt install composer
composer update
composer update --with-all-dependencies
php composer.phar install --no-plugins --no-scripts
cd olw
php composer.phar install --no-plugins --no-scripts
ls
cd olw
ls
apt update
composer update
./vendor/bin/sail up -d
./vendor/bin/sail down
./vendor/bin/sail up -d
composer update
composer update --with-all
ls
sudo su albert
sudo su alber
cd ow
cd olw
./vendor/bin/sail up -d
code .
./vendor/bin/sail up -d
php composer.phar update --no-plugins --no-scripts
ls
composer install
code .
php composer.phar install --no-plugins --no-scripts
cls
clear
./vendor/bin/sail up -d
./vendor/bin/sail down
php composer.phar install --no-plugins --no-scripts
composer update
cd ..
ls
cd ..
ls
chmod 777 usr/ -R
php --ini
php -ini
composer install
cd olw
pwd
ls
cd home
ls
cd ..
ls
cd root
ls
cd olw
composer install
npm i
cd public/
ls
cd buido
cd buid
cd build
ls
cd asstes
cd assets
ls
ls
chmod 777 olw/ -R
cd olw
sail up -d
./vendor/bin/sail up -d
./vendor/bin/sail composer dumpautoload
./vendor/bin/sail composer autoload
./vendor/bin/sail composer dump-autoload
composer install
composer --ignore-platform-req=ext-simplexml --ignore-platform-req=ext-dom --ignore-platform-req=ext-dom --ignore-platform-req=ext-xml --ignore-platform-req=ext-dom --ignore-platform-req=ext-dom --ignore-platform-req=ext-dom --ignore-platform-req=ext-curl --ignore-platform-req=ext-dom --ignore-platform-req=ext-simplexml
composer dumautoload --ignore-platform-req=ext-simplexml --ignore-platform-req=ext-dom --ignore-platform-req=ext-dom --ignore-platform-req=ext-xml --ignore-platform-req=ext-dom --ignore-platform-req=ext-dom --ignore-platform-req=ext-dom --ignore-platform-req=ext-curl --ignore-platform-req=ext-dom --ignore-platform-req=ext-simplexml
composer dumpautoload --ignore-platform-req=ext-simplexml --ignore-platform-req=ext-dom --ignore-platform-req=ext-dom --ignore-platform-req=ext-xml --ignore-platform-req=ext-dom --ignore-platform-req=ext-dom --ignore-platform-req=ext-dom --ignore-platform-req=ext-curl --ignore-platform-req=ext-dom --ignore-platform-req=ext-simplexml
./vendor/bin/sail up -d
code .
./vendor/bin/sail up -d
cd ..
ls
./vendor/bin/down
./vendor/bin/sail down
cd root
cd olw
./vendor/bin/sail down
cd olw
./vendor/bin/sail up -d
cd ..
rm -rf olw
ls
exit
docker ps
docker ps -la
docker ps -l
exit
nmp run dev
ls
cd example-app/
ls
sail 
./vendor/bin/sail up -d
code .
./vendor/bin/sail stop
cd ..
docker
docker ps
clear
cd ..
sudo chmod 777 olw/ -R
composer require laravel/breeze --dev
php -ini
php --ini
clear
./vendor/bin/sail composer require laravel/breeze --dev
cd olw
./vendor/bin/sail composer require laravel/breeze --dev
./vendor/bin/sail artisan breeze:install vue
./vendor/bin/sail art migrate
alias sail='[ -f sail ] && sh sail || sh vendor/bin/sail'
sail art make:controller BeerController
sail ps
sail artisan make:controller BeerController
sail artisan make:request BeerRequest
sail composer require psr/simple-cache:^2.0 maatwebsite/excel
./vendor/bin/sail composer require psr/simple-cache:^2.0 maatwebsite/excel
./vendor/bin/sail composer dump-autoload
./vendor/bin/sail artisan make:export BeerExport
./vendor/bin/sail art config:cache
./vendor/bin/sail art optimize:clear
./vendor/bin/sail composer require psr/simple-cache:^2.0 maatwebsite/excel
./vendor/bin/sail composer require -W league/flysystem-aws-s3-v3 "^3.0"
curl -s "https://laravel.build/olw?with=mysql,redis,mailhog,minio" | bash
ls
rm -rf example-app/
ls
rm -rf olw
clear
curl -s "https://laravel.build/olw?with=mysql,redis,mailhog,minio" | bash
docker scan
cd olw && ./vendor/bin/sail up -d
code .
cd olw && ./vendor/bin/sail up -d
./vendor/bin/sail up -d
code .
./vendor/bin/sail down
./vendor/bin/sail up -d
sail down
./vendor/bin/sail down
./vendor/bin/sail up -d
code .
./vendor/bin/sail up -d
code .
./vendor/bin/sail up -d
sail down
./vendor/bin/sail down
ls
cd olw
./vendor/bin/sail up -d
docker ps
ls
cd olx
ls
cd olw
./vendor/bin/sail up -d
docker ps
clear
code .
ls
cd ..
ls
docker ps
docker exec -it 51288723f17a bash
ls
./vendor/bin/sail up -d
cd olw
./vendor/bin/sail up -d
./vendor/bin/sail down
./vendor/bin/sail up -d
./vendor/bin/sail art migrate
php artisan migrate
clear
composer update
npm i
npm
composer install
php --ini
alias sail='[ -f sail ] && sh sail || sh vendor/bin/sail'
sail ps
s ps
sh ps
clear
sail art make:migration create_history_table
sail art make:model Export -mr
sail art make: Export -mr
sail art make:model Export -mr
sail art make:model Meal -mr
sail art make:factory MealFactory
sail art make:seed MealSeeder
sail composer require jzonta/faker-restaurant
sail composer dump-autoload
./vendor/bin/sail composer dump-autoload
clear
alias sail='[ -f sail ]
alias sail='[ -f sail ] && sh sail || sh vendor/bin/sail'
sail art migrate:fresh --seed
clear
sail art migrate:fresh --seed
sail art make:mail ExportEmail
sail up -d
sail down
sail up -d
docker ps
ols
olw
ls
cd olw
ls
sail ps
clear
./vendor/bin/sail up -d
code .
./vendor/bin/sail up -d
./vendor/bin/sail art server
./vendor/bin/sail art serve
sail art migrate:fresh --seed
alias sail='[ -f sail ] && sh sail || sh vendor/bin/sail'
sail composer dump-autoload
sail up -d
sail composer require jzonta/faker-restaurant
sail ps
sail composer install
composer install
php --ini
composer install
php -S localhost:8000
cd ..
chmod 777 olw/ -R
sail ps
./vendor/bin/sail up -d
cd olw
./vendor/bin/sail up -d
docker ps
./vendor/bin/sail up -d -->
"# notas" 

### FAKER
Falso#
Downloads do empacotador Status do fluxo de trabalho do GitHub

Faker é uma biblioteca PHP que gera dados falsos para você. Se você precisa inicializar seu banco de dados, criar documentos XML de boa aparência, preencher sua persistência para testá-lo ou anonimizar dados obtidos de um serviço de produção, o Faker é para você.

É fortemente inspirado por Perl's Data::Faker , e por Ruby's Faker .

Instalação#
Faker requer PHP >= 7.1.


composer require fakerphp/faker
Uso básico#
Carregamento automático#
Faker suporta tanto PSR-0como PSR-4autoloaders.


// when installed via composer
require_once 'vendor/autoload.php';
Você também pode carregar o autoloader FakersenviadoPSR-0


// load Faker autoloader
require_once '/path/to/Faker/src/autoload.php';
alternativamente, você pode usar qualquer outro autoloader compatível com PSR-4

Crie dados falsos#
Use Faker\Factory::create()para criar e inicializar um gerador faker, que pode gerar dados chamando métodos com o nome do tipo de dados desejado.


require_once 'vendor/autoload.php';

// use the factory to create a Faker\Generator instance
$faker = Faker\Factory::create();
// generate data by calling methods
echo $faker->name();
// 'Vince Sporer'
echo $faker->email();
// 'walter.sophia@hotmail.com'
echo $faker->text();
// 'Numquam ut mollitia at consequuntur inventore dolorem.'
Cada chamada para $faker->name()produz um resultado diferente (aleatório). Isso ocorre porque o Faker usa __call()magia e encaminha Faker\Generator->$method()chamadas para Faker\Generator->format($method, $attributes).


for ($i = 0; $i < 3; $i++) {
    echo $faker->name() . "\n";
}

// 'Cyrus Boyle'
// 'Alena Cummerata'
// 'Orlo Bergstrom'
Modificadores#
Faker fornece três provedores especiais, unique(), optional(), e valid(), para serem chamados antes de qualquer provedor.


// unique() forces providers to return unique values
$values = [];
for ($i = 0; $i < 10; $i++) {
    // get a random digit, but always a new one, to avoid duplicates
    $values []= $faker->unique()->randomDigit();
}
print_r($values); // [4, 1, 8, 5, 0, 2, 6, 9, 7, 3]

// providers with a limited range will throw an exception when no new unique value can be generated
$values = [];
try {
    for ($i = 0; $i < 10; $i++) {
        $values []= $faker->unique()->randomDigitNotNull();
    }
} catch (\OverflowException $e) {
    echo "There are only 9 unique digits not null, Faker can't generate 10 of them!";
}

// you can reset the unique modifier for all providers by passing true as first argument
$faker->unique($reset = true)->randomDigitNotNull(); // will not throw OverflowException since unique() was reset
// tip: unique() keeps one array of values per provider

// optional() sometimes bypasses the provider to return a default value instead (which defaults to NULL)
$values = [];
for ($i = 0; $i < 10; $i++) {
    // get a random digit, but also null sometimes
    $values []= $faker->optional()->randomDigit();
}
print_r($values); // [1, 4, null, 9, 5, null, null, 4, 6, null]

// optional() accepts a weight argument to specify the probability of receiving the default value.
// 0 will always return the default value; 1.0 will always return the provider. Default weight is 0.5 (50% chance).
// Please note that the weight can be provided as float (0 / 1.0) or int (0 / 100)

// As float
$faker->optional($weight = 0.1)->randomDigit(); // 90% chance of NULL
$faker->optional($weight = 0.9)->randomDigit(); // 10% chance of NULL

// As int
$faker->optional($weight = 10)->randomDigit; // 90% chance of NULL
$faker->optional($weight = 100)->randomDigit; // 0% chance of NULL

// optional() accepts a default argument to specify the default value to return.
// Defaults to NULL.
$faker->optional($weight = 0.5, $default = false)->randomDigit(); // 50% chance of FALSE
$faker->optional($weight = 0.9, $default = 'abc')->word(); // 10% chance of 'abc'

// valid() only accepts valid values according to the passed validator functions
$values = [];
$evenValidator = function($digit) {
    return $digit % 2 === 0;
};
for ($i = 0; $i < 10; $i++) {
    $values []= $faker->valid($evenValidator)->randomDigit();
}
print_r($values); // [0, 4, 8, 4, 2, 6, 0, 8, 8, 6]

// just like unique(), valid() throws an overflow exception when it can't generate a valid value
$values = [];
try {
    $faker->valid($evenValidator)->randomElement([1, 3, 5, 7, 9]);
} catch (\OverflowException $e) {
    echo "Can't pick an even number in that set!";
}
Se você quiser usar um modificador com um valor não gerado pelo Faker, use o passthrough()método. passthrough() simplesmente retorna qualquer valor que foi dado.


$faker->optional()->passthrough(mt_rand(5, 15));
Localização#
Faker\Factorypode receber uma localidade como argumento, para retornar dados localizados. Se nenhum provedor localizado for encontrado, a fábrica retornará à localidade padrão (en_US).


// create a French faker
$faker = Faker\Factory::create('fr_FR');
for ($i = 0; $i < 3; $i++) {
    echo $faker->name() . "\n";
}

// Luce du Coulon
// Auguste Dupont
// Roger Le Voisin
Você pode verificar as localidades do Faker disponíveis no código-fonte, no Providerdiretório . A localização do Faker é um processo contínuo, para o qual precisamos da sua ajuda. Não hesite em criar provedores localizados para sua própria localidade e enviar um PR!

Semeando o Gerador#
Você pode querer sempre obter os mesmos dados gerados - por exemplo, ao usar o Faker para fins de teste de unidade. O gerador oferece um seed()método que propaga o gerador de números aleatórios. Chamar o mesmo script duas vezes com a mesma semente produz os mesmos resultados.


$faker = Faker\Factory::create();
$faker->seed(1234);

echo $faker->name(); // 'Jess Mraz I';
Dica
Os formatadores DateTime não reproduzirão os mesmos dados falsos se você não corrigir o $maxvalor:


// even when seeded, this line will return different results because $max varies
$faker->dateTime(); // equivalent to $faker->dateTime($max = 'now')
// make sure you fix the $max parameter
$faker->dateTime('2014-02-25 08:37:17'); // will return always the same date when seeded
Dica
Os formatadores não reproduzirão os mesmos dados falsos se você usar a rand()função php. Use $fakerou mt_rand()em vez disso:


// bad
$faker->realText(rand(10, 20));
// good
$faker->realText($faker->numberBetween(10, 20));
Faker Internals: Entendendo os Provedores#
Um Faker\Generatorsozinho não pode fazer muita geração. Ele precisa Faker\Providerde objetos para delegar a geração de dados a eles. Faker\Factory::create()realmente cria um Faker\Generatorpacote com os provedores padrão. Aqui está o que acontece sob o capô:


$faker = new Faker\Generator();
$faker->addProvider(new Faker\Provider\en_US\Person($faker));
$faker->addProvider(new Faker\Provider\en_US\Address($faker));
$faker->addProvider(new Faker\Provider\en_US\PhoneNumber($faker));
$faker->addProvider(new Faker\Provider\en_US\Company($faker));
$faker->addProvider(new Faker\Provider\Lorem($faker));
$faker->addProvider(new Faker\Provider\Internet($faker));
Sempre que você tenta acessar uma propriedade do $fakerobjeto, o gerador procura um método com o mesmo nome em todos os provedores anexados a ele. Por exemplo, chamar $faker->nameaciona uma chamada para Faker\Provider\Person::name(). E como o Faker começa com o último provedor, você pode facilmente substituir os formatadores existentes: basta adicionar um provedor contendo métodos nomeados de acordo com os formatadores que você deseja substituir.

Isso significa que você pode adicionar facilmente seus próprios provedores a uma Faker\Generatorinstância. Um provedor geralmente é uma classe que estende o \Faker\Provider\Base. Essa classe pai permite que você use métodos como lexify()ou randomNumber(); também lhe dá acesso a formatadores de outros provedores, através da $generatorpropriedade protegida. Os novos formatadores são os métodos públicos da classe do provedor.

Aqui está um exemplo de provedor para preencher dados de livros:


namespace Faker\Provider;

class Book extends \Faker\Provider\Base
{
  public function title($nbWords = 5)
  {
    $sentence = $this->generator->sentence($nbWords);
    return substr($sentence, 0, strlen($sentence) - 1);
  }

  public function ISBN()
  {
    return $this->generator->ean13();
  }
}
Para registrar este provedor, basta adicionar uma nova instância de \Faker\Provider\Booka um gerador existente:


$faker->addProvider(new \Faker\Provider\Book($faker));
Agora você pode usar os dois novos formatadores como qualquer outro formatador Faker:


$book = new Book();
$book->setTitle($faker->title());
$book->setISBN($faker->ISBN());
$book->setSummary($faker->text());
$book->setPrice($faker->randomNumber(2));
Dica
Um provedor também pode ser um Plain Old PHP Object. Nesse caso, todos os métodos públicos do provedor ficam disponíveis para o gerador.

Formatadores específicos de idioma#
As localidades suportadas podem ser encontradas no cabeçalho "Locales" à esquerda.

Localidades com nomes errados#
Nome atual	Nome correto
at_AT	de_AT
zh_CN	zh_Hans_CN
zh_TW	zh_Hant_TW
Fonte: https://www.localeplanet.com/icu/

Licença#
Faker é lançado sob a licença MIT. Consulte o arquivo LICENSE incluído para obter detalhes.

### COMANDOS DO DOCKER ##########################################################################



### docker --help

### docker run --help

### docker build . => gera a imagem

### docker run -d -p 8000:8000 --name myApp <id_da_imagem>

### >docker exec -it 744487d64b38 bash  => Acessa o container que está em execução

### docker build -t <NOME_PARA_A_ IMAGEM> .   => NOME PARA A IMAGEM NA HORA DO BUIL (NA HORA DA CRIAÇÃO)

### docker images => lista as imagens

### docker ps -a  => Lista as imagens dispoiveis

### docker run --rm <container>  => Remove ao parar o container

### docker login        CASO ESTEJA LOGADO NO DOCKER DESKTOP DISPENSA CREDENCIAIS
                    username: ***********@hotmail.com
                    password: *******

### CRIA O REPOSITÓRIO E CRIA O BUILd COM O MESMO NOME DO REPOSITÓRIO docker build -t matheusbattisti/nodeteste .

### docker build -t albertogomesdasilva/nodeteste . e depois: docker push albertogomesdasilva/nodeteste  => envia para o docker hub

### docker pull albertogomesdasilva/nodeteste => baixa a imagem do docker hub

### docker push matheusbattisti/nodeteste

### >docker build -t albertogomesdasilva/nodeteste:novaversao .   => buildaando uma nova versão

### docker push  albertogomesdasilva/nodeteste:novaversao  => faz o upload da nova versão sem ter que criar um novo repositório no docker hub on line.

docker cp [OPTIONS] CONTAINER:SRC_PATH DEST_PATH|-
docker cp [OPTIONS] SRC_PATH|- CONTAINER:DEST_PATH
### >docker cp app:/app/app.js ./bkp/   => Copia arquivo app.js de dentro do container configurado no Dokerfile como WORKDIR /app, para a pasta bkp da raiz do projeto.

### \projetos>docker cp ./bkp/teste.txt app:/app/    => copia o arquivo teste.txt da pasta bkp dentro de projeto  para a pasta do app na imagem rodando.

### >docker exec -it app bash Acessa o prompt da imagem rodando
### ls lista o arquivo dentro da imagem: Dockerfile  app.js  node_modules  package-lock.json  package.json  teste.txt 

### docker stop <id_ou_nome_do_container>

### docker rmi <nome>:<tag> => Remove a imagem também

### docker system prune => Remove Imagens, containers e redes que não usamos


### docker pull <nome_da_imagem> => Baixa a imagem do docker hub

### docker start -i <nome_do_container> => roda no modo iterativo uma imagem que ja´está no pc

### docker rmi <nome_da_imagem_ou_id>  => Remove imagem

### docker -it <nome_da_imagem> => Roda a imagem e libera o prompt de interação com a imagem. (MODO DETACHED)

### docker tag <nome> <id_da_imagem>

### docker tag <id_da_iamgem> <nome_da_imagem>:<tag_para_a_imagem> => atribui uma tag para a imagem (TAG É UMA VERSÃO PARA A IMAGEM)

### docker pull <nome_da_imagem>:<tag>  => BAIXA A IMAGEM DAQUELA VERSÃO


### docker ps
CONTAINER ID   IMAGE          COMMAND                  CREATED              STATUS              PORTS                              NAMES
7bb33d0e43a6   26ee7a516e9e   "docker-entrypoint.s…"   About a minute ago   Up About a minute   3000/tcp, 0.0.0.0:8000->8000/tcp   myApp

###  docker system prune => Remove todos 

###  docker system prune -a => Remove tudo sem exceção

* >docker run -d -p 3000:3000 528392dd249e meu_app   -> RODA A NOVA IMAGEM CRIADA PASSANDO AS CONFIGURAÇÕES DE PORTA E NOME

* docker run -d -p 80:80 --name nginx_app nginx -> Baixa e roda em segundo plano na porta 80 a imagem nginx e usa o nome nginx_app
* docker start <nome_ou_id_da_imagem>   -> Roda uma imagem já baixada
* docker stop <nome_da_image>   -> para a execução da imagem
* docker ps => Lista containers em execução
* docker ps -a   -> lista todos os contaniners parados e em execução
* docker ps -q => Lista apenas os IDs numériocos dos containers em vez de toda a tabela de informações
* docker images   -> Lista todas as imagens com mais detalhes
* docker images -a _> Lista todas as imagens
* docker log nginx_app  -> exibe os logs gerados pela imagem
* docker -f log <nome_ou_id_da_imagem>   -> fica exibindo os logs da imagem em execução
* docker -rm <nome_ou_id_da_imagem> -> Apaga a imagem
* docker -rm -f <nome_ou_id_da_imagem> -> Força apagar a imagem que pode está em execução
* docker rmi <nome_ou_id_da_imagem> <nome_ou_id_da_imagem> <nome_ou_id_da_imagem> => Remove todas imagens listadas
*docker images -q => lista os id's da imagens
* docker rmi $(docker images -q) 
* docker stop $(docker ps -a -q)  => para todos os containers em execução
* docker rm $(docker ps -a -q) => Exclui todos os containers parados
* 
###  docker system prune => Remove todos 

###  docker system prune -a => Remove tudo sem exceção


* docker images purge => Limpa todas as imagens não marcadas

* docker images -f dangling=true =>  Listar imagens sem uso

* docker images purge => Remove imagens sem uso

* docker build .   => "DOCKER BUIL PONTO" => GERAR A IMAGEM

### !-- GUIA DE COMANDOS DOCKER --
Um Guia de Consulta Rápida do Docker
Introdução
O Docker facilita o agrupamento de suas aplicações e serviços em contêineres de forma que você pode executar em qualquer lugar. Ao trabalhar com o Docker, no entanto, também é fácil acumular um número limitado de imagens, contêineres e volumes de dados não utilizados que atrapalham a saída e consomem espaço em disco.

O Docker lhe fornece todas as ferramentas que você precisa para resolver seu sistema a partir da linha de comando. Este guia no estilo cheat sheet fornece uma referência rápida para comandos que são úteis para liberar espaço em disco e seu sistema organizado, removendo imagens Docker não utilizadas, contêineres e volumes.

Como Usar Este Guia:

Este guia não tem formato de consulta rápida, com trechos de linha de comando independentes.
Vá para qualquer seção que seja relevante para a tarefa que você é relevante.
A sintaxe de substituição de comando está, usada nos comandos disponíveis em muitos shells populares, como o bash, zsh e Windows Powershell.comando $(comando)

Limpando Todas as Imagens, Contêineres, Volumes e Redes Não Utilizadas ou Pendentes
O Docker fornece um único comando que irá reservar recursos, imagens, contêineres e redes pendentes (não associados a um contêiner):

docker system prune
Para removedor adicionalmente quaisquer e todas as imagens pendentes não incluídas, a bandeira -aao comando:

docker system prune -a
Removendo Imagens Docker
Remover uma ou mais imagens específicas
Use o comando docker imagescom a flag -apara localizar o ID das imagens que você deseja remover. Isso lhe mostrará todas as imagens, incluindo as características de imagem. Quando você encontrou as imagens que deseja excluir, você pode passar o ID tag delas para o docker rmi:

Listar:

docker images -a
Removedor:

docker rmi Image Image
Remover imagens pendentes
As imagens do Docker consistem em várias camadas. As imagens pendentes são camadas que não têm relação com nenhuma imagem marcada. Elas não servem a um propósito e consomem espaço na discoteca. Elas podem ser localizadas adicionando a sinalização de filtro, -fcom um valor de dangling=truecomando docker images. Quando você tiver certeza de que deseja excluí-las, você pode usar o comando docker images purge:

Nota: se você construir uma imagem sem marca-la, ela aparecerá na lista de imagens pendentes porque ela não nenhuma associação com uma imagem marcada. Você pode evitar esta situação de alimentação, e você pode marcar retroativamente uma imagem com o comando docker tag .

Listar:

docker images -f dangling=true
Removedor:

docker images purge
Removendo imagens de acordo com um padrão
Você pode encontrar todas as imagens que correspondem a um padrão usando imagens docker imagese imagens grep. Assim que estiver satisfeito, você pode excluí-las usando o awkpara passar os IDs para o docker rmi. Observe que esses equipamentos e sistemas não são fornecidos pelo

Listar:

docker images -a |  grep "pattern"
Removedor:

docker images -a | grep "pattern" | awk '{print $3}' | xargs docker rmi
Remover todas as imagens
Todas as imagens podem ser usadas como recurso Docker -aao comando docker images. Assim que tiver certeza de que você excluirá todas elas, você poderá adicionar a sinalização -qpara passar o ID da Imagem o docker rmi:

Listar:

docker images -a
Removedor:

docker rmi $(docker images -a -q)
Removendo Contêineres
Remover um ou mais contêineres detalhes
Use o comando docker pscom a sinalização -apara localizar o nome e o ID dos contêineres que você deseja remover.

Listar:

docker ps -a
Removedor:

docker rm ID_or_Name ID_or_Name
Remover um contêiner ao sair
Se você sabe, ao contêiner, que você não deseja criar exclui-lo por perto assim que terminar você pode executar docker run --rmparaí-lo automaticamente quando ele for fechado.

Executar e Remover:

docker run --rm image_name
Remover todos os contêineres finalizados
Você pode localizar o contêiner usando o docker ps -ae trá-los pelo seu status: created, restarting, running, paused or exited. Para revisar a lista de contêineres finalizados, use um sinalizador -fpara filtrar com base no status. Quando você estiver selecionado, você deseja remover esses contêineres, usando -qpara passar os IDs para o comando docker rm.

Listar:

docker ps -a -f status=exited
Removedor:

docker rm $(docker ps -a -f status=exited -q)
Remover contêineres usando mais de um filtro.
Os filtros do Docker podem ser combinados repetindo a sinalização de filtro com um valor adicional. Isso resulta em uma lista de contêineres que corresponde a qualquer das condições. Por exemplo, se você quiser excluir todos os contêineres marcados como Created (um estado que pode resultar quando você pode resultar em um contêiner com um comando inválido) ou Exited , você pode usar dois filtros:

Listar:

docker ps -a -f status=exited -f status=created
Removedor:

docker rm $(docker ps -a -f status=exited -f status=created -q)
Remover contêineres de acordo com um padrão
Você pode encontrar todos os contêineres que correspondem a um padrão usando odocker ps grep . Quando você estiver satisfeito com a lista que deseja excluir, você poderá usar o eo para fornecer o ID para o . Observe que esses equipamentos e sistemas não são fornecidos peloawkxargsdocker rmi

Listar:

docker ps -a |  grep "pattern”
Removedor:

docker ps -a | grep "pattern" | awk '{print $3}' | xargs docker rmi
Parar e remover todos os contêineres
Você pode revisar os contêineres em seu sistema com o docker ps. Adicionando um sinalizador -apara mostrar todos os contêineres. Quando você tiver certeza de que deseja excluí-los, você pode adicionar um sinalizador -qpara fornecer os IDs para os comandos docker stope docker rm:

Listar:

docker ps -a
Removedor:

docker stop $(docker ps -a -q)
docker rm $(docker ps -a -q)
Removendo Volumes
Remover um ou mais volumes - Docker 1.9 e mais recentes
Use o comando docker volume lspara localizar o nome de volume que você deseja excluir. Em seguida, você pode remover um ou mais volumes com o comando docker volume rm:

Listar:

docker volume ls
Removedor:

docker volume rm volume_name volume_name
Remover volumes pendentes - Docker 1.9 e acima
Como a ideia de volumes é existente independentemente dos contêineres, quando um contêiner é removido, um volume não é removido automaticamente ao mesmo tempo. Quando um volume existe e não está mais conectado a um contêiner, ele é de volume pendente, ou volume pendente. Para localizá-los para confirmar que você deseja removê-los, você pode usar o comando docker volume lscom um filtro para limitar os resultados aos volumes pendentes. Quando você estiver satisfeito com a lista, você pode remover todos eles com docker volume prune:

Listar:

docker volume ls -f dangling=true
Removedor:

docker volume prune
Remover um contêiner e seu volume
Se você criou um volume não nomeado, ele pode ser excluído ao mesmo tempo que o contêiner com a sinalização -v. Observe que isso funciona apenas com volumes não nomeados . Quando o contêiner for removido com sucesso, seu ID é exibido. Observe que nenhuma referência é feita à remoção do volume. Se ele está sem nome, ele é removido silenciosamente do sistema. Se ele está nomeado, ele permanece silenciosamente presente.

Removedor:

docker rm -v container_name
Conclusão
Este guia cobre alguns dos comandos comuns usados ​​para remover imagens, contêineres e volumes com o Docker. Há muitas outras tantas e bandeiras que podem ser usadas com cada um deles. Para um guia abrangente sobre o que está disponível, consulte a documentação do Docker para docker system prune, docker rmi, docker rm, e docker volume rm. Se tarefas comuns de limpeza que você gostaria de ver no guia, por favor, pergunte ou faça sugestões nos comentários"# docker" 

### ANALISE DE CONTAINERS - ANALISANDO
docker top app
UID                 PID                 PPID                C                   STIME               TTY                 TIME                CMD
root                5919                5899                0                   19:40               ?                   00:00:00            node app.js

### INSPECIONANDO CONTAINER: docker inspect <nome_ou_id_do_container> => Verifica detalhadamente o processo do container

### docker stats => Mostra o desempenho em tempo real dos container que estão rodando
CONTAINER ID   NAME      CPU %     MEM USAGE / LIMIT     MEM %     NET I/O           BLOCK I/O   PIDS
0c2d26ef44cc   app       0.00%     12.96MiB / 3.706GiB   0.34%     32.3kB / 9.87kB   0B / 0B     7



##### DOCKER LARAVEL ####################
Introdução
Laravelé uma estrutura php de código aberto que fornece um conjunto de ferramentas e recursos para construir aplicações PHP modernas. Nesta série tutorial baseada em projetos, você construirá um aplicativoLinks Landing Pagecom a estrutura Laravel, usando um ambiente de desenvolvimento PHP containerizado gerenciado pela Docker Compose.

Aplicativo de demonstração de laravel landing - Versão final

No final, você terá um site de uma página construído com Laravel e gerenciado através de comandos artesanais onde você pode compartilhar links relevantes para uma audiência em canais sociais e apresentações.

Pré-requisitos
Para acompanhar esta série, você precisará:

Acesso a uma máquina local ou servidor de desenvolvimento do Ubuntu 20.04 como um usuário não raiz com privilégios sudo. Se você estiver usando um servidor remoto, é aconselhável ter um firewall ativo instalado. Para configurar isso, consulte nossoGuia inicial de configuração do servidor para o Ubuntu 20.04.
Docker instalado em sua máquina local ou servidor de desenvolvimento, seguindoas etapas 1e2deComo Instalar e Usar Docker no Ubuntu 20.04.
Docker Compose instalado em sua máquina local ou servidor de desenvolvimento, seguindo opasso 1deComo Instalar e Usar o Docker Compose no Ubuntu 20.04.
Uma vez que você tenha esses pré-requisitos configurados, você está pronto para começar.

EXIBIÇÃO DE RESUMO
VISUALIZAÇÃO DETALHADA
Tutorial//
Como bootstrap um novo aplicativo Laravel com docker compose
Publicado em 17 de dezembro de 2020 · Atualizado em 29 de abril de 2022
Para começar, você precisará criar um ambiente contêiner capaz de executar PHP eComposer, a ferramenta de gerenciamento de dependência PHP. Em seguida, você poderá inicializado o novo aplicativo Laravel do zero, sem a necessidade de ter um ambiente PHP local instalado em sua máquina local ou servidor de desenvolvimento.

Neste guia, instruções simplificadas serão fornecidas sobre como configurar esse ambiente com base em nosso tutorial sobrecomo instalar o Laravel com o Docker Compose no Ubuntu 20.04. Consulte esse tutorial para obter instruções mais detalhadas sobre cada uma das opções usadas dentro do arquivo Docker Compose que será fornecido neste guia.

Crie um novo diretório para sua aplicação na pasta inicial:

mkdir ~/landing-laravel
cd ~/landing-laravel
Em seguida, você criará o arquivo que definirá o ambiente contêiner. Neste arquivo, você configurará um serviço chamado, que será baseado em uma imagem docker personalizada construída com um Arquivo Docker que você configurará mais tarde.docker-compose.ymlapp

Os argumentos de compilação, ambos definidos no arquivo e usados no Arquivo Docker na hora da compilação, devem ser alterados para refletir seu próprio nome de usuário e uid em sua máquina local ou servidor de desenvolvimento. Para descobrir o uid do usuário atual, digite:useruiddocker-compose.yml

echo $UID
Output
1000
As variações estarão disponíveis no tempo de compilação e serão usadas no Dockerfile para criar um novo usuário no serviço com o mesmo nome de usuário e uid que o usuário atual do sistema em sua máquina local ou servidor de desenvolvimento. Isso evitará problemas de permissão e propriedade ao trabalhar com arquivos de aplicativos tanto do contêiner quanto do host que executa o Docker.useruidapp

Crie um novo arquivo usando seu editor de texto de escolha. Aqui, é usado:docker-compose.ymlnano

nano docker-compose.yml
Copie o seguinte conteúdo para este arquivo e não se esqueça de substituir os valores destacados por valores apropriados, dependendo do seu próprio nome de usuário e uid no sistema que executa o Docker:

~/landing-laravel/docker-compor.yml
version: "3.7"
services:
  app:
    build:
      args:
        user: sammy
        uid: 1000
      context: ./
      dockerfile: Dockerfile
    image: landing-app
    restart: unless-stopped
    working_dir: /var/www/
    volumes:
      - ./:/var/www
    networks:
      - landing

networks:
  landing:
    driver: bridge
Salve e feche o arquivo quando terminar. Se você estiver usando, você pode fazer isso pressionando+, então, para confirmar.nanoCTRLXYENTER

Em seguida, você configurará o Arquivo Docker que é referenciado no arquivo, que configurará uma imagem personalizada para o serviço:docker-compose.ymlapp

nano Dockerfile
Este Arquivo Docker se estende da imagem padrãoDocker. Ele usa asandvariáveis para criar um novo usuário capaz de executar comandos de Artesão e Compositor. Ele também instala algumas dependências php que são exigidas por Laravel, e o Compositor executável.php:7.4-fpmuseruid

Copie o seguinte conteúdo para o seu Dockerfile:

~/minha-toda-lista/Dockerfile
FROM php:7.4-fpm

# Arguments defined in docker-compose.yml
ARG user
ARG uid

# Install system dependencies
RUN apt-get update && apt-get install -y \
    git \
    curl \
    libpng-dev \
    libonig-dev \
    libxml2-dev \
    zip \
    unzip

# Clear cache
RUN apt-get clean && rm -rf /var/lib/apt/lists/*

# Install PHP extensions
RUN docker-php-ext-install pdo_mysql mbstring exif pcntl bcmath gd

# Get latest Composer
COPY --from=composer:latest /usr/bin/composer /usr/bin/composer

# Create system user to run Composer and Artisan Commands
RUN useradd -G www-data,root -u $uid -d /home/$user $user
RUN mkdir -p /home/$user/.composer && \
    chown -R $user:$user /home/$user

# Set working directory
WORKDIR /var/www

USER $user
Salve e feche o arquivo quando terminar. Em seguida, você pode trazer o seu ambiente com:

docker-compose up -d
Este comando executará o Docker Compose nomodo destacado, o que significa que ele será executado em segundo plano. Na primeira vez que você traz um ambiente com uma imagem personalizada, o Docker Compose construirá automaticamente a imagem para você antes de criar os recipientes necessários. Isso pode levar alguns momentos para terminar. Você verá saída semelhante a esta:

Output
Creating network "landing-laravel_landing" with driver "bridge"
Building app
Step 1/11 : FROM php:7.4-fpm
 ---> fa37bd6db22a
...
Step 10/11 : WORKDIR /var/www
 ---> Using cache
 ---> 769afd5d44d8
Step 11/11 : USER $user
 ---> Using cache
 ---> 841eb5852b69

Successfully built 841eb5852b69
Successfully tagged landing-app:latest
WARNING: Image for service app was built because it did not already exist. To rebuild this image you must use `docker-compose build` or `docker-compose up --build`.
Creating landing-laravel_app_1 ... done

Você pode verificar se seu ambiente está funcionando com:

docker-compose ps
Output
        Name                       Command              State    Ports  
------------------------------------------------------------------------
landing-laravel_app_1   docker-php-entrypoint php-fpm   Up      9000/tcp
Uma vez que o serviço esteja em alta, você pode executar o Composer, a ferramenta de gerenciamento de dependência PHP, para inicialar um novo aplicativo Laravel. Para isso, você usará para executar comandos no serviço, onde o PHP está instalado.appdocker compose execapp

O seguinte comando usará o Docker Compose para executar, o que inicializárá uma nova instalação de Laravel com base no pacote:composer create-projectlaravel/laravel

docker-compose exec app composer create-project laravel/laravel --prefer-dist application
Creating a "laravel/laravel" project at "./application"
Installing laravel/laravel (v8.4.0)
  - Downloading laravel/laravel (v8.4.0)
  - Installing laravel/laravel (v8.4.0): Extracting archive
Created project in /var/www/application
> @php -r "file_exists('.env') || copy('.env.example', '.env');"
Loading composer repositories with package information
Updating dependencies
Lock file operations: 104 installs, 0 updates, 0 removals
…
Package manifest generated successfully.
71 packages you are using are looking for funding.
Use the `composer fund` command to find out more!
> @php artisan key:generate --ansi
Application key set successfully.
Esta instalação cria um novo arquivo baseado no arquivo padrão que vem com o Laravel. O arquivo contém credenciais de banco de dados e outras configurações sensíveis do aplicativo, e deve ser único por ambiente onde o aplicativo é executado. Você voltará para editar este arquivo depois de terminar de configurar o ambiente de desenvolvimento..env.env.example.env

Em seguida, copie os arquivos do aplicativo para o mesmo diretório que o arquivo, para que você possa compartilhar o arquivo de variáveis de ambiente da Laravel com o Docker Compose. Em seguida, você pode remover o diretor criado pelo Composer:docker-compose.ymlapplication

cp -rT application .
rm -rfv application
Seu aplicativo agora está em inicializado, mas você precisará incluir alguns serviços no arquivo Docker Compose para poder acessar o aplicativo a partir de um navegador. O Anservice servirá o aplicativo usando o servidor web Nginx, e o Aservice hospedará o banco de dados MySQL do aplicativo.nginxdb

Primeiro, derrubeseu ambiente com:

docker-compose down
Output
Stopping landing-laravel_app_1 ... done
Removing landing-laravel_app_1 ... done
Removing network landing-laravel_landing
Isso removerá todos os contêineres e redes associados a este ambiente. Antes de editar seu arquivo para adicionar os novos serviços, crie um novo diretório para compartilhar arquivos de configuração com contêineres. Você precisará disso para configurar corretamente o Nginx para lidar com o aplicativo Laravel PHP.docker-compose.yml

mkdir -p docker-compose/nginx
Em seguida, crie um novo arquivo contendo um bloco de servidor Nginx personalizado. Mais tarde, você configurará um volume para compartilhar este arquivo dentro do contêiner de serviço.landing-laravel.confnginx

Abra um novo arquivo de configuração Nginx com:

nano docker-compose/nginx/landing-laravel.conf
O seguinte bloco de servidor configura o Nginx para servir um aplicativo Laravel usando um serviço externo () para lidar com o código PHP. Copie este conteúdo para seu próprio arquivo de configuração Nginx:app

docker-compor/nginx/landing-laravel.conf
server {
    listen 80;
    index index.php index.html;
    error_log  /var/log/nginx/error.log;
    access_log /var/log/nginx/access.log;
    root /var/www/public;
    location ~ \.php$ {
        try_files $uri =404;
        fastcgi_split_path_info ^(.+\.php)(/.+)$;
        fastcgi_pass app:9000;
        fastcgi_index index.php;
        include fastcgi_params;
        fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
        fastcgi_param PATH_INFO $fastcgi_path_info;
    }
    location / {
        try_files $uri $uri/ /index.php?$query_string;
        gzip_static on;
    }
}
Salve e feche o arquivo quando terminar.

Em seguida, abra seu arquivo:docker-compose.yml

nano docker-compose.yml
Inclua a seguinte configuração para o serviço, no mesmo nível do serviço configurado anteriormente. Isso criará um novo serviço baseado na imagem, e todas as solicitações no portof do host onde o Docker está executando serão redirecionadas para portin o contêiner de serviço. Além dos arquivos do aplicativo, você também compartilhará um volume contendo o arquivo de configuração do Nginx para um aplicativo Laravel:nginxappnginx:alpine800080

  nginx:
    image: nginx:alpine
    restart: unless-stopped
    ports:
      - 8000:80
    volumes:
      - ./:/var/www
      - ./docker-compose/nginx:/etc/nginx/conf.d/
    networks:
      - landing

Em seguida, inclua o seguinte bloco de configuração para o serviço. Isso criará um serviço baseado na imagem padrão do MySQL 8 e puxará os valores definidos no arquivo de ambiente da Laravel para configurar o acesso ao banco de dados:db

  db:
    image: mysql:8
    restart: unless-stopped
    environment:
      MYSQL_DATABASE: ${DB_DATABASE}
      MYSQL_ROOT_PASSWORD: ${DB_PASSWORD}
      MYSQL_PASSWORD: ${DB_PASSWORD}
      MYSQL_USER: ${DB_USERNAME}
    networks:
      - landing
É assim que seu arquivo atualizado deve ser quando terminar:docker-compose.yml

~/landing-laravel/docker-compor.yml
version: "3.7"
services:
  app:
    build:
      args:
        user: sammy
        uid: 1000
      context: ./
      dockerfile: Dockerfile
    image: landing-app
    restart: unless-stopped
    working_dir: /var/www/
    volumes:
      - ./:/var/www
    networks:
      - landing

  nginx:
    image: nginx:alpine
    restart: unless-stopped
    ports:
      - 8000:80
    volumes:
      - ./:/var/www
      - ./docker-compose/nginx:/etc/nginx/conf.d/
    networks:
      - landing
  db:
    image: mysql:8
    restart: unless-stopped
    environment:
      MYSQL_DATABASE: ${DB_DATABASE}
      MYSQL_ROOT_PASSWORD: ${DB_PASSWORD}
      MYSQL_PASSWORD: ${DB_PASSWORD}
      MYSQL_USER: ${DB_USERNAME}
    networks:
      - landing

networks:
  landing:
    driver: bridge

Nota: para obter informações mais detalhadas sobre os ambientes Laravel de contêineres, incluindo explicações sobre volumes e redes compartilhadas, consulte nosso guia completo sobreComo Instalar o Laravel com o Docker Compose no Ubuntu 20.04.

Salve e feche o arquivo quando terminar de editar. Por fim, atualize seu arquivo Laravel dot env () para apontar a configuração do host do banco de dados MySQL para o host onde o serviço MySQL estará em execução, chamado:.envdb

nano .env
O arquivo que é gerado automaticamente pelo Composer após a instalação vem com alguns valores padrão que você pode querer alterar, como o e o. Avariável de banco de dados deve ser alterada para apontar para o serviço onde o MySQL estará em execução, e você pode referenciá-lo pelo nome de serviço, conforme definido no arquivo. Neste exemplo, você usou como nome para o serviço de banco de dados, então isso estará disponível na rede contêinerizada como um host nomeado..envAPP_NAMEAPP_URLDB_HOSTdocker-compose.ymldbdb

Altere-o de acordo com o exemplo a seguir como base. Os valores destacados foram atualizados aqui para refletir o estado da aplicação em desenvolvimento:.env

~/landing-laravel/.env
APP_NAME=LandingLaravel
APP_ENV=local
APP_KEY=base64:ffYPNP8kPeQDf8gE/qh3kWjk59p6gFY66kCKhhKUa2w=
APP_DEBUG=true
APP_URL=http://localhost:8000

LOG_CHANNEL=stack
LOG_LEVEL=debug

DB_CONNECTION=mysql
DB_HOST=db
DB_PORT=3306
DB_DATABASE=landing-db
DB_USERNAME=landing-user
DB_PASSWORD=dev-password

...
Você não precisa alterar nenhuma outra seção deste arquivo, mas sinta-se livre para ajustar ao seu caso de uso específico.

Salve e feche o arquivo quando terminar de editar seu conteúdo.

Agora você pode trazer o ambiente atualizado com:

docker-compose up -d
Output
Creating network "landing-laravel_landing" with driver "bridge"
Creating landing-laravel_app_1   ... done
Creating landing-laravel_db_1    ... done
Creating landing-laravel_nginx_1 ... done
Com o ambiente completo para cima, agora você pode apontar o seu navegador para ou o endereço IP do seu servidor remoto, na porta:localhost8000

http://localhost:8000
 */

 ### create_despesas_table
 <?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create('despesas', function (Blueprint $table) {
            $table->id();
            $table->string('despesa');
            $table->float('valor');
            $table->date('vencimento');
            $table->boolean('is_pg');
            $table->date('pagamento');
            $table->timestamps();
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists('despesas');
    }
};

##### UDEMY
* composer create-project laravel/laravel --prefer-dist <nome-do-app>:^x.x 

* composer require laravel/ui:^3.2

php --ini -> para saber o local dos arquivo de configuração do php caso necessite ajustes por exemplo de memória
php.ini (memory_limite = -1) -> para o php usar a quantidade de memória necessária para a aplicação.

php artisan list (deve aparecer o grupo ui: ui:auth, ui:controllers)
php artisan route:list
php artisan auth

* php artisan ui bootstrap --auth (trabalhando as definições de front com bootstrap)

* npm install

* npm run dev -> para gerar os assts do front end da aplicação de acordo com a tecnologia selecionada.
npm install resolve-url-loader@^5.0.0 --save-dev --legacy-peer-deps  -> executar se der erro.

* php artisan migrate (cria o banco de dados)

* php artisan make:controller --resource TarefaController --model=Tarefa

* PARA A ROTA PASSAR PELA AUTENTICAÇÃO PODEMOS:
- NO CONTROLADOR DA ROTA INCLUIR:
 //.. 
 {
    public function __construct() {
        $this->middleware('auth');
    }
    public function //....
 }
- NA PRÓPRIA ROTA APONTAR PARA O MIDDLEWARE 'Auth':
Route::'resource'('tarefa', 'App\Http\Controllers\TarefaController')->middleware('auth');

* AUTENTICAÇÃO SOMENTE EM ALGUNS RECURSOS DO RESOURCE, DENTRO DE UM MÉTODO DO CONTROLADOR:

TarefaController.php

<?php

namespace App\Http\Controllers;

use App\Models\Tarefa;
use Illuminate\Http\Request;

class TarefaController extends Controller
{
    /**
     * Display a listing of the resource.
     *
     * @return \Illuminate\Http\Response
     */
    public function index()
    {
        if(auth()->check()) 
        {
            return 'Você está logado';
        } else {
           return view('welcome');
        }
    }
//..v



